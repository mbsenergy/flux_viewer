/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/cheetah-grid/dist/cheetahGrid.es5.js":
/*!***********************************************************!*\
  !*** ./node_modules/cheetah-grid/dist/cheetahGrid.es5.js ***!
  \***********************************************************/
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! Cheetah Grid v1.16.0 | license MIT */
(function(){
"use strict";

function set(target, property, value, receiver) { if (typeof Reflect !== "undefined" && Reflect.set) { set = Reflect.set; } else { set = function set(target, property, value, receiver) { var base = _superPropBase(target, property); var desc; if (base) { desc = Object.getOwnPropertyDescriptor(base, property); if (desc.set) { desc.set.call(receiver, value); return true; } else if (!desc.writable) { return false; } } desc = Object.getOwnPropertyDescriptor(receiver, property); if (desc) { if (!desc.writable) { return false; } desc.value = value; Object.defineProperty(receiver, property, desc); } else { _defineProperty(receiver, property, value); } return true; }; } return set(target, property, value, receiver); }

function _set(target, property, value, receiver, isStrict) { var s = set(target, property, value, receiver || target); if (!s && isStrict) { throw new Error('failed to set property'); } return value; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

(function (window) {
  (function webpackUniversalModuleDefinition(root, factory) {
    if (( false ? 0 : _typeof(exports)) === 'object' && ( false ? 0 : _typeof(module)) === 'object') module.exports = factory();else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {}
  })(window, function () {
    return (
      /******/
      function (modules) {
        // webpackBootstrap

        /******/
        // The module cache

        /******/
        var installedModules = {};
        /******/

        /******/
        // The require function

        /******/

        function __nested_webpack_require_6786__(moduleId) {
          /******/

          /******/
          // Check if module is in cache

          /******/
          if (installedModules[moduleId]) {
            /******/
            return installedModules[moduleId].exports;
            /******/
          }
          /******/
          // Create a new module (and put it into the cache)

          /******/


          var module = installedModules[moduleId] = {
            /******/
            i: moduleId,

            /******/
            l: false,

            /******/
            exports: {}
            /******/

          };
          /******/

          /******/
          // Execute the module function

          /******/

          modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_6786__);
          /******/

          /******/
          // Flag the module as loaded

          /******/

          module.l = true;
          /******/

          /******/
          // Return the exports of the module

          /******/

          return module.exports;
          /******/
        }
        /******/

        /******/

        /******/
        // expose the modules object (__webpack_modules__)

        /******/


        __nested_webpack_require_6786__.m = modules;
        /******/

        /******/
        // expose the module cache

        /******/

        __nested_webpack_require_6786__.c = installedModules;
        /******/

        /******/
        // define getter function for harmony exports

        /******/

        __nested_webpack_require_6786__.d = function (exports, name, getter) {
          /******/
          if (!__nested_webpack_require_6786__.o(exports, name)) {
            /******/
            Object.defineProperty(exports, name, {
              enumerable: true,
              get: getter
            });
            /******/
          }
          /******/

        };
        /******/

        /******/
        // define __esModule on exports

        /******/


        __nested_webpack_require_6786__.r = function (exports) {
          /******/
          if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
            /******/
            Object.defineProperty(exports, Symbol.toStringTag, {
              value: 'Module'
            });
            /******/
          }
          /******/


          Object.defineProperty(exports, '__esModule', {
            value: true
          });
          /******/
        };
        /******/

        /******/
        // create a fake namespace object

        /******/
        // mode & 1: value is a module id, require it

        /******/
        // mode & 2: merge all properties of value into the ns

        /******/
        // mode & 4: return value when already ns object

        /******/
        // mode & 8|1: behave like require

        /******/


        __nested_webpack_require_6786__.t = function (value, mode) {
          /******/
          if (mode & 1) value = __nested_webpack_require_6786__(value);
          /******/

          if (mode & 8) return value;
          /******/

          if (mode & 4 && _typeof(value) === 'object' && value && value.__esModule) return value;
          /******/

          var ns = Object.create(null);
          /******/

          __nested_webpack_require_6786__.r(ns);
          /******/


          Object.defineProperty(ns, 'default', {
            enumerable: true,
            value: value
          });
          /******/

          if (mode & 2 && typeof value != 'string') for (var key in value) {
            __nested_webpack_require_6786__.d(ns, key, function (key) {
              return value[key];
            }.bind(null, key));
          }
          /******/

          return ns;
          /******/
        };
        /******/

        /******/
        // getDefaultExport function for compatibility with non-harmony modules

        /******/


        __nested_webpack_require_6786__.n = function (module) {
          /******/
          var getter = module && module.__esModule ?
          /******/
          function getDefault() {
            return module['default'];
          } :
          /******/
          function getModuleExports() {
            return module;
          };
          /******/

          __nested_webpack_require_6786__.d(getter, 'a', getter);
          /******/


          return getter;
          /******/
        };
        /******/

        /******/
        // Object.prototype.hasOwnProperty.call

        /******/


        __nested_webpack_require_6786__.o = function (object, property) {
          return Object.prototype.hasOwnProperty.call(object, property);
        };
        /******/

        /******/
        // __webpack_public_path__

        /******/


        __nested_webpack_require_6786__.p = "";
        /******/

        /******/

        /******/
        // Load entry module and return exports

        /******/

        return __nested_webpack_require_6786__(__nested_webpack_require_6786__.s = "./main.js");
        /******/
      }(
      /************************************************************************/

      /******/
      {
        /***/
        "../node_modules/css-loader/dist/cjs.js?!../node_modules/postcss-loader/src/index.js?!../src/js/columns/action/internal/InlineInputElement.css":
        /*!**************************************************************************************************************************************************************!*\
          !*** ../node_modules/css-loader/dist/cjs.js??ref--5-1!../node_modules/postcss-loader/src??ref--5-2!../src/js/columns/action/internal/InlineInputElement.css ***!
          \**************************************************************************************************************************************************************/

        /*! exports provided: default */

        /*! ModuleConcatenation bailout: Module uses module.id */

        /***/
        function node_modulesCssLoaderDistCjsJsNode_modulesPostcssLoaderSrcIndexJsSrcJsColumnsActionInternalInlineInputElementCss(module, __nested_webpack_exports__, __nested_webpack_require_12751__) {
          "use strict";

          __nested_webpack_require_12751__.r(__nested_webpack_exports__);
          /* harmony import */


          var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_12751__(
          /*! ../../../../../node_modules/css-loader/dist/runtime/api.js */
          "../node_modules/css-loader/dist/runtime/api.js");
          /* harmony import */


          var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_12751__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__); // Imports


          var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(false); // Module


          ___CSS_LOADER_EXPORT___.push([module.i, ".cheetah-grid__inline-input::-ms-clear{visibility:hidden}.cheetah-grid__inline-input{position:absolute;-webkit-box-sizing:border-box;box-sizing:border-box}", ""]); // Exports

          /* harmony default export */


          __nested_webpack_exports__["default"] = ___CSS_LOADER_EXPORT___;
          /***/
        },

        /***/
        "../node_modules/css-loader/dist/cjs.js?!../node_modules/postcss-loader/src/index.js?!../src/js/columns/action/internal/InlineMenuElement.css":
        /*!*************************************************************************************************************************************************************!*\
          !*** ../node_modules/css-loader/dist/cjs.js??ref--5-1!../node_modules/postcss-loader/src??ref--5-2!../src/js/columns/action/internal/InlineMenuElement.css ***!
          \*************************************************************************************************************************************************************/

        /*! exports provided: default */

        /*! ModuleConcatenation bailout: Module uses module.id */

        /***/
        function node_modulesCssLoaderDistCjsJsNode_modulesPostcssLoaderSrcIndexJsSrcJsColumnsActionInternalInlineMenuElementCss(module, __nested_webpack_exports__, __nested_webpack_require_14857__) {
          "use strict";

          __nested_webpack_require_14857__.r(__nested_webpack_exports__);
          /* harmony import */


          var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_14857__(
          /*! ../../../../../node_modules/css-loader/dist/runtime/api.js */
          "../node_modules/css-loader/dist/runtime/api.js");
          /* harmony import */


          var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_14857__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__); // Imports


          var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(false); // Module


          ___CSS_LOADER_EXPORT___.push([module.i, ".cheetah-grid__inline-menu{position:absolute;color:rgba(0,0,0,.87);-webkit-box-sizing:content-box;box-sizing:content-box;margin:-1px auto auto -1px;padding:8px 0;background-color:#fafafa;list-style-type:none;border-radius:2px;max-height:calc(100vh - 40px);overflow-y:auto}.cheetah-grid__inline-menu--hidden{-webkit-transform:scale(.9);transform:scale(.9);-webkit-box-shadow:none;box-shadow:none;opacity:0;pointer-events:none;-webkit-transition:all 50ms ease-out;transition:all 50ms ease-out}.cheetah-grid__inline-menu--hidden *{pointer-events:none}.cheetah-grid__inline-menu--shown{-webkit-transform:translateY(-7px);transform:translateY(-7px);-webkit-box-shadow:0 3px 1px -2px rgba(0,0,0,.2),0 2px 2px 0 rgba(0,0,0,.14),0 1px 5px 0 rgba(0,0,0,.12);box-shadow:0 3px 1px -2px rgba(0,0,0,.2),0 2px 2px 0 rgba(0,0,0,.14),0 1px 5px 0 rgba(0,0,0,.12);opacity:1;-webkit-transition:all .15s ease-out;transition:all .15s ease-out}.cheetah-grid__inline-menu__menu-item{height:100%;-webkit-box-sizing:border-box;box-sizing:border-box;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;outline:none;cursor:pointer;position:relative;overflow:hidden;padding:0 16px}.cheetah-grid__inline-menu__menu-item--empty{color:rgba(0,0,0,.38)}.cheetah-grid__inline-menu__menu-item:before{content:\"\";position:absolute;top:-50%;left:-50%;width:200%;height:200%;background-color:#000;opacity:0;pointer-events:none;-webkit-transition:opacity 15ms linear;transition:opacity 15ms linear}.cheetah-grid__inline-menu__menu-item:hover:before,.cheetah-grid__inline-menu__menu-item[data-select]:before{opacity:.04}.cheetah-grid__inline-menu__menu-item:focus:before{opacity:.12}", ""]); // Exports

          /* harmony default export */


          __nested_webpack_exports__["default"] = ___CSS_LOADER_EXPORT___;
          /***/
        },

        /***/
        "../node_modules/css-loader/dist/cjs.js?!../node_modules/postcss-loader/src/index.js?!../src/js/columns/action/internal/SmallDialogInputElement.css":
        /*!*******************************************************************************************************************************************************************!*\
          !*** ../node_modules/css-loader/dist/cjs.js??ref--5-1!../node_modules/postcss-loader/src??ref--5-2!../src/js/columns/action/internal/SmallDialogInputElement.css ***!
          \*******************************************************************************************************************************************************************/

        /*! exports provided: default */

        /*! ModuleConcatenation bailout: Module uses module.id */

        /***/
        function node_modulesCssLoaderDistCjsJsNode_modulesPostcssLoaderSrcIndexJsSrcJsColumnsActionInternalSmallDialogInputElementCss(module, __nested_webpack_exports__, __nested_webpack_require_18619__) {
          "use strict";

          __nested_webpack_require_18619__.r(__nested_webpack_exports__);
          /* harmony import */


          var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_18619__(
          /*! ../../../../../node_modules/css-loader/dist/runtime/api.js */
          "../node_modules/css-loader/dist/runtime/api.js");
          /* harmony import */


          var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_18619__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__); // Imports


          var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(false); // Module


          ___CSS_LOADER_EXPORT___.push([module.i, ".cheetah-grid__small-dialog-input__input::-ms-clear{visibility:hidden}@-webkit-keyframes cheetah-grid__small-dialog-input--hidden-animation{0%{opacity:1}99%{opacity:1}to{opacity:0}}@keyframes cheetah-grid__small-dialog-input--hidden-animation{0%{opacity:1}99%{opacity:1}to{opacity:0}}.cheetah-grid__small-dialog-input{position:absolute;-webkit-box-sizing:content-box;box-sizing:content-box;margin:-1px auto auto -1px;border-radius:3px;background-color:#fafafa;-webkit-transition:padding .15s ease-out,-webkit-box-shadow .15s ease-out;transition:padding .15s ease-out,-webkit-box-shadow .15s ease-out;transition:padding .15s ease-out,box-shadow .15s ease-out;transition:padding .15s ease-out,box-shadow .15s ease-out,-webkit-box-shadow .15s ease-out}.cheetah-grid__small-dialog-input--hidden{-webkit-box-shadow:none;box-shadow:none;padding:0;pointer-events:none;-webkit-animation:cheetah-grid__small-dialog-input--hidden-animation .15s ease-out;animation:cheetah-grid__small-dialog-input--hidden-animation .15s ease-out;opacity:0}.cheetah-grid__small-dialog-input--shown{-webkit-box-shadow:0 3px 1px -2px rgba(0,0,0,.2),0 2px 2px 0 rgba(0,0,0,.14),0 1px 5px 0 rgba(0,0,0,.12);box-shadow:0 3px 1px -2px rgba(0,0,0,.2),0 2px 2px 0 rgba(0,0,0,.14),0 1px 5px 0 rgba(0,0,0,.12);padding:8px 24px}.cheetah-grid__small-dialog-input__input{width:100%;height:100%;-webkit-box-sizing:border-box;box-sizing:border-box;padding:3px 2px 0 4px;border:none;border-bottom:1px solid rgba(0,0,0,.87);outline:none;background-color:transparent;-webkit-transition:all .3s ease-out;transition:all .3s ease-out}.cheetah-grid__small-dialog-input__input:focus{border-bottom:1px solid #2196f3;-webkit-box-shadow:0 1px 0 0 #2196f3;box-shadow:0 1px 0 0 #2196f3}.cheetah-grid__small-dialog-input:after{content:\"\";font-family:Roboto;font-size:12px;font-size:.75rem;min-height:1em;line-height:1;display:block;width:100%;padding-top:8px}.cheetah-grid__small-dialog-input.helper-text--right-justified:after{text-align:right}.cheetah-grid__small-dialog-input[data-helper-text]:after{content:attr(data-helper-text);color:rgba(0,0,0,.87)}.cheetah-grid__small-dialog-input[data-error-message] input{border-bottom:1px solid #ff1744;-webkit-box-shadow:0 1px 0 0 #ff1744;box-shadow:0 1px 0 0 #ff1744}.cheetah-grid__small-dialog-input[data-error-message]:after{content:attr(data-error-message);color:#ff1744;text-align:left}", ""]); // Exports

          /* harmony default export */


          __nested_webpack_exports__["default"] = ___CSS_LOADER_EXPORT___;
          /***/
        },

        /***/
        "../node_modules/css-loader/dist/cjs.js?!../node_modules/postcss-loader/src/index.js?!../src/js/columns/message/internal/ErrorMessageElement.css":
        /*!****************************************************************************************************************************************************************!*\
          !*** ../node_modules/css-loader/dist/cjs.js??ref--5-1!../node_modules/postcss-loader/src??ref--5-2!../src/js/columns/message/internal/ErrorMessageElement.css ***!
          \****************************************************************************************************************************************************************/

        /*! exports provided: default */

        /*! ModuleConcatenation bailout: Module uses module.id */

        /***/
        function node_modulesCssLoaderDistCjsJsNode_modulesPostcssLoaderSrcIndexJsSrcJsColumnsMessageInternalErrorMessageElementCss(module, __nested_webpack_exports__, __nested_webpack_require_22967__) {
          "use strict";

          __nested_webpack_require_22967__.r(__nested_webpack_exports__);
          /* harmony import */


          var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_22967__(
          /*! ../../../../../node_modules/css-loader/dist/runtime/api.js */
          "../node_modules/css-loader/dist/runtime/api.js");
          /* harmony import */


          var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_22967__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__); // Imports


          var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(false); // Module


          ___CSS_LOADER_EXPORT___.push([module.i, ".cheetah-grid__error-message-element{border-top:1px solid #ff1744;color:#ff1744}", ""]); // Exports

          /* harmony default export */


          __nested_webpack_exports__["default"] = ___CSS_LOADER_EXPORT___;
          /***/
        },

        /***/
        "../node_modules/css-loader/dist/cjs.js?!../node_modules/postcss-loader/src/index.js?!../src/js/columns/message/internal/MessageElement.css":
        /*!***********************************************************************************************************************************************************!*\
          !*** ../node_modules/css-loader/dist/cjs.js??ref--5-1!../node_modules/postcss-loader/src??ref--5-2!../src/js/columns/message/internal/MessageElement.css ***!
          \***********************************************************************************************************************************************************/

        /*! exports provided: default */

        /*! ModuleConcatenation bailout: Module uses module.id */

        /***/
        function node_modulesCssLoaderDistCjsJsNode_modulesPostcssLoaderSrcIndexJsSrcJsColumnsMessageInternalMessageElementCss(module, __nested_webpack_exports__, __nested_webpack_require_24988__) {
          "use strict";

          __nested_webpack_require_24988__.r(__nested_webpack_exports__);
          /* harmony import */


          var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_24988__(
          /*! ../../../../../node_modules/css-loader/dist/runtime/api.js */
          "../node_modules/css-loader/dist/runtime/api.js");
          /* harmony import */


          var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_24988__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__); // Imports


          var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(false); // Module


          ___CSS_LOADER_EXPORT___.push([module.i, ".cheetah-grid__message-element{position:absolute;margin-top:-2px;-webkit-box-sizing:border-box;box-sizing:border-box;border-radius:0 0 3px 3px;background-color:hsla(0,0%,98%,.85);padding:8px 2px;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;border-top:1px solid rgba(0,0,0,.87);color:rgba(0,0,0,.87)}.cheetah-grid__message-element--hidden{display:none}.cheetah-grid__message-element--shown{display:block}.cheetah-grid__message-element__message{font-family:Roboto;font-size:12px;font-size:.75rem;min-height:1em;line-height:1;display:block;width:100%}", ""]); // Exports

          /* harmony default export */


          __nested_webpack_exports__["default"] = ___CSS_LOADER_EXPORT___;
          /***/
        },

        /***/
        "../node_modules/css-loader/dist/cjs.js?!../node_modules/postcss-loader/src/index.js?!../src/js/columns/message/internal/WarningMessageElement.css":
        /*!******************************************************************************************************************************************************************!*\
          !*** ../node_modules/css-loader/dist/cjs.js??ref--5-1!../node_modules/postcss-loader/src??ref--5-2!../src/js/columns/message/internal/WarningMessageElement.css ***!
          \******************************************************************************************************************************************************************/

        /*! exports provided: default */

        /*! ModuleConcatenation bailout: Module uses module.id */

        /***/
        function node_modulesCssLoaderDistCjsJsNode_modulesPostcssLoaderSrcIndexJsSrcJsColumnsMessageInternalWarningMessageElementCss(module, __nested_webpack_exports__, __nested_webpack_require_27572__) {
          "use strict";

          __nested_webpack_require_27572__.r(__nested_webpack_exports__);
          /* harmony import */


          var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_27572__(
          /*! ../../../../../node_modules/css-loader/dist/runtime/api.js */
          "../node_modules/css-loader/dist/runtime/api.js");
          /* harmony import */


          var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_27572__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__); // Imports


          var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(false); // Module


          ___CSS_LOADER_EXPORT___.push([module.i, ".cheetah-grid__warning-message-element{border-top:1px solid #dd2c00;color:#dd2c00}", ""]); // Exports

          /* harmony default export */


          __nested_webpack_exports__["default"] = ___CSS_LOADER_EXPORT___;
          /***/
        },

        /***/
        "../node_modules/css-loader/dist/cjs.js?!../node_modules/postcss-loader/src/index.js?!../src/js/internal/style.css":
        /*!**********************************************************************************************************************************!*\
          !*** ../node_modules/css-loader/dist/cjs.js??ref--5-1!../node_modules/postcss-loader/src??ref--5-2!../src/js/internal/style.css ***!
          \**********************************************************************************************************************************/

        /*! exports provided: default */

        /*! ModuleConcatenation bailout: Module uses module.id */

        /***/
        function node_modulesCssLoaderDistCjsJsNode_modulesPostcssLoaderSrcIndexJsSrcJsInternalStyleCss(module, __nested_webpack_exports__, __nested_webpack_require_29472__) {
          "use strict";

          __nested_webpack_require_29472__.r(__nested_webpack_exports__);
          /* harmony import */


          var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_29472__(
          /*! ../../../node_modules/css-loader/dist/runtime/api.js */
          "../node_modules/css-loader/dist/runtime/api.js");
          /* harmony import */


          var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_29472__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__); // Imports


          var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(false); // Module


          ___CSS_LOADER_EXPORT___.push([module.i, ".cheetah-grid .grid-scrollable{height:100%;width:100%;position:absolute;overflow:scroll}.cheetah-grid .grid-scroll-end-point{opacity:0;position:relative}.cheetah-grid{position:relative;width:100%;height:100%}.cheetah-grid>canvas{position:absolute;width:0;height:0}.cheetah-grid .grid-focus-control{position:relative!important;width:1px;height:1px;opacity:0;padding:0;margin:0;-webkit-box-sizing:border-box;box-sizing:border-box;pointer-events:none;max-width:0;max-height:0;float:none!important}.cheetah-grid input.grid-focus-control::-ms-clear{visibility:hidden}.cheetah-grid input.grid-focus-control.composition{opacity:1;max-width:none;max-height:none}", ""]); // Exports

          /* harmony default export */


          __nested_webpack_exports__["default"] = ___CSS_LOADER_EXPORT___;
          /***/
        },

        /***/
        "../node_modules/css-loader/dist/cjs.js?!../node_modules/postcss-loader/src/index.js?!../src/js/tooltip/internal/TooltipElement.css":
        /*!***************************************************************************************************************************************************!*\
          !*** ../node_modules/css-loader/dist/cjs.js??ref--5-1!../node_modules/postcss-loader/src??ref--5-2!../src/js/tooltip/internal/TooltipElement.css ***!
          \***************************************************************************************************************************************************/

        /*! exports provided: default */

        /*! ModuleConcatenation bailout: Module uses module.id */

        /***/
        function node_modulesCssLoaderDistCjsJsNode_modulesPostcssLoaderSrcIndexJsSrcJsTooltipInternalTooltipElementCss(module, __nested_webpack_exports__, __nested_webpack_require_32022__) {
          "use strict";

          __nested_webpack_require_32022__.r(__nested_webpack_exports__);
          /* harmony import */


          var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_32022__(
          /*! ../../../../node_modules/css-loader/dist/runtime/api.js */
          "../node_modules/css-loader/dist/runtime/api.js");
          /* harmony import */


          var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_32022__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__); // Imports


          var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(false); // Module


          ___CSS_LOADER_EXPORT___.push([module.i, "@-webkit-keyframes cheetah-grid__tooltip-element--shown-animation{0%{opacity:0;-webkit-transform:scale(.8) translateX(-60%);transform:scale(.8) translateX(-60%)}to{opacity:1;-webkit-transform:scale(1) translateX(-50%);transform:scale(1) translateX(-50%)}}@keyframes cheetah-grid__tooltip-element--shown-animation{0%{opacity:0;-webkit-transform:scale(.8) translateX(-60%);transform:scale(.8) translateX(-60%)}to{opacity:1;-webkit-transform:scale(1) translateX(-50%);transform:scale(1) translateX(-50%)}}.cheetah-grid__tooltip-element{position:absolute;-webkit-box-sizing:border-box;box-sizing:border-box;border-radius:3px;background-color:#232f34;padding:8px;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;color:#fff}.cheetah-grid__tooltip-element--hidden{opacity:0;-webkit-transform:translateX(-50%);transform:translateX(-50%);-webkit-transition:opacity 75ms linear;transition:opacity 75ms linear}.cheetah-grid__tooltip-element--shown{opacity:1;-webkit-transform:translateX(-50%);transform:translateX(-50%);-webkit-animation:cheetah-grid__tooltip-element--shown-animation .15s ease-out;animation:cheetah-grid__tooltip-element--shown-animation .15s ease-out}.cheetah-grid__tooltip-element__content{font-family:Roboto;font-size:12px;font-size:.75rem;min-height:1em;line-height:1;width:100%;display:block;white-space:pre-wrap;margin:0;-webkit-box-sizing:border-box;box-sizing:border-box}", ""]); // Exports

          /* harmony default export */


          __nested_webpack_exports__["default"] = ___CSS_LOADER_EXPORT___;
          /***/
        },

        /***/
        "../node_modules/css-loader/dist/runtime/api.js":
        /*!******************************************************!*\
          !*** ../node_modules/css-loader/dist/runtime/api.js ***!
          \******************************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function node_modulesCssLoaderDistRuntimeApiJs(module, exports, __webpack_require__) {
          "use strict";
          /*
            MIT License http://www.opensource.org/licenses/mit-license.php
            Author Tobias Koppers @sokra
          */
          // css base code, injected by the css-loader
          // eslint-disable-next-line func-names

          module.exports = function (useSourceMap) {
            var list = []; // return the list of modules as css string

            list.toString = function toString() {
              return this.map(function (item) {
                var content = cssWithMappingToString(item, useSourceMap);

                if (item[2]) {
                  return "@media ".concat(item[2], " {").concat(content, "}");
                }

                return content;
              }).join('');
            }; // import a list of modules into the list
            // eslint-disable-next-line func-names


            list.i = function (modules, mediaQuery, dedupe) {
              if (typeof modules === 'string') {
                // eslint-disable-next-line no-param-reassign
                modules = [[null, modules, '']];
              }

              var alreadyImportedModules = {};

              if (dedupe) {
                for (var i = 0; i < this.length; i++) {
                  // eslint-disable-next-line prefer-destructuring
                  var id = this[i][0];

                  if (id != null) {
                    alreadyImportedModules[id] = true;
                  }
                }
              }

              for (var _i = 0; _i < modules.length; _i++) {
                var item = [].concat(modules[_i]);

                if (dedupe && alreadyImportedModules[item[0]]) {
                  // eslint-disable-next-line no-continue
                  continue;
                }

                if (mediaQuery) {
                  if (!item[2]) {
                    item[2] = mediaQuery;
                  } else {
                    item[2] = "".concat(mediaQuery, " and ").concat(item[2]);
                  }
                }

                list.push(item);
              }
            };

            return list;
          };

          function cssWithMappingToString(item, useSourceMap) {
            var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring

            var cssMapping = item[3];

            if (!cssMapping) {
              return content;
            }

            if (useSourceMap && typeof btoa === 'function') {
              var sourceMapping = toComment(cssMapping);
              var sourceURLs = cssMapping.sources.map(function (source) {
                return "/*# sourceURL=".concat(cssMapping.sourceRoot || '').concat(source, " */");
              });
              return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
            }

            return [content].join('\n');
          } // Adapted from convert-source-map (MIT)


          function toComment(sourceMap) {
            // eslint-disable-next-line no-undef
            var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
            var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
            return "/*# ".concat(data, " */");
          }
          /***/

        },

        /***/
        "../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
        /*!*****************************************************************************!*\
          !*** ../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
          \*****************************************************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function node_modulesStyleLoaderDistRuntimeInjectStylesIntoStyleTagJs(module, exports, __nested_webpack_require_38831__) {
          "use strict";

          var isOldIE = function isOldIE() {
            var memo;
            return function memorize() {
              if (typeof memo === 'undefined') {
                // Test for IE <= 9 as proposed by Browserhacks
                // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
                // Tests for existence of standard globals is to allow style-loader
                // to operate correctly into non-standard environments
                // @see https://github.com/webpack-contrib/style-loader/issues/177
                memo = Boolean(window && document && document.all && !window.atob);
              }

              return memo;
            };
          }();

          var getTarget = function getTarget() {
            var memo = {};
            return function memorize(target) {
              if (typeof memo[target] === 'undefined') {
                var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

                if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
                  try {
                    // This will throw an exception if access to iframe is blocked
                    // due to cross-origin restrictions
                    styleTarget = styleTarget.contentDocument.head;
                  } catch (e) {
                    // istanbul ignore next
                    styleTarget = null;
                  }
                }

                memo[target] = styleTarget;
              }

              return memo[target];
            };
          }();

          var stylesInDom = [];

          function getIndexByIdentifier(identifier) {
            var result = -1;

            for (var i = 0; i < stylesInDom.length; i++) {
              if (stylesInDom[i].identifier === identifier) {
                result = i;
                break;
              }
            }

            return result;
          }

          function modulesToDom(list, options) {
            var idCountMap = {};
            var identifiers = [];

            for (var i = 0; i < list.length; i++) {
              var item = list[i];
              var id = options.base ? item[0] + options.base : item[0];
              var count = idCountMap[id] || 0;
              var identifier = "".concat(id, " ").concat(count);
              idCountMap[id] = count + 1;
              var index = getIndexByIdentifier(identifier);
              var obj = {
                css: item[1],
                media: item[2],
                sourceMap: item[3]
              };

              if (index !== -1) {
                stylesInDom[index].references++;
                stylesInDom[index].updater(obj);
              } else {
                stylesInDom.push({
                  identifier: identifier,
                  updater: addStyle(obj, options),
                  references: 1
                });
              }

              identifiers.push(identifier);
            }

            return identifiers;
          }

          function insertStyleElement(options) {
            var style = document.createElement('style');
            var attributes = options.attributes || {};

            if (typeof attributes.nonce === 'undefined') {
              var nonce =  true ? __nested_webpack_require_38831__.nc : 0;

              if (nonce) {
                attributes.nonce = nonce;
              }
            }

            Object.keys(attributes).forEach(function (key) {
              style.setAttribute(key, attributes[key]);
            });

            if (typeof options.insert === 'function') {
              options.insert(style);
            } else {
              var target = getTarget(options.insert || 'head');

              if (!target) {
                throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
              }

              target.appendChild(style);
            }

            return style;
          }

          function removeStyleElement(style) {
            // istanbul ignore if
            if (style.parentNode === null) {
              return false;
            }

            style.parentNode.removeChild(style);
          }
          /* istanbul ignore next  */


          var replaceText = function replaceText() {
            var textStore = [];
            return function replace(index, replacement) {
              textStore[index] = replacement;
              return textStore.filter(Boolean).join('\n');
            };
          }();

          function applyToSingletonTag(style, index, remove, obj) {
            var css = remove ? '' : obj.media ? "@media ".concat(obj.media, " {").concat(obj.css, "}") : obj.css; // For old IE

            /* istanbul ignore if  */

            if (style.styleSheet) {
              style.styleSheet.cssText = replaceText(index, css);
            } else {
              var cssNode = document.createTextNode(css);
              var childNodes = style.childNodes;

              if (childNodes[index]) {
                style.removeChild(childNodes[index]);
              }

              if (childNodes.length) {
                style.insertBefore(cssNode, childNodes[index]);
              } else {
                style.appendChild(cssNode);
              }
            }
          }

          function applyToTag(style, options, obj) {
            var css = obj.css;
            var media = obj.media;
            var sourceMap = obj.sourceMap;

            if (media) {
              style.setAttribute('media', media);
            } else {
              style.removeAttribute('media');
            }

            if (sourceMap && typeof btoa !== 'undefined') {
              css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
            } // For old IE

            /* istanbul ignore if  */


            if (style.styleSheet) {
              style.styleSheet.cssText = css;
            } else {
              while (style.firstChild) {
                style.removeChild(style.firstChild);
              }

              style.appendChild(document.createTextNode(css));
            }
          }

          var singleton = null;
          var singletonCounter = 0;

          function addStyle(obj, options) {
            var style;
            var update;
            var remove;

            if (options.singleton) {
              var styleIndex = singletonCounter++;
              style = singleton || (singleton = insertStyleElement(options));
              update = applyToSingletonTag.bind(null, style, styleIndex, false);
              remove = applyToSingletonTag.bind(null, style, styleIndex, true);
            } else {
              style = insertStyleElement(options);
              update = applyToTag.bind(null, style, options);

              remove = function remove() {
                removeStyleElement(style);
              };
            }

            update(obj);
            return function updateStyle(newObj) {
              if (newObj) {
                if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {
                  return;
                }

                update(obj = newObj);
              } else {
                remove();
              }
            };
          }

          module.exports = function (list, options) {
            options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
            // tags it will allow on a page

            if (!options.singleton && typeof options.singleton !== 'boolean') {
              options.singleton = isOldIE();
            }

            list = list || [];
            var lastIdentifiers = modulesToDom(list, options);
            return function update(newList) {
              newList = newList || [];

              if (Object.prototype.toString.call(newList) !== '[object Array]') {
                return;
              }

              for (var i = 0; i < lastIdentifiers.length; i++) {
                var identifier = lastIdentifiers[i];
                var index = getIndexByIdentifier(identifier);
                stylesInDom[index].references--;
              }

              var newLastIdentifiers = modulesToDom(newList, options);

              for (var _i = 0; _i < lastIdentifiers.length; _i++) {
                var _identifier = lastIdentifiers[_i];

                var _index = getIndexByIdentifier(_identifier);

                if (stylesInDom[_index].references === 0) {
                  stylesInDom[_index].updater();

                  stylesInDom.splice(_index, 1);
                }
              }

              lastIdentifiers = newLastIdentifiers;
            };
          };
          /***/

        },

        /***/
        "../node_modules/webpack/buildin/global.js":
        /*!*************************************************!*\
          !*** ../node_modules/webpack/buildin/global.js ***!
          \*************************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function node_modulesWebpackBuildinGlobalJs(module, exports) {
          var g; // This works in non-strict mode

          g = function () {
            return this;
          }();

          try {
            // This works if eval is allowed (see CSP)
            g = g || new Function("return this")();
          } catch (e) {
            // This works if the window reference is available
            if (_typeof(window) === "object") g = window;
          } // g can still be undefined, but nothing to do about it...
          // We return undefined, instead of nothing here, so it's
          // easier to handle this case. if(!global) { ...}


          module.exports = g;
          /***/
        },

        /***/
        "../src/js/columns/action/internal/InlineInputElement.css":
        /*!****************************************************************!*\
          !*** ../src/js/columns/action/internal/InlineInputElement.css ***!
          \****************************************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function srcJsColumnsActionInternalInlineInputElementCss(module, exports, __nested_webpack_require_49454__) {
          var api = __nested_webpack_require_49454__(
          /*! ../../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */
          "../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");

          var content = __nested_webpack_require_49454__(
          /*! !../../../../../node_modules/css-loader/dist/cjs.js??ref--5-1!../../../../../node_modules/postcss-loader/src??ref--5-2!./InlineInputElement.css */
          "../node_modules/css-loader/dist/cjs.js?!../node_modules/postcss-loader/src/index.js?!../src/js/columns/action/internal/InlineInputElement.css");

          content = content.__esModule ? content.default : content;

          if (typeof content === 'string') {
            content = [[module.i, content, '']];
          }

          var options = {};
          options.insert = "head";
          options.singleton = false;
          var update = api(content, options);
          module.exports = content.locals || {};
          /***/
        },

        /***/
        "../src/js/columns/action/internal/InlineMenuElement.css":
        /*!***************************************************************!*\
          !*** ../src/js/columns/action/internal/InlineMenuElement.css ***!
          \***************************************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function srcJsColumnsActionInternalInlineMenuElementCss(module, exports, __nested_webpack_require_50991__) {
          var api = __nested_webpack_require_50991__(
          /*! ../../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */
          "../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");

          var content = __nested_webpack_require_50991__(
          /*! !../../../../../node_modules/css-loader/dist/cjs.js??ref--5-1!../../../../../node_modules/postcss-loader/src??ref--5-2!./InlineMenuElement.css */
          "../node_modules/css-loader/dist/cjs.js?!../node_modules/postcss-loader/src/index.js?!../src/js/columns/action/internal/InlineMenuElement.css");

          content = content.__esModule ? content.default : content;

          if (typeof content === 'string') {
            content = [[module.i, content, '']];
          }

          var options = {};
          options.insert = "head";
          options.singleton = false;
          var update = api(content, options);
          module.exports = content.locals || {};
          /***/
        },

        /***/
        "../src/js/columns/action/internal/SmallDialogInputElement.css":
        /*!*********************************************************************!*\
          !*** ../src/js/columns/action/internal/SmallDialogInputElement.css ***!
          \*********************************************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function srcJsColumnsActionInternalSmallDialogInputElementCss(module, exports, __nested_webpack_require_52556__) {
          var api = __nested_webpack_require_52556__(
          /*! ../../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */
          "../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");

          var content = __nested_webpack_require_52556__(
          /*! !../../../../../node_modules/css-loader/dist/cjs.js??ref--5-1!../../../../../node_modules/postcss-loader/src??ref--5-2!./SmallDialogInputElement.css */
          "../node_modules/css-loader/dist/cjs.js?!../node_modules/postcss-loader/src/index.js?!../src/js/columns/action/internal/SmallDialogInputElement.css");

          content = content.__esModule ? content.default : content;

          if (typeof content === 'string') {
            content = [[module.i, content, '']];
          }

          var options = {};
          options.insert = "head";
          options.singleton = false;
          var update = api(content, options);
          module.exports = content.locals || {};
          /***/
        },

        /***/
        "../src/js/columns/message/internal/ErrorMessageElement.css":
        /*!******************************************************************!*\
          !*** ../src/js/columns/message/internal/ErrorMessageElement.css ***!
          \******************************************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function srcJsColumnsMessageInternalErrorMessageElementCss(module, exports, __nested_webpack_require_54118__) {
          var api = __nested_webpack_require_54118__(
          /*! ../../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */
          "../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");

          var content = __nested_webpack_require_54118__(
          /*! !../../../../../node_modules/css-loader/dist/cjs.js??ref--5-1!../../../../../node_modules/postcss-loader/src??ref--5-2!./ErrorMessageElement.css */
          "../node_modules/css-loader/dist/cjs.js?!../node_modules/postcss-loader/src/index.js?!../src/js/columns/message/internal/ErrorMessageElement.css");

          content = content.__esModule ? content.default : content;

          if (typeof content === 'string') {
            content = [[module.i, content, '']];
          }

          var options = {};
          options.insert = "head";
          options.singleton = false;
          var update = api(content, options);
          module.exports = content.locals || {};
          /***/
        },

        /***/
        "../src/js/columns/message/internal/MessageElement.css":
        /*!*************************************************************!*\
          !*** ../src/js/columns/message/internal/MessageElement.css ***!
          \*************************************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function srcJsColumnsMessageInternalMessageElementCss(module, exports, __nested_webpack_require_55648__) {
          var api = __nested_webpack_require_55648__(
          /*! ../../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */
          "../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");

          var content = __nested_webpack_require_55648__(
          /*! !../../../../../node_modules/css-loader/dist/cjs.js??ref--5-1!../../../../../node_modules/postcss-loader/src??ref--5-2!./MessageElement.css */
          "../node_modules/css-loader/dist/cjs.js?!../node_modules/postcss-loader/src/index.js?!../src/js/columns/message/internal/MessageElement.css");

          content = content.__esModule ? content.default : content;

          if (typeof content === 'string') {
            content = [[module.i, content, '']];
          }

          var options = {};
          options.insert = "head";
          options.singleton = false;
          var update = api(content, options);
          module.exports = content.locals || {};
          /***/
        },

        /***/
        "../src/js/columns/message/internal/WarningMessageElement.css":
        /*!********************************************************************!*\
          !*** ../src/js/columns/message/internal/WarningMessageElement.css ***!
          \********************************************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function srcJsColumnsMessageInternalWarningMessageElementCss(module, exports, __nested_webpack_require_57203__) {
          var api = __nested_webpack_require_57203__(
          /*! ../../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */
          "../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");

          var content = __nested_webpack_require_57203__(
          /*! !../../../../../node_modules/css-loader/dist/cjs.js??ref--5-1!../../../../../node_modules/postcss-loader/src??ref--5-2!./WarningMessageElement.css */
          "../node_modules/css-loader/dist/cjs.js?!../node_modules/postcss-loader/src/index.js?!../src/js/columns/message/internal/WarningMessageElement.css");

          content = content.__esModule ? content.default : content;

          if (typeof content === 'string') {
            content = [[module.i, content, '']];
          }

          var options = {};
          options.insert = "head";
          options.singleton = false;
          var update = api(content, options);
          module.exports = content.locals || {};
          /***/
        },

        /***/
        "../src/js/internal/style.css":
        /*!************************************!*\
          !*** ../src/js/internal/style.css ***!
          \************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function srcJsInternalStyleCss(module, exports, __nested_webpack_require_58614__) {
          var api = __nested_webpack_require_58614__(
          /*! ../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */
          "../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");

          var content = __nested_webpack_require_58614__(
          /*! !../../../node_modules/css-loader/dist/cjs.js??ref--5-1!../../../node_modules/postcss-loader/src??ref--5-2!./style.css */
          "../node_modules/css-loader/dist/cjs.js?!../node_modules/postcss-loader/src/index.js?!../src/js/internal/style.css");

          content = content.__esModule ? content.default : content;

          if (typeof content === 'string') {
            content = [[module.i, content, '']];
          }

          var options = {};
          options.insert = "head";
          options.singleton = false;
          var update = api(content, options);
          module.exports = content.locals || {};
          /***/
        },

        /***/
        "../src/js/tooltip/internal/TooltipElement.css":
        /*!*****************************************************!*\
          !*** ../src/js/tooltip/internal/TooltipElement.css ***!
          \*****************************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function srcJsTooltipInternalTooltipElementCss(module, exports, __nested_webpack_require_60043__) {
          var api = __nested_webpack_require_60043__(
          /*! ../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */
          "../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");

          var content = __nested_webpack_require_60043__(
          /*! !../../../../node_modules/css-loader/dist/cjs.js??ref--5-1!../../../../node_modules/postcss-loader/src??ref--5-2!./TooltipElement.css */
          "../node_modules/css-loader/dist/cjs.js?!../node_modules/postcss-loader/src/index.js?!../src/js/tooltip/internal/TooltipElement.css");

          content = content.__esModule ? content.default : content;

          if (typeof content === 'string') {
            content = [[module.i, content, '']];
          }

          var options = {};
          options.insert = "head";
          options.singleton = false;
          var update = api(content, options);
          module.exports = content.locals || {};
          /***/
        },

        /***/
        "./GridCanvasHelper.js":
        /*!*****************************!*\
          !*** ./GridCanvasHelper.js ***!
          \*****************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function GridCanvasHelperJs(module, exports, __nested_webpack_require_61392__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.GridCanvasHelper = void 0;

          var calc = __importStar(__nested_webpack_require_61392__(
          /*! ./internal/calc */
          "./internal/calc.js"));

          var canvashelper = __importStar(__nested_webpack_require_61392__(
          /*! ./tools/canvashelper */
          "./tools/canvashelper.js"));

          var fonts = __importStar(__nested_webpack_require_61392__(
          /*! ./internal/fonts */
          "./internal/fonts.js"));

          var inlineUtils = __importStar(__nested_webpack_require_61392__(
          /*! ./element/inlines */
          "./element/inlines.js"));

          var themes = __importStar(__nested_webpack_require_61392__(
          /*! ./themes */
          "./themes.js"));

          var canvases_1 = __nested_webpack_require_61392__(
          /*! ./internal/canvases */
          "./internal/canvases.js");

          var utils_1 = __nested_webpack_require_61392__(
          /*! ./internal/utils */
          "./internal/utils.js");

          var InlineDrawer_1 = __nested_webpack_require_61392__(
          /*! ./element/InlineDrawer */
          "./element/InlineDrawer.js");

          var Rect_1 = __nested_webpack_require_61392__(
          /*! ./internal/Rect */
          "./internal/Rect.js");

          var color_1 = __nested_webpack_require_61392__(
          /*! ./internal/color */
          "./internal/color.js");

          var _toBoxArray = utils_1.style.toBoxArray;
          var INLINE_ELLIPSIS = inlineUtils.of("\u2026");
          var TEXT_OFFSET = 2;
          var CHECKBOX_OFFSET = TEXT_OFFSET + 1;

          function invalidateCell(context, grid) {
            var col = context.col,
                row = context.row;
            grid.invalidateCell(col, row);
          }

          function _getStyleProperty(color, col, row, grid, context) {
            return (0, utils_1.getOrApply)(color, {
              col: col,
              row: row,
              grid: grid,
              context: context
            });
          }

          function getFont(font, col, row, grid, context) {
            if (font == null) {
              return undefined;
            }

            return (0, utils_1.getOrApply)(font, {
              col: col,
              row: row,
              grid: grid,
              context: context
            });
          }

          function _getThemeValue(grid) {
            for (var _len = arguments.length, names = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              names[_key - 1] = arguments[_key];
            }

            var gridThemeValue = (0, utils_1.getChainSafe).apply(void 0, [grid.theme].concat(names));

            if (gridThemeValue == null) {
              // use default theme
              return (0, utils_1.getChainSafe).apply(void 0, [themes.getDefault()].concat(names));
            }

            if (typeof gridThemeValue !== "function") {
              return gridThemeValue;
            }

            var defaultThemeValue; // eslint-disable-next-line @typescript-eslint/no-explicit-any

            return function (args) {
              var value = gridThemeValue(args);

              if (value != null) {
                // use grid theme
                return value;
              } // use default theme


              defaultThemeValue = defaultThemeValue || (0, utils_1.getChainSafe).apply(void 0, [themes.getDefault()].concat(names));
              return (0, utils_1.getOrApply)(defaultThemeValue, args); // eslint-disable-next-line @typescript-eslint/no-explicit-any
            };
          }

          function _testFontLoad(font, value, context, grid) {
            if (font) {
              if (!fonts.check(font, value)) {
                fonts.load(font, value, function () {
                  return invalidateCell(context, grid);
                });
                return false;
              }
            }

            return true;
          }

          function drawInlines(ctx, inlines, rect, offset, offsetTop, offsetBottom, col, row, grid) {
            function drawInline(inline, offsetLeft, offsetRight) {
              if (inline.canDraw()) {
                ctx.save();

                try {
                  ctx.fillStyle = _getStyleProperty(inline.color() || ctx.fillStyle, col, row, grid, ctx);
                  ctx.font = inline.font() || ctx.font;
                  inline.draw({
                    ctx: ctx,
                    canvashelper: canvashelper,
                    rect: rect,
                    offset: offset,
                    offsetLeft: offsetLeft,
                    offsetRight: offsetRight,
                    offsetTop: offsetTop,
                    offsetBottom: offsetBottom
                  });
                } finally {
                  ctx.restore();
                }
              } else {
                inline.onReady(function () {
                  return grid.invalidateCell(col, row);
                }); //noop
              }
            }

            if (inlines.length === 1) {
              //1
              var inline = inlines[0];
              drawInline(inline, 0, 0);
            } else {
              var inlineWidths = inlines.map(function (inline) {
                return (inline.width({
                  ctx: ctx
                }) || 0) - 0;
              });
              var offsetRight = inlineWidths.reduce(function (a, b) {
                return a + b;
              });
              var offsetLeft = 0;
              inlines.forEach(function (inline, index) {
                var inlineWidth = inlineWidths[index];
                offsetRight -= inlineWidth;
                drawInline(inline, offsetLeft, offsetRight);
                offsetLeft += inlineWidth;
              });
            }
          }

          function buildInlines(icons, inline) {
            return inlineUtils.buildInlines(icons, inline || "");
          }

          function inlineToString(inline) {
            return inlineUtils.string(inline);
          }

          function getOverflowInline(textOverflow) {
            if (!isAllowOverflow(textOverflow) || textOverflow === "ellipsis") {
              return INLINE_ELLIPSIS;
            }

            textOverflow = textOverflow.trim();

            if (textOverflow.length === 1) {
              return inlineUtils.of(textOverflow[0]);
            }

            return INLINE_ELLIPSIS;
          }

          function isAllowOverflow(textOverflow) {
            return Boolean(textOverflow && textOverflow !== "clip" && typeof textOverflow === "string");
          }

          function getOverflowInlinesIndex(ctx, inlines, width) {
            var maxWidth = width - 3;
            /*buffer*/

            var lineWidth = 0;

            for (var i = 0; i < inlines.length; i++) {
              var inline = inlines[i];
              var inlineWidth = (inline.width({
                ctx: ctx
              }) || 0) - 0;

              if (lineWidth + inlineWidth > maxWidth) {
                return {
                  index: i,
                  lineWidth: lineWidth,
                  remWidth: maxWidth - lineWidth
                };
              }

              lineWidth += inlineWidth;
            }

            return null;
          }

          function isOverflowInlines(ctx, inlines, width) {
            return !!getOverflowInlinesIndex(ctx, inlines, width);
          }

          function breakWidthInlines(ctx, inlines, width) {
            var indexData = getOverflowInlinesIndex(ctx, inlines, width);

            if (!indexData) {
              return {
                beforeInlines: inlines,
                overflow: false,
                afterInlines: []
              };
            }

            var index = indexData.index,
                remWidth = indexData.remWidth;
            var inline = inlines[index];
            var beforeInlines = inlines.slice(0, index);
            var afterInlines = [];

            if (inline.canBreak()) {
              var _inline$breakWord = inline.breakWord(ctx, remWidth),
                  before = _inline$breakWord.before,
                  after = _inline$breakWord.after;

              if (!before && !beforeInlines.length) {
                var _inline$breakAll = inline.breakAll(ctx, remWidth);

                before = _inline$breakAll.before;
                after = _inline$breakAll.after;
              }

              if (!before && !beforeInlines.length) {
                // Always return one char
                var _inline$splitIndex = inline.splitIndex(1);

                before = _inline$splitIndex.before;
                after = _inline$splitIndex.after;
              }

              if (before) {
                beforeInlines.push(before);
              }

              if (after) {
                afterInlines.push(after);
              }

              afterInlines.push.apply(afterInlines, _toConsumableArray(inlines.slice(index + 1)));
            } else {
              if (!beforeInlines.length) {
                // Always return one char
                beforeInlines.push(inline);
              }

              afterInlines.push.apply(afterInlines, _toConsumableArray(inlines.slice(beforeInlines.length)));
            }

            return {
              beforeInlines: beforeInlines,
              overflow: true,
              afterInlines: afterInlines
            };
          }

          function truncateInlines(ctx, inlines, width, option) {
            var indexData = getOverflowInlinesIndex(ctx, inlines, width);

            if (!indexData) {
              return {
                inlines: inlines,
                overflow: false
              };
            }

            var index = indexData.index,
                lineWidth = indexData.lineWidth;
            var inline = inlines[index];
            var overflowInline = getOverflowInline(option);
            var ellipsisWidth = overflowInline.width({
              ctx: ctx
            });
            var remWidth = width - lineWidth - ellipsisWidth;
            var result = inlines.slice(0, index);

            if (inline.canBreak()) {
              var _inline$breakAll2 = inline.breakAll(ctx, remWidth),
                  before = _inline$breakAll2.before;

              if (before) {
                result.push(before);
              }
            }

            result.push(overflowInline);
            return {
              inlines: result,
              overflow: true
            };
          }

          function _inlineRect(grid, ctx, inline, drawRect, col, row, _ref) {
            var offset = _ref.offset,
                color = _ref.color,
                textAlign = _ref.textAlign,
                textBaseline = _ref.textBaseline,
                font = _ref.font,
                textOverflow = _ref.textOverflow,
                icons = _ref.icons,
                trailingIcon = _ref.trailingIcon;
            //style
            ctx.fillStyle = _getStyleProperty(color || ctx.fillStyle, col, row, grid, ctx);
            ctx.textAlign = textAlign;
            ctx.textBaseline = textBaseline;
            ctx.font = font || ctx.font;
            var inlines = buildInlines(icons, inline);
            var trailingIconInline = trailingIcon ? inlineUtils.iconOf(trailingIcon) : null;
            var inlineDrawRect = drawRect;
            var width = drawRect.width;
            var trailingIconWidth = 0;

            if (trailingIconInline) {
              trailingIconWidth = trailingIconInline.width({
                ctx: ctx
              });
              width -= trailingIconWidth;
              inlineDrawRect = new Rect_1.Rect(drawRect.left, drawRect.top, width, drawRect.height);
            }

            if (isAllowOverflow(textOverflow) && isOverflowInlines(ctx, inlines, width)) {
              var _truncateInlines = truncateInlines(ctx, inlines, width, textOverflow),
                  truncInlines = _truncateInlines.inlines,
                  overflow = _truncateInlines.overflow;

              inlines = truncInlines;
              grid.setCellOverflowText(col, row, overflow && inlineToString(inline));
            } else {
              grid.setCellOverflowText(col, row, false);
            }

            drawInlines(ctx, inlines, inlineDrawRect, offset, 0, 0, col, row, grid);

            if (trailingIconInline) {
              // Draw trailing icon
              var sumWidth = 0;
              inlines.forEach(function (inline) {
                sumWidth += inline.width({
                  ctx: ctx
                });
              });
              var baseRect = new Rect_1.Rect(drawRect.left, drawRect.top, drawRect.width, drawRect.height);
              var trailingIconRect = baseRect.copy();

              if (width < sumWidth) {
                trailingIconRect.left = trailingIconRect.right - trailingIconWidth - offset;
              } else {
                trailingIconRect.left += sumWidth;
              }

              trailingIconRect.right = baseRect.right;
              drawInlines(ctx, [trailingIconInline], trailingIconRect, offset, 0, 0, col, row, grid);
            }
          } // eslint-disable-next-line complexity


          function _multiInlineRect(grid, ctx, multiInlines, drawRect, col, row, _ref2) {
            var offset = _ref2.offset,
                color = _ref2.color,
                textAlign = _ref2.textAlign,
                textBaseline = _ref2.textBaseline,
                font = _ref2.font,
                lineHeight = _ref2.lineHeight,
                autoWrapText = _ref2.autoWrapText,
                lineClamp = _ref2.lineClamp,
                textOverflow = _ref2.textOverflow,
                icons = _ref2.icons,
                trailingIcon = _ref2.trailingIcon;
            //style
            ctx.fillStyle = _getStyleProperty(color || ctx.fillStyle, col, row, grid, ctx);
            ctx.textAlign = textAlign;
            ctx.textBaseline = textBaseline;
            ctx.font = font || ctx.font;

            if (lineClamp === "auto") {
              var rectHeight = drawRect.height - offset * 2 - 2;
              /*offset added by Inline#draw*/

              lineClamp = Math.max(Math.floor(rectHeight / lineHeight), 1);
            }

            var trailingIconInline = trailingIcon ? inlineUtils.iconOf(trailingIcon) : null;
            var width = drawRect.width;
            var trailingIconWidth = 0;

            if (trailingIconInline) {
              trailingIconWidth = trailingIconInline.width({
                ctx: ctx
              });
              width -= trailingIconWidth;
            }

            var buildedMultiInlines;

            if (autoWrapText || lineClamp > 0 || isAllowOverflow(textOverflow)) {
              buildedMultiInlines = [];
              var procLineClamp = lineClamp > 0 ? function (inlines, hasNext) {
                if (buildedMultiInlines.length + 1 >= lineClamp) {
                  if (inlines.length === 0 && hasNext) {
                    buildedMultiInlines.push([getOverflowInline(textOverflow)]);
                    grid.setCellOverflowText(col, row, multiInlines.map(inlineToString).join("\n"));
                  } else {
                    var _truncateInlines2 = truncateInlines(ctx, inlines, width, textOverflow),
                        truncInlines = _truncateInlines2.inlines,
                        overflow = _truncateInlines2.overflow;

                    buildedMultiInlines.push(hasNext && !overflow ? truncInlines.concat([getOverflowInline(textOverflow)]) : truncInlines);

                    if (overflow || hasNext) {
                      grid.setCellOverflowText(col, row, multiInlines.map(inlineToString).join("\n"));
                    }
                  }

                  return false;
                }

                return true;
              } : function () {
                return true;
              };
              var procLine = autoWrapText ? function (inlines, hasNext) {
                if (!procLineClamp(inlines, hasNext)) {
                  return false;
                }

                while (inlines.length) {
                  if (!procLineClamp(inlines, hasNext)) {
                    return false;
                  }

                  var _breakWidthInlines = breakWidthInlines(ctx, inlines, width),
                      beforeInlines = _breakWidthInlines.beforeInlines,
                      afterInlines = _breakWidthInlines.afterInlines;

                  buildedMultiInlines.push(beforeInlines);
                  inlines = afterInlines;
                }

                return true;
              } : isAllowOverflow(textOverflow) ? function (inlines, hasNext) {
                if (!procLineClamp(inlines, hasNext)) {
                  return false;
                }

                var _truncateInlines3 = truncateInlines(ctx, inlines, width, textOverflow),
                    truncInlines = _truncateInlines3.inlines,
                    overflow = _truncateInlines3.overflow;

                buildedMultiInlines.push(truncInlines);

                if (overflow) {
                  grid.setCellOverflowText(col, row, multiInlines.map(inlineToString).join("\n"));
                }

                return true;
              } : function (inlines, hasNext) {
                if (!procLineClamp(inlines, hasNext)) {
                  return false;
                }

                buildedMultiInlines.push(inlines);
                return true;
              };
              grid.setCellOverflowText(col, row, false);

              for (var lineRow = 0; lineRow < multiInlines.length; lineRow++) {
                var inline = multiInlines[lineRow];
                var buildedInline = buildInlines(lineRow === 0 ? icons : undefined, inline);

                if (!procLine(buildedInline, lineRow + 1 < multiInlines.length)) {
                  break;
                }
              }
            } else {
              grid.setCellOverflowText(col, row, false);
              buildedMultiInlines = multiInlines.map(function (inline, lineRow) {
                return buildInlines(lineRow === 0 ? icons : undefined, inline);
              });
            }

            var paddingTop = 0;
            var paddingBottom = lineHeight * (buildedMultiInlines.length - 1);

            if (ctx.textBaseline === "top" || ctx.textBaseline === "hanging") {
              var em = (0, canvases_1.getFontSize)(ctx, ctx.font).height;
              var pad = (lineHeight - em) / 2;
              paddingTop += pad;
              paddingBottom -= pad;
            } else if (ctx.textBaseline === "bottom" || ctx.textBaseline === "alphabetic" || ctx.textBaseline === "ideographic") {
              var _em = (0, canvases_1.getFontSize)(ctx, ctx.font).height;

              var _pad = (lineHeight - _em) / 2;

              paddingTop -= _pad;
              paddingBottom += _pad;
            }

            buildedMultiInlines.forEach(function (buildedInline) {
              drawInlines(ctx, buildedInline, drawRect, offset, paddingTop, paddingBottom, col, row, grid);
              paddingTop += lineHeight;
              paddingBottom -= lineHeight;
            });

            if (trailingIconInline) {
              // Draw trailing icon
              var maxWidth = 0;
              buildedMultiInlines.forEach(function (buildedInline) {
                var sumWidth = 0;
                buildedInline.forEach(function (inline) {
                  sumWidth += inline.width({
                    ctx: ctx
                  });
                });
                maxWidth = Math.max(maxWidth, sumWidth);
              });
              var baseRect = new Rect_1.Rect(drawRect.left, drawRect.top, drawRect.width, drawRect.height);
              var trailingIconRect = baseRect.copy();

              if (width < maxWidth) {
                trailingIconRect.left = trailingIconRect.right - trailingIconWidth - offset;
              } else {
                trailingIconRect.left += maxWidth;
              }

              trailingIconRect.right = baseRect.right;
              drawInlines(ctx, [trailingIconInline], trailingIconRect, offset, 0, 0, col, row, grid);
            }
          }

          function calcElapsedColor(startColor, endColor, elapsedTime) {
            var startColorRGB = (0, color_1.colorToRGB)(startColor);
            var endColorRGB = (0, color_1.colorToRGB)(endColor);

            var getRGB = function getRGB(colorName) {
              var start = startColorRGB[colorName];
              var end = endColorRGB[colorName];

              if (elapsedTime >= 1) {
                return end;
              }

              if (elapsedTime <= 0) {
                return start;
              }

              var diff = start - end;
              return Math.ceil(start - diff * elapsedTime);
            };

            return "rgb(".concat(getRGB("r"), ", ").concat(getRGB("g"), ", ").concat(getRGB("b"), ")");
          }

          function drawCheckbox(ctx, rect, col, row, check, helper, _ref3) {
            var _ref3$animElapsedTime = _ref3.animElapsedTime,
                animElapsedTime = _ref3$animElapsedTime === void 0 ? 1 : _ref3$animElapsedTime,
                _ref3$uncheckBgColor = _ref3.uncheckBgColor,
                uncheckBgColor = _ref3$uncheckBgColor === void 0 ? helper.theme.checkbox.uncheckBgColor : _ref3$uncheckBgColor,
                _ref3$checkBgColor = _ref3.checkBgColor,
                checkBgColor = _ref3$checkBgColor === void 0 ? helper.theme.checkbox.checkBgColor : _ref3$checkBgColor,
                _ref3$borderColor = _ref3.borderColor,
                borderColor = _ref3$borderColor === void 0 ? helper.theme.checkbox.borderColor : _ref3$borderColor,
                _ref3$textAlign = _ref3.textAlign,
                textAlign = _ref3$textAlign === void 0 ? "center" : _ref3$textAlign,
                _ref3$textBaseline = _ref3.textBaseline,
                textBaseline = _ref3$textBaseline === void 0 ? "middle" : _ref3$textBaseline;
            var positionOpt = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : {};
            var boxWidth = canvashelper.measureCheckbox(ctx).width;
            ctx.textAlign = textAlign;
            ctx.textBaseline = textBaseline;
            var pos = (0, canvases_1.calcStartPosition)(ctx, rect, boxWidth + 1
            /*+1*/
            , boxWidth + 1
            /*+1*/
            , positionOpt);
            uncheckBgColor = helper.getColor(uncheckBgColor, col, row, ctx);
            checkBgColor = helper.getColor(checkBgColor, col, row, ctx);
            borderColor = helper.getColor(borderColor, col, row, ctx);

            if (0 < animElapsedTime && animElapsedTime < 1) {
              uncheckBgColor = check ? uncheckBgColor : calcElapsedColor(checkBgColor, uncheckBgColor, animElapsedTime);
              checkBgColor = check ? calcElapsedColor(uncheckBgColor, checkBgColor, animElapsedTime) : checkBgColor;
            }

            canvashelper.drawCheckbox(ctx, pos.x, pos.y, check ? animElapsedTime : false, {
              uncheckBgColor: uncheckBgColor,
              checkBgColor: checkBgColor,
              borderColor: borderColor
            });
          }

          function drawRadioButton(ctx, rect, col, row, check, helper, _ref4) {
            var _ref4$animElapsedTime = _ref4.animElapsedTime,
                animElapsedTime = _ref4$animElapsedTime === void 0 ? 1 : _ref4$animElapsedTime,
                _ref4$checkColor = _ref4.checkColor,
                checkColor = _ref4$checkColor === void 0 ? helper.theme.radioButton.checkColor : _ref4$checkColor,
                _ref4$uncheckBorderCo = _ref4.uncheckBorderColor,
                uncheckBorderColor = _ref4$uncheckBorderCo === void 0 ? helper.theme.radioButton.uncheckBorderColor : _ref4$uncheckBorderCo,
                _ref4$checkBorderColo = _ref4.checkBorderColor,
                checkBorderColor = _ref4$checkBorderColo === void 0 ? helper.theme.radioButton.checkBorderColor : _ref4$checkBorderColo,
                _ref4$uncheckBgColor = _ref4.uncheckBgColor,
                uncheckBgColor = _ref4$uncheckBgColor === void 0 ? helper.theme.radioButton.uncheckBgColor : _ref4$uncheckBgColor,
                _ref4$checkBgColor = _ref4.checkBgColor,
                checkBgColor = _ref4$checkBgColor === void 0 ? helper.theme.radioButton.checkBgColor : _ref4$checkBgColor,
                _ref4$textAlign = _ref4.textAlign,
                textAlign = _ref4$textAlign === void 0 ? "center" : _ref4$textAlign,
                _ref4$textBaseline = _ref4.textBaseline,
                textBaseline = _ref4$textBaseline === void 0 ? "middle" : _ref4$textBaseline;
            var positionOpt = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : {};
            var boxWidth = canvashelper.measureRadioButton(ctx).width;
            ctx.textAlign = textAlign;
            ctx.textBaseline = textBaseline;
            var pos = (0, canvases_1.calcStartPosition)(ctx, rect, boxWidth + 1
            /*+1*/
            , boxWidth + 1
            /*+1*/
            , positionOpt);
            checkColor = helper.getColor(checkColor, col, row, ctx);
            uncheckBorderColor = helper.getColor(uncheckBorderColor, col, row, ctx);
            checkBorderColor = helper.getColor(checkBorderColor, col, row, ctx);
            uncheckBgColor = helper.getColor(uncheckBgColor, col, row, ctx);
            checkBgColor = helper.getColor(checkBgColor, col, row, ctx);
            var borderColor = check ? checkBorderColor : uncheckBorderColor;
            var bgColor = check ? checkBgColor : uncheckBgColor;

            if (0 < animElapsedTime && animElapsedTime < 1) {
              borderColor = check ? calcElapsedColor(uncheckBorderColor, checkBorderColor, animElapsedTime) : calcElapsedColor(checkBorderColor, uncheckBorderColor, animElapsedTime);
              bgColor = check ? calcElapsedColor(uncheckBgColor, checkBgColor, animElapsedTime) : calcElapsedColor(checkBgColor, uncheckBgColor, animElapsedTime);
            }

            canvashelper.drawRadioButton(ctx, pos.x, pos.y, check ? animElapsedTime : 1 - animElapsedTime, {
              checkColor: checkColor,
              borderColor: borderColor,
              bgColor: bgColor
            });
          }

          var ThemeResolver = /*#__PURE__*/function () {
            function ThemeResolver(grid) {
              _classCallCheck(this, ThemeResolver);

              this._checkbox = null;
              this._radioButton = null;
              this._button = null;
              this._tree = null;
              this._header = null;
              this._messages = null;
              this._indicators = null;
              this._grid = grid;
            }

            _createClass(ThemeResolver, [{
              key: "getThemeValue",
              value: function getThemeValue() {
                for (var _len2 = arguments.length, name = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                  name[_key2] = arguments[_key2];
                }

                return _getThemeValue.apply(void 0, [this._grid].concat(name));
              }
            }, {
              key: "font",
              get: function get() {
                return _getThemeValue(this._grid, "font");
              }
            }, {
              key: "underlayBackgroundColor",
              get: function get() {
                return _getThemeValue(this._grid, "underlayBackgroundColor");
              } // color

            }, {
              key: "color",
              get: function get() {
                return _getThemeValue(this._grid, "color");
              }
            }, {
              key: "frozenRowsColor",
              get: function get() {
                return _getThemeValue(this._grid, "frozenRowsColor");
              } // background

            }, {
              key: "defaultBgColor",
              get: function get() {
                return _getThemeValue(this._grid, "defaultBgColor");
              }
            }, {
              key: "frozenRowsBgColor",
              get: function get() {
                return _getThemeValue(this._grid, "frozenRowsBgColor");
              }
            }, {
              key: "selectionBgColor",
              get: function get() {
                return _getThemeValue(this._grid, "selectionBgColor");
              }
            }, {
              key: "highlightBgColor",
              get: function get() {
                return _getThemeValue(this._grid, "highlightBgColor");
              } // border

            }, {
              key: "borderColor",
              get: function get() {
                return _getThemeValue(this._grid, "borderColor");
              }
            }, {
              key: "frozenRowsBorderColor",
              get: function get() {
                return _getThemeValue(this._grid, "frozenRowsBorderColor");
              }
            }, {
              key: "highlightBorderColor",
              get: function get() {
                return _getThemeValue(this._grid, "highlightBorderColor");
              }
            }, {
              key: "checkbox",
              get: function get() {
                var grid = this._grid;
                return this._checkbox || (this._checkbox = {
                  get uncheckBgColor() {
                    return getCheckboxProp("uncheckBgColor");
                  },

                  get checkBgColor() {
                    return getCheckboxProp("checkBgColor");
                  },

                  get borderColor() {
                    return getCheckboxProp("borderColor");
                  }

                });

                function getCheckboxProp(prop) {
                  return _getThemeValue(grid, "checkbox", prop);
                }
              }
            }, {
              key: "radioButton",
              get: function get() {
                var grid = this._grid;
                return this._radioButton || (this._radioButton = {
                  get checkColor() {
                    return getRadioButtonProp("checkColor");
                  },

                  get uncheckBorderColor() {
                    return getRadioButtonProp("uncheckBorderColor");
                  },

                  get checkBorderColor() {
                    return getRadioButtonProp("checkBorderColor");
                  },

                  get uncheckBgColor() {
                    return getRadioButtonProp("uncheckBgColor");
                  },

                  get checkBgColor() {
                    return getRadioButtonProp("checkBgColor");
                  }

                });

                function getRadioButtonProp(prop) {
                  return _getThemeValue(grid, "radioButton", prop);
                }
              }
            }, {
              key: "button",
              get: function get() {
                var grid = this._grid;
                return this._button || (this._button = {
                  get color() {
                    return getButtonProp("color");
                  },

                  get bgColor() {
                    return getButtonProp("bgColor");
                  }

                });

                function getButtonProp(prop) {
                  return _getThemeValue(grid, "button", prop);
                }
              }
            }, {
              key: "tree",
              get: function get() {
                var grid = this._grid;
                return this._tree || (this._tree = {
                  get lineStyle() {
                    return getTreeProp("lineStyle");
                  },

                  get lineColor() {
                    return getTreeProp("lineColor");
                  },

                  get lineWidth() {
                    return getTreeProp("lineWidth");
                  },

                  get treeIcon() {
                    return getTreeProp("treeIcon");
                  }

                });

                function getTreeProp(prop) {
                  return _getThemeValue(grid, "tree", prop);
                }
              }
            }, {
              key: "header",
              get: function get() {
                var grid = this._grid;
                return this._header || (this._header = {
                  get sortArrowColor() {
                    return _getThemeValue(grid, "header", "sortArrowColor");
                  }

                });
              }
            }, {
              key: "messages",
              get: function get() {
                var grid = this._grid;
                return this._messages || (this._messages = {
                  get infoBgColor() {
                    return getMessageProp("infoBgColor");
                  },

                  get errorBgColor() {
                    return getMessageProp("errorBgColor");
                  },

                  get warnBgColor() {
                    return getMessageProp("warnBgColor");
                  },

                  get boxWidth() {
                    return getMessageProp("boxWidth");
                  },

                  get markHeight() {
                    return getMessageProp("markHeight");
                  }

                });

                function getMessageProp(prop) {
                  return _getThemeValue(grid, "messages", prop);
                }
              }
            }, {
              key: "indicators",
              get: function get() {
                var grid = this._grid;
                return this._indicators || (this._indicators = {
                  get topLeftColor() {
                    return getIndicatorsProp("topLeftColor");
                  },

                  get topLeftSize() {
                    return getIndicatorsProp("topLeftSize");
                  },

                  get topRightColor() {
                    return getIndicatorsProp("topRightColor");
                  },

                  get topRightSize() {
                    return getIndicatorsProp("topRightSize");
                  },

                  get bottomRightColor() {
                    return getIndicatorsProp("bottomRightColor");
                  },

                  get bottomRightSize() {
                    return getIndicatorsProp("bottomRightSize");
                  },

                  get bottomLeftColor() {
                    return getIndicatorsProp("bottomLeftColor");
                  },

                  get bottomLeftSize() {
                    return getIndicatorsProp("bottomLeftSize");
                  }

                });

                function getIndicatorsProp(prop) {
                  return _getThemeValue(grid, "indicators", prop);
                }
              }
            }]);

            return ThemeResolver;
          }();

          function strokeRect(ctx, color, left, top, width, height) {
            if (!Array.isArray(color)) {
              if (color) {
                ctx.strokeStyle = color;
                ctx.strokeRect(left, top, width, height);
              }
            } else {
              var borderColors = _toBoxArray(color);

              canvashelper.strokeColorsRect(ctx, borderColors, left, top, width, height);
            }
          }

          function getPaddedRect(rect, padding, font, // eslint-disable-next-line @typescript-eslint/no-explicit-any
          helper, context) {
            if (!padding) {
              return rect;
            }

            var _helper$toBoxPixelArr = helper.toBoxPixelArray(padding, context, font),
                pTop = _helper$toBoxPixelArr[0],
                pRight = _helper$toBoxPixelArr[1],
                pBottom = _helper$toBoxPixelArr[2],
                pLeft = _helper$toBoxPixelArr[3];

            var left = rect.left + pLeft;
            var top = rect.top + pTop;
            var width = rect.width - pRight - pLeft;
            var height = rect.height - pTop - pBottom;
            return new Rect_1.Rect(left, top, width, height);
          }

          var GridCanvasHelper = /*#__PURE__*/function () {
            function GridCanvasHelper(grid) {
              _classCallCheck(this, GridCanvasHelper);

              this._grid = grid;
              this._theme = new ThemeResolver(grid);
            }

            _createClass(GridCanvasHelper, [{
              key: "createCalculator",
              value: function createCalculator(context, font) {
                return {
                  calcWidth: function calcWidth(width) {
                    return calc.toPx(width, {
                      get full() {
                        var rect = context.getRect();
                        return rect.width;
                      },

                      get em() {
                        return (0, canvases_1.getFontSize)(context.getContext(), font).width;
                      }

                    });
                  },
                  calcHeight: function calcHeight(height) {
                    return calc.toPx(height, {
                      get full() {
                        var rect = context.getRect();
                        return rect.height;
                      },

                      get em() {
                        return (0, canvases_1.getFontSize)(context.getContext(), font).height;
                      }

                    });
                  }
                };
              }
            }, {
              key: "getColor",
              value: function getColor(color, col, row, ctx) {
                return _getStyleProperty(color, col, row, this._grid, ctx);
              }
            }, {
              key: "getStyleProperty",
              value: function getStyleProperty(style, col, row, ctx) {
                return _getStyleProperty(style, col, row, this._grid, ctx);
              }
            }, {
              key: "toBoxArray",
              value: function toBoxArray(obj) {
                return _toBoxArray(obj);
              }
            }, {
              key: "toBoxPixelArray",
              value: function toBoxPixelArray(value, context, font) {
                if (typeof value === "string" || Array.isArray(value)) {
                  var calculator = this.createCalculator(context, font);

                  var box = _toBoxArray(value);

                  return [calculator.calcHeight(box[0]), calculator.calcWidth(box[1]), calculator.calcHeight(box[2]), calculator.calcWidth(box[3])];
                }

                return _toBoxArray(value);
              }
            }, {
              key: "theme",
              get: function get() {
                return this._theme;
              }
            }, {
              key: "drawWithClip",
              value: function drawWithClip(context, draw) {
                var drawRect = context.getDrawRect();

                if (!drawRect) {
                  return;
                }

                var ctx = context.getContext();
                ctx.save();

                try {
                  ctx.beginPath();
                  ctx.rect(drawRect.left, drawRect.top, drawRect.width, drawRect.height); //clip

                  ctx.clip();
                  draw(ctx);
                } finally {
                  ctx.restore();
                }
              }
            }, {
              key: "drawBorderWithClip",
              value: function drawBorderWithClip(context, draw) {
                var drawRect = context.getDrawRect();

                if (!drawRect) {
                  return;
                }

                var rect = context.getRect();
                var ctx = context.getContext();
                ctx.save();

                try {
                  //clip
                  ctx.beginPath();
                  var clipLeft = drawRect.left;
                  var clipWidth = drawRect.width;

                  if (drawRect.left === rect.left) {
                    clipLeft += -1;
                    clipWidth += 1;
                  }

                  var clipTop = drawRect.top;
                  var clipHeight = drawRect.height;

                  if (drawRect.top === rect.top) {
                    clipTop += -1;
                    clipHeight += 1;
                  }

                  ctx.rect(clipLeft, clipTop, clipWidth, clipHeight);
                  ctx.clip();
                  draw(ctx);
                } finally {
                  ctx.restore();
                }
              }
            }, {
              key: "text",
              value: function text(_text, context) {
                var _this = this;

                var _ref5 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
                    padding = _ref5.padding,
                    _ref5$offset = _ref5.offset,
                    offset = _ref5$offset === void 0 ? TEXT_OFFSET : _ref5$offset,
                    color = _ref5.color,
                    _ref5$textAlign = _ref5.textAlign,
                    textAlign = _ref5$textAlign === void 0 ? "left" : _ref5$textAlign,
                    _ref5$textBaseline = _ref5.textBaseline,
                    textBaseline = _ref5$textBaseline === void 0 ? "middle" : _ref5$textBaseline,
                    font = _ref5.font,
                    _ref5$textOverflow = _ref5.textOverflow,
                    textOverflow = _ref5$textOverflow === void 0 ? "clip" : _ref5$textOverflow,
                    icons = _ref5.icons,
                    trailingIcon = _ref5.trailingIcon;

                var col = context.col,
                    row = context.row;

                if (!color) {
                  color = this.theme.color;

                  // header color
                  var isFrozenCell = this._grid.isFrozenCell(col, row);

                  if (isFrozenCell && isFrozenCell.row) {
                    color = this.theme.frozenRowsColor;
                  }
                }

                this.drawWithClip(context, function (ctx) {
                  font = getFont(font, context.col, context.row, _this._grid, ctx);
                  var rect = getPaddedRect(context.getRect(), padding, font, _this, context);

                  _inlineRect(_this._grid, ctx, _text, rect, col, row, {
                    offset: offset,
                    color: color,
                    textAlign: textAlign,
                    textBaseline: textBaseline,
                    font: font,
                    textOverflow: textOverflow,
                    icons: icons,
                    trailingIcon: trailingIcon
                  });
                });
              }
            }, {
              key: "multilineText",
              value: function multilineText(lines, context) {
                var _this2 = this;

                var _ref6 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
                    padding = _ref6.padding,
                    _ref6$offset = _ref6.offset,
                    offset = _ref6$offset === void 0 ? TEXT_OFFSET : _ref6$offset,
                    color = _ref6.color,
                    _ref6$textAlign = _ref6.textAlign,
                    textAlign = _ref6$textAlign === void 0 ? "left" : _ref6$textAlign,
                    _ref6$textBaseline = _ref6.textBaseline,
                    textBaseline = _ref6$textBaseline === void 0 ? "middle" : _ref6$textBaseline,
                    font = _ref6.font,
                    _ref6$lineHeight = _ref6.lineHeight,
                    lineHeight = _ref6$lineHeight === void 0 ? "1em" : _ref6$lineHeight,
                    _ref6$autoWrapText = _ref6.autoWrapText,
                    autoWrapText = _ref6$autoWrapText === void 0 ? false : _ref6$autoWrapText,
                    _ref6$lineClamp = _ref6.lineClamp,
                    lineClamp = _ref6$lineClamp === void 0 ? 0 : _ref6$lineClamp,
                    _ref6$textOverflow = _ref6.textOverflow,
                    textOverflow = _ref6$textOverflow === void 0 ? "clip" : _ref6$textOverflow,
                    icons = _ref6.icons,
                    trailingIcon = _ref6.trailingIcon;

                var col = context.col,
                    row = context.row;

                if (!color) {
                  color = this.theme.color;

                  // header color
                  var isFrozenCell = this._grid.isFrozenCell(col, row);

                  if (isFrozenCell && isFrozenCell.row) {
                    color = this.theme.frozenRowsColor;
                  }
                }

                this.drawWithClip(context, function (ctx) {
                  font = getFont(font, context.col, context.row, _this2._grid, ctx);
                  var rect = getPaddedRect(context.getRect(), padding, font, _this2, context);

                  var calculator = _this2.createCalculator(context, font);

                  lineHeight = calculator.calcHeight(lineHeight);

                  _multiInlineRect(_this2._grid, ctx, lines, rect, col, row, {
                    offset: offset,
                    color: color,
                    textAlign: textAlign,
                    textBaseline: textBaseline,
                    font: font,
                    lineHeight: lineHeight,
                    autoWrapText: autoWrapText,
                    lineClamp: lineClamp,
                    textOverflow: textOverflow,
                    icons: icons,
                    trailingIcon: trailingIcon
                  });
                });
              }
            }, {
              key: "fillText",
              value: function fillText(text, x, y, context) {
                var _ref7 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {},
                    color = _ref7.color,
                    _ref7$textAlign = _ref7.textAlign,
                    textAlign = _ref7$textAlign === void 0 ? "left" : _ref7$textAlign,
                    _ref7$textBaseline = _ref7.textBaseline,
                    textBaseline = _ref7$textBaseline === void 0 ? "top" : _ref7$textBaseline,
                    font = _ref7.font;

                var col = context.col,
                    row = context.row;

                if (!color) {
                  color = this.theme.color;

                  // header color
                  var isFrozenCell = this._grid.isFrozenCell(col, row);

                  if (isFrozenCell && isFrozenCell.row) {
                    color = this.theme.frozenRowsColor;
                  }
                }

                var ctx = context.getContext();
                ctx.save();

                try {
                  font = getFont(font, context.col, context.row, this._grid, ctx);
                  ctx.fillStyle = _getStyleProperty(color, col, row, this._grid, ctx);
                  ctx.textAlign = textAlign;
                  ctx.textBaseline = textBaseline;
                  ctx.font = font || ctx.font;
                  ctx.fillText(text, x, y);
                } finally {
                  ctx.restore();
                }
              }
            }, {
              key: "fillCell",
              value: function fillCell(context) {
                var _this3 = this;

                var _ref8 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
                    _ref8$fillColor = _ref8.fillColor,
                    fillColor = _ref8$fillColor === void 0 ? this.theme.defaultBgColor : _ref8$fillColor;

                var rect = context.getRect();
                this.drawWithClip(context, function (ctx) {
                  var col = context.col,
                      row = context.row;
                  ctx.fillStyle = _getStyleProperty(fillColor, col, row, _this3._grid, ctx);
                  ctx.beginPath();
                  ctx.rect(rect.left, rect.top, rect.width, rect.height);
                  ctx.fill();
                });
              }
            }, {
              key: "fillCellWithState",
              value: function fillCellWithState(context) {
                var option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                option.fillColor = this.getFillColorState(context, option);
                this.fillCell(context, option);
              }
            }, {
              key: "fillRect",
              value: function fillRect(rect, context) {
                var _ref9 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
                    _ref9$fillColor = _ref9.fillColor,
                    fillColor = _ref9$fillColor === void 0 ? this.theme.defaultBgColor : _ref9$fillColor;

                var ctx = context.getContext();
                ctx.save();

                try {
                  var col = context.col,
                      row = context.row;
                  ctx.fillStyle = _getStyleProperty(fillColor, col, row, this._grid, ctx);
                  ctx.beginPath();
                  ctx.rect(rect.left, rect.top, rect.width, rect.height);
                  ctx.fill();
                } finally {
                  ctx.restore();
                }
              }
            }, {
              key: "fillRectWithState",
              value: function fillRectWithState(rect, context) {
                var option = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
                option.fillColor = this.getFillColorState(context, option);
                this.fillRect(rect, context, option);
              }
            }, {
              key: "getFillColorState",
              value: function getFillColorState(context) {
                var option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                var sel = context.getSelection();
                var col = context.col,
                    row = context.row;

                if (!(0, utils_1.cellEquals)(sel.select, context) && (0, utils_1.cellInRange)(sel.range, col, row)) {
                  return this.theme.selectionBgColor;
                }

                if (option.fillColor) {
                  return option.fillColor;
                }

                if ((0, utils_1.cellEquals)(sel.select, context)) {
                  return this.theme.highlightBgColor;
                }

                var isFrozenCell = this._grid.isFrozenCell(col, row);

                if (isFrozenCell && isFrozenCell.row) {
                  return this.theme.frozenRowsBgColor;
                }

                return this.theme.defaultBgColor;
              }
            }, {
              key: "border",
              value: function border(context) {
                var _this4 = this;

                var _ref10 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
                    _ref10$borderColor = _ref10.borderColor,
                    borderColor = _ref10$borderColor === void 0 ? this.theme.borderColor : _ref10$borderColor,
                    _ref10$lineWidth = _ref10.lineWidth,
                    lineWidth = _ref10$lineWidth === void 0 ? 1 : _ref10$lineWidth;

                var rect = context.getRect();
                this.drawBorderWithClip(context, function (ctx) {
                  var col = context.col,
                      row = context.row;

                  var borderColors = _getStyleProperty(borderColor, col, row, _this4._grid, ctx);

                  if (lineWidth === 1) {
                    ctx.lineWidth = 1;
                    strokeRect(ctx, borderColors, rect.left - 0.5, rect.top - 0.5, rect.width, rect.height);
                  } else if (lineWidth === 2) {
                    ctx.lineWidth = 2;
                    strokeRect(ctx, borderColors, rect.left, rect.top, rect.width - 1, rect.height - 1);
                  } else {
                    ctx.lineWidth = lineWidth;
                    var startOffset = lineWidth / 2 - 1;
                    strokeRect(ctx, borderColors, rect.left + startOffset, rect.top + startOffset, rect.width - lineWidth + 1, rect.height - lineWidth + 1);
                  }
                });
              } // Unused in main

            }, {
              key: "borderWithState",
              value: function borderWithState(context) {
                var _this5 = this;

                var option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                var rect = context.getRect();
                var sel = context.getSelection();
                var col = context.col,
                    row = context.row; //

                if ((0, utils_1.cellEquals)(sel.select, context)) {
                  option.borderColor = this.theme.highlightBorderColor;
                  option.lineWidth = 2;
                  this.border(context, option);
                } else {
                  // header color
                  var isFrozenCell = this._grid.isFrozenCell(col, row);

                  if (isFrozenCell === null || isFrozenCell === void 0 ? void 0 : isFrozenCell.row) {
                    option.borderColor = this.theme.frozenRowsBorderColor;
                  }

                  option.lineWidth = 1;
                  this.border(context, option); //

                  var _sel = this._grid.selection.select;

                  if (_sel.col + 1 === col && _sel.row === row) {
                    //
                    this.drawBorderWithClip(context, function (ctx) {
                      var borderColors = _toBoxArray(_getStyleProperty(_this5.theme.highlightBorderColor, _sel.col, _sel.row, _this5._grid, ctx));

                      ctx.lineWidth = 1;
                      ctx.strokeStyle = borderColors[1] || ctx.strokeStyle;
                      ctx.beginPath();
                      ctx.moveTo(rect.left - 0.5, rect.top);
                      ctx.lineTo(rect.left - 0.5, rect.bottom);
                      ctx.stroke();
                    });
                  } else if (_sel.col === col && _sel.row + 1 === row) {
                    //
                    this.drawBorderWithClip(context, function (ctx) {
                      var borderColors = _toBoxArray(_getStyleProperty(_this5.theme.highlightBorderColor, _sel.col, _sel.row, _this5._grid, ctx));

                      ctx.lineWidth = 1;
                      ctx.strokeStyle = borderColors[0] || ctx.strokeStyle;
                      ctx.beginPath();
                      ctx.moveTo(rect.left, rect.top - 0.5);
                      ctx.lineTo(rect.right, rect.top - 0.5);
                      ctx.stroke();
                    });
                  }
                }
              }
            }, {
              key: "buildCheckBoxInline",
              value: function buildCheckBoxInline(check, context) {
                var option = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
                // eslint-disable-next-line @typescript-eslint/no-this-alias
                var self = this;
                var ctx = context.getContext();
                var boxWidth = canvashelper.measureCheckbox(ctx).width;
                return new InlineDrawer_1.InlineDrawer({
                  draw: draw,
                  width: boxWidth + 3,
                  height: boxWidth + 1,
                  color: undefined
                });

                function draw(_ref11) {
                  var ctx = _ref11.ctx,
                      rect = _ref11.rect,
                      offset = _ref11.offset,
                      offsetLeft = _ref11.offsetLeft,
                      offsetRight = _ref11.offsetRight,
                      offsetTop = _ref11.offsetTop,
                      offsetBottom = _ref11.offsetBottom;
                  var col = context.col,
                      row = context.row;
                  drawCheckbox(ctx, rect, col, row, check, self, option, {
                    offset: offset + (CHECKBOX_OFFSET - TEXT_OFFSET),
                    padding: {
                      left: offsetLeft + (CHECKBOX_OFFSET - TEXT_OFFSET),
                      right: offsetRight,
                      top: offsetTop,
                      bottom: offsetBottom
                    }
                  });
                }
              }
            }, {
              key: "checkbox",
              value: function checkbox(check, context) {
                var _this6 = this;

                var _ref12 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
                    padding = _ref12.padding,
                    animElapsedTime = _ref12.animElapsedTime,
                    _ref12$offset = _ref12.offset,
                    offset = _ref12$offset === void 0 ? CHECKBOX_OFFSET : _ref12$offset,
                    uncheckBgColor = _ref12.uncheckBgColor,
                    checkBgColor = _ref12.checkBgColor,
                    borderColor = _ref12.borderColor,
                    textAlign = _ref12.textAlign,
                    textBaseline = _ref12.textBaseline;

                this.drawWithClip(context, function (ctx) {
                  var col = context.col,
                      row = context.row;
                  drawCheckbox(ctx, getPaddedRect(context.getRect(), padding, undefined
                  /* font */
                  , _this6, context), col, row, check, _this6, {
                    animElapsedTime: animElapsedTime,
                    uncheckBgColor: uncheckBgColor,
                    checkBgColor: checkBgColor,
                    borderColor: borderColor,
                    textAlign: textAlign,
                    textBaseline: textBaseline
                  }, {
                    offset: offset,
                    padding: {
                      left: CHECKBOX_OFFSET - TEXT_OFFSET
                    }
                  });
                });
              }
            }, {
              key: "radioButton",
              value: function radioButton(check, context) {
                var _this7 = this;

                var _ref13 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
                    padding = _ref13.padding,
                    animElapsedTime = _ref13.animElapsedTime,
                    _ref13$offset = _ref13.offset,
                    offset = _ref13$offset === void 0 ? CHECKBOX_OFFSET : _ref13$offset,
                    checkColor = _ref13.checkColor,
                    uncheckBorderColor = _ref13.uncheckBorderColor,
                    checkBorderColor = _ref13.checkBorderColor,
                    uncheckBgColor = _ref13.uncheckBgColor,
                    checkBgColor = _ref13.checkBgColor,
                    textAlign = _ref13.textAlign,
                    textBaseline = _ref13.textBaseline;

                this.drawWithClip(context, function (ctx) {
                  var col = context.col,
                      row = context.row;
                  drawRadioButton(ctx, getPaddedRect(context.getRect(), padding, undefined
                  /* font */
                  , _this7, context), col, row, check, _this7, {
                    animElapsedTime: animElapsedTime,
                    checkColor: checkColor,
                    uncheckBorderColor: uncheckBorderColor,
                    checkBorderColor: checkBorderColor,
                    uncheckBgColor: uncheckBgColor,
                    checkBgColor: checkBgColor,
                    textAlign: textAlign,
                    textBaseline: textBaseline
                  }, {
                    offset: offset,
                    padding: {
                      left: CHECKBOX_OFFSET - TEXT_OFFSET
                    }
                  });
                });
              }
            }, {
              key: "button",
              value: function button(caption, context) {
                var _this8 = this;

                var _ref14 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
                    _ref14$bgColor = _ref14.bgColor,
                    bgColor = _ref14$bgColor === void 0 ? this.theme.button.bgColor : _ref14$bgColor,
                    padding = _ref14.padding,
                    _ref14$offset = _ref14.offset,
                    offset = _ref14$offset === void 0 ? TEXT_OFFSET : _ref14$offset,
                    _ref14$color = _ref14.color,
                    color = _ref14$color === void 0 ? this.theme.button.color : _ref14$color,
                    _ref14$textAlign = _ref14.textAlign,
                    textAlign = _ref14$textAlign === void 0 ? "center" : _ref14$textAlign,
                    _ref14$textBaseline = _ref14.textBaseline,
                    textBaseline = _ref14$textBaseline === void 0 ? "middle" : _ref14$textBaseline,
                    shadow = _ref14.shadow,
                    font = _ref14.font,
                    _ref14$textOverflow = _ref14.textOverflow,
                    textOverflow = _ref14$textOverflow === void 0 ? "clip" : _ref14$textOverflow,
                    icons = _ref14.icons;

                var rect = context.getRect();
                this.drawWithClip(context, function (ctx) {
                  font = getFont(font, context.col, context.row, _this8._grid, ctx);
                  var col = context.col,
                      row = context.row;

                  var _getPaddedRect = getPaddedRect(rect, padding || rect.height / 8, font, _this8, context),
                      left = _getPaddedRect.left,
                      top = _getPaddedRect.top,
                      width = _getPaddedRect.width,
                      height = _getPaddedRect.height;

                  bgColor = _getStyleProperty(bgColor, context.col, context.row, _this8._grid, ctx);
                  canvashelper.drawButton(ctx, left, top, width, height, {
                    bgColor: bgColor,
                    radius: rect.height / 8,
                    // offset,
                    shadow: shadow
                  });

                  _inlineRect(_this8._grid, ctx, caption, new Rect_1.Rect(left, top, width, height), col, row, {
                    offset: offset,
                    color: color,
                    textAlign: textAlign,
                    textBaseline: textBaseline,
                    font: font,
                    textOverflow: textOverflow,
                    icons: icons
                  });
                });
              }
            }, {
              key: "testFontLoad",
              value: function testFontLoad(font, value, context) {
                return _testFontLoad(font, value, context, this._grid);
              }
            }]);

            return GridCanvasHelper;
          }();

          exports.GridCanvasHelper = GridCanvasHelper;
          /***/
        },

        /***/
        "./ListGrid.js":
        /*!*********************!*\
          !*** ./ListGrid.js ***!
          \*********************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function ListGridJs(module, exports, __nested_webpack_require_126191__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          var _a;

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.ListGrid = void 0;

          var icons = __importStar(__nested_webpack_require_126191__(
          /*! ./internal/icons */
          "./internal/icons.js"));

          var themes = __importStar(__nested_webpack_require_126191__(
          /*! ./themes */
          "./themes.js"));

          var data_1 = __nested_webpack_require_126191__(
          /*! ./data */
          "./data.js");

          var layout_map_1 = __nested_webpack_require_126191__(
          /*! ./list-grid/layout-map */
          "./list-grid/layout-map/index.js");

          var MessageHandler_1 = __nested_webpack_require_126191__(
          /*! ./columns/message/MessageHandler */
          "./columns/message/MessageHandler.js");

          var utils_1 = __nested_webpack_require_126191__(
          /*! ./internal/utils */
          "./internal/utils.js");

          var style_1 = __nested_webpack_require_126191__(
          /*! ./columns/style */
          "./columns/style.js");

          var DrawGrid_1 = __nested_webpack_require_126191__(
          /*! ./core/DrawGrid */
          "./core/DrawGrid.js");

          var GridCanvasHelper_1 = __nested_webpack_require_126191__(
          /*! ./GridCanvasHelper */
          "./GridCanvasHelper.js");

          var style_2 = __nested_webpack_require_126191__(
          /*! ./header/style */
          "./header/style.js");

          var LG_EVENT_TYPE_1 = __nested_webpack_require_126191__(
          /*! ./list-grid/LG_EVENT_TYPE */
          "./list-grid/LG_EVENT_TYPE.js");

          var Rect_1 = __nested_webpack_require_126191__(
          /*! ./internal/Rect */
          "./internal/Rect.js");

          var TooltipHandler_1 = __nested_webpack_require_126191__(
          /*! ./tooltip/TooltipHandler */
          "./tooltip/TooltipHandler.js"); //protected symbol


          var symbolManager_1 = __nested_webpack_require_126191__(
          /*! ./internal/symbolManager */
          "./internal/symbolManager.js");

          var paste_utils_1 = __nested_webpack_require_126191__(
          /*! ./internal/paste-utils */
          "./internal/paste-utils.js");
          /** @private */


          var _ = (0, symbolManager_1.getProtectedSymbol)(); //private methods

          /** @private */


          function _getCellRange(grid, col, row) {
            return grid[_].layoutMap.getCellRange(col, row);
          }
          /** @private */


          function _updateRect(grid, col, row, context) {
            context.setRectFilter(function (rect) {
              var left = rect.left,
                  right = rect.right,
                  top = rect.top,
                  bottom = rect.bottom;

              var _getCellRange2 = _getCellRange(grid, col, row),
                  _getCellRange2$start = _getCellRange2.start,
                  startCol = _getCellRange2$start.col,
                  startRow = _getCellRange2$start.row,
                  _getCellRange2$end = _getCellRange2.end,
                  endCol = _getCellRange2$end.col,
                  endRow = _getCellRange2$end.row;

              for (var c = col - 1; c >= startCol; c--) {
                left -= grid.getColWidth(c);
              }

              for (var _c2 = col + 1; _c2 <= endCol; _c2++) {
                right += grid.getColWidth(_c2);
              }

              for (var r = row - 1; r >= startRow; r--) {
                top -= grid.getRowHeight(r);
              }

              for (var _r = row + 1; _r <= endRow; _r++) {
                bottom += grid.getRowHeight(_r);
              }

              return Rect_1.Rect.bounds(left, top, right, bottom);
            });
          }
          /** @private */


          function _getCellValue(grid, col, row) {
            if (row < grid[_].layoutMap.headerRowCount) {
              var _grid$_$layoutMap$get = grid[_].layoutMap.getHeader(col, row),
                  caption = _grid$_$layoutMap$get.caption;

              return typeof caption === "function" ? caption() : caption;
            } else {
              var _grid$_$layoutMap$get2 = grid[_].layoutMap.getBody(col, row),
                  field = _grid$_$layoutMap$get2.field;

              return _getField(grid, field, row);
            }
          }
          /** @private */


          function _setCellValue(grid, col, row, // eslint-disable-next-line @typescript-eslint/no-explicit-any
          value) {
            if (row < grid[_].layoutMap.headerRowCount) {
              // nop
              return false;
            } else {
              var _grid$_$layoutMap$get3 = grid[_].layoutMap.getBody(col, row),
                  field = _grid$_$layoutMap$get3.field;

              if (field == null) {
                return false;
              }

              var index = _getRecordIndexByRow(grid, row);

              return grid[_].dataSource.setField(index, field, value);
            }
          }
          /** @private */


          function _getCellMessage(grid, col, row) {
            if (row < grid[_].layoutMap.headerRowCount) {
              return null;
            } else {
              var _grid$_$layoutMap$get4 = grid[_].layoutMap.getBody(col, row),
                  message = _grid$_$layoutMap$get4.message;

              if (!message) {
                return null;
              }

              if (!Array.isArray(message)) {
                return _getField(grid, message, row);
              }

              var promises = [];

              for (var index = 0; index < message.length; index++) {
                var msg = _getField(grid, message[index], row);

                if ((0, utils_1.isPromise)(msg)) {
                  promises.push(msg);
                } else if ((0, MessageHandler_1.hasMessage)(msg)) {
                  return msg;
                }
              }

              if (!promises.length) {
                return null;
              }

              return new Promise(function (resolve, reject) {
                promises.forEach(function (p) {
                  p.then(function (msg) {
                    if ((0, MessageHandler_1.hasMessage)(msg)) {
                      resolve(msg);
                    }
                  }, reject);
                });
              });
            }
          }

          function _getCellIcon0(grid, icon, row) {
            if (Array.isArray(icon)) {
              return icon.map(function (i) {
                return _getCellIcon0(grid, i, row);
              });
            }

            if (!utils_1.obj.isObject(icon) || typeof icon === "function") {
              return _getField(grid, icon, row);
            } // eslint-disable-next-line @typescript-eslint/no-explicit-any


            var retIcon = {}; // eslint-disable-next-line @typescript-eslint/no-explicit-any

            var iconOpt = icon;
            icons.iconPropKeys.forEach(function (k) {
              if (iconOpt[k]) {
                var f = _getField(grid, iconOpt[k], row);

                if (f != null) {
                  retIcon[k] = f;
                } else {
                  if (!_hasField(grid, iconOpt[k], row)) {
                    retIcon[k] = iconOpt[k];
                  }
                }
              }
            });
            return retIcon;
          }
          /** @private */


          function _getCellIcon(grid, col, row) {
            if (row < grid[_].layoutMap.headerRowCount) {
              var _grid$_$layoutMap$get5 = grid[_].layoutMap.getHeader(col, row),
                  headerIcon = _grid$_$layoutMap$get5.headerIcon;

              if (headerIcon == null) {
                return null;
              }

              return headerIcon;
            } else {
              var _grid$_$layoutMap$get6 = grid[_].layoutMap.getBody(col, row),
                  icon = _grid$_$layoutMap$get6.icon;

              if (icon == null) {
                return null;
              }

              return _getCellIcon0(grid, icon, row);
            }
          }
          /** @private */


          function _getField(grid, field, row) {
            if (field == null) {
              return null;
            }

            if (row < grid[_].layoutMap.headerRowCount) {
              return null;
            } else {
              var index = _getRecordIndexByRow(grid, row);

              return grid[_].dataSource.getField(index, field);
            }
          }
          /** @private */


          function _hasField(grid, field, row) {
            if (field == null) {
              return false;
            }

            if (row < grid[_].layoutMap.headerRowCount) {
              return false;
            } else {
              var index = _getRecordIndexByRow(grid, row);

              return grid[_].dataSource.hasField(index, field);
            }
          }
          /** @private */


          function _onDrawValue(grid, cellValue, context, _ref15, style, draw) {
            var col = _ref15.col,
                row = _ref15.row;
            var helper = grid[_].gridCanvasHelper;

            var drawCellBg = function drawCellBg() {
              var _ref16 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
                  bgColor = _ref16.bgColor;

              var fillOpt = {
                fillColor: bgColor
              }; //cell

              helper.fillCellWithState(context, fillOpt);
            };

            var drawCellBorder = function drawCellBorder() {
              if (context.col === grid.frozenColCount - 1) {
                //
                var rect = context.getRect();
                helper.drawWithClip(context, function (ctx) {
                  var borderColor = context.row >= grid.frozenRowCount ? helper.theme.borderColor : helper.theme.frozenRowsBorderColor;
                  var borderColors = helper.toBoxArray(helper.getColor(borderColor, context.col, context.row, ctx));

                  if (borderColors[1]) {
                    ctx.lineWidth = 1;
                    ctx.strokeStyle = borderColors[1];
                    ctx.beginPath();
                    ctx.moveTo(rect.right - 2.5, rect.top);
                    ctx.lineTo(rect.right - 2.5, rect.bottom);
                    ctx.stroke();
                  }
                });
              }

              _borderWithState(grid, helper, context);
            };

            var drawCellBase = function drawCellBase() {
              var _ref17 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
                  bgColor = _ref17.bgColor;

              drawCellBg({
                bgColor: bgColor
              });
              drawCellBorder();
            };

            var info = {
              getRecord: function getRecord() {
                return grid.getRowRecord(row);
              },
              getIcon: function getIcon() {
                return _getCellIcon(grid, col, row);
              },
              getMessage: function getMessage() {
                return _getCellMessage(grid, col, row);
              },
              messageHandler: grid[_].messageHandler,
              style: style,
              drawCellBase: drawCellBase,
              drawCellBg: drawCellBg,
              drawCellBorder: drawCellBorder
            };
            return draw(cellValue, info, context, grid);
          }
          /** @private */


          function _borderWithState(grid, helper, context) {
            var col = context.col,
                row = context.row;
            var sel = grid.selection.select;
            var layoutMap = grid[_].layoutMap;
            var rect = context.getRect();
            var option = {};
            var selRecordIndex = layoutMap.getRecordIndexByRow(sel.row);
            var selId = layoutMap.getCellId(sel.col, sel.row);

            function isSelectCell(col, row) {
              if (col === sel.col && row === sel.row) {
                return true;
              }

              return selId != null && layoutMap.getCellId(col, row) === selId && layoutMap.getRecordIndexByRow(row) === selRecordIndex;
            } //


            if (isSelectCell(col, row)) {
              option.borderColor = helper.theme.highlightBorderColor;
              option.lineWidth = 2;
              helper.border(context, option);
            } else {
              option.lineWidth = 1; // header color

              var isFrozenCell = grid.isFrozenCell(col, row);

              if (isFrozenCell === null || isFrozenCell === void 0 ? void 0 : isFrozenCell.row) {
                option.borderColor = helper.theme.frozenRowsBorderColor;
              }

              helper.border(context, option); //

              if (col > 0 && isSelectCell(col - 1, row)) {
                //
                helper.drawBorderWithClip(context, function (ctx) {
                  var borderColors = helper.toBoxArray(helper.getColor(helper.theme.highlightBorderColor, sel.col, sel.row, ctx));

                  if (borderColors[1]) {
                    ctx.lineWidth = 1;
                    ctx.strokeStyle = borderColors[1];
                    ctx.beginPath();
                    ctx.moveTo(rect.left - 0.5, rect.top);
                    ctx.lineTo(rect.left - 0.5, rect.bottom);
                    ctx.stroke();
                  }
                });
              } else if (row > 0 && isSelectCell(col, row - 1)) {
                //
                helper.drawBorderWithClip(context, function (ctx) {
                  var borderColors = helper.toBoxArray(helper.getColor(helper.theme.highlightBorderColor, sel.col, sel.row, ctx));

                  if (borderColors[0]) {
                    ctx.lineWidth = 1;
                    ctx.strokeStyle = borderColors[0];
                    ctx.beginPath();
                    ctx.moveTo(rect.left, rect.top - 0.5);
                    ctx.lineTo(rect.right, rect.top - 0.5);
                    ctx.stroke();
                  }
                });
              }
            }
          }
          /** @private */


          function _refreshHeader(grid) {
            var _b;

            var protectedSpace = grid[_];

            if (protectedSpace.headerEvents) {
              protectedSpace.headerEvents.forEach(function (id) {
                return grid.unlisten(id);
              });
            }

            var headerEvents = grid[_].headerEvents = [];
            headerEvents.forEach(function (id) {
              return grid.unlisten(id);
            });
            var layoutMap;

            if (protectedSpace.layout && (!Array.isArray(protectedSpace.layout) || protectedSpace.layout.length > 0)) {
              layoutMap = protectedSpace.layoutMap = new layout_map_1.MultiLayoutMap(protectedSpace.layout);
            } else {
              layoutMap = protectedSpace.layoutMap = new layout_map_1.SimpleHeaderLayoutMap((_b = protectedSpace.header) !== null && _b !== void 0 ? _b : []);
            }

            layoutMap.headerObjects.forEach(function (cell) {
              var ids = cell.headerType.bindGridEvent(grid, cell.id);
              headerEvents.push.apply(headerEvents, _toConsumableArray(ids));

              if (cell.style) {
                if (cell.style instanceof style_2.BaseStyle) {
                  var id = cell.style.listen(style_2.BaseStyle.EVENT_TYPE.CHANGE_STYLE, function () {
                    grid.invalidate();
                  });
                  headerEvents.push(id);
                }
              }

              if (cell.action) {
                var _ids = cell.action.bindGridEvent(grid, cell.id);

                headerEvents.push.apply(headerEvents, _toConsumableArray(_ids));
              }
            });
            layoutMap.columnObjects.forEach(function (col) {
              if (col.action) {
                var ids = col.action.bindGridEvent(grid, col.id);
                headerEvents.push.apply(headerEvents, _toConsumableArray(ids));
              }

              if (col.columnType) {
                var _ids2 = col.columnType.bindGridEvent(grid, col.id);

                headerEvents.push.apply(headerEvents, _toConsumableArray(_ids2));
              }

              if (col.style) {
                if (col.style instanceof style_1.BaseStyle) {
                  var id = col.style.listen(style_1.BaseStyle.EVENT_TYPE.CHANGE_STYLE, function () {
                    grid.invalidate();
                  });
                  headerEvents.push(id);
                }
              }
            });

            for (var col = 0; col < layoutMap.columnWidths.length; col++) {
              var column = layoutMap.columnWidths[col];
              var width = column.width,
                  minWidth = column.minWidth,
                  maxWidth = column.maxWidth;

              if (width && (typeof width === "string" || width > 0)) {
                grid.setColWidth(col, width);
              } else {
                grid.setColWidth(col, null);
              }

              if (minWidth && (typeof minWidth === "string" || minWidth > 0)) {
                grid.setMinColWidth(col, minWidth);
              } else {
                grid.setMinColWidth(col, null);
              }

              if (maxWidth && (typeof maxWidth === "string" || maxWidth > 0)) {
                grid.setMaxColWidth(col, maxWidth);
              } else {
                grid.setMaxColWidth(col, null);
              }
            }

            var headerRowHeight = grid[_].headerRowHeight;

            for (var row = 0; row < layoutMap.headerRowCount; row++) {
              var height = Array.isArray(headerRowHeight) ? headerRowHeight[row] : headerRowHeight;

              if (height && height > 0) {
                grid.setRowHeight(row, height);
              } else {
                grid.setRowHeight(row, null);
              }
            }

            grid.colCount = layoutMap.colCount;

            _refreshRowCount(grid);

            grid.frozenRowCount = layoutMap.headerRowCount;
          }
          /** @private */


          function _refreshRowCount(grid) {
            var layoutMap = grid[_].layoutMap;
            grid.rowCount = grid[_].dataSource.length * layoutMap.bodyRowCount + layoutMap.headerRowCount;
          }
          /** @private */


          function _tryWithUpdateDataSource(grid, fn) {
            var dataSourceEventIds = grid[_].dataSourceEventIds;

            if (dataSourceEventIds) {
              dataSourceEventIds.forEach(function (id) {
                return grid[_].handler.off(id);
              });
            }

            fn(grid);
            grid[_].dataSourceEventIds = [grid[_].handler.on(grid[_].dataSource, data_1.DataSource.EVENT_TYPE.UPDATED_LENGTH, function () {
              _refreshRowCount(grid);

              grid.invalidate();
            }), grid[_].handler.on(grid[_].dataSource, data_1.DataSource.EVENT_TYPE.UPDATED_ORDER, function () {
              grid.invalidate();
            })];
          }
          /** @private */


          function _setRecords(grid) {
            var records = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

            _tryWithUpdateDataSource(grid, function () {
              grid[_].records = records;
              var newDataSource = grid[_].dataSource = data_1.CachedDataSource.ofArray(records);
              grid.addDisposable(newDataSource);
            });
          }
          /** @private */


          function _setDataSource(grid, dataSource) {
            _tryWithUpdateDataSource(grid, function () {
              if (dataSource) {
                if (dataSource instanceof data_1.DataSource) {
                  grid[_].dataSource = dataSource;
                } else {
                  var newDataSource = grid[_].dataSource = new data_1.CachedDataSource(dataSource);
                  grid.addDisposable(newDataSource);
                }
              } else {
                grid[_].dataSource = data_1.DataSource.EMPTY;
              }

              grid[_].records = null;
            });
          }
          /** @private */


          function _getRecordIndexByRow(grid, row) {
            var layoutMap = grid[_].layoutMap;
            return layoutMap.getRecordIndexByRow(row);
          }
          /** @private */


          function _onRangePaste(text) {
            var _this9 = this;

            var test = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {
              return true;
            };

            var _b;

            var layoutMap = this[_].layoutMap;
            var selectionRange = this.selection.range;

            var _this$getCellRange = this.getCellRange(selectionRange.start.col, selectionRange.start.row),
                start = _this$getCellRange.start;

            var _this$getCellRange2 = this.getCellRange(selectionRange.end.col, selectionRange.end.row),
                end = _this$getCellRange2.end;

            var values = (0, paste_utils_1.parsePasteRangeBoxValues)(text, {
              trimOnPaste: this.trimOnPaste
            });
            var pasteRowCount = Math.min(Math.max(end.row - start.row + 1, values.rowCount), this.rowCount - start.row);
            var pasteColCount = Math.min(Math.max(end.col - start.col + 1, values.colCount), this.colCount - start.col);
            var hasEditable = false;
            var actionColumnsBox = [];

            for (var bodyRow = 0; bodyRow < layoutMap.bodyRowCount; bodyRow++) {
              var actionColumnsRow = [];
              actionColumnsBox.push(actionColumnsRow);

              for (var offsetCol = 0; offsetCol < pasteColCount; offsetCol++) {
                var body = layoutMap.getBody(start.col + offsetCol, bodyRow + layoutMap.headerRowCount);
                actionColumnsRow[offsetCol] = body;

                if (!hasEditable && ((_b = body.action) === null || _b === void 0 ? void 0 : _b.editable)) {
                  hasEditable = true;
                }
              }
            }

            if (!hasEditable) {
              return;
            }

            var startRow = layoutMap.getRecordStartRowByRecordIndex(layoutMap.getRecordIndexByRow(start.row));
            var startRowOffset = start.row - startRow;
            var rejectedDetail = [];

            var addRejectedDetail = function addRejectedDetail(cell, record, define, pasteValue) {
              rejectedDetail.push({
                col: cell.col,
                row: cell.row,
                record: record,
                define: define,
                pasteValue: pasteValue
              });
            };

            var timeout = null;

            var processRejected = function processRejected() {
              if (timeout) clearTimeout(timeout);
              timeout = setTimeout(function () {
                if (rejectedDetail.length > 0) {
                  _this9.fireListeners(LG_EVENT_TYPE_1.LG_EVENT_TYPE.REJECTED_PASTE_VALUES, {
                    detail: rejectedDetail
                  });

                  rejectedDetail = [];
                }
              }, 100);
            };

            var _reject = addRejectedDetail;
            var duplicate = {};
            var actionRow = startRowOffset;
            var valuesRow = 0;

            for (var offsetRow = 0; offsetRow < pasteRowCount; offsetRow++) {
              var valuesCol = 0;

              var _loop = function _loop(_offsetCol) {
                var _actionColumnsBox$act = actionColumnsBox[actionRow][_offsetCol],
                    action = _actionColumnsBox$act.action,
                    id = _actionColumnsBox$act.id,
                    define = _actionColumnsBox$act.define;

                if (!duplicate[id] && (action === null || action === void 0 ? void 0 : action.editable)) {
                  duplicate[id] = true;
                  var col = start.col + _offsetCol;
                  var row = start.row + offsetRow;
                  var cellValue = values.getCellValue(valuesCol, valuesRow);
                  (0, utils_1.then)(_this9.getRowRecord(row), function (record) {
                    (0, utils_1.then)(_getCellValue(_this9, col, row), function (oldValue) {
                      if (test({
                        grid: _this9,
                        record: record,
                        col: col,
                        row: row,
                        value: cellValue,
                        oldValue: oldValue
                      })) {
                        action.onPasteCellRangeBox(_this9, {
                          col: col,
                          row: row
                        }, cellValue, {
                          reject: function reject() {
                            _reject({
                              col: col,
                              row: row
                            }, record, define, cellValue);
                          }
                        });
                      }
                    });
                  });
                }

                valuesCol++;

                if (valuesCol >= values.colCount) {
                  valuesCol = 0;
                }
              };

              for (var _offsetCol = 0; _offsetCol < pasteColCount; _offsetCol++) {
                _loop(_offsetCol);
              }

              actionRow++;

              if (actionRow >= layoutMap.bodyRowCount) {
                actionRow = 0;
                duplicate = {};
              }

              valuesRow++;

              if (valuesRow >= values.rowCount) {
                valuesRow = 0;
              }
            }

            var newEnd = {
              col: start.col + pasteColCount - 1,
              row: start.row + pasteRowCount - 1
            };
            this.selection.range = {
              start: start,
              end: newEnd
            };
            this.invalidateCellRange(this.selection.range);
            processRejected();

            _reject = function _reject(cell, record, define, pasteValue) {
              addRejectedDetail(cell, record, define, pasteValue);
              processRejected();
            };
          }
          /** @private */


          function _onRangeDelete() {
            var _this10 = this;

            var _b;

            var layoutMap = this[_].layoutMap;
            var selectionRange = this.selection.range;

            var _this$getCellRange3 = this.getCellRange(selectionRange.start.col, selectionRange.start.row),
                start = _this$getCellRange3.start;

            var _this$getCellRange4 = this.getCellRange(selectionRange.end.col, selectionRange.end.row),
                end = _this$getCellRange4.end;

            var deleteRowCount = Math.min(end.row - start.row + 1, this.rowCount - start.row);
            var deleteColCount = Math.min(end.col - start.col + 1, this.colCount - start.col);
            var hasEditable = false;
            var actionColumnsBox = [];

            for (var bodyRow = 0; bodyRow < layoutMap.bodyRowCount; bodyRow++) {
              var actionColumnsRow = [];
              actionColumnsBox.push(actionColumnsRow);

              for (var offsetCol = 0; offsetCol < deleteColCount; offsetCol++) {
                var body = layoutMap.getBody(start.col + offsetCol, bodyRow + layoutMap.headerRowCount);
                actionColumnsRow[offsetCol] = body;

                if (!hasEditable && ((_b = body.action) === null || _b === void 0 ? void 0 : _b.editable)) {
                  hasEditable = true;
                }
              }
            }

            if (!hasEditable) {
              return;
            }

            var startRow = layoutMap.getRecordStartRowByRecordIndex(layoutMap.getRecordIndexByRow(start.row));
            var startRowOffset = start.row - startRow;
            var duplicate = {};
            var actionRow = startRowOffset;

            for (var offsetRow = 0; offsetRow < deleteRowCount; offsetRow++) {
              var _loop2 = function _loop2(_offsetCol2) {
                var _actionColumnsBox$act2 = actionColumnsBox[actionRow][_offsetCol2],
                    action = _actionColumnsBox$act2.action,
                    id = _actionColumnsBox$act2.id;

                if (!duplicate[id] && (action === null || action === void 0 ? void 0 : action.editable)) {
                  duplicate[id] = true;
                  var col = start.col + _offsetCol2;
                  var row = start.row + offsetRow;
                  (0, utils_1.then)(_this10.getRowRecord(row), function (_record) {
                    (0, utils_1.then)(_getCellValue(_this10, col, row), function (_oldValue) {
                      action.onDeleteCellRangeBox(_this10, {
                        col: col,
                        row: row
                      });
                    });
                  });
                }
              };

              for (var _offsetCol2 = 0; _offsetCol2 < deleteColCount; _offsetCol2++) {
                _loop2(_offsetCol2);
              }

              actionRow++;

              if (actionRow >= layoutMap.bodyRowCount) {
                actionRow = 0;
                duplicate = {};
              }
            }

            this.invalidateCellRange(selectionRange);
          }
          /**
           * ListGrid
           * @classdesc cheetahGrid.ListGrid
           * @memberof cheetahGrid
           */


          var ListGrid = /*#__PURE__*/function (_DrawGrid_1$DrawGrid) {
            _inherits(ListGrid, _DrawGrid_1$DrawGrid);

            var _super = _createSuper(ListGrid);

            /**
             * constructor
             *
             * @constructor
             * @param options Constructor options
             */
            function ListGrid() {
              var _this11;

              var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, ListGrid);

              var _b;

              _this11 = _super.call(this, (0, utils_1.omit)(options, ["colCount", "rowCount", "frozenRowCount"]));
              _this11[_a] = _this11[_];
              _this11.disabled = false;
              _this11.readOnly = false;
              var protectedSpace = _this11[_];
              protectedSpace.header = options.header || [];
              protectedSpace.layout = options.layout || [];
              protectedSpace.headerRowHeight = options.headerRowHeight || [];

              if (options.dataSource) {
                _setDataSource(_assertThisInitialized(_this11), options.dataSource);
              } else {
                _setRecords(_assertThisInitialized(_this11), options.records);
              }

              protectedSpace.allowRangePaste = (_b = options.allowRangePaste) !== null && _b !== void 0 ? _b : false;

              _refreshHeader(_assertThisInitialized(_this11));

              protectedSpace.sortState = {
                col: -1,
                row: -1,
                order: undefined
              };
              protectedSpace.gridCanvasHelper = new GridCanvasHelper_1.GridCanvasHelper(_assertThisInitialized(_this11));
              protectedSpace.theme = themes.of(options.theme);
              protectedSpace.messageHandler = new MessageHandler_1.MessageHandler(_assertThisInitialized(_this11), function (col, row) {
                return _getCellMessage(_assertThisInitialized(_this11), col, row);
              });
              protectedSpace.tooltipHandler = new TooltipHandler_1.TooltipHandler(_assertThisInitialized(_this11));

              _this11.invalidate();

              protectedSpace.handler.on(window, "resize", function () {
                _this11.updateSize();

                _this11.updateScroll();

                _this11.invalidate();
              });
              return _this11;
            }
            /**
             * Dispose the grid instance.
             * @returns {void}
             */


            _createClass(ListGrid, [{
              key: "dispose",
              value: function dispose() {
                var protectedSpace = this[_];
                protectedSpace.messageHandler.dispose();
                protectedSpace.tooltipHandler.dispose();

                _get(_getPrototypeOf(ListGrid.prototype), "dispose", this).call(this);
              }
              /**
               * Gets the define of the header.
               */

            }, {
              key: "header",
              get: function get() {
                return this[_].header;
              }
              /**
               * Sets the define of the header with the given data.
               * <pre>
               * column options
               * -----
               * caption: header caption
               * field: field name
               * width: column width
               * minWidth: column min width
               * maxWidth: column max width
               * icon: icon definition
               * message: message key name
               * columnType: column type
               * action: column action
               * style: column style
               * headerType: header type
               * headerStyle: header style
               * headerAction: header action
               * headerField: header field name
               * headerIcon: header icon definition
               * sort: define sort setting
               * -----
               *
               * multiline header
               * -----
               * caption: header caption
               * columns: columns define
               * -----
               * </pre>
               */
              ,
              set: function set(header) {
                this[_].header = header;

                _refreshHeader(this);
              }
              /**
               * Gets the define of the layout.
               */

            }, {
              key: "layout",
              get: function get() {
                return this[_].layout;
              }
              /**
               * Sets the define of the layout with the given data.
               */
              ,
              set: function set(layout) {
                this[_].layout = layout;

                _refreshHeader(this);
              }
              /**
               * Gets the define of the headerRowHeight.
               */

            }, {
              key: "headerRowHeight",
              get: function get() {
                return this[_].headerRowHeight;
              }
              /**
               * Sets the define of the headerRowHeight with the given data.
               */
              ,
              set: function set(headerRowHeight) {
                this[_].headerRowHeight = headerRowHeight || [];

                _refreshHeader(this);
              }
              /**
               * Get the row count per record
               */

            }, {
              key: "recordRowCount",
              get: function get() {
                return this[_].layoutMap.bodyRowCount;
              }
              /**
               * Get the records.
               */

            }, {
              key: "records",
              get: function get() {
                return this[_].records || null;
              }
              /**
               * Set the records from given
               */
              ,
              set: function set(records) {
                if (records == null) {
                  return;
                }

                _setRecords(this, records);

                _refreshRowCount(this);

                this.invalidate();
              }
              /**
               * Get the data source.
               */

            }, {
              key: "dataSource",
              get: function get() {
                return this[_].dataSource;
              }
              /**
               * Set the data source from given
               */
              ,
              set: function set(dataSource) {
                _setDataSource(this, dataSource);

                _refreshRowCount(this);

                this.invalidate();
              }
              /**
               * Get the theme.
               */

            }, {
              key: "theme",
              get: function get() {
                return this[_].theme;
              }
              /**
               * Set the theme from given
               */
              ,
              set: function set(theme) {
                this[_].theme = themes.of(theme);
                this.invalidate();
              }
              /**
               * If set to true to allow pasting of ranges.
               */

            }, {
              key: "allowRangePaste",
              get: function get() {
                return this[_].allowRangePaste;
              },
              set: function set(allowRangePaste) {
                this[_].allowRangePaste = allowRangePaste;
              }
              /**
               * Get the font definition as a string.
               * @override
               */

            }, {
              key: "font",
              get: function get() {
                return _get(_getPrototypeOf(ListGrid.prototype), "font", this) || this[_].gridCanvasHelper.theme.font;
              }
              /**
               * Set the font definition with the given string.
               * @override
               */
              ,
              set: function set(font) {
                _set(_getPrototypeOf(ListGrid.prototype), "font", font, this, true);
              }
              /**
               * Get the background color of the underlay.
               * @override
               */

            }, {
              key: "underlayBackgroundColor",
              get: function get() {
                return _get(_getPrototypeOf(ListGrid.prototype), "underlayBackgroundColor", this) || this[_].gridCanvasHelper.theme.underlayBackgroundColor;
              }
              /**
               * Set the background color of the underlay.
               * @override
               */
              ,
              set: function set(underlayBackgroundColor) {
                _set(_getPrototypeOf(ListGrid.prototype), "underlayBackgroundColor", underlayBackgroundColor, this, true);
              }
              /**
               * Get the sort state.
               */

            }, {
              key: "sortState",
              get: function get() {
                return this[_].sortState;
              }
              /**
               * Sets the sort state.
               * If `null` to set, the sort state is initialized.
               */
              ,
              set: function set(sortState) {
                var oldState = this.sortState;
                var oldField;

                if (oldState.col >= 0 && oldState.row >= 0) {
                  oldField = this.getHeaderField(oldState.col, oldState.row);
                }

                var newState = this[_].sortState = sortState != null ? sortState : {
                  col: -1,
                  row: -1,
                  order: undefined
                };
                var newField;

                if (newState.col >= 0 && newState.row >= 0) {
                  newField = this.getHeaderField(newState.col, newState.row);
                } // bind header value


                if (oldField != null && oldField !== newField) {
                  this.setHeaderValue(oldState.col, oldState.row, undefined);
                }

                if (newField != null) {
                  this.setHeaderValue(newState.col, newState.row, newState.order);
                }
              }
              /**
               * Get the header values.
               */

            }, {
              key: "headerValues",
              get: function get() {
                return this[_].headerValues || (this[_].headerValues = new Map());
              }
              /**
               * Sets the header values.
               */
              ,
              set: function set(headerValues) {
                this[_].headerValues = headerValues || new Map();
              }
              /**
               * Get the field of the given column index.
               * @param  {number} col The column index.
               * @param  {number} row The row index.
               * @return {*} The field object.
               */

            }, {
              key: "getField",
              value: function getField(col, row) {
                return this[_].layoutMap.getBody(col, row !== null && row !== void 0 ? row : this[_].layoutMap.headerRowCount).field;
              }
              /**
               * Get the column define of the given column index.
               * @param  {number} col The column index.
               * @param  {number} row The row index.
               * @return {*} The column define object.
               */

            }, {
              key: "getColumnDefine",
              value: function getColumnDefine(col, row) {
                return this[_].layoutMap.getBody(col, row !== null && row !== void 0 ? row : this[_].layoutMap.headerRowCount).define;
              }
            }, {
              key: "getColumnType",
              value: function getColumnType(col, row) {
                return this[_].layoutMap.getBody(col, row).columnType;
              }
            }, {
              key: "getColumnAction",
              value: function getColumnAction(col, row) {
                return this[_].layoutMap.getBody(col, row).action;
              }
              /**
               * Get the header field of the given header cell.
               * @param  {number} col The column index.
               * @param  {number} row The header row index.
               * @return {*} The field object.
               */
              // eslint-disable-next-line @typescript-eslint/no-explicit-any

            }, {
              key: "getHeaderField",
              value: function getHeaderField(col, row) {
                var hd = this[_].layoutMap.getHeader(col, row);

                return hd.field;
              }
              /**
               * Get the header define of the given header cell.
               * @param  {number} col The column index.
               * @param  {number} row The header row index.
               * @return {*} The header define object.
               */

            }, {
              key: "getHeaderDefine",
              value: function getHeaderDefine(col, row) {
                var hd = this[_].layoutMap.getHeader(col, row);

                return hd.define;
              }
              /**
               * Get the record of the given row index.
               * @param  {number} row The row index.
               * @return {object} The record.
               */

            }, {
              key: "getRowRecord",
              value: function getRowRecord(row) {
                if (row < this[_].layoutMap.headerRowCount) {
                  // eslint-disable-next-line @typescript-eslint/no-explicit-any
                  return undefined;
                } else {
                  return this[_].dataSource.get(_getRecordIndexByRow(this, row));
                }
              }
              /**
               * Get the record index of the given row index.
               * @param  {number} row The row index.
               */

            }, {
              key: "getRecordIndexByRow",
              value: function getRecordIndexByRow(row) {
                return _getRecordIndexByRow(this, row);
              }
              /**
               * Gets the row index starting at the given record index.
               * @param  {number} index The record index.
               */

            }, {
              key: "getRecordStartRowByRecordIndex",
              value: function getRecordStartRowByRecordIndex(index) {
                return this[_].layoutMap.getRecordStartRowByRecordIndex(index);
              }
              /**
               * Get the column index of the given field.
               * @param  {*} field The field.
               * @return {number} The column index.
               * @deprecated use `getCellRangeByField` instead
               */

            }, {
              key: "getColumnIndexByField",
              value: function getColumnIndexByField(field) {
                var _b;

                var range = this.getCellRangeByField(field, 0);
                return (_b = range === null || range === void 0 ? void 0 : range.start.col) !== null && _b !== void 0 ? _b : null;
              }
              /**
               * Get the column index of the given field.
               * @param  {*} field The field.
               * @param  {number} index The record index
               * @return {number} The column index.
               */

            }, {
              key: "getCellRangeByField",
              value: function getCellRangeByField(field, index) {
                var layoutMap = this[_].layoutMap;
                var colObj = layoutMap.columnObjects.find(function (col) {
                  return col.field === field;
                });

                if (colObj) {
                  var layoutRange = layoutMap.getBodyLayoutRangeById(colObj.id);
                  var startRow = layoutMap.getRecordStartRowByRecordIndex(index);
                  return {
                    start: {
                      col: layoutRange.start.col,
                      row: startRow + layoutRange.start.row
                    },
                    end: {
                      col: layoutRange.end.col,
                      row: startRow + layoutRange.end.row
                    }
                  };
                }

                return null;
              }
              /**
               * Focus the cell.
               * @param  {*} field The field.
               * @param  {number} index The record index
               * @return {void}
               */

            }, {
              key: "focusGridCell",
              value: function focusGridCell(field, index) {
                var _b;

                var _this$selection$range = this.selection.range,
                    _this$selection$range2 = _this$selection$range.start,
                    startCol = _this$selection$range2.col,
                    startRow = _this$selection$range2.row,
                    _this$selection$range3 = _this$selection$range.end,
                    endCol = _this$selection$range3.col,
                    endRow = _this$selection$range3.row;
                var newFocus = (_b = this.getCellRangeByField(field, index)) === null || _b === void 0 ? void 0 : _b.start;

                if (newFocus == null) {
                  return;
                }

                this.focusCell(newFocus.col, newFocus.row);
                this.selection.select = newFocus;
                this.invalidateGridRect(startCol, startRow, endCol, endRow);
                this.invalidateCell(newFocus.col, newFocus.row);
              }
              /**
               * Scroll to where cell is visible.
               * @param  {*} field The field.
               * @param  {number} index The record index
               * @return {void}
               */

            }, {
              key: "makeVisibleGridCell",
              value: function makeVisibleGridCell(field, index) {
                var _b, _c, _d;

                var cell = (_b = this.getCellRangeByField(field, index)) === null || _b === void 0 ? void 0 : _b.start;
                this.makeVisibleCell((_c = cell === null || cell === void 0 ? void 0 : cell.col) !== null && _c !== void 0 ? _c : 0, (_d = cell === null || cell === void 0 ? void 0 : cell.row) !== null && _d !== void 0 ? _d : this[_].layoutMap.headerRowCount);
              }
            }, {
              key: "getGridCanvasHelper",
              value: function getGridCanvasHelper() {
                return this[_].gridCanvasHelper;
              }
              /**
               * Get cell range information for a given cell.
               * @param {number} col column index of the cell
               * @param {number} row row index of the cell
               * @returns {object} cell range info
               */

            }, {
              key: "getCellRange",
              value: function getCellRange(col, row) {
                return _getCellRange(this, col, row);
              }
              /**
               * Get header range information for a given cell.
               * @param {number} col column index of the cell
               * @param {number} row row index of the cell
               * @returns {object} cell range info
               * @deprecated use `getCellRange` instead
               */

            }, {
              key: "getHeaderCellRange",
              value: function getHeaderCellRange(col, row) {
                return this.getCellRange(col, row);
              }
            }, {
              key: "getCopyCellValue",
              value: function getCopyCellValue(col, row, range) {
                var cellRange = _getCellRange(this, col, row);

                var startCol = range ? Math.max(range.start.col, cellRange.start.col) : cellRange.start.col;
                var startRow = range ? Math.max(range.start.row, cellRange.start.row) : cellRange.start.row;

                if (startCol !== col || startRow !== row) {
                  return "";
                }

                var value = _getCellValue(this, col, row);

                if (row < this[_].layoutMap.headerRowCount) {
                  var headerData = this[_].layoutMap.getHeader(col, row);

                  return headerData.headerType.getCopyCellValue(value, this, {
                    col: col,
                    row: row
                  });
                }

                var columnData = this[_].layoutMap.getBody(col, row);

                return columnData.columnType.getCopyCellValue(value, this, {
                  col: col,
                  row: row
                });
              }
            }, {
              key: "onDrawCell",
              value: function onDrawCell(col, row, context) {
                var layoutMap = this[_].layoutMap;
                var draw;
                var style;

                if (row < layoutMap.headerRowCount) {
                  var hd = layoutMap.getHeader(col, row);
                  draw = hd.headerType.onDrawCell;
                  style = hd.style;

                  _updateRect(this, col, row, context);
                } else {
                  var column = layoutMap.getBody(col, row);
                  draw = column.columnType.onDrawCell;
                  style = column.style;

                  _updateRect(this, col, row, context);
                }

                var cellValue = _getCellValue(this, col, row);

                if (this.rowCount <= row) {
                  // Depending on the FilterDataSource, the rowCount may be reduced.
                  return undefined;
                }

                return _onDrawValue(this, cellValue, context, {
                  col: col,
                  row: row
                }, style, draw);
              }
            }, {
              key: "doGetCellValue",
              value: function doGetCellValue(col, row, // eslint-disable-next-line @typescript-eslint/no-explicit-any
              valueCallback) {
                if (row < this[_].layoutMap.headerRowCount) {
                  // nop
                  return false;
                } else {
                  var value = _getCellValue(this, col, row);

                  if ((0, utils_1.isPromise)(value)) {
                    //
                    return false;
                  }

                  valueCallback(value);
                }

                return true;
              }
            }, {
              key: "doChangeValue",
              value: function doChangeValue(col, row, // eslint-disable-next-line @typescript-eslint/no-explicit-any
              changeValueCallback) {
                var _this12 = this;

                if (row < this[_].layoutMap.headerRowCount) {
                  // nop
                  return false;
                } else {
                  var record = this.getRowRecord(row);

                  if ((0, utils_1.isPromise)(record)) {
                    //
                    return false;
                  }

                  var before = _getCellValue(this, col, row);

                  if ((0, utils_1.isPromise)(before)) {
                    //
                    return false;
                  }

                  var after = changeValueCallback(before);

                  if (after === undefined) {
                    return false;
                  }

                  var _this$_$layoutMap$get = this[_].layoutMap.getBody(col, row),
                      field = _this$_$layoutMap$get.field;

                  this.fireListeners(LG_EVENT_TYPE_1.LG_EVENT_TYPE.BEFORE_CHANGE_VALUE, {
                    col: col,
                    row: row,
                    record: record,
                    field: field,
                    value: after,
                    oldValue: before
                  });
                  return (0, utils_1.then)(_setCellValue(this, col, row, after), function (ret) {
                    if (ret) {
                      var _this12$_$layoutMap$g = _this12[_].layoutMap.getBody(col, row),
                          _field2 = _this12$_$layoutMap$g.field;

                      _this12.fireListeners(LG_EVENT_TYPE_1.LG_EVENT_TYPE.CHANGED_VALUE, {
                        col: col,
                        row: row,
                        record: record,
                        field: _field2,
                        value: after,
                        oldValue: before
                      });
                    }

                    return ret;
                  });
                }
              }
            }, {
              key: "doSetPasteValue",
              value: function doSetPasteValue(text, test) {
                _onRangePaste.call(this, text, test);
              } // eslint-disable-next-line @typescript-eslint/no-explicit-any

            }, {
              key: "getHeaderValue",
              value: function getHeaderValue(col, row) {
                var field = this.getHeaderField(col, row);
                return this.headerValues.get(field);
              } // eslint-disable-next-line @typescript-eslint/no-explicit-any

            }, {
              key: "setHeaderValue",
              value: function setHeaderValue(col, row, newValue) {
                var field = this.getHeaderField(col, row);
                var oldValue = this.headerValues.get(field);
                this.headerValues.set(field, newValue);
                this.fireListeners(LG_EVENT_TYPE_1.LG_EVENT_TYPE.CHANGED_HEADER_VALUE, {
                  col: col,
                  row: row,
                  field: field,
                  value: newValue,
                  oldValue: oldValue
                });
              }
            }, {
              key: "getLayoutCellId",
              value: function getLayoutCellId(col, row) {
                return this[_].layoutMap.getCellId(col, row);
              }
            }, {
              key: "bindEventsInternal",
              value: function bindEventsInternal() {
                var _this13 = this;

                var grid = this;
                grid.listen(LG_EVENT_TYPE_1.LG_EVENT_TYPE.SELECTED_CELL, function (e) {
                  var range = _getCellRange(_this13, e.col, e.row);

                  var _range$start = range.start,
                      startCol = _range$start.col,
                      startRow = _range$start.row,
                      _range$end = range.end,
                      endCol = _range$end.col,
                      endRow = _range$end.row;

                  if (startCol !== endCol || startRow !== endRow) {
                    _this13.invalidateCellRange(range);
                  }
                });
                grid.listen(LG_EVENT_TYPE_1.LG_EVENT_TYPE.PASTE_CELL, function (e) {
                  if (!_this13[_].allowRangePaste) {
                    return;
                  }

                  var _this13$selection$ran = _this13.selection.range,
                      start = _this13$selection$ran.start,
                      end = _this13$selection$ran.end;

                  if (!e.multi && (0, utils_1.cellEquals)(start, end)) {
                    return;
                  }

                  var layoutMap = _this13[_].layoutMap;

                  if (start.row < layoutMap.headerRowCount) {
                    return;
                  }

                  utils_1.event.cancel(e.event);

                  _onRangePaste.call(_this13, e.normalizeValue);
                });
                grid.listen(LG_EVENT_TYPE_1.LG_EVENT_TYPE.DELETE_CELL, function (e) {
                  var start = _this13.selection.range.start;
                  var layoutMap = _this13[_].layoutMap;

                  if (start.row < layoutMap.headerRowCount) {
                    return;
                  }

                  utils_1.event.cancel(e.event);

                  _onRangeDelete.call(_this13);
                });
              }
            }, {
              key: "getMoveLeftColByKeyDownInternal",
              value: function getMoveLeftColByKeyDownInternal(_ref18) {
                var col = _ref18.col,
                    row = _ref18.row;

                var _getCellRange3 = _getCellRange(this, col, row),
                    startCol = _getCellRange3.start.col;

                col = startCol;
                return _get(_getPrototypeOf(ListGrid.prototype), "getMoveLeftColByKeyDownInternal", this).call(this, {
                  col: col,
                  row: row
                });
              }
            }, {
              key: "getMoveRightColByKeyDownInternal",
              value: function getMoveRightColByKeyDownInternal(_ref19) {
                var col = _ref19.col,
                    row = _ref19.row;

                var _getCellRange4 = _getCellRange(this, col, row),
                    endCol = _getCellRange4.end.col;

                col = endCol;
                return _get(_getPrototypeOf(ListGrid.prototype), "getMoveRightColByKeyDownInternal", this).call(this, {
                  col: col,
                  row: row
                });
              }
            }, {
              key: "getMoveUpRowByKeyDownInternal",
              value: function getMoveUpRowByKeyDownInternal(_ref20) {
                var col = _ref20.col,
                    row = _ref20.row;

                var _getCellRange5 = _getCellRange(this, col, row),
                    startRow = _getCellRange5.start.row;

                row = startRow;
                return _get(_getPrototypeOf(ListGrid.prototype), "getMoveUpRowByKeyDownInternal", this).call(this, {
                  col: col,
                  row: row
                });
              }
            }, {
              key: "getMoveDownRowByKeyDownInternal",
              value: function getMoveDownRowByKeyDownInternal(_ref21) {
                var col = _ref21.col,
                    row = _ref21.row;

                var _getCellRange6 = _getCellRange(this, col, row),
                    endRow = _getCellRange6.end.row;

                row = endRow;
                return _get(_getPrototypeOf(ListGrid.prototype), "getMoveDownRowByKeyDownInternal", this).call(this, {
                  col: col,
                  row: row
                });
              }
            }, {
              key: "getOffsetInvalidateCells",
              value: function getOffsetInvalidateCells() {
                return 1;
              }
            }, {
              key: "getCopyRangeInternal",
              value: function getCopyRangeInternal(range) {
                var _this$getCellRange5 = this.getCellRange(range.start.col, range.start.row),
                    start = _this$getCellRange5.start;

                var _this$getCellRange6 = this.getCellRange(range.end.col, range.end.row),
                    end = _this$getCellRange6.end;

                return {
                  start: start,
                  end: end
                };
              }
            }, {
              key: "fireListeners",
              value: function fireListeners(type) {
                var _get2;

                for (var _len3 = arguments.length, event = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
                  event[_key3 - 1] = arguments[_key3];
                }

                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                return (_get2 = _get(_getPrototypeOf(ListGrid.prototype), "fireListeners", this)).call.apply(_get2, [this, type].concat(event));
              }
            }], [{
              key: "EVENT_TYPE",
              get: function get() {
                return LG_EVENT_TYPE_1.LG_EVENT_TYPE;
              }
            }]);

            return ListGrid;
          }(DrawGrid_1.DrawGrid);

          exports.ListGrid = ListGrid;
          _a = _;
          /***/
        },

        /***/
        "./columns.js":
        /*!********************!*\
          !*** ./columns.js ***!
          \********************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsJs(module, exports, __nested_webpack_require_189310__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.style = exports.type = exports.action = void 0;

          var action = __importStar(__nested_webpack_require_189310__(
          /*! ./columns/action */
          "./columns/action.js"));

          exports.action = action;

          var style = __importStar(__nested_webpack_require_189310__(
          /*! ./columns/style */
          "./columns/style.js"));

          exports.style = style;

          var type = __importStar(__nested_webpack_require_189310__(
          /*! ./columns/type */
          "./columns/type.js"));

          exports.type = type;
          /***/
        },

        /***/
        "./columns/action.js":
        /*!***************************!*\
          !*** ./columns/action.js ***!
          \***************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsActionJs(module, exports, __nested_webpack_require_191753__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.of = exports.InlineMenuEditor = exports.InlineInputEditor = exports.SmallDialogInputEditor = exports.ButtonAction = exports.RadioEditor = exports.CheckEditor = exports.Action = exports.Editor = exports.BaseAction = exports.ACTIONS = void 0;

          var Action_1 = __nested_webpack_require_191753__(
          /*! ./action/Action */
          "./columns/action/Action.js");

          Object.defineProperty(exports, "Action", {
            enumerable: true,
            get: function get() {
              return Action_1.Action;
            }
          });

          var BaseAction_1 = __nested_webpack_require_191753__(
          /*! ./action/BaseAction */
          "./columns/action/BaseAction.js");

          Object.defineProperty(exports, "BaseAction", {
            enumerable: true,
            get: function get() {
              return BaseAction_1.BaseAction;
            }
          });

          var ButtonAction_1 = __nested_webpack_require_191753__(
          /*! ./action/ButtonAction */
          "./columns/action/ButtonAction.js");

          Object.defineProperty(exports, "ButtonAction", {
            enumerable: true,
            get: function get() {
              return ButtonAction_1.ButtonAction;
            }
          });

          var CheckEditor_1 = __nested_webpack_require_191753__(
          /*! ./action/CheckEditor */
          "./columns/action/CheckEditor.js");

          Object.defineProperty(exports, "CheckEditor", {
            enumerable: true,
            get: function get() {
              return CheckEditor_1.CheckEditor;
            }
          });

          var Editor_1 = __nested_webpack_require_191753__(
          /*! ./action/Editor */
          "./columns/action/Editor.js");

          Object.defineProperty(exports, "Editor", {
            enumerable: true,
            get: function get() {
              return Editor_1.Editor;
            }
          });

          var InlineInputEditor_1 = __nested_webpack_require_191753__(
          /*! ./action/InlineInputEditor */
          "./columns/action/InlineInputEditor.js");

          Object.defineProperty(exports, "InlineInputEditor", {
            enumerable: true,
            get: function get() {
              return InlineInputEditor_1.InlineInputEditor;
            }
          });

          var InlineMenuEditor_1 = __nested_webpack_require_191753__(
          /*! ./action/InlineMenuEditor */
          "./columns/action/InlineMenuEditor.js");

          Object.defineProperty(exports, "InlineMenuEditor", {
            enumerable: true,
            get: function get() {
              return InlineMenuEditor_1.InlineMenuEditor;
            }
          });

          var RadioEditor_1 = __nested_webpack_require_191753__(
          /*! ./action/RadioEditor */
          "./columns/action/RadioEditor.js");

          Object.defineProperty(exports, "RadioEditor", {
            enumerable: true,
            get: function get() {
              return RadioEditor_1.RadioEditor;
            }
          });

          var SmallDialogInputEditor_1 = __nested_webpack_require_191753__(
          /*! ./action/SmallDialogInputEditor */
          "./columns/action/SmallDialogInputEditor.js");

          Object.defineProperty(exports, "SmallDialogInputEditor", {
            enumerable: true,
            get: function get() {
              return SmallDialogInputEditor_1.SmallDialogInputEditor;
            }
          }); // eslint-disable-next-line @typescript-eslint/no-explicit-any

          var ImmutableCheckEditor = /*#__PURE__*/function (_CheckEditor_1$CheckE) {
            _inherits(ImmutableCheckEditor, _CheckEditor_1$CheckE);

            var _super2 = _createSuper(ImmutableCheckEditor);

            function ImmutableCheckEditor() {
              _classCallCheck(this, ImmutableCheckEditor);

              return _super2.apply(this, arguments);
            }

            _createClass(ImmutableCheckEditor, [{
              key: "disabled",
              get: function get() {
                return this._disabled;
              }
            }, {
              key: "readOnly",
              get: function get() {
                return this._readOnly;
              }
            }]);

            return ImmutableCheckEditor;
          }(CheckEditor_1.CheckEditor); // eslint-disable-next-line @typescript-eslint/no-explicit-any


          var ImmutableRadioEditor = /*#__PURE__*/function (_RadioEditor_1$RadioE) {
            _inherits(ImmutableRadioEditor, _RadioEditor_1$RadioE);

            var _super3 = _createSuper(ImmutableRadioEditor);

            function ImmutableRadioEditor() {
              _classCallCheck(this, ImmutableRadioEditor);

              return _super3.apply(this, arguments);
            }

            _createClass(ImmutableRadioEditor, [{
              key: "disabled",
              get: function get() {
                return this._disabled;
              }
            }, {
              key: "readOnly",
              get: function get() {
                return this._readOnly;
              }
            }]);

            return ImmutableRadioEditor;
          }(RadioEditor_1.RadioEditor); // eslint-disable-next-line @typescript-eslint/no-explicit-any


          var ImmutableInputEditor = /*#__PURE__*/function (_SmallDialogInputEdit) {
            _inherits(ImmutableInputEditor, _SmallDialogInputEdit);

            var _super4 = _createSuper(ImmutableInputEditor);

            function ImmutableInputEditor() {
              _classCallCheck(this, ImmutableInputEditor);

              return _super4.apply(this, arguments);
            }

            _createClass(ImmutableInputEditor, [{
              key: "disabled",
              get: function get() {
                return this._disabled;
              }
            }, {
              key: "readOnly",
              get: function get() {
                return this._readOnly;
              }
            }]);

            return ImmutableInputEditor;
          }(SmallDialogInputEditor_1.SmallDialogInputEditor);

          exports.ACTIONS = {
            CHECK: new ImmutableCheckEditor(),
            INPUT: new ImmutableInputEditor(),
            RADIO: new ImmutableRadioEditor()
          };

          function of(columnAction) {
            if (!columnAction) {
              return undefined;
            } else if (typeof columnAction === "string") {
              var key = columnAction.toUpperCase();
              return exports.ACTIONS[key] || of(null);
            } else {
              return columnAction;
            }
          }

          exports.of = of;
          /***/
        },

        /***/
        "./columns/action/Action.js":
        /*!**********************************!*\
          !*** ./columns/action/Action.js ***!
          \**********************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsActionActionJs(module, exports, __nested_webpack_require_198839__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.Action = exports.AbstractAction = void 0;

          var actionBind_1 = __nested_webpack_require_198839__(
          /*! ./actionBind */
          "./columns/action/actionBind.js");

          var BaseAction_1 = __nested_webpack_require_198839__(
          /*! ./BaseAction */
          "./columns/action/BaseAction.js");

          var utils_1 = __nested_webpack_require_198839__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var action_utils_1 = __nested_webpack_require_198839__(
          /*! ./action-utils */
          "./columns/action/action-utils.js");

          var AbstractAction = /*#__PURE__*/function (_BaseAction_1$BaseAct) {
            _inherits(AbstractAction, _BaseAction_1$BaseAct);

            var _super5 = _createSuper(AbstractAction);

            function AbstractAction() {
              var _this14;

              var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, AbstractAction);

              _this14 = _super5.call(this, option);

              _this14._action = option.action || function () {};

              return _this14;
            }

            _createClass(AbstractAction, [{
              key: "editable",
              get: function get() {
                return false;
              }
            }, {
              key: "action",
              get: function get() {
                return this._action;
              },
              set: function set(action) {
                this._action = action;
              }
            }, {
              key: "bindGridEvent",
              value: function bindGridEvent(grid, cellId) {
                var _this15 = this;

                var state = this.getState(grid);

                var action = function action(cell) {
                  if ((0, action_utils_1.isDisabledRecord)(_this15.disabled, grid, cell.row)) {
                    return;
                  }

                  var record = grid.getRowRecord(cell.row);

                  _this15._action(record, (0, utils_1.extend)(cell, {
                    grid: grid
                  }));
                };

                return [].concat(_toConsumableArray((0, actionBind_1.bindCellClickAction)(grid, cellId, {
                  action: action,
                  mouseOver: function mouseOver(e) {
                    if ((0, action_utils_1.isDisabledRecord)(_this15.disabled, grid, e.row)) {
                      return false;
                    }

                    state.mouseActiveCell = {
                      col: e.col,
                      row: e.row
                    };
                    var range = grid.getCellRange(e.col, e.row);
                    grid.invalidateCellRange(range);
                    return true;
                  },
                  mouseOut: function mouseOut(e) {
                    delete state.mouseActiveCell;
                    var range = grid.getCellRange(e.col, e.row);
                    grid.invalidateCellRange(range);
                  },
                  area: function area(e) {
                    if (!_this15.area) {
                      return true;
                    }

                    var event = e.event;
                    var clientX = event.clientX || event.pageX + window.scrollX;
                    var clientY = event.clientY || event.pageY + window.scrollY;
                    var canvasRect = grid.canvas.getBoundingClientRect();
                    var xInCanvas = clientX - canvasRect.left;
                    var yInCanvas = clientY - canvasRect.top;
                    var rect = grid.getCellRect(e.col, e.row);
                    return _this15.area({
                      col: e.col,
                      row: e.row,
                      grid: grid,
                      pointInCell: {
                        x: xInCanvas - rect.left + grid.scrollLeft,
                        y: yInCanvas - rect.top + grid.scrollTop
                      },
                      pointInDrawingCanvas: {
                        x: xInCanvas,
                        y: yInCanvas
                      }
                    });
                  }
                })), _toConsumableArray((0, actionBind_1.bindCellKeyAction)(grid, cellId, {
                  action: action
                })));
              }
            }, {
              key: "onPasteCellRangeBox",
              value: function onPasteCellRangeBox() {// noop
              }
            }, {
              key: "onDeleteCellRangeBox",
              value: function onDeleteCellRangeBox() {// noop
              }
            }]);

            return AbstractAction;
          }(BaseAction_1.BaseAction);

          exports.AbstractAction = AbstractAction;

          var Action = /*#__PURE__*/function (_AbstractAction) {
            _inherits(Action, _AbstractAction);

            var _super6 = _createSuper(Action);

            function Action() {
              var _this16;

              var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, Action);

              _this16 = _super6.call(this, option);
              _this16._area = option.area;
              return _this16;
            }

            _createClass(Action, [{
              key: "area",
              get: function get() {
                return this._area;
              },
              set: function set(area) {
                this._area = area;
              }
            }, {
              key: "clone",
              value: function clone() {
                return new Action(this);
              }
            }, {
              key: "getState",
              value: function getState(_grid) {
                return {};
              }
            }]);

            return Action;
          }(AbstractAction);

          exports.Action = Action;
          /***/
        },

        /***/
        "./columns/action/BaseAction.js":
        /*!**************************************!*\
          !*** ./columns/action/BaseAction.js ***!
          \**************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsActionBaseActionJs(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.BaseAction = void 0;

          var BaseAction = /*#__PURE__*/function () {
            function BaseAction() {
              var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, BaseAction);

              this._disabled = option.disabled || false;
            }

            _createClass(BaseAction, [{
              key: "disabled",
              get: function get() {
                return this._disabled;
              },
              set: function set(disabled) {
                this._disabled = disabled;
                this.onChangeDisabledInternal();
              }
            }, {
              key: "onChangeDisabledInternal",
              value: function onChangeDisabledInternal() {// abstract
              }
            }]);

            return BaseAction;
          }();

          exports.BaseAction = BaseAction;
          /***/
        },

        /***/
        "./columns/action/BaseInputEditor.js":
        /*!*******************************************!*\
          !*** ./columns/action/BaseInputEditor.js ***!
          \*******************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsActionBaseInputEditorJs(module, exports, __nested_webpack_require_206837__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.BaseInputEditor = void 0;

          var utils_1 = __nested_webpack_require_206837__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var action_utils_1 = __nested_webpack_require_206837__(
          /*! ./action-utils */
          "./columns/action/action-utils.js");

          var DG_EVENT_TYPE_1 = __nested_webpack_require_206837__(
          /*! ../../core/DG_EVENT_TYPE */
          "./core/DG_EVENT_TYPE.js");

          var Editor_1 = __nested_webpack_require_206837__(
          /*! ./Editor */
          "./columns/action/Editor.js");

          var KEY_ENTER = 13;
          var KEY_F2 = 113;

          var BaseInputEditor = /*#__PURE__*/function (_Editor_1$Editor) {
            _inherits(BaseInputEditor, _Editor_1$Editor);

            var _super7 = _createSuper(BaseInputEditor);

            function BaseInputEditor() {
              var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, BaseInputEditor);

              return _super7.call(this, option);
            }

            _createClass(BaseInputEditor, [{
              key: "bindGridEvent",
              value: function bindGridEvent(grid, cellId) {
                var _this17 = this;

                var open = function open(cell) {
                  if ((0, action_utils_1.isReadOnlyRecord)(_this17.readOnly, grid, cell.row) || (0, action_utils_1.isDisabledRecord)(_this17.disabled, grid, cell.row)) {
                    return false;
                  }

                  _this17.onOpenCellInternal(grid, cell);

                  return true;
                };

                var input = function input(cell, value) {
                  if ((0, action_utils_1.isReadOnlyRecord)(_this17.readOnly, grid, cell.row) || (0, action_utils_1.isDisabledRecord)(_this17.disabled, grid, cell.row)) {
                    return;
                  }

                  _this17.onInputCellInternal(grid, cell, value);
                };

                function isTarget(col, row) {
                  return grid.getLayoutCellId(col, row) === cellId;
                }

                return [grid.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.INPUT_CELL, function (e) {
                  if (!isTarget(e.col, e.row)) {
                    return;
                  }

                  input({
                    col: e.col,
                    row: e.row
                  }, e.value);
                }), grid.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.PASTE_CELL, function (e) {
                  if (e.multi) {
                    // ignore multi cell values
                    return;
                  }

                  var selectionRange = grid.selection.range;

                  if (!(0, utils_1.cellEquals)(selectionRange.start, selectionRange.end)) {
                    // ignore multi paste values
                    return;
                  }

                  if (!isTarget(e.col, e.row)) {
                    return;
                  }

                  utils_1.event.cancel(e.event);
                  input({
                    col: e.col,
                    row: e.row
                  }, e.normalizeValue);
                }), grid.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.DBLCLICK_CELL, function (cell) {
                  if (!isTarget(cell.col, cell.row)) {
                    return;
                  }

                  open({
                    col: cell.col,
                    row: cell.row
                  });
                }), grid.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.DBLTAP_CELL, function (e) {
                  if (!isTarget(e.col, e.row)) {
                    return;
                  }

                  open({
                    col: e.col,
                    row: e.row
                  });
                  utils_1.event.cancel(e.event);
                }), grid.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.KEYDOWN, function (e) {
                  if (e.keyCode !== KEY_F2 && e.keyCode !== KEY_ENTER) {
                    return;
                  }

                  var sel = grid.selection.select;

                  if (!isTarget(sel.col, sel.row)) {
                    return;
                  }

                  if (open({
                    col: sel.col,
                    row: sel.row
                  })) {
                    e.stopCellMoving();
                  }
                }), grid.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.SELECTED_CELL, function (e) {
                  if (!isTarget(e.col, e.row)) {
                    return;
                  }

                  _this17.onChangeSelectCellInternal(grid, {
                    col: e.col,
                    row: e.row
                  }, e.selected);
                }), grid.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.SCROLL, function () {
                  _this17.onGridScrollInternal(grid);
                }), grid.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.EDITABLEINPUT_CELL, function (cell) {
                  if (!isTarget(cell.col, cell.row)) {
                    return false;
                  }

                  if ((0, action_utils_1.isReadOnlyRecord)(_this17.readOnly, grid, cell.row) || (0, action_utils_1.isDisabledRecord)(_this17.disabled, grid, cell.row)) {
                    return false;
                  }

                  return true;
                }), grid.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.MODIFY_STATUS_EDITABLEINPUT_CELL, function (cell) {
                  if (!isTarget(cell.col, cell.row)) {
                    return;
                  }

                  if ((0, action_utils_1.isReadOnlyRecord)(_this17.readOnly, grid, cell.row) || (0, action_utils_1.isDisabledRecord)(_this17.disabled, grid, cell.row)) {
                    return;
                  }

                  var range = grid.getCellRange(cell.col, cell.row);

                  if (range.start.col !== range.end.col || range.start.row !== range.end.row) {
                    var _input = cell.input;
                    var baseRect = grid.getCellRect(cell.col, cell.row);
                    var rangeRect = grid.getCellRangeRect(range);
                    _input.style.top = "".concat((parseFloat(_input.style.top) + (rangeRect.top - baseRect.top)).toFixed(), "px");
                    _input.style.left = "".concat((parseFloat(_input.style.left) + (rangeRect.left - baseRect.left)).toFixed(), "px");
                    _input.style.width = "".concat(rangeRect.width.toFixed(), "px");
                    _input.style.height = "".concat(rangeRect.height.toFixed(), "px");
                  }

                  _this17.onSetInputAttrsInternal(grid, {
                    col: cell.col,
                    row: cell.row
                  }, cell.input);
                })];
              }
            }, {
              key: "onPasteCellRangeBox",
              value: function onPasteCellRangeBox(grid, cell, value) {
                var _this18 = this;

                if ((0, action_utils_1.isReadOnlyRecord)(this.readOnly, grid, cell.row) || (0, action_utils_1.isDisabledRecord)(this.disabled, grid, cell.row)) {
                  return;
                }

                grid.doChangeValue(cell.col, cell.row, function () {
                  if (_this18.isSupportMultilineValue()) {
                    return value;
                  }

                  return value.replace(/\r?\n/g, " ");
                });
              }
            }, {
              key: "onDeleteCellRangeBox",
              value: function onDeleteCellRangeBox(grid, cell) {
                if ((0, action_utils_1.isReadOnlyRecord)(this.readOnly, grid, cell.row) || (0, action_utils_1.isDisabledRecord)(this.disabled, grid, cell.row)) {
                  return;
                }

                grid.doChangeValue(cell.col, cell.row, function () {
                  return "";
                });
              }
            }, {
              key: "isSupportMultilineValue",
              value: function isSupportMultilineValue() {
                return false;
              }
            }]);

            return BaseInputEditor;
          }(Editor_1.Editor);

          exports.BaseInputEditor = BaseInputEditor;
          /***/
        },

        /***/
        "./columns/action/ButtonAction.js":
        /*!****************************************!*\
          !*** ./columns/action/ButtonAction.js ***!
          \****************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsActionButtonActionJs(module, exports, __nested_webpack_require_215613__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.ButtonAction = void 0;

          var Action_1 = __nested_webpack_require_215613__(
          /*! ./Action */
          "./columns/action/Action.js");

          var symbolManager_1 = __nested_webpack_require_215613__(
          /*! ../../internal/symbolManager */
          "./internal/symbolManager.js");

          var utils_1 = __nested_webpack_require_215613__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var BUTTON_COLUMN_STATE_ID = (0, symbolManager_1.getButtonColumnStateId)();

          var ButtonAction = /*#__PURE__*/function (_Action_1$AbstractAct) {
            _inherits(ButtonAction, _Action_1$AbstractAct);

            var _super8 = _createSuper(ButtonAction);

            function ButtonAction() {
              var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, ButtonAction);

              return _super8.call(this, option);
            }

            _createClass(ButtonAction, [{
              key: "area",
              get: function get() {
                return undefined;
              },
              set: function set(_area) {// noop
              }
            }, {
              key: "clone",
              value: function clone() {
                return new ButtonAction(this);
              }
            }, {
              key: "getState",
              value: function getState(grid) {
                var state = grid[BUTTON_COLUMN_STATE_ID];

                if (!state) {
                  state = {};
                  utils_1.obj.setReadonly(grid, BUTTON_COLUMN_STATE_ID, state);
                }

                return state;
              }
            }]);

            return ButtonAction;
          }(Action_1.AbstractAction);

          exports.ButtonAction = ButtonAction;
          /***/
        },

        /***/
        "./columns/action/CheckEditor.js":
        /*!***************************************!*\
          !*** ./columns/action/CheckEditor.js ***!
          \***************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsActionCheckEditorJs(module, exports, __nested_webpack_require_218009__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.CheckEditor = void 0;

          var actionBind_1 = __nested_webpack_require_218009__(
          /*! ./actionBind */
          "./columns/action/actionBind.js");

          var utils_1 = __nested_webpack_require_218009__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var action_utils_1 = __nested_webpack_require_218009__(
          /*! ./action-utils */
          "./columns/action/action-utils.js");

          var DG_EVENT_TYPE_1 = __nested_webpack_require_218009__(
          /*! ../../core/DG_EVENT_TYPE */
          "./core/DG_EVENT_TYPE.js");

          var Editor_1 = __nested_webpack_require_218009__(
          /*! ./Editor */
          "./columns/action/Editor.js");

          var animate_1 = __nested_webpack_require_218009__(
          /*! ../../internal/animate */
          "./internal/animate.js");

          var symbolManager_1 = __nested_webpack_require_218009__(
          /*! ../../internal/symbolManager */
          "./internal/symbolManager.js");

          var CHECK_COLUMN_STATE_ID = (0, symbolManager_1.getCheckColumnStateId)();

          var CheckEditor = /*#__PURE__*/function (_Editor_1$Editor2) {
            _inherits(CheckEditor, _Editor_1$Editor2);

            var _super9 = _createSuper(CheckEditor);

            function CheckEditor() {
              _classCallCheck(this, CheckEditor);

              return _super9.apply(this, arguments);
            }

            _createClass(CheckEditor, [{
              key: "clone",
              value: function clone() {
                return new CheckEditor(this);
              }
            }, {
              key: "bindGridEvent",
              value: function bindGridEvent(grid, cellId) {
                var _this19 = this;

                var _state = grid[CHECK_COLUMN_STATE_ID];

                if (!_state) {
                  _state = {
                    block: {},
                    elapsed: {}
                  };
                  utils_1.obj.setReadonly(grid, CHECK_COLUMN_STATE_ID, _state);
                }

                var state = _state;

                var _action = function action(cell) {
                  var range = grid.getCellRange(cell.col, cell.row);
                  var cellKey = "".concat(range.start.col, ":").concat(range.start.row);

                  if ((0, action_utils_1.isReadOnlyRecord)(_this19.readOnly, grid, cell.row) || (0, action_utils_1.isDisabledRecord)(_this19.disabled, grid, cell.row) || state.block[cellKey]) {
                    return;
                  }

                  var ret = grid.doChangeValue(cell.col, cell.row, action_utils_1.toggleValue);

                  if (ret) {
                    var onChange = function onChange() {
                      // checkbox animation
                      (0, animate_1.animate)(200, function (point) {
                        if (point === 1) {
                          delete state.elapsed[cellKey];
                        } else {
                          state.elapsed[cellKey] = point;
                        }

                        grid.invalidateCellRange(range);
                      });
                    };

                    if ((0, utils_1.isPromise)(ret)) {
                      state.block[cellKey] = true;
                      ret.then(function () {
                        delete state.block[cellKey];
                        onChange();
                      });
                    } else {
                      onChange();
                    }
                  }
                };

                function isTarget(col, row) {
                  return grid.getLayoutCellId(col, row) === cellId;
                }

                return [].concat(_toConsumableArray((0, actionBind_1.bindCellClickAction)(grid, cellId, {
                  action: _action,
                  mouseOver: function mouseOver(e) {
                    if ((0, action_utils_1.isDisabledRecord)(_this19.disabled, grid, e.row)) {
                      return false;
                    }

                    state.mouseActiveCell = {
                      col: e.col,
                      row: e.row
                    };
                    var range = grid.getCellRange(e.col, e.row);
                    grid.invalidateCellRange(range);
                    return true;
                  },
                  mouseOut: function mouseOut(e) {
                    delete state.mouseActiveCell;
                    var range = grid.getCellRange(e.col, e.row);
                    grid.invalidateCellRange(range);
                  }
                })), _toConsumableArray((0, actionBind_1.bindCellKeyAction)(grid, cellId, {
                  action: function action(_e) {
                    var selrange = grid.selection.range;
                    var col = grid.selection.select.col;

                    for (var row = selrange.start.row; row <= selrange.end.row; row++) {
                      if (!isTarget(col, row)) {
                        continue;
                      }

                      _action({
                        col: col,
                        row: row
                      });
                    }
                  }
                })), [// paste value
                grid.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.PASTE_CELL, function (e) {
                  if (e.multi) {
                    // ignore multi cell values
                    return;
                  }

                  var selectionRange = grid.selection.range;

                  if (!(0, utils_1.cellEquals)(selectionRange.start, selectionRange.end)) {
                    // ignore multi paste values
                    return;
                  }

                  if (!isTarget(e.col, e.row)) {
                    return;
                  }

                  utils_1.event.cancel(e.event);
                  var pasteValue = e.normalizeValue.trim();
                  grid.doGetCellValue(e.col, e.row, function (value) {
                    var newValue = (0, action_utils_1.toggleValue)(value);

                    if ("".concat(newValue).trim() === pasteValue) {
                      _action({
                        col: e.col,
                        row: e.row
                      });
                    } else if (isRejectValue(value, pasteValue)) {
                      var record = grid.getRowRecord(e.row);

                      if (!(0, utils_1.isPromise)(record)) {
                        grid.fireListeners("rejected_paste_values", {
                          detail: [{
                            col: e.col,
                            row: e.row,
                            record: record,
                            define: grid.getColumnDefine(e.col, e.row),
                            pasteValue: pasteValue
                          }]
                        });
                      }
                    }
                  });
                })]);
              }
            }, {
              key: "onPasteCellRangeBox",
              value: function onPasteCellRangeBox(grid, cell, value, context) {
                if ((0, action_utils_1.isReadOnlyRecord)(this.readOnly, grid, cell.row) || (0, action_utils_1.isDisabledRecord)(this.disabled, grid, cell.row)) {
                  return;
                }

                var pasteValue = value.trim();
                grid.doGetCellValue(cell.col, cell.row, function (value) {
                  var newValue = (0, action_utils_1.toggleValue)(value);

                  if ("".concat(newValue).trim() === pasteValue) {
                    grid.doChangeValue(cell.col, cell.row, action_utils_1.toggleValue);
                  } else if (isRejectValue(value, pasteValue)) {
                    context.reject();
                  }
                });
              }
            }, {
              key: "onDeleteCellRangeBox",
              value: function onDeleteCellRangeBox() {// noop
              }
            }]);

            return CheckEditor;
          }(Editor_1.Editor);

          exports.CheckEditor = CheckEditor;

          function isRejectValue(oldValue, pasteValue) {
            if ((oldValue != null ? "".concat(oldValue).trim() : "") === pasteValue) {
              return false;
            }

            var newValue = (0, action_utils_1.toggleValue)(oldValue);
            return "".concat(newValue).trim() !== pasteValue && "".concat((0, action_utils_1.toggleValue)(newValue)).trim() !== pasteValue;
          }
          /***/

        },

        /***/
        "./columns/action/Editor.js":
        /*!**********************************!*\
          !*** ./columns/action/Editor.js ***!
          \**********************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsActionEditorJs(module, exports, __nested_webpack_require_226989__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.Editor = void 0;

          var BaseAction_1 = __nested_webpack_require_226989__(
          /*! ./BaseAction */
          "./columns/action/BaseAction.js");

          var Editor = /*#__PURE__*/function (_BaseAction_1$BaseAct2) {
            _inherits(Editor, _BaseAction_1$BaseAct2);

            var _super10 = _createSuper(Editor);

            function Editor() {
              var _this20;

              var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, Editor);

              _this20 = _super10.call(this, option);
              _this20._readOnly = option.readOnly || false;
              return _this20;
            }

            _createClass(Editor, [{
              key: "editable",
              get: function get() {
                return true;
              }
            }, {
              key: "readOnly",
              get: function get() {
                return this._readOnly;
              },
              set: function set(readOnly) {
                this._readOnly = readOnly;
                this.onChangeReadOnlyInternal();
              }
            }, {
              key: "onChangeReadOnlyInternal",
              value: function onChangeReadOnlyInternal() {// abstruct
              }
            }]);

            return Editor;
          }(BaseAction_1.BaseAction);

          exports.Editor = Editor;
          /***/
        },

        /***/
        "./columns/action/InlineInputEditor.js":
        /*!*********************************************!*\
          !*** ./columns/action/InlineInputEditor.js ***!
          \*********************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsActionInlineInputEditorJs(module, exports, __nested_webpack_require_229014__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.InlineInputEditor = void 0;

          var BaseInputEditor_1 = __nested_webpack_require_229014__(
          /*! ./BaseInputEditor */
          "./columns/action/BaseInputEditor.js");

          var InlineInputElement_1 = __nested_webpack_require_229014__(
          /*! ./internal/InlineInputElement */
          "./columns/action/internal/InlineInputElement.js");

          var symbolManager_1 = __nested_webpack_require_229014__(
          /*! ../../internal/symbolManager */
          "./internal/symbolManager.js");

          var utils_1 = __nested_webpack_require_229014__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var _ = (0, symbolManager_1.getInlineInputEditorStateId)();

          function getState(grid) {
            var state = grid[_];

            if (!state) {
              state = {};
              utils_1.obj.setReadonly(grid, _, state);
            }

            return state;
          } // eslint-disable-next-line @typescript-eslint/no-explicit-any


          var globalElement = null;
          var bindGridCount = 0;

          function attachInput(grid, cell, editor, value) {
            var state = getState(grid);

            if (!globalElement) {
              globalElement = new InlineInputElement_1.InlineInputElement();
            }

            if (!state.element) {
              state.element = globalElement;
              bindGridCount++;
              grid.addDisposable({
                dispose: function dispose() {
                  bindGridCount--;

                  if (!bindGridCount) {
                    globalElement === null || globalElement === void 0 ? void 0 : globalElement.dispose();
                    globalElement = null;
                    state.element = null;
                  }
                }
              });
            }

            globalElement.attach(grid, editor, cell.col, cell.row, value);
          }

          function detachInput(gridFocus) {
            if (globalElement) {
              globalElement.detach(gridFocus);
            }
          }

          function doChangeValue(_grid) {
            if (globalElement) {
              globalElement.doChangeValue();
            }
          }

          var InlineInputEditor = /*#__PURE__*/function (_BaseInputEditor_1$Ba) {
            _inherits(InlineInputEditor, _BaseInputEditor_1$Ba);

            var _super11 = _createSuper(InlineInputEditor);

            function InlineInputEditor() {
              var _this21;

              var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, InlineInputEditor);

              _this21 = _super11.call(this, option);
              _this21._classList = option.classList;
              _this21._type = option.type;
              return _this21;
            }

            _createClass(InlineInputEditor, [{
              key: "classList",
              get: function get() {
                if (!this._classList) {
                  return undefined;
                }

                return Array.isArray(this._classList) ? this._classList : [this._classList];
              },
              set: function set(classList) {
                this._classList = classList;
              }
            }, {
              key: "type",
              get: function get() {
                return this._type;
              },
              set: function set(type) {
                this._type = type;
              }
            }, {
              key: "clone",
              value: function clone() {
                return new InlineInputEditor(this);
              }
            }, {
              key: "onInputCellInternal",
              value: function onInputCellInternal(grid, cell, inputValue) {
                attachInput(grid, cell, this, inputValue);
              }
            }, {
              key: "onOpenCellInternal",
              value: function onOpenCellInternal(grid, cell) {
                var _this22 = this;

                grid.doGetCellValue(cell.col, cell.row, function (value) {
                  attachInput(grid, cell, _this22, value);
                });
              }
            }, {
              key: "onChangeSelectCellInternal",
              value: function onChangeSelectCellInternal(grid, _cell, _selected) {
                doChangeValue(grid);
                detachInput();
              }
            }, {
              key: "onGridScrollInternal",
              value: function onGridScrollInternal(grid) {
                doChangeValue(grid);
                detachInput(true);
              }
            }, {
              key: "onChangeDisabledInternal",
              value: function onChangeDisabledInternal() {
                // cancel input
                detachInput(true);
              }
            }, {
              key: "onChangeReadOnlyInternal",
              value: function onChangeReadOnlyInternal() {
                // cancel input
                detachInput(true);
              }
            }, {
              key: "onSetInputAttrsInternal",
              value: function onSetInputAttrsInternal(grid, _cell, input) {
                InlineInputElement_1.InlineInputElement.setInputAttrs(this, grid, input);
              }
            }]);

            return InlineInputEditor;
          }(BaseInputEditor_1.BaseInputEditor);

          exports.InlineInputEditor = InlineInputEditor;
          /***/
        },

        /***/
        "./columns/action/InlineMenuEditor.js":
        /*!********************************************!*\
          !*** ./columns/action/InlineMenuEditor.js ***!
          \********************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsActionInlineMenuEditorJs(module, exports, __nested_webpack_require_235045__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.InlineMenuEditor = void 0;

          var utils_1 = __nested_webpack_require_235045__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var action_utils_1 = __nested_webpack_require_235045__(
          /*! ./action-utils */
          "./columns/action/action-utils.js");

          var DG_EVENT_TYPE_1 = __nested_webpack_require_235045__(
          /*! ../../core/DG_EVENT_TYPE */
          "./core/DG_EVENT_TYPE.js");

          var Editor_1 = __nested_webpack_require_235045__(
          /*! ./Editor */
          "./columns/action/Editor.js");

          var InlineMenuElement_1 = __nested_webpack_require_235045__(
          /*! ./internal/InlineMenuElement */
          "./columns/action/internal/InlineMenuElement.js");

          var type_1 = __nested_webpack_require_235045__(
          /*! ../type */
          "./columns/type.js");

          var symbolManager_1 = __nested_webpack_require_235045__(
          /*! ../../internal/symbolManager */
          "./internal/symbolManager.js");

          var menu_items_1 = __nested_webpack_require_235045__(
          /*! ../../internal/menu-items */
          "./internal/menu-items.js");

          var _ = (0, symbolManager_1.getInlineMenuEditorStateId)();

          function getState(grid) {
            var state = grid[_];

            if (!state) {
              state = {};
              utils_1.obj.setReadonly(grid, _, state);
            }

            return state;
          } // eslint-disable-next-line @typescript-eslint/no-explicit-any


          var globalElement = null;
          var bindGridCount = 0;

          function attachMenu(grid, cell, editor, value, record) {
            var state = getState(grid);

            if (!globalElement) {
              globalElement = new InlineMenuElement_1.InlineMenuElement();
            }

            if (!state.element) {
              state.element = globalElement;
              bindGridCount++;
              grid.addDisposable({
                dispose: function dispose() {
                  bindGridCount--;

                  if (!bindGridCount) {
                    globalElement === null || globalElement === void 0 ? void 0 : globalElement.dispose();
                    globalElement = null;
                    state.element = null;
                  }
                }
              });
            }

            globalElement.attach(grid, editor, cell.col, cell.row, value, record);
          }

          function detachMenu(gridFocus) {
            if (globalElement) {
              globalElement.detach(gridFocus);
            }
          }

          var KEY_ENTER = 13;
          var KEY_F2 = 113;

          var InlineMenuEditor = /*#__PURE__*/function (_Editor_1$Editor3) {
            _inherits(InlineMenuEditor, _Editor_1$Editor3);

            var _super12 = _createSuper(InlineMenuEditor);

            function InlineMenuEditor() {
              var _this23;

              var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, InlineMenuEditor);

              _this23 = _super12.call(this, option);
              _this23._classList = option.classList;
              _this23._options = (0, menu_items_1.normalizeToFn)(option.options);
              return _this23;
            }

            _createClass(InlineMenuEditor, [{
              key: "dispose",
              value: function dispose() {// noop
              }
            }, {
              key: "classList",
              get: function get() {
                if (!this._classList) {
                  return undefined;
                }

                return Array.isArray(this._classList) ? this._classList : [this._classList];
              },
              set: function set(classList) {
                this._classList = classList;
              }
            }, {
              key: "options",
              get: function get() {
                return this._options;
              },
              set: function set(options) {
                this._options = (0, menu_items_1.normalizeToFn)(options);
              }
            }, {
              key: "clone",
              value: function clone() {
                return new InlineMenuEditor(this);
              }
            }, {
              key: "onChangeDisabledInternal",
              value: function onChangeDisabledInternal() {
                // cancel input
                detachMenu(true);
              }
            }, {
              key: "onChangeReadOnlyInternal",
              value: function onChangeReadOnlyInternal() {
                // cancel input
                detachMenu(true);
              }
            }, {
              key: "bindGridEvent",
              value: function bindGridEvent(grid, cellId) {
                var _this24 = this;

                var open = function open(cell) {
                  if ((0, action_utils_1.isReadOnlyRecord)(_this24.readOnly, grid, cell.row) || (0, action_utils_1.isDisabledRecord)(_this24.disabled, grid, cell.row)) {
                    return false;
                  }

                  grid.doGetCellValue(cell.col, cell.row, function (value) {
                    var record = grid.getRowRecord(cell.row);

                    if ((0, utils_1.isPromise)(record)) {
                      return;
                    }

                    attachMenu(grid, cell, _this24, value, record);
                  });
                  return true;
                };

                function isTarget(col, row) {
                  return grid.getLayoutCellId(col, row) === cellId;
                }

                return [grid.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.CLICK_CELL, function (cell) {
                  if (!isTarget(cell.col, cell.row)) {
                    return;
                  }

                  open({
                    col: cell.col,
                    row: cell.row
                  });
                }), grid.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.KEYDOWN, function (e) {
                  if (e.keyCode !== KEY_F2 && e.keyCode !== KEY_ENTER) {
                    return;
                  }

                  var sel = grid.selection.select;

                  if (!isTarget(sel.col, sel.row)) {
                    return;
                  }

                  if (open({
                    col: sel.col,
                    row: sel.row
                  })) {
                    e.stopCellMoving();
                  }
                }), grid.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.SELECTED_CELL, function (_e) {
                  detachMenu();
                }), grid.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.SCROLL, function () {
                  detachMenu(true);
                }), // mouse move
                grid.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.MOUSEOVER_CELL, function (e) {
                  if (!isTarget(e.col, e.row)) {
                    return;
                  }

                  if ((0, action_utils_1.isReadOnlyRecord)(_this24.readOnly, grid, e.row) || (0, action_utils_1.isDisabledRecord)(_this24.disabled, grid, e.row)) {
                    return;
                  }

                  grid.getElement().style.cursor = "pointer";
                }), grid.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.MOUSEMOVE_CELL, function (e) {
                  if (!isTarget(e.col, e.row)) {
                    return;
                  }

                  if ((0, action_utils_1.isReadOnlyRecord)(_this24.readOnly, grid, e.row) || (0, action_utils_1.isDisabledRecord)(_this24.disabled, grid, e.row)) {
                    return;
                  }

                  if (!grid.getElement().style.cursor) {
                    grid.getElement().style.cursor = "pointer";
                  }
                }), grid.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.MOUSEOUT_CELL, function (e) {
                  if (!isTarget(e.col, e.row)) {
                    return;
                  }

                  grid.getElement().style.cursor = "";
                }), // paste value
                grid.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.PASTE_CELL, function (e) {
                  if (e.multi) {
                    // ignore multi cell values
                    return;
                  }

                  var selectionRange = grid.selection.range;

                  if (!(0, utils_1.cellEquals)(selectionRange.start, selectionRange.end)) {
                    // ignore multi paste values
                    return;
                  }

                  if (!isTarget(e.col, e.row)) {
                    return;
                  }

                  if ((0, action_utils_1.isReadOnlyRecord)(_this24.readOnly, grid, e.row) || (0, action_utils_1.isDisabledRecord)(_this24.disabled, grid, e.row)) {
                    return;
                  }

                  var record = grid.getRowRecord(e.row);

                  if ((0, utils_1.isPromise)(record)) {
                    return;
                  }

                  var pasteOpt = _this24._pasteDataToOptionValue(e.normalizeValue, grid, e, record);

                  if (pasteOpt) {
                    utils_1.event.cancel(e.event);
                    (0, utils_1.then)(grid.doChangeValue(e.col, e.row, function () {
                      return pasteOpt.value;
                    }), function () {
                      var range = grid.getCellRange(e.col, e.row);
                      grid.invalidateCellRange(range);
                    });
                  } else {
                    grid.fireListeners("rejected_paste_values", {
                      detail: [{
                        col: e.col,
                        row: e.row,
                        record: record,
                        define: grid.getColumnDefine(e.col, e.row),
                        pasteValue: e.normalizeValue
                      }]
                    });
                  }
                })];
              }
            }, {
              key: "onPasteCellRangeBox",
              value: function onPasteCellRangeBox(grid, cell, value, context) {
                if ((0, action_utils_1.isReadOnlyRecord)(this.readOnly, grid, cell.row) || (0, action_utils_1.isDisabledRecord)(this.disabled, grid, cell.row)) {
                  return;
                }

                var record = grid.getRowRecord(cell.row);

                if ((0, utils_1.isPromise)(record)) {
                  return;
                }

                var pasteOpt = this._pasteDataToOptionValue(value, grid, cell, record);

                if (pasteOpt) {
                  grid.doChangeValue(cell.col, cell.row, function () {
                    return pasteOpt.value;
                  });
                } else {
                  // unknown
                  context.reject();
                }
              }
            }, {
              key: "onDeleteCellRangeBox",
              value: function onDeleteCellRangeBox(grid, cell) {
                if ((0, action_utils_1.isReadOnlyRecord)(this.readOnly, grid, cell.row) || (0, action_utils_1.isDisabledRecord)(this.disabled, grid, cell.row)) {
                  return;
                }

                var record = grid.getRowRecord(cell.row);

                if ((0, utils_1.isPromise)(record)) {
                  return;
                }

                var pasteOpt = this._pasteDataToOptionValue("", grid, cell, record);

                if (pasteOpt) {
                  grid.doChangeValue(cell.col, cell.row, function () {
                    return pasteOpt.value;
                  });
                }
              }
            }, {
              key: "_pasteDataToOptionValue",
              value: function _pasteDataToOptionValue(value, grid, cell, record) {
                var options = this._options(record);

                var pasteOpt = _textToOptionValue(value, options);

                if (pasteOpt) {
                  return pasteOpt;
                }

                var columnType = grid.getColumnType(cell.col, cell.row);

                if (hasOptions(columnType)) {
                  // Find with caption.
                  var pasteValue = normalizePasteValueStr(value);
                  var captionOpt = utils_1.array.find(columnType.options, function (opt) {
                    return normalizePasteValueStr(opt.label) === pasteValue;
                  });

                  if (captionOpt) {
                    return _textToOptionValue(captionOpt.value, options);
                  }
                }

                return undefined;
              }
            }]);

            return InlineMenuEditor;
          }(Editor_1.Editor);

          exports.InlineMenuEditor = InlineMenuEditor;

          function _textToOptionValue(value, options) {
            var pasteValue = normalizePasteValueStr(value);
            var pasteOpt = utils_1.array.find(options, function (opt) {
              return normalizePasteValueStr(opt.value) === pasteValue;
            });

            if (pasteOpt) {
              return pasteOpt;
            }

            return undefined;
          } // eslint-disable-next-line @typescript-eslint/no-explicit-any


          function normalizePasteValueStr(value) {
            if (value == null) {
              return "";
            }

            return "".concat(value).trim();
          } // eslint-disable-next-line @typescript-eslint/no-explicit-any


          function hasOptions(columnType) {
            if (columnType instanceof type_1.MenuColumn) {
              return true;
            } // eslint-disable-next-line @typescript-eslint/no-explicit-any


            if (Array.isArray(columnType.options)) {
              return true;
            }

            return false;
          }
          /***/

        },

        /***/
        "./columns/action/RadioEditor.js":
        /*!***************************************!*\
          !*** ./columns/action/RadioEditor.js ***!
          \***************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsActionRadioEditorJs(module, exports, __nested_webpack_require_249341__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.RadioEditor = void 0;

          var actionBind_1 = __nested_webpack_require_249341__(
          /*! ./actionBind */
          "./columns/action/actionBind.js");

          var utils_1 = __nested_webpack_require_249341__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var action_utils_1 = __nested_webpack_require_249341__(
          /*! ./action-utils */
          "./columns/action/action-utils.js");

          var DG_EVENT_TYPE_1 = __nested_webpack_require_249341__(
          /*! ../../core/DG_EVENT_TYPE */
          "./core/DG_EVENT_TYPE.js");

          var Editor_1 = __nested_webpack_require_249341__(
          /*! ./Editor */
          "./columns/action/Editor.js");

          var animate_1 = __nested_webpack_require_249341__(
          /*! ../../internal/animate */
          "./internal/animate.js");

          var symbolManager_1 = __nested_webpack_require_249341__(
          /*! ../../internal/symbolManager */
          "./internal/symbolManager.js");

          var utils_2 = __nested_webpack_require_249341__(
          /*! ../utils */
          "./columns/utils/index.js");

          var RADIO_COLUMN_STATE_ID = (0, symbolManager_1.getRadioColumnStateId)();

          var RadioEditor = /*#__PURE__*/function (_Editor_1$Editor4) {
            _inherits(RadioEditor, _Editor_1$Editor4);

            var _super13 = _createSuper(RadioEditor);

            function RadioEditor() {
              var _this25;

              var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, RadioEditor);

              _this25 = _super13.call(this, option);
              _this25._group = option.group;
              _this25._checkAction = option.checkAction;
              return _this25;
            }

            _createClass(RadioEditor, [{
              key: "clone",
              value: function clone() {
                return new RadioEditor(this);
              }
              /** @deprecated Use checkAction instead. */

            }, {
              key: "group",
              get: function get() {
                return this._group;
              }
              /** @deprecated Use checkAction instead. */
              ,
              set: function set(group) {
                this._group = group;
              }
            }, {
              key: "checkAction",
              get: function get() {
                return this._checkAction;
              },
              set: function set(checkAction) {
                this._checkAction = checkAction;
              }
            }, {
              key: "bindGridEvent",
              value: function bindGridEvent(grid, cellId) {
                var _this26 = this;

                var _state = grid[RADIO_COLUMN_STATE_ID];

                if (!_state) {
                  _state = {
                    block: {},
                    elapsed: {}
                  };
                  utils_1.obj.setReadonly(grid, RADIO_COLUMN_STATE_ID, _state);
                }

                var state = _state;

                var action = function action(cell) {
                  _this26._action(grid, cell);
                };

                function isTarget(col, row) {
                  return grid.getLayoutCellId(col, row) === cellId;
                }

                return [].concat(_toConsumableArray((0, actionBind_1.bindCellClickAction)(grid, cellId, {
                  action: action,
                  mouseOver: function mouseOver(e) {
                    if ((0, action_utils_1.isDisabledRecord)(_this26.disabled, grid, e.row)) {
                      return false;
                    }

                    state.mouseActiveCell = {
                      col: e.col,
                      row: e.row
                    };
                    var range = grid.getCellRange(e.col, e.row);
                    grid.invalidateCellRange(range);
                    return true;
                  },
                  mouseOut: function mouseOut(e) {
                    delete state.mouseActiveCell;
                    var range = grid.getCellRange(e.col, e.row);
                    grid.invalidateCellRange(range);
                  }
                })), _toConsumableArray((0, actionBind_1.bindCellKeyAction)(grid, cellId, {
                  action: action
                })), [// paste value
                grid.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.PASTE_CELL, function (e) {
                  if (e.multi) {
                    // ignore multi cell values
                    return;
                  }

                  var selectionRange = grid.selection.range;

                  if (!(0, utils_1.cellEquals)(selectionRange.start, selectionRange.end)) {
                    // ignore multi paste values
                    return;
                  }

                  if (!isTarget(e.col, e.row)) {
                    return;
                  }

                  utils_1.event.cancel(e.event);
                  var pasteValue = e.normalizeValue.trim();

                  if (isRejectValue(pasteValue)) {
                    // Not a boolean
                    var record = grid.getRowRecord(e.row);

                    if (!(0, utils_1.isPromise)(record)) {
                      grid.fireListeners("rejected_paste_values", {
                        detail: [{
                          col: e.col,
                          row: e.row,
                          record: record,
                          define: grid.getColumnDefine(e.col, e.row),
                          pasteValue: pasteValue
                        }]
                      });
                    }

                    return;
                  }

                  if (!(0, utils_2.toBoolean)(pasteValue)) {
                    return;
                  }

                  action({
                    col: e.col,
                    row: e.row
                  });
                })]);
              }
            }, {
              key: "onPasteCellRangeBox",
              value: function onPasteCellRangeBox(grid, cell, value, context) {
                if ((0, action_utils_1.isReadOnlyRecord)(this.readOnly, grid, cell.row) || (0, action_utils_1.isDisabledRecord)(this.disabled, grid, cell.row)) {
                  return;
                }

                var pasteValue = value.trim();

                if (isRejectValue(pasteValue)) {
                  // Not a boolean
                  context.reject();
                  return;
                }

                if (!(0, utils_2.toBoolean)(pasteValue)) {
                  return;
                }

                this._action(grid, {
                  col: cell.col,
                  row: cell.row
                });
              }
            }, {
              key: "onDeleteCellRangeBox",
              value: function onDeleteCellRangeBox() {// noop
              }
            }, {
              key: "_action",
              value: function _action(grid, cell) {
                var _this27 = this;

                var state = grid[RADIO_COLUMN_STATE_ID];
                var range = grid.getCellRange(cell.col, cell.row);
                var cellKey = "".concat(range.start.col, ":").concat(range.start.row);

                if ((0, action_utils_1.isReadOnlyRecord)(this.readOnly, grid, cell.row) || (0, action_utils_1.isDisabledRecord)(this.disabled, grid, cell.row) || state.block[cellKey]) {
                  return;
                }

                grid.doGetCellValue(cell.col, cell.row, function (value) {
                  if ((0, utils_2.toBoolean)(value)) {
                    return;
                  }

                  if (_this27._checkAction) {
                    // User behavior
                    var record = grid.getRowRecord(cell.row);

                    _this27._checkAction(record, (0, utils_1.extend)(cell, {
                      grid: grid
                    }));

                    return;
                  }

                  if (_this27._group) {
                    // Backward compatibility
                    var _state2 = grid[RADIO_COLUMN_STATE_ID];

                    var targets = _this27._group({
                      grid: grid,
                      col: cell.col,
                      row: cell.row
                    });

                    targets.forEach(function (_ref22) {
                      var col = _ref22.col,
                          row = _ref22.row;
                      var range = grid.getCellRange(col, row);
                      var cellKey = "".concat(range.start.col, ":").concat(range.start.row);

                      if ((0, action_utils_1.isReadOnlyRecord)(_this27.readOnly, grid, cell.row) || (0, action_utils_1.isDisabledRecord)(_this27.disabled, grid, cell.row) || _state2.block[cellKey]) {
                        return;
                      }

                      actionCell(grid, col, row, col === cell.col && row === cell.row);
                    });
                    return;
                  } // default behavior


                  var field = grid.getField(cell.col, cell.row);
                  var recordStartRow = grid.getRecordStartRowByRecordIndex(grid.getRecordIndexByRow(cell.row));
                  /** Original DataSource */

                  var dataSource = grid.dataSource.dataSource;
                  var girdRecords = getAllRecordsFromGrid(grid);

                  var _loop3 = function _loop3(index) {
                    var record = dataSource.get(index);
                    var showData = girdRecords.find(function (d) {
                      return d.record === record;
                    });

                    if (showData) {
                      actionCell(grid, cell.col, showData.row, showData.row === recordStartRow);
                    } else {
                      // Hidden record
                      (0, utils_1.then)(dataSource.getField(index, field), function (value) {
                        if (!(0, utils_2.toBoolean)(value)) {
                          return;
                        }

                        dataSource.setField(index, field, (0, action_utils_1.toggleValue)(value));
                      });
                    }
                  };

                  for (var index = 0; index < dataSource.length; index++) {
                    _loop3(index);
                  }
                });
              }
            }]);

            return RadioEditor;
          }(Editor_1.Editor);

          exports.RadioEditor = RadioEditor;

          function getAllRecordsFromGrid(grid) {
            var result = [];
            var rowCount = grid.rowCount,
                recordRowCount = grid.recordRowCount;

            for (var targetRow = grid.frozenRowCount; targetRow < rowCount; targetRow += recordRowCount) {
              var record = grid.getRowRecord(targetRow);
              result.push({
                row: targetRow,
                record: record
              });
            }

            return result;
          }

          function actionCell(grid, col, row, flag) {
            grid.doGetCellValue(col, row, function (value) {
              if ((0, utils_2.toBoolean)(value) === flag) {
                return;
              }

              var state = grid[RADIO_COLUMN_STATE_ID];
              var range = grid.getCellRange(col, row);
              var cellKey = "".concat(range.start.col, ":").concat(range.start.row);
              var ret = grid.doChangeValue(col, row, action_utils_1.toggleValue);

              if (ret) {
                var onChange = function onChange() {
                  // checkbox animation
                  (0, animate_1.animate)(200, function (point) {
                    if (point === 1) {
                      delete state.elapsed[cellKey];
                    } else {
                      state.elapsed[cellKey] = point;
                    }

                    grid.invalidateCellRange(range);
                  });
                };

                if ((0, utils_1.isPromise)(ret)) {
                  state.block[cellKey] = true;
                  ret.then(function () {
                    delete state.block[cellKey];
                    onChange();
                  });
                } else {
                  onChange();
                }
              }
            });
          }

          function isRejectValue(pasteValue) {
            return (0, action_utils_1.toggleValue)((0, action_utils_1.toggleValue)(pasteValue)) !== pasteValue;
          }
          /***/

        },

        /***/
        "./columns/action/SmallDialogInputEditor.js":
        /*!**************************************************!*\
          !*** ./columns/action/SmallDialogInputEditor.js ***!
          \**************************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsActionSmallDialogInputEditorJs(module, exports, __nested_webpack_require_262491__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.SmallDialogInputEditor = void 0;

          var BaseInputEditor_1 = __nested_webpack_require_262491__(
          /*! ./BaseInputEditor */
          "./columns/action/BaseInputEditor.js");

          var SmallDialogInputElement_1 = __nested_webpack_require_262491__(
          /*! ./internal/SmallDialogInputElement */
          "./columns/action/internal/SmallDialogInputElement.js");

          var symbolManager_1 = __nested_webpack_require_262491__(
          /*! ../../internal/symbolManager */
          "./internal/symbolManager.js");

          var utils_1 = __nested_webpack_require_262491__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var _ = (0, symbolManager_1.getSmallDialogInputEditorStateId)();

          function getState(grid) {
            var state = grid[_];

            if (!state) {
              state = {};
              utils_1.obj.setReadonly(grid, _, state);
            }

            return state;
          } // eslint-disable-next-line @typescript-eslint/no-explicit-any


          var globalElement = null;
          var bindGridCount = 0;

          function attachInput(grid, cell, editor, value) {
            var state = getState(grid);

            if (!globalElement) {
              globalElement = new SmallDialogInputElement_1.SmallDialogInputElement();
            }

            if (!state.element) {
              state.element = globalElement;
              bindGridCount++;
              grid.addDisposable({
                dispose: function dispose() {
                  bindGridCount--;

                  if (!bindGridCount) {
                    globalElement === null || globalElement === void 0 ? void 0 : globalElement.dispose();
                    globalElement = null;
                    state.element = null;
                  }
                }
              });
            }

            globalElement.attach(grid, editor, cell.col, cell.row, value);
          }

          function detachInput(gridFocus) {
            if (globalElement) {
              globalElement.detach(gridFocus);
            }
          }

          var SmallDialogInputEditor = /*#__PURE__*/function (_BaseInputEditor_1$Ba2) {
            _inherits(SmallDialogInputEditor, _BaseInputEditor_1$Ba2);

            var _super14 = _createSuper(SmallDialogInputEditor);

            function SmallDialogInputEditor() {
              var _this28;

              var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, SmallDialogInputEditor);

              _this28 = _super14.call(this, option);
              _this28._helperText = option.helperText;
              _this28._inputValidator = option.inputValidator;
              _this28._validator = option.validator;
              _this28._classList = option.classList;
              _this28._type = option.type;
              return _this28;
            }

            _createClass(SmallDialogInputEditor, [{
              key: "dispose",
              value: function dispose() {//noop
              }
            }, {
              key: "classList",
              get: function get() {
                if (!this._classList) {
                  return undefined;
                }

                return Array.isArray(this._classList) ? this._classList : [this._classList];
              },
              set: function set(classList) {
                this._classList = classList;
              }
            }, {
              key: "type",
              get: function get() {
                return this._type;
              },
              set: function set(type) {
                this._type = type;
              }
            }, {
              key: "helperText",
              get: function get() {
                return this._helperText;
              }
            }, {
              key: "inputValidator",
              get: function get() {
                return this._inputValidator;
              }
            }, {
              key: "validator",
              get: function get() {
                return this._validator;
              }
            }, {
              key: "clone",
              value: function clone() {
                return new SmallDialogInputEditor(this);
              }
            }, {
              key: "onInputCellInternal",
              value: function onInputCellInternal(grid, cell, inputValue) {
                attachInput(grid, cell, this, inputValue);
              }
            }, {
              key: "onOpenCellInternal",
              value: function onOpenCellInternal(grid, cell) {
                var _this29 = this;

                grid.doGetCellValue(cell.col, cell.row, function (value) {
                  attachInput(grid, cell, _this29, value);
                });
              }
            }, {
              key: "onChangeSelectCellInternal",
              value: function onChangeSelectCellInternal(_grid, _cell, _selected) {
                // cancel input
                detachInput();
              }
            }, {
              key: "onGridScrollInternal",
              value: function onGridScrollInternal(_grid) {
                // cancel input
                detachInput(true);
              }
            }, {
              key: "onChangeDisabledInternal",
              value: function onChangeDisabledInternal() {
                // cancel input
                detachInput(true);
              }
            }, {
              key: "onChangeReadOnlyInternal",
              value: function onChangeReadOnlyInternal() {
                // cancel input
                detachInput(true);
              }
            }, {
              key: "onSetInputAttrsInternal",
              value: function onSetInputAttrsInternal(grid, _cell, input) {
                SmallDialogInputElement_1.SmallDialogInputElement.setInputAttrs(this, grid, input);
              }
            }]);

            return SmallDialogInputEditor;
          }(BaseInputEditor_1.BaseInputEditor);

          exports.SmallDialogInputEditor = SmallDialogInputEditor;
          /***/
        },

        /***/
        "./columns/action/action-utils.js":
        /*!****************************************!*\
          !*** ./columns/action/action-utils.js ***!
          \****************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsActionActionUtilsJs(module, exports, __nested_webpack_require_269160__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.toggleValue = exports.isReadOnlyRecord = exports.isDisabledRecord = void 0;

          var utils_1 = __nested_webpack_require_269160__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          function isDisabledRecord(option, grid, row) {
            if (grid.disabled) {
              return true;
            }

            return getBooleanOptionOfRecord(option, grid, row);
          }

          exports.isDisabledRecord = isDisabledRecord;

          function isReadOnlyRecord(option, grid, row) {
            if (grid.readOnly) {
              return true;
            }

            return getBooleanOptionOfRecord(option, grid, row);
          }

          exports.isReadOnlyRecord = isReadOnlyRecord;

          function toggleValue(val) {
            if (typeof val === "number") {
              if (val === 0) {
                return 1;
              } else {
                return 0;
              }
            } else if (typeof val === "string") {
              if (val === "false") {
                return "true";
              } else if (val === "off") {
                return "on";
              } else if (/^0+$/.exec(val)) {
                return val.replace(/^(0*)0$/, "$11");
              } else if (val === "true") {
                return "false";
              } else if (val === "on") {
                return "off";
              } else if (/^0*1$/.exec(val)) {
                return val.replace(/^(0*)1$/, "$10");
              }
            }

            return !val;
          }

          exports.toggleValue = toggleValue;

          function getBooleanOptionOfRecord(option, grid, row) {
            if (typeof option === "function") {
              var record = grid.getRowRecord(row);

              if ((0, utils_1.isPromise)(record)) {
                return true;
              }

              return !!option(record);
            }

            return !!option;
          }
          /***/

        },

        /***/
        "./columns/action/actionBind.js":
        /*!**************************************!*\
          !*** ./columns/action/actionBind.js ***!
          \**************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsActionActionBindJs(module, exports, __nested_webpack_require_271691__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.bindCellKeyAction = exports.bindCellClickAction = void 0;

          var utils_1 = __nested_webpack_require_271691__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var DG_EVENT_TYPE_1 = __nested_webpack_require_271691__(
          /*! ../../core/DG_EVENT_TYPE */
          "./core/DG_EVENT_TYPE.js");

          var KEY_ENTER = 13;
          var KEY_SPACE = 32;

          function bindCellClickAction(grid, cellId, _ref23) {
            var action = _ref23.action,
                mouseOver = _ref23.mouseOver,
                mouseOut = _ref23.mouseOut,
                area = _ref23.area;

            function isTarget(col, row) {
              return grid.getLayoutCellId(col, row) === cellId;
            }

            var mouseIsInCell = null;
            var mouseOvered = null;

            function processMouseOver(e) {
              mouseOvered = e;

              if (mouseOver) {
                if (!mouseOver({
                  col: e.col,
                  row: e.row
                })) {
                  return;
                }
              }

              grid.getElement().style.cursor = "pointer";
            }

            function processMouseOut(e) {
              if (mouseOut) {
                mouseOut({
                  col: e.col,
                  row: e.row
                });
              }

              mouseOvered = null;
              grid.getElement().style.cursor = "";
            }

            var disposables = [// click
            grid.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.CLICK_CELL, function (e) {
              if (!isTarget(e.col, e.row)) {
                return;
              }

              if ((0, utils_1.isPromise)(grid.getRowRecord(e.row))) {
                return;
              }

              if (area) {
                if (!area(e)) return;
              }

              action({
                col: e.col,
                row: e.row
              });
            }), // mouse move
            grid.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.MOUSEOVER_CELL, function (e) {
              if (!isTarget(e.col, e.row)) {
                return;
              }

              if ((0, utils_1.isPromise)(grid.getRowRecord(e.row))) {
                return;
              }

              mouseIsInCell = e;

              if (area) {
                if (!area(e)) return;
              }

              processMouseOver(e);
            }), grid.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.MOUSEOUT_CELL, function (e) {
              if (!mouseIsInCell || mouseIsInCell.col !== e.col || mouseIsInCell.row !== e.row) {
                return;
              }

              if (!mouseOvered) {
                processMouseOut(e);
              }
            })];

            if (area) {
              disposables.push(grid.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.MOUSEMOVE_CELL, function (e) {
                if (!mouseIsInCell || mouseIsInCell.col !== e.col || mouseIsInCell.row !== e.row) {
                  return;
                }

                var isInArea = area(e);

                if (!mouseOvered) {
                  if (!isInArea) return; // mouse over

                  processMouseOver(e);
                } else {
                  if (isInArea) return; // mouse out

                  processMouseOut(e);
                }
              }));
            }

            return disposables;
          }

          exports.bindCellClickAction = bindCellClickAction;

          function bindCellKeyAction(grid, cellId, _ref24) {
            var action = _ref24.action,
                _ref24$acceptKeys = _ref24.acceptKeys,
                acceptKeys = _ref24$acceptKeys === void 0 ? [] : _ref24$acceptKeys;

            function isTarget(col, row) {
              return grid.getLayoutCellId(col, row) === cellId;
            }

            acceptKeys = [].concat(_toConsumableArray(acceptKeys), [KEY_ENTER, KEY_SPACE]);
            return [// enter key down
            grid.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.KEYDOWN, function (e) {
              var _a;

              if (acceptKeys.indexOf(e.keyCode) === -1) {
                return;
              }

              if (((_a = grid.keyboardOptions) === null || _a === void 0 ? void 0 : _a.moveCellOnEnter) && e.keyCode === KEY_ENTER) {
                // When moving with the enter key, no action is taken with the enter key.
                return;
              }

              var sel = grid.selection.select;

              if (!isTarget(sel.col, sel.row)) {
                return;
              }

              if ((0, utils_1.isPromise)(grid.getRowRecord(sel.row))) {
                return;
              }

              action({
                col: sel.col,
                row: sel.row
              });
              utils_1.event.cancel(e.event);
            })];
          }

          exports.bindCellKeyAction = bindCellKeyAction;
          /***/
        },

        /***/
        "./columns/action/internal/InlineInputElement.js":
        /*!*******************************************************!*\
          !*** ./columns/action/internal/InlineInputElement.js ***!
          \*******************************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsActionInternalInlineInputElementJs(module, exports, __nested_webpack_require_277266__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.InlineInputElement = void 0;

          var EventHandler_1 = __nested_webpack_require_277266__(
          /*! ../../../internal/EventHandler */
          "./internal/EventHandler.js");

          var dom_1 = __nested_webpack_require_277266__(
          /*! ../../../internal/dom */
          "./internal/dom.js");

          var utils_1 = __nested_webpack_require_277266__(
          /*! ../../../internal/utils */
          "./internal/utils.js");

          var input_value_handler_1 = __nested_webpack_require_277266__(
          /*! ./input-value-handler */
          "./columns/action/internal/input-value-handler.js");

          var KEY_TAB = 9;
          var KEY_ENTER = 13;
          var CLASSNAME = "cheetah-grid__inline-input";

          function createInputElement() {
            __nested_webpack_require_277266__(
            /*! @/columns/action/internal/InlineInputElement.css */
            "../src/js/columns/action/internal/InlineInputElement.css");

            return (0, dom_1.createElement)("input", {
              classList: CLASSNAME
            });
          }

          function _setInputAttrs(editor, _grid, input) {
            var classList = editor.classList,
                type = editor.type;

            if (classList) {
              var _input$classList;

              (_input$classList = input.classList).add.apply(_input$classList, _toConsumableArray(classList));
            }

            input.type = type || "";
          }

          var InlineInputElement = /*#__PURE__*/function () {
            function InlineInputElement() {
              _classCallCheck(this, InlineInputElement);

              this._handler = new EventHandler_1.EventHandler();
              this._input = createInputElement();

              this._bindInputEvents();
            }

            _createClass(InlineInputElement, [{
              key: "dispose",
              value: function dispose() {
                var _a;

                var input = this._input;
                this.detach();

                this._handler.dispose(); // @ts-expect-error -- ignore


                delete this._input;
                this._beforePropEditor = null;
                (_a = input.parentElement) === null || _a === void 0 ? void 0 : _a.removeChild(input);
              }
            }, {
              key: "attach",
              value: function attach(grid, editor, col, row, value) {
                var _this30 = this;

                var input = this._input;
                var handler = this._handler;

                if (this._beforePropEditor) {
                  var classList = this._beforePropEditor.classList;

                  if (classList) {
                    var _input$classList2;

                    (_input$classList2 = input.classList).remove.apply(_input$classList2, _toConsumableArray(classList));
                  }
                }

                input.style.font = grid.font || "16px sans-serif";

                var _grid$getAttachCellsA = grid.getAttachCellsArea(grid.getCellRange(col, row)),
                    element = _grid$getAttachCellsA.element,
                    rect = _grid$getAttachCellsA.rect;

                input.style.top = "".concat(rect.top.toFixed(), "px");
                input.style.left = "".concat(rect.left.toFixed(), "px");
                input.style.width = "".concat(rect.width.toFixed(), "px");
                input.style.height = "".concat(rect.height.toFixed(), "px");
                element.appendChild(input);

                _setInputAttrs(editor, grid, input);

                (0, input_value_handler_1.setInputValue)(input, value);
                this._activeData = {
                  grid: grid,
                  col: col,
                  row: row,
                  editor: editor
                };
                this._beforePropEditor = editor;

                var focus = function focus() {
                  input.focus();
                  var end = input.value.length;

                  try {
                    if (typeof input.selectionStart !== "undefined") {
                      input.selectionStart = end;
                      input.selectionEnd = end;
                      return;
                    }
                  } catch (e) {//ignore
                  } // eslint-disable-next-line @typescript-eslint/no-explicit-any


                  if (document.selection) {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    var range = input.createTextRange();
                    range.collapse();
                    range.moveEnd("character", end);
                    range.moveStart("character", end);
                    range.select();
                  }
                };

                handler.tryWithOffEvents(input, "blur", function () {
                  focus();
                });
                this._attaching = true;
                setTimeout(function () {
                  delete _this30._attaching;
                });
              }
            }, {
              key: "detach",
              value: function detach(gridFocus) {
                if (this._isActive()) {
                  var _this$_activeData = this._activeData,
                      grid = _this$_activeData.grid,
                      col = _this$_activeData.col,
                      row = _this$_activeData.row;
                  var input = this._input;

                  this._handler.tryWithOffEvents(input, "blur", function () {
                    var _a;

                    (_a = input.parentElement) === null || _a === void 0 ? void 0 : _a.removeChild(input);
                  });

                  var range = grid.getCellRange(col, row);
                  grid.invalidateCellRange(range);

                  if (gridFocus) {
                    grid.focus();
                  }
                }

                this._activeData = null;
              }
            }, {
              key: "doChangeValue",
              value: function doChangeValue() {
                if (!this._isActive()) {
                  return;
                }

                var input = this._input;
                var value = input.value;
                var _this$_activeData2 = this._activeData,
                    grid = _this$_activeData2.grid,
                    col = _this$_activeData2.col,
                    row = _this$_activeData2.row;
                grid.doChangeValue(col, row, function () {
                  return value;
                });
              }
            }, {
              key: "_isActive",
              value: function _isActive() {
                var input = this._input;

                if (!input || !input.parentElement) {
                  return false;
                }

                if (!this._activeData) {
                  return false;
                }

                return true;
              }
            }, {
              key: "_bindInputEvents",
              value: function _bindInputEvents() {
                var _this31 = this;

                var handler = this._handler;
                var input = this._input;

                var stopPropagationOnly = function stopPropagationOnly(e) {
                  return e.stopPropagation();
                }; // grid


                handler.on(input, "click", stopPropagationOnly);
                handler.on(input, "mousedown", stopPropagationOnly);
                handler.on(input, "touchstart", stopPropagationOnly);
                handler.on(input, "dblclick", stopPropagationOnly);
                handler.on(input, "compositionstart", function (_e) {
                  input.classList.add("composition");
                });
                handler.on(input, "compositionend", function (_e) {
                  input.classList.remove("composition");
                });
                handler.on(input, "keydown", function (e) {
                  if (input.classList.contains("composition")) {
                    return;
                  }

                  var keyCode = utils_1.event.getKeyCode(e);

                  if (keyCode === KEY_ENTER) {
                    _this31._onKeydownEnter(e);
                  } else if (keyCode === KEY_TAB) {
                    _this31._onKeydownTab(e);
                  }
                });
                handler.on(input, "blur", function (_e) {
                  _this31.doChangeValue();

                  _this31.detach();
                });
              }
            }, {
              key: "_onKeydownEnter",
              value: function _onKeydownEnter(e) {
                var _a;

                if (!this._isActive() || this._attaching) {
                  return;
                }

                var grid = this._activeData.grid;
                this.doChangeValue();
                this.detach(true);
                utils_1.event.cancel(e);

                if ((_a = grid.keyboardOptions) === null || _a === void 0 ? void 0 : _a.moveCellOnEnter) {
                  grid.onKeyDownMove(e);
                }
              }
            }, {
              key: "_onKeydownTab",
              value: function _onKeydownTab(e) {
                var _a;

                if (!this._isActive()) {
                  return;
                }

                var grid = this._activeData.grid;

                if (!((_a = grid.keyboardOptions) === null || _a === void 0 ? void 0 : _a.moveCellOnTab)) {
                  return;
                }

                this.doChangeValue();
                this.detach(true);
                grid.onKeyDownMove(e);
              }
            }], [{
              key: "setInputAttrs",
              value: function setInputAttrs(editor, grid, input) {
                _setInputAttrs(editor, grid, input);
              }
            }]);

            return InlineInputElement;
          }();

          exports.InlineInputElement = InlineInputElement;
          /***/
        },

        /***/
        "./columns/action/internal/InlineMenuElement.js":
        /*!******************************************************!*\
          !*** ./columns/action/internal/InlineMenuElement.js ***!
          \******************************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsActionInternalInlineMenuElementJs(module, exports, __nested_webpack_require_287867__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.InlineMenuElement = void 0;

          var dom_1 = __nested_webpack_require_287867__(
          /*! ../../../internal/dom */
          "./internal/dom.js");

          var EventHandler_1 = __nested_webpack_require_287867__(
          /*! ../../../internal/EventHandler */
          "./internal/EventHandler.js");

          var utils_1 = __nested_webpack_require_287867__(
          /*! ../../../internal/utils */
          "./internal/utils.js");

          var KEY_TAB = 9;
          var KEY_ENTER = 13;
          var KEY_UP = 38;
          var KEY_DOWN = 40;
          var KEY_ESC = 27;
          var CLASSNAME = "cheetah-grid__inline-menu";
          var ITEM_CLASSNAME = "".concat(CLASSNAME, "__menu-item");
          var HIDDEN_CLASSNAME = "".concat(CLASSNAME, "--hidden");
          var SHOWN_CLASSNAME = "".concat(CLASSNAME, "--shown");
          var EMPTY_ITEM_CLASSNAME = "".concat(ITEM_CLASSNAME, "--empty");

          function findItemParents(target) {
            var el = target;

            while (el && !el.classList.contains(ITEM_CLASSNAME)) {
              el = el.parentElement;

              if (!el || el.classList.contains(CLASSNAME)) {
                return null;
              }
            }

            return el;
          }

          function createMenuElement() {
            __nested_webpack_require_287867__(
            /*! @/columns/action/internal/InlineMenuElement.css */
            "../src/js/columns/action/internal/InlineMenuElement.css");

            return (0, dom_1.createElement)("ul", {
              classList: CLASSNAME
            });
          }

          function attachElement(element, rect, menu) {
            menu.style.top = "".concat(rect.top.toFixed(), "px");
            menu.style.left = "".concat(rect.left.toFixed(), "px");
            menu.style.width = "".concat(rect.width.toFixed(), "px");
            menu.style.lineHeight = "".concat(rect.height.toFixed(), "px");
            element.appendChild(menu);
          }

          function optionToLi(_ref25, index) {
            var classList = _ref25.classList,
                label = _ref25.label,
                value = _ref25.value,
                html = _ref25.html;
            var item = (0, dom_1.createElement)("li", {
              classList: ITEM_CLASSNAME
            });
            item.tabIndex = 0;
            item.dataset.valueindex = "".concat(index);

            if (classList) {
              var _item$classList;

              (_item$classList = item.classList).add.apply(_item$classList, _toConsumableArray(Array.isArray(classList) ? classList : [classList]));
            }

            if (label) {
              var span = (0, dom_1.createElement)("span", {
                text: label
              });
              item.appendChild(span);
            } else if (html) {
              (0, dom_1.appendHtml)(item, html);
            }

            if (value === "" || value == null) {
              item.classList.add(EMPTY_ITEM_CLASSNAME);
            }

            return item;
          }

          function openMenu(grid, editor, col, row, value, options, menu) {
            var classList = editor.classList;
            menu.classList.remove(SHOWN_CLASSNAME);
            menu.classList.add(HIDDEN_CLASSNAME);
            (0, dom_1.empty)(menu);
            menu.style.font = grid.font || "16px sans-serif";
            var emptyItemEl = null;
            var valueItemEl = null;
            options.forEach(function (option, i) {
              var item = optionToLi(option, i);
              menu.appendChild(item);

              if (option.value === value) {
                valueItemEl = item;
                item.dataset.select = "select";
              }

              if (item.classList.contains(EMPTY_ITEM_CLASSNAME)) {
                emptyItemEl = item;
              }
            });
            var focusEl = valueItemEl || emptyItemEl || menu.children[0];

            if (classList) {
              var _menu$classList;

              (_menu$classList = menu.classList).add.apply(_menu$classList, _toConsumableArray(classList));
            }

            var children = Array.prototype.slice.call(menu.children, 0);
            var focusIndex = children.indexOf(focusEl);

            var _grid$getAttachCellsA2 = grid.getAttachCellsArea(grid.getCellRange(col, row)),
                element = _grid$getAttachCellsA2.element,
                rect = _grid$getAttachCellsA2.rect; // Cover the right line


            rect.width++; // append for calculation

            attachElement(element, rect, menu); // Make the selection item at the middle

            var offset = 0;

            for (var i = 0; i < focusIndex; i++) {
              var offsetHeight = children[i].offsetHeight;
              offset += offsetHeight;
            }

            rect.offsetTop(-offset);
            menu.style.transformOrigin = "center ".concat(offset + Math.ceil(children[focusIndex].offsetHeight / 2), "px 0px");
            attachElement(element, rect, menu); // Control not to overflow the screen range

            var bkTransform = menu.style.transform;
            var menuClientRect;

            try {
              // To calculate the original position, set `transform` to `none`.
              menu.style.transform = "none";
              menuClientRect = menu.getBoundingClientRect();
            } finally {
              menu.style.transform = bkTransform;
            }

            var orgMenuTop = menuClientRect.top;
            var menuTop = orgMenuTop;
            var winBottom = window.innerHeight;
            var winMargin = 20;

            if (menuClientRect.bottom > winBottom - winMargin) {
              var diff = menuClientRect.bottom - winBottom + winMargin;
              menuTop -= diff;
            }

            if (menuTop < 0
            /*winTop*/
            + winMargin) {
              menuTop = winMargin;
            }

            if (menuTop !== orgMenuTop) {
              rect.offsetTop(-(orgMenuTop - menuTop)); // Sets the center of the menu since it is not possible to determine the exact center of the selected element.

              menu.style.transformOrigin = "center"; // re update

              attachElement(element, rect, menu);
            }

            if (focusEl) {
              focusEl.focus();
            }

            menu.classList.remove(HIDDEN_CLASSNAME);
            menu.classList.add(SHOWN_CLASSNAME);
          }

          function closeMenu(_grid, _col, _row, menu) {
            menu.classList.remove(SHOWN_CLASSNAME);
            menu.classList.add(HIDDEN_CLASSNAME);
            (0, dom_1.disableFocus)(menu);
          }

          var InlineMenuElement = /*#__PURE__*/function () {
            function InlineMenuElement() {
              var _this32 = this;

              _classCallCheck(this, InlineMenuElement);

              var handler = this._handler = new EventHandler_1.EventHandler();
              this._menu = createMenuElement();

              this._bindMenuEvents();

              var bodyClickListenerId;

              var deregisterBodyClickListener = this._deregisterBodyClickListener = function () {
                return handler.off(bodyClickListenerId);
              };

              this._registerBodyClickListener = function () {
                deregisterBodyClickListener();
                bodyClickListenerId = handler.on(document.body, "click", _this32._onBodyClick.bind(_this32), {
                  capture: true
                });
              };
            }

            _createClass(InlineMenuElement, [{
              key: "dispose",
              value: function dispose() {
                var _a;

                var menu = this._menu;
                this.detach();

                this._handler.dispose(); // @ts-expect-error -- ignore


                delete this._menu;
                this._beforePropEditor = null;
                (_a = menu.parentElement) === null || _a === void 0 ? void 0 : _a.removeChild(menu);
              }
            }, {
              key: "attach",
              value: function attach(grid, editor, col, row, value, record) {
                var menu = this._menu;

                if (this._beforePropEditor) {
                  var classList = this._beforePropEditor.classList;

                  if (classList) {
                    var _menu$classList2;

                    (_menu$classList2 = menu.classList).remove.apply(_menu$classList2, _toConsumableArray(classList));
                  }
                }

                var options = editor.options(record);
                openMenu(grid, editor, col, row, value, options, menu);
                this._activeData = {
                  grid: grid,
                  col: col,
                  row: row,
                  editor: editor,
                  options: options
                };
                this._beforePropEditor = editor;

                this._registerBodyClickListener();
              }
            }, {
              key: "detach",
              value: function detach(gridFocus) {
                if (this._isActive()) {
                  var _this$_activeData3 = this._activeData,
                      grid = _this$_activeData3.grid,
                      col = _this$_activeData3.col,
                      row = _this$_activeData3.row;
                  var menu = this._menu;
                  closeMenu(grid, col, row, menu);
                  var range = grid.getCellRange(col, row);
                  grid.invalidateCellRange(range);

                  if (gridFocus) {
                    grid.focus();
                  }
                }

                this._activeData = null;

                this._deregisterBodyClickListener();
              }
            }, {
              key: "_doChangeValue",
              value: function _doChangeValue(valueindex) {
                if (!this._isActive()) {
                  return;
                }

                var _this$_activeData4 = this._activeData,
                    grid = _this$_activeData4.grid,
                    col = _this$_activeData4.col,
                    row = _this$_activeData4.row,
                    options = _this$_activeData4.options;
                var option = options[Number(valueindex)];

                if (option) {
                  var value = option.value;
                  grid.doChangeValue(col, row, function () {
                    return value;
                  });
                }
              }
            }, {
              key: "_isActive",
              value: function _isActive() {
                var menu = this._menu;

                if (!menu || !menu.parentElement) {
                  return false;
                }

                if (!this._activeData) {
                  return false;
                }

                return true;
              }
            }, {
              key: "_bindMenuEvents",
              value: function _bindMenuEvents() {
                var _this33 = this;

                var handler = this._handler;
                var menu = this._menu;

                var stopPropagationOnly = function stopPropagationOnly(e) {
                  return e.stopPropagation();
                }; // grid


                handler.on(menu, "mousedown", stopPropagationOnly);
                handler.on(menu, "touchstart", stopPropagationOnly);
                handler.on(menu, "dblclick", stopPropagationOnly);
                handler.on(menu, "click", function (e) {
                  e.stopPropagation();
                  var item = findItemParents(e.target);

                  if (!item) {
                    return;
                  }

                  var valueindex = item.dataset.valueindex;

                  _this33._doChangeValue(valueindex || "");

                  _this33.detach(true);
                });
                handler.on(menu, "keydown", function (e) {
                  var item = findItemParents(e.target);

                  if (!item) {
                    return;
                  }

                  var keyCode = utils_1.event.getKeyCode(e);

                  if (keyCode === KEY_ENTER) {
                    _this33._onKeydownEnter(menu, item, e);
                  } else if (keyCode === KEY_ESC) {
                    _this33.detach(true);

                    utils_1.event.cancel(e);
                  } else if (keyCode === KEY_UP) {
                    var n = (0, dom_1.findPrevSiblingFocusable)(item);

                    if (n) {
                      n.focus();
                      utils_1.event.cancel(e);
                    }
                  } else if (keyCode === KEY_DOWN) {
                    var _n = (0, dom_1.findNextSiblingFocusable)(item);

                    if (_n) {
                      _n.focus();

                      utils_1.event.cancel(e);
                    }
                  } else if (keyCode === KEY_TAB) {
                    _this33._onKeydownTab(menu, item, e);
                  }
                });
              }
            }, {
              key: "_onBodyClick",
              value: function _onBodyClick(e) {
                var el = e.target;

                if (!el) {
                  return;
                }

                if (this._menu.contains(el)) {
                  return;
                }

                if (this._isActive()) {
                  var grid = this._activeData.grid;

                  if (grid.getElement().contains(el)) {
                    return;
                  }
                }

                this.detach();
              }
            }, {
              key: "_onKeydownEnter",
              value: function _onKeydownEnter(_menu, item, e) {
                var _a;

                var grid = this._isActive() ? this._activeData.grid : null;
                var valueindex = item.dataset.valueindex;

                this._doChangeValue(valueindex || "");

                this.detach(true);
                utils_1.event.cancel(e);

                if (grid) {
                  if ((_a = grid.keyboardOptions) === null || _a === void 0 ? void 0 : _a.moveCellOnEnter) {
                    grid.onKeyDownMove(e);
                  }
                }
              }
            }, {
              key: "_onKeydownTab",
              value: function _onKeydownTab(menu, item, e) {
                var _a;

                if (this._isActive()) {
                  var grid = this._activeData.grid;

                  if ((_a = grid.keyboardOptions) === null || _a === void 0 ? void 0 : _a.moveCellOnTab) {
                    var valueindex = item.dataset.valueindex;

                    this._doChangeValue(valueindex || "");

                    this.detach(true);
                    grid.onKeyDownMove(e);
                    return;
                  }
                }

                if (!e.shiftKey) {
                  if (!(0, dom_1.findNextSiblingFocusable)(item)) {
                    var n = menu.querySelector(".".concat(ITEM_CLASSNAME));

                    if (!(0, dom_1.isFocusable)(n)) {
                      n = (0, dom_1.findNextSiblingFocusable)(n);
                    }

                    if (n) {
                      n.focus();
                      utils_1.event.cancel(e);
                    }
                  }
                } else {
                  if (!(0, dom_1.findPrevSiblingFocusable)(item)) {
                    var items = menu.querySelectorAll(".".concat(ITEM_CLASSNAME));
                    var _n2 = items[items.length - 1];

                    if (!(0, dom_1.isFocusable)(_n2)) {
                      _n2 = (0, dom_1.findPrevSiblingFocusable)(_n2);
                    }

                    if (_n2) {
                      _n2.focus();

                      utils_1.event.cancel(e);
                    }
                  }
                }
              }
            }]);

            return InlineMenuElement;
          }();

          exports.InlineMenuElement = InlineMenuElement;
          /***/
        },

        /***/
        "./columns/action/internal/SmallDialogInputElement.js":
        /*!************************************************************!*\
          !*** ./columns/action/internal/SmallDialogInputElement.js ***!
          \************************************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsActionInternalSmallDialogInputElementJs(module, exports, __nested_webpack_require_304618__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.SmallDialogInputElement = void 0;

          var utils_1 = __nested_webpack_require_304618__(
          /*! ../../../internal/utils */
          "./internal/utils.js");

          var EventHandler_1 = __nested_webpack_require_304618__(
          /*! ../../../internal/EventHandler */
          "./internal/EventHandler.js");

          var dom_1 = __nested_webpack_require_304618__(
          /*! ../../../internal/dom */
          "./internal/dom.js");

          var input_value_handler_1 = __nested_webpack_require_304618__(
          /*! ./input-value-handler */
          "./columns/action/internal/input-value-handler.js");

          var CLASSNAME = "cheetah-grid__small-dialog-input";
          var INPUT_CLASSNAME = "".concat(CLASSNAME, "__input");
          var HIDDEN_CLASSNAME = "".concat(CLASSNAME, "--hidden");
          var SHOWN_CLASSNAME = "".concat(CLASSNAME, "--shown");
          var KEY_ENTER = 13;
          var KEY_ESC = 27;

          function _focus(input, handler) {
            var focus = function focus() {
              input.focus();
              var end = input.value.length;

              try {
                if (typeof input.selectionStart !== "undefined") {
                  input.selectionStart = end;
                  input.selectionEnd = end;
                  return;
                }
              } catch (e) {//ignore
              } // eslint-disable-next-line @typescript-eslint/no-explicit-any


              if (document.selection) {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                var range = input.createTextRange();
                range.collapse();
                range.moveEnd("character", end);
                range.moveStart("character", end);
                range.select();
              }
            };

            handler.tryWithOffEvents(input, "blur", function () {
              focus();
            });
          }

          function createDialogElement() {
            __nested_webpack_require_304618__(
            /*! @/columns/action/internal/SmallDialogInputElement.css */
            "../src/js/columns/action/internal/SmallDialogInputElement.css");

            var element = (0, dom_1.createElement)("div", {
              classList: [CLASSNAME, HIDDEN_CLASSNAME]
            });
            var input = (0, dom_1.createElement)("input", {
              classList: INPUT_CLASSNAME
            });
            input.readOnly = true;
            input.tabIndex = -1;
            element.appendChild(input);
            return element;
          }

          function bindProps(grid, dialog, input, editor) {
            var classList = editor.classList,
                helperText = editor.helperText;

            if (classList) {
              var _dialog$classList;

              (_dialog$classList = dialog.classList).add.apply(_dialog$classList, _toConsumableArray(classList));
            }

            if (helperText && typeof helperText !== "function") {
              dialog.dataset.helperText = helperText;
            }

            _setInputAttrs2(editor, grid, input);
          }

          function unbindProps(_grid, dialog, input, editor) {
            var classList = editor.classList;

            if (classList) {
              var _dialog$classList2;

              (_dialog$classList2 = dialog.classList).remove.apply(_dialog$classList2, _toConsumableArray(classList));
            }

            delete dialog.dataset.helperText;
            input.type = "";
          }

          function _setInputAttrs2(editor, _grid, input) {
            var type = editor.type;
            input.type = type || "";
          }

          var SmallDialogInputElement = /*#__PURE__*/function () {
            function SmallDialogInputElement() {
              _classCallCheck(this, SmallDialogInputElement);

              this._handler = new EventHandler_1.EventHandler();
              this._dialog = createDialogElement();
              this._input = this._dialog.querySelector(".".concat(INPUT_CLASSNAME));

              this._bindDialogEvents();
            }

            _createClass(SmallDialogInputElement, [{
              key: "dispose",
              value: function dispose() {
                var dialog = this._dialog;
                this.detach();

                this._handler.dispose(); // @ts-expect-error -- ignore


                delete this._dialog; // @ts-expect-error -- ignore

                delete this._input;
                this._beforePropEditor = null;

                if (dialog.parentElement) {
                  dialog.parentElement.removeChild(dialog);
                }
              }
            }, {
              key: "attach",
              value: function attach(grid, editor, col, row, value) {
                var _this34 = this;

                var handler = this._handler;
                var dialog = this._dialog;
                var input = this._input;

                if (this._beforePropEditor) {
                  unbindProps(grid, dialog, input, this._beforePropEditor);
                }

                delete dialog.dataset.errorMessage;
                dialog.classList.remove(SHOWN_CLASSNAME);
                dialog.classList.add(HIDDEN_CLASSNAME);
                input.readOnly = true;
                input.tabIndex = 0;

                var _grid$getAttachCellsA3 = grid.getAttachCellsArea(grid.getCellRange(col, row)),
                    element = _grid$getAttachCellsA3.element,
                    rect = _grid$getAttachCellsA3.rect;

                dialog.style.top = "".concat(rect.top.toFixed(), "px");
                dialog.style.left = "".concat(rect.left.toFixed(), "px");
                dialog.style.width = "".concat(rect.width.toFixed(), "px");
                input.style.height = "".concat(rect.height.toFixed(), "px");
                element.appendChild(dialog);
                (0, input_value_handler_1.setInputValue)(input, value);
                input.style.font = grid.font || "16px sans-serif";
                var activeData = {
                  grid: grid,
                  col: col,
                  row: row,
                  editor: editor
                };

                this._onInputValue(input, activeData);

                if (!utils_1.browser.IE) {
                  _focus(input, handler);
                } else {
                  // On the paste-event on IE, since it may not be focused, it will be delayed and focused.
                  setTimeout(function () {
                    return _focus(input, handler);
                  });
                }

                dialog.classList.add(SHOWN_CLASSNAME);
                dialog.classList.remove(HIDDEN_CLASSNAME);
                input.readOnly = false;
                bindProps(grid, dialog, input, editor);
                this._activeData = activeData;
                this._beforePropEditor = editor;
                this._attaching = true;
                setTimeout(function () {
                  delete _this34._attaching;
                });
              }
            }, {
              key: "detach",
              value: function detach(gridFocus) {
                if (this._isActive()) {
                  var dialog = this._dialog;
                  var input = this._input;
                  dialog.classList.remove(SHOWN_CLASSNAME);
                  dialog.classList.add(HIDDEN_CLASSNAME);
                  input.readOnly = true;
                  input.tabIndex = -1;
                  var _this$_activeData5 = this._activeData,
                      grid = _this$_activeData5.grid,
                      col = _this$_activeData5.col,
                      row = _this$_activeData5.row;
                  var range = grid.getCellRange(col, row);
                  grid.invalidateCellRange(range);

                  if (gridFocus) {
                    grid.focus();
                  }
                }

                this._activeData = null;
                this._beforeValue = null;
              }
            }, {
              key: "_doChangeValue",
              value: function _doChangeValue() {
                var _this35 = this;

                if (!this._isActive()) {
                  return false;
                }

                var input = this._input;
                var value = input.value;
                return (0, utils_1.then)(this._validate(value), function (res) {
                  if (res && value === input.value) {
                    var _this35$_activeData = _this35._activeData,
                        grid = _this35$_activeData.grid,
                        col = _this35$_activeData.col,
                        row = _this35$_activeData.row;
                    grid.doChangeValue(col, row, function () {
                      return value;
                    });
                    return true;
                  }

                  return false;
                });
              }
            }, {
              key: "_isActive",
              value: function _isActive() {
                var dialog = this._dialog;

                if (!dialog || !dialog.parentElement) {
                  return false;
                }

                if (!this._activeData) {
                  return false;
                }

                return true;
              }
            }, {
              key: "_bindDialogEvents",
              value: function _bindDialogEvents() {
                var _this36 = this;

                var handler = this._handler;
                var dialog = this._dialog;
                var input = this._input;

                var stopPropagationOnly = function stopPropagationOnly(e) {
                  return e.stopPropagation();
                }; // grid


                handler.on(dialog, "click", stopPropagationOnly);
                handler.on(dialog, "dblclick", stopPropagationOnly);
                handler.on(dialog, "mousedown", stopPropagationOnly);
                handler.on(dialog, "touchstart", stopPropagationOnly);
                handler.on(input, "compositionstart", function (_e) {
                  input.classList.add("composition");
                });
                handler.on(input, "compositionend", function (_e) {
                  input.classList.remove("composition");

                  _this36._onInputValue(input);
                });

                var onKeyupAndPress = function onKeyupAndPress(_e) {
                  if (input.classList.contains("composition")) {
                    return;
                  }

                  _this36._onInputValue(input);
                };

                handler.on(input, "keyup", onKeyupAndPress);
                handler.on(input, "keypress", onKeyupAndPress);
                handler.on(input, "keydown", function (e) {
                  if (input.classList.contains("composition")) {
                    return;
                  }

                  var keyCode = utils_1.event.getKeyCode(e);

                  if (keyCode === KEY_ESC) {
                    _this36.detach(true);

                    utils_1.event.cancel(e);
                  } else if (keyCode === KEY_ENTER) {
                    _this36._onKeydownEnter(e);
                  } else {
                    _this36._onInputValue(input);
                  }
                });
              }
            }, {
              key: "_onKeydownEnter",
              value: function _onKeydownEnter(e) {
                var _this37 = this;

                if (this._attaching) {
                  return;
                }

                var input = this._input;
                var value = input.value;
                (0, utils_1.then)(this._doChangeValue(), function (r) {
                  var _a;

                  if (r && value === input.value) {
                    var grid = _this37._isActive() ? _this37._activeData.grid : null;

                    _this37.detach(true);

                    if ((_a = grid === null || grid === void 0 ? void 0 : grid.keyboardOptions) === null || _a === void 0 ? void 0 : _a.moveCellOnEnter) {
                      grid.onKeyDownMove(e);
                    }
                  }
                });
                utils_1.event.cancel(e);
              }
            }, {
              key: "_onInputValue",
              value: function _onInputValue(input, activeData) {
                var before = this._beforeValue;
                var value = input.value;

                if (before !== value) {
                  this._onInputValueChange(value, activeData);
                }

                this._beforeValue = value;
              }
            }, {
              key: "_onInputValueChange",
              value: function _onInputValueChange(after, activeData) {
                activeData = activeData || this._activeData;
                var dialog = this._dialog;
                var _activeData = activeData,
                    grid = _activeData.grid,
                    col = _activeData.col,
                    row = _activeData.row,
                    editor = _activeData.editor;

                if (typeof editor.helperText === "function") {
                  var helperText = editor.helperText(after, {
                    grid: grid,
                    col: col,
                    row: row
                  });

                  if (helperText) {
                    dialog.dataset.helperText = helperText;
                  } else {
                    delete dialog.dataset.helperText;
                  }
                }

                if ("errorMessage" in dialog.dataset) {
                  this._validate(after, true);
                }
              }
            }, {
              key: "_validate",
              value: function _validate(value, inputOnly) {
                var dialog = this._dialog;
                var input = this._input;
                var _this$_activeData6 = this._activeData,
                    grid = _this$_activeData6.grid,
                    col = _this$_activeData6.col,
                    row = _this$_activeData6.row,
                    editor = _this$_activeData6.editor;
                var message = "";

                if (editor.inputValidator) {
                  message = editor.inputValidator(value, {
                    grid: grid,
                    col: col,
                    row: row
                  });
                }

                return (0, utils_1.then)(message, function (message) {
                  if (!message && editor.validator && !inputOnly) {
                    message = editor.validator(value, {
                      grid: grid,
                      col: col,
                      row: row
                    });
                  }

                  return (0, utils_1.then)(message, function (message) {
                    if (message && value === input.value) {
                      dialog.dataset.errorMessage = message;
                    } else {
                      delete dialog.dataset.errorMessage;
                    }

                    return !message;
                  });
                });
              }
            }], [{
              key: "setInputAttrs",
              value: function setInputAttrs(editor, grid, input) {
                _setInputAttrs2(editor, grid, input);
              }
            }]);

            return SmallDialogInputElement;
          }();

          exports.SmallDialogInputElement = SmallDialogInputElement;
          /***/
        },

        /***/
        "./columns/action/internal/input-value-handler.js":
        /*!********************************************************!*\
          !*** ./columns/action/internal/input-value-handler.js ***!
          \********************************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsActionInternalInputValueHandlerJs(module, exports, __nested_webpack_require_320778__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.setInputValue = void 0;

          var EventHandler_1 = __nested_webpack_require_320778__(
          /*! ../../../internal/EventHandler */
          "./internal/EventHandler.js");

          function setInputValue(input, value) {
            var sign = input.type === "number" && value === "-";

            if (sign) {
              // When `type="number"`, the minus sign is not accepted, so change it to `type="text"` once.
              input.type = "";
              var handler = new EventHandler_1.EventHandler();

              var dispose = function dispose() {
                if (handler) {
                  handler.dispose();
                  handler = null;
                }
              };

              handler.once(input, "input", function (_e) {
                input.type = "number";
                dispose();
              });
              handler.once(input, "blur", function (_e) {
                dispose();
              });
            }

            input.value = value !== null && value !== void 0 ? value : "";
          }

          exports.setInputValue = setInputValue;
          /***/
        },

        /***/
        "./columns/indicator/handlers.js":
        /*!***************************************!*\
          !*** ./columns/indicator/handlers.js ***!
          \***************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsIndicatorHandlersJs(module, exports, __nested_webpack_require_322471__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.getDrawIndicator = void 0;

          var triangle_1 = __nested_webpack_require_322471__(
          /*! ./triangle */
          "./columns/indicator/triangle.js");

          function getDrawIndicator(indicatorStyle) {
            var style = indicatorStyle.style;

            if (style === "triangle") {
              return triangle_1.drawTriangleIndicator;
            }

            return null;
          }

          exports.getDrawIndicator = getDrawIndicator;
          /***/
        },

        /***/
        "./columns/indicator/triangle.js":
        /*!***************************************!*\
          !*** ./columns/indicator/triangle.js ***!
          \***************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsIndicatorTriangleJs(module, exports, __webpack_require__) {
          "use strict";

          var _KIND_PROCESS_MAP;

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.drawTriangleIndicator = void 0;
          var KIND_PROCESS_MAP = (_KIND_PROCESS_MAP = {}, _defineProperty(_KIND_PROCESS_MAP, 0
          /* DrawIndicatorKind.topLeft */
          , {
            themeColor: function themeColor(helper) {
              return helper.theme.indicators.topLeftColor;
            },
            themeSize: function themeSize(helper) {
              return helper.theme.indicators.topLeftSize;
            },
            drawPath: function drawPath(ctx, rect, size) {
              var baseLeft = rect.left + 1;
              var baseTop = rect.top + 1;
              ctx.moveTo(baseLeft, baseTop);
              ctx.lineTo(baseLeft + size, baseTop);
              ctx.lineTo(baseLeft, baseTop + size);
            }
          }), _defineProperty(_KIND_PROCESS_MAP, 1
          /* DrawIndicatorKind.topRight */
          , {
            themeColor: function themeColor(helper) {
              return helper.theme.indicators.topRightColor;
            },
            themeSize: function themeSize(helper) {
              return helper.theme.indicators.topRightSize;
            },
            drawPath: function drawPath(ctx, rect, size) {
              var baseRight = rect.right - 2;
              var baseTop = rect.top + 1;
              ctx.moveTo(baseRight, baseTop);
              ctx.lineTo(baseRight - size, baseTop);
              ctx.lineTo(baseRight, baseTop + size);
            }
          }), _defineProperty(_KIND_PROCESS_MAP, 2
          /* DrawIndicatorKind.bottomRight */
          , {
            themeColor: function themeColor(helper) {
              return helper.theme.indicators.bottomRightColor;
            },
            themeSize: function themeSize(helper) {
              return helper.theme.indicators.bottomRightSize;
            },
            drawPath: function drawPath(ctx, rect, size) {
              var baseRight = rect.right - 2;
              var baseBottom = rect.bottom - 2;
              ctx.moveTo(baseRight, baseBottom);
              ctx.lineTo(baseRight - size, baseBottom);
              ctx.lineTo(baseRight, baseBottom - size);
            }
          }), _defineProperty(_KIND_PROCESS_MAP, 3
          /* DrawIndicatorKind.bottomLeft */
          , {
            themeColor: function themeColor(helper) {
              return helper.theme.indicators.bottomLeftColor;
            },
            themeSize: function themeSize(helper) {
              return helper.theme.indicators.bottomLeftSize;
            },
            drawPath: function drawPath(ctx, rect, size) {
              var baseLeft = rect.left + 1;
              var baseBottom = rect.bottom - 2;
              ctx.moveTo(baseLeft, baseBottom);
              ctx.lineTo(baseLeft + size, baseBottom);
              ctx.lineTo(baseLeft, baseBottom - size);
            }
          }), _KIND_PROCESS_MAP);

          function drawTriangleIndicator(context, style, kind, helper) {
            var process = KIND_PROCESS_MAP[kind];

            if (!process) {
              return;
            }

            helper.drawBorderWithClip(context, function (ctx) {
              var rect = context.getRect();
              var color = style.color || helper.getColor(process.themeColor(helper), context.col, context.row, ctx);
              var size = style.size && Number(style.size) || process.themeSize(helper) || rect.height / 6; // draw triangle

              ctx.fillStyle = color;
              ctx.beginPath();
              process.drawPath(ctx, rect, size);
              ctx.closePath();
              ctx.fill();
            });
          }

          exports.drawTriangleIndicator = drawTriangleIndicator;
          /***/
        },

        /***/
        "./columns/message/BaseMessage.js":
        /*!****************************************!*\
          !*** ./columns/message/BaseMessage.js ***!
          \****************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsMessageBaseMessageJs(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.BaseMessage = void 0;

          var BaseMessage = /*#__PURE__*/function () {
            function BaseMessage(grid) {
              _classCallCheck(this, BaseMessage);

              this._messageElement = null;
              this._grid = grid;
            }

            _createClass(BaseMessage, [{
              key: "dispose",
              value: function dispose() {
                this.detachMessageElement();

                if (this._messageElement) {
                  this._messageElement.dispose();
                }

                this._messageElement = null;
              }
            }, {
              key: "_getMessageElement",
              value: function _getMessageElement() {
                return this._messageElement || (this._messageElement = this.createMessageElementInternal());
              }
            }, {
              key: "attachMessageElement",
              value: function attachMessageElement(col, row, message) {
                var messageElement = this._getMessageElement();

                messageElement.attach(this._grid, col, row, message);
              }
            }, {
              key: "moveMessageElement",
              value: function moveMessageElement(col, row) {
                var messageElement = this._getMessageElement();

                messageElement.move(this._grid, col, row);
              }
            }, {
              key: "detachMessageElement",
              value: function detachMessageElement() {
                var messageElement = this._getMessageElement();

                messageElement._detach();
              }
            }, {
              key: "drawCellMessage",
              value: function drawCellMessage(message, context, style, helper, grid, info) {
                this.drawCellMessageInternal(message, context, style, helper, grid, info);
              }
            }]);

            return BaseMessage;
          }();

          exports.BaseMessage = BaseMessage;
          /***/
        },

        /***/
        "./columns/message/ErrorMessage.js":
        /*!*****************************************!*\
          !*** ./columns/message/ErrorMessage.js ***!
          \*****************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsMessageErrorMessageJs(module, exports, __nested_webpack_require_330405__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.ErrorMessage = void 0;

          var messageUtils = __importStar(__nested_webpack_require_330405__(
          /*! ./messageUtils */
          "./columns/message/messageUtils.js"));

          var BaseMessage_1 = __nested_webpack_require_330405__(
          /*! ./BaseMessage */
          "./columns/message/BaseMessage.js");

          var ErrorMessageElement_1 = __nested_webpack_require_330405__(
          /*! ./internal/ErrorMessageElement */
          "./columns/message/internal/ErrorMessageElement.js");

          var utils_1 = __nested_webpack_require_330405__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var RED_A100 = "#ff8a80";

          var ErrorMessage = /*#__PURE__*/function (_BaseMessage_1$BaseMe) {
            _inherits(ErrorMessage, _BaseMessage_1$BaseMe);

            var _super15 = _createSuper(ErrorMessage);

            function ErrorMessage() {
              _classCallCheck(this, ErrorMessage);

              return _super15.apply(this, arguments);
            }

            _createClass(ErrorMessage, [{
              key: "createMessageElementInternal",
              value: function createMessageElementInternal() {
                return new ErrorMessageElement_1.ErrorMessageElement();
              }
            }, {
              key: "drawCellMessageInternal",
              value: function drawCellMessageInternal(_message, context, style, helper, grid, _info) {
                var bgColor = style.bgColor;

                var _context$getSelection = context.getSelection(),
                    select = _context$getSelection.select;

                if (!(0, utils_1.cellInRange)(grid.getCellRange(context.col, context.row), select.col, select.row) || !grid.hasFocusGrid()) {
                  helper.drawBorderWithClip(context, function (ctx) {
                    messageUtils.drawExclamationMarkBox(context, {
                      bgColor: helper.getColor(helper.theme.messages.errorBgColor, context.col, context.row, ctx) || RED_A100,
                      color: bgColor,
                      boxWidth: helper.theme.messages.boxWidth,
                      markHeight: helper.theme.messages.markHeight
                    }, helper);
                  });
                }
              }
            }]);

            return ErrorMessage;
          }(BaseMessage_1.BaseMessage);

          exports.ErrorMessage = ErrorMessage;
          /***/
        },

        /***/
        "./columns/message/InfoMessage.js":
        /*!****************************************!*\
          !*** ./columns/message/InfoMessage.js ***!
          \****************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsMessageInfoMessageJs(module, exports, __nested_webpack_require_334755__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.InfoMessage = void 0;

          var messageUtils = __importStar(__nested_webpack_require_334755__(
          /*! ./messageUtils */
          "./columns/message/messageUtils.js"));

          var BaseMessage_1 = __nested_webpack_require_334755__(
          /*! ./BaseMessage */
          "./columns/message/BaseMessage.js");

          var MessageElement_1 = __nested_webpack_require_334755__(
          /*! ./internal/MessageElement */
          "./columns/message/internal/MessageElement.js");

          var utils_1 = __nested_webpack_require_334755__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var GREY_L2 = "#e0e0e0";

          var InfoMessage = /*#__PURE__*/function (_BaseMessage_1$BaseMe2) {
            _inherits(InfoMessage, _BaseMessage_1$BaseMe2);

            var _super16 = _createSuper(InfoMessage);

            function InfoMessage() {
              _classCallCheck(this, InfoMessage);

              return _super16.apply(this, arguments);
            }

            _createClass(InfoMessage, [{
              key: "createMessageElementInternal",
              value: function createMessageElementInternal() {
                return new MessageElement_1.MessageElement();
              }
            }, {
              key: "drawCellMessageInternal",
              value: function drawCellMessageInternal(_message, context, style, helper, grid, _info) {
                var bgColor = style.bgColor;

                var _context$getSelection2 = context.getSelection(),
                    select = _context$getSelection2.select;

                if (!(0, utils_1.cellInRange)(grid.getCellRange(context.col, context.row), select.col, select.row) || !grid.hasFocusGrid()) {
                  helper.drawBorderWithClip(context, function (ctx) {
                    messageUtils.drawInformationMarkBox(context, {
                      bgColor: helper.getColor(helper.theme.messages.infoBgColor, context.col, context.row, ctx) || GREY_L2,
                      color: bgColor,
                      boxWidth: helper.theme.messages.boxWidth,
                      markHeight: helper.theme.messages.markHeight
                    }, helper);
                  });
                }
              }
            }]);

            return InfoMessage;
          }(BaseMessage_1.BaseMessage);

          exports.InfoMessage = InfoMessage;
          /***/
        },

        /***/
        "./columns/message/MessageHandler.js":
        /*!*******************************************!*\
          !*** ./columns/message/MessageHandler.js ***!
          \*******************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsMessageMessageHandlerJs(module, exports, __nested_webpack_require_339086__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.MessageHandler = exports.hasMessage = void 0;

          var ErrorMessage_1 = __nested_webpack_require_339086__(
          /*! ./ErrorMessage */
          "./columns/message/ErrorMessage.js");

          var InfoMessage_1 = __nested_webpack_require_339086__(
          /*! ./InfoMessage */
          "./columns/message/InfoMessage.js");

          var LG_EVENT_TYPE_1 = __nested_webpack_require_339086__(
          /*! ../../list-grid/LG_EVENT_TYPE */
          "./list-grid/LG_EVENT_TYPE.js");

          var WarningMessage_1 = __nested_webpack_require_339086__(
          /*! ./WarningMessage */
          "./columns/message/WarningMessage.js");

          var utils_1 = __nested_webpack_require_339086__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var EMPTY_MESSAGE = {
            type: "error",
            message: null
          };
          var MESSAGE_INSTANCE_FACTORY = {
            error: function error(grid) {
              return new ErrorMessage_1.ErrorMessage(grid);
            },
            info: function info(grid) {
              return new InfoMessage_1.InfoMessage(grid);
            },
            warning: function warning(grid) {
              return new WarningMessage_1.WarningMessage(grid);
            }
          };

          function normalizeMessage(message) {
            if (!message || (0, utils_1.isPromise)(message)) {
              return EMPTY_MESSAGE;
            }

            if (typeof message === "string") {
              return {
                type: "error",
                message: message,
                original: message
              };
            }

            var type = message.type || "error";

            if (type && type in MESSAGE_INSTANCE_FACTORY) {
              return {
                type: type.toLowerCase(),
                message: message.message,
                original: message
              };
            }

            return {
              type: "error",
              // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
              message: "".concat(message),
              original: message
            };
          }

          function hasMessage(message) {
            return !!normalizeMessage(message).message;
          }

          exports.hasMessage = hasMessage;

          var MessageHandler = /*#__PURE__*/function () {
            function MessageHandler(grid, getMessage) {
              _classCallCheck(this, MessageHandler);

              this._attachInfo = null;
              this._grid = grid;
              this._messageInstances = {};

              this._bindGridEvent(grid, getMessage);
            }

            _createClass(MessageHandler, [{
              key: "dispose",
              value: function dispose() {
                var _a;

                var messageInstances = this._messageInstances;

                for (var k in messageInstances) {
                  (_a = messageInstances[k]) === null || _a === void 0 ? void 0 : _a.dispose();
                } // @ts-expect-error -- ignore


                delete this._messageInstances; // @ts-expect-error -- ignore

                delete this._attachInfo;
              }
            }, {
              key: "drawCellMessage",
              value: function drawCellMessage(message, context, style, helper, grid, info) {
                if (!hasMessage(message)) {
                  return;
                }

                var instance = this._getMessageInstanceOfMessage(message);

                instance.drawCellMessage(normalizeMessage(message), context, style, helper, grid, info);
              }
            }, {
              key: "_attach",
              value: function _attach(col, row, message) {
                var info = this._attachInfo;

                var instance = this._getMessageInstanceOfMessage(message);

                if (info && info.instance !== instance) {
                  info.instance.detachMessageElement();
                }

                instance.attachMessageElement(col, row, normalizeMessage(message));
                this._attachInfo = {
                  col: col,
                  row: row,
                  instance: instance
                };
              }
            }, {
              key: "_move",
              value: function _move(col, row) {
                var info = this._attachInfo;

                if (!info || info.col !== col || info.row !== row) {
                  return;
                }

                var instance = info.instance;
                instance.moveMessageElement(col, row);
              }
            }, {
              key: "_detach",
              value: function _detach() {
                var info = this._attachInfo;

                if (!info) {
                  return;
                }

                var instance = info.instance;
                instance.detachMessageElement();
                this._attachInfo = null;
              }
            }, {
              key: "_bindGridEvent",
              value: function _bindGridEvent(grid, getMessage) {
                var _this38 = this;

                var onSelectMessage = function onSelectMessage(sel) {
                  var setMessageData = function setMessageData(msg) {
                    if (!hasMessage(msg)) {
                      _this38._detach();
                    } else {
                      _this38._attach(sel.col, sel.row, msg);
                    }
                  };

                  var message = getMessage(sel.col, sel.row);

                  if ((0, utils_1.isPromise)(message)) {
                    _this38._detach();

                    message.then(function (msg) {
                      var newSel = grid.selection.select;

                      if (newSel.col !== sel.col || newSel.row !== sel.row) {
                        return;
                      }

                      setMessageData(msg);
                    });
                    return;
                  }

                  setMessageData(message);
                };

                grid.listen(LG_EVENT_TYPE_1.LG_EVENT_TYPE.SELECTED_CELL, function (e) {
                  if (!e.selected) {
                    return;
                  }

                  if (e.before.col === e.col && e.before.row === e.row) {
                    return;
                  }

                  onSelectMessage(e);
                });
                grid.listen(LG_EVENT_TYPE_1.LG_EVENT_TYPE.SCROLL, function () {
                  var sel = grid.selection.select;

                  _this38._move(sel.col, sel.row);
                });
                grid.listen(LG_EVENT_TYPE_1.LG_EVENT_TYPE.CHANGED_VALUE, function (e) {
                  if (!grid.hasFocusGrid()) {
                    return;
                  }

                  var sel = grid.selection.select;

                  if (sel.col !== e.col || sel.row !== e.row) {
                    return;
                  }

                  onSelectMessage(e);
                });
                grid.listen(LG_EVENT_TYPE_1.LG_EVENT_TYPE.FOCUS_GRID, function (_e) {
                  var sel = grid.selection.select;
                  onSelectMessage(sel);
                });
                grid.listen(LG_EVENT_TYPE_1.LG_EVENT_TYPE.BLUR_GRID, function (_e) {
                  _this38._detach();
                });
              }
            }, {
              key: "_getMessageInstanceOfMessage",
              value: function _getMessageInstanceOfMessage(message) {
                var messageInstances = this._messageInstances;

                var _normalizeMessage = normalizeMessage(message),
                    type = _normalizeMessage.type;

                return messageInstances[type] || (messageInstances[type] = MESSAGE_INSTANCE_FACTORY[type](this._grid));
              }
            }]);

            return MessageHandler;
          }();

          exports.MessageHandler = MessageHandler;
          /***/
        },

        /***/
        "./columns/message/WarningMessage.js":
        /*!*******************************************!*\
          !*** ./columns/message/WarningMessage.js ***!
          \*******************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsMessageWarningMessageJs(module, exports, __nested_webpack_require_347626__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.WarningMessage = void 0;

          var messageUtils = __importStar(__nested_webpack_require_347626__(
          /*! ./messageUtils */
          "./columns/message/messageUtils.js"));

          var BaseMessage_1 = __nested_webpack_require_347626__(
          /*! ./BaseMessage */
          "./columns/message/BaseMessage.js");

          var WarningMessageElement_1 = __nested_webpack_require_347626__(
          /*! ./internal/WarningMessageElement */
          "./columns/message/internal/WarningMessageElement.js");

          var utils_1 = __nested_webpack_require_347626__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var DEEP_ORANGE_A100 = "#ff9e80";

          var WarningMessage = /*#__PURE__*/function (_BaseMessage_1$BaseMe3) {
            _inherits(WarningMessage, _BaseMessage_1$BaseMe3);

            var _super17 = _createSuper(WarningMessage);

            function WarningMessage() {
              _classCallCheck(this, WarningMessage);

              return _super17.apply(this, arguments);
            }

            _createClass(WarningMessage, [{
              key: "createMessageElementInternal",
              value: function createMessageElementInternal() {
                return new WarningMessageElement_1.WarningMessageElement();
              }
            }, {
              key: "drawCellMessageInternal",
              value: function drawCellMessageInternal(_message, context, style, helper, grid, _info) {
                var bgColor = style.bgColor;

                var _context$getSelection3 = context.getSelection(),
                    select = _context$getSelection3.select;

                if (!(0, utils_1.cellInRange)(grid.getCellRange(context.col, context.row), select.col, select.row) || !grid.hasFocusGrid()) {
                  helper.drawBorderWithClip(context, function (ctx) {
                    messageUtils.drawExclamationMarkBox(context, {
                      bgColor: helper.getColor(helper.theme.messages.warnBgColor, context.col, context.row, ctx) || DEEP_ORANGE_A100,
                      color: bgColor,
                      boxWidth: helper.theme.messages.boxWidth,
                      markHeight: helper.theme.messages.markHeight
                    }, helper);
                  });
                }
              }
            }]);

            return WarningMessage;
          }(BaseMessage_1.BaseMessage);

          exports.WarningMessage = WarningMessage;
          /***/
        },

        /***/
        "./columns/message/internal/ErrorMessageElement.js":
        /*!*********************************************************!*\
          !*** ./columns/message/internal/ErrorMessageElement.js ***!
          \*********************************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsMessageInternalErrorMessageElementJs(module, exports, __nested_webpack_require_352109__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.ErrorMessageElement = void 0;

          var MessageElement_1 = __nested_webpack_require_352109__(
          /*! ./MessageElement */
          "./columns/message/internal/MessageElement.js");

          var CLASSNAME = "cheetah-grid__error-message-element";
          var MESSAGE_CLASSNAME = "".concat(CLASSNAME, "__message");

          var ErrorMessageElement = /*#__PURE__*/function (_MessageElement_1$Mes) {
            _inherits(ErrorMessageElement, _MessageElement_1$Mes);

            var _super18 = _createSuper(ErrorMessageElement);

            function ErrorMessageElement() {
              var _this39;

              _classCallCheck(this, ErrorMessageElement);

              _this39 = _super18.call(this);

              __nested_webpack_require_352109__(
              /*! @/columns/message/internal/ErrorMessageElement.css */
              "../src/js/columns/message/internal/ErrorMessageElement.css");

              _this39._rootElement.classList.add(CLASSNAME);

              _this39._messageElement.classList.add(MESSAGE_CLASSNAME);

              return _this39;
            }

            return ErrorMessageElement;
          }(MessageElement_1.MessageElement);

          exports.ErrorMessageElement = ErrorMessageElement;
          /***/
        },

        /***/
        "./columns/message/internal/MessageElement.js":
        /*!****************************************************!*\
          !*** ./columns/message/internal/MessageElement.js ***!
          \****************************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsMessageInternalMessageElementJs(module, exports, __nested_webpack_require_353993__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.MessageElement = void 0;

          var EventHandler_1 = __nested_webpack_require_353993__(
          /*! ../../../internal/EventHandler */
          "./internal/EventHandler.js");

          var dom_1 = __nested_webpack_require_353993__(
          /*! ../../../internal/dom */
          "./internal/dom.js");

          var CLASSNAME = "cheetah-grid__message-element";
          var MESSAGE_CLASSNAME = "".concat(CLASSNAME, "__message");
          var HIDDEN_CLASSNAME = "".concat(CLASSNAME, "--hidden");
          var SHOWN_CLASSNAME = "".concat(CLASSNAME, "--shown");
          var LEFT_DIFF_CSS_PROP_NAME = "--cheetah-grid-message-element-left-diff";

          function createMessageDomElement() {
            __nested_webpack_require_353993__(
            /*! @/columns/message/internal/MessageElement.css */
            "../src/js/columns/message/internal/MessageElement.css");

            var rootElement = (0, dom_1.createElement)("div", {
              classList: [CLASSNAME, HIDDEN_CLASSNAME]
            });
            var messageElement = (0, dom_1.createElement)("span", {
              classList: [MESSAGE_CLASSNAME]
            });
            rootElement.appendChild(messageElement);
            return rootElement;
          }

          var MessageElement = /*#__PURE__*/function () {
            function MessageElement() {
              _classCallCheck(this, MessageElement);

              this._handler = new EventHandler_1.EventHandler();
              var rootElement = this._rootElement = createMessageDomElement();
              this._messageElement = rootElement.querySelector(".".concat(MESSAGE_CLASSNAME));
            }

            _createClass(MessageElement, [{
              key: "dispose",
              value: function dispose() {
                this.detach();

                this._handler.dispose(); // @ts-expect-error -- ignore


                delete this._rootElement; // @ts-expect-error -- ignore

                delete this._messageElement;
              }
            }, {
              key: "attach",
              value: function attach(grid, col, row, message) {
                var rootElement = this._rootElement;
                var messageElement = this._messageElement;
                rootElement.classList.remove(SHOWN_CLASSNAME);
                rootElement.classList.add(HIDDEN_CLASSNAME);

                if (this._attachCell(grid, col, row)) {
                  rootElement.classList.add(SHOWN_CLASSNAME);
                  rootElement.classList.remove(HIDDEN_CLASSNAME);
                  messageElement.textContent = message.message;

                  this._adjustStyle(grid, col, row);
                } else {
                  this._detach();
                }
              }
            }, {
              key: "move",
              value: function move(grid, col, row) {
                var rootElement = this._rootElement;

                if (this._attachCell(grid, col, row)) {
                  rootElement.classList.add(SHOWN_CLASSNAME);
                  rootElement.classList.remove(HIDDEN_CLASSNAME);
                } else {
                  this._detach();
                }
              }
            }, {
              key: "detach",
              value: function detach() {
                this._detach();
              }
            }, {
              key: "_detach",
              value: function _detach() {
                var rootElement = this._rootElement;

                if (rootElement.parentElement) {
                  rootElement.parentElement.removeChild(rootElement);
                  rootElement.classList.remove(SHOWN_CLASSNAME);
                  rootElement.classList.add(HIDDEN_CLASSNAME);
                }
              }
            }, {
              key: "_attachCell",
              value: function _attachCell(grid, col, row) {
                var rootElement = this._rootElement;

                var _grid$getAttachCellsA4 = grid.getAttachCellsArea(grid.getCellRange(col, row)),
                    element = _grid$getAttachCellsA4.element,
                    rect = _grid$getAttachCellsA4.rect;

                var top = rect.bottom,
                    left = rect.left,
                    width = rect.width;
                var frozenRowCount = grid.frozenRowCount,
                    frozenColCount = grid.frozenColCount;

                if (row >= frozenRowCount && frozenRowCount > 0) {
                  var _grid$getAttachCellsA5 = grid.getAttachCellsArea(grid.getCellRange(col, frozenRowCount - 1)),
                      frozenRect = _grid$getAttachCellsA5.rect;

                  if (top < frozenRect.bottom) {
                    return false; // Outside the rectangle.
                  }
                } else {
                  if (top < 0) {
                    return false; // Outside the rectangle.
                  }
                }

                if (col >= frozenColCount && frozenColCount > 0) {
                  var _grid$getAttachCellsA6 = grid.getAttachCellsArea(grid.getCellRange(frozenColCount - 1, row)),
                      _frozenRect = _grid$getAttachCellsA6.rect;

                  if (left < _frozenRect.right) {
                    return false; // Outside the rectangle.
                  }
                } else {
                  if (left < 0) {
                    return false; // Outside the rectangle.
                  }
                }

                var offsetHeight = element.offsetHeight,
                    offsetWidth = element.offsetWidth;

                if (offsetHeight < top) {
                  return false; // Outside the rectangle.
                }

                if (offsetWidth < left) {
                  return false; // Outside the rectangle.
                }

                rootElement.style.top = "".concat(top.toFixed(), "px");
                rootElement.style.left = "".concat(left.toFixed(), "px");
                rootElement.style.width = "".concat(width.toFixed(), "px");

                if (rootElement.parentElement !== element) {
                  element.appendChild(rootElement);
                }

                return true;
              }
              /**
               * If the message is placed outside the Grid, adjust its position.
               */

            }, {
              key: "_adjustStyle",
              value: function _adjustStyle(grid, col, row) {
                var rootElement = this._rootElement;
                var element = grid.getElement();
                var messageRect = rootElement.getBoundingClientRect();
                var elementRect = element.getBoundingClientRect();
                var messageLeft = messageRect.left;

                if (elementRect.right < messageRect.right) {
                  var overflow = messageRect.right - elementRect.right;
                  messageLeft -= overflow;
                }

                if (messageLeft < elementRect.left) {
                  messageLeft = elementRect.left;
                }

                if (messageLeft !== messageRect.left) {
                  var diff = messageRect.left - messageLeft;

                  var _grid$getAttachCellsA7 = grid.getAttachCellsArea(grid.getCellRange(col, row)),
                      rect = _grid$getAttachCellsA7.rect;

                  rootElement.style.left = "".concat((rect.left - diff).toFixed(), "px");
                  var diffCss = "".concat(diff.toFixed(), "px");
                  rootElement.style.setProperty(LEFT_DIFF_CSS_PROP_NAME, diffCss);
                } else {
                  rootElement.style.removeProperty(LEFT_DIFF_CSS_PROP_NAME);
                }
              }
            }]);

            return MessageElement;
          }();

          exports.MessageElement = MessageElement;
          /***/
        },

        /***/
        "./columns/message/internal/WarningMessageElement.js":
        /*!***********************************************************!*\
          !*** ./columns/message/internal/WarningMessageElement.js ***!
          \***********************************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsMessageInternalWarningMessageElementJs(module, exports, __nested_webpack_require_362441__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.WarningMessageElement = void 0;

          var MessageElement_1 = __nested_webpack_require_362441__(
          /*! ./MessageElement */
          "./columns/message/internal/MessageElement.js");

          var CLASSNAME = "cheetah-grid__warning-message-element";
          var MESSAGE_CLASSNAME = "".concat(CLASSNAME, "__message");

          var WarningMessageElement = /*#__PURE__*/function (_MessageElement_1$Mes2) {
            _inherits(WarningMessageElement, _MessageElement_1$Mes2);

            var _super19 = _createSuper(WarningMessageElement);

            function WarningMessageElement() {
              var _this40;

              _classCallCheck(this, WarningMessageElement);

              _this40 = _super19.call(this);

              __nested_webpack_require_362441__(
              /*! @/columns/message/internal/WarningMessageElement.css */
              "../src/js/columns/message/internal/WarningMessageElement.css");

              _this40._rootElement.classList.add(CLASSNAME);

              _this40._messageElement.classList.add(MESSAGE_CLASSNAME);

              return _this40;
            }

            return WarningMessageElement;
          }(MessageElement_1.MessageElement);

          exports.WarningMessageElement = WarningMessageElement;
          /***/
        },

        /***/
        "./columns/message/messageUtils.js":
        /*!*****************************************!*\
          !*** ./columns/message/messageUtils.js ***!
          \*****************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsMessageMessageUtilsJs(module, exports, __nested_webpack_require_364297__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.drawInformationMarkBox = exports.drawExclamationMarkBox = void 0;

          var Rect_1 = __nested_webpack_require_364297__(
          /*! ../../internal/Rect */
          "./internal/Rect.js");

          function drawExclamationMarkBox(context, style, helper) {
            var bgColor = style.bgColor,
                color = style.color,
                boxWidth = style.boxWidth,
                markHeight = style.markHeight;
            var ctx = context.getContext();
            var rect = context.getRect(); // draw box

            ctx.fillStyle = bgColor;
            var boxRect = rect.copy();
            boxRect.left = boxRect.right - (Number(boxWidth) || 24);
            ctx.fillRect(boxRect.left, boxRect.top, boxRect.width, boxRect.height - 1); // draw exclamation mark

            var fillColor = color;
            var height = Number(markHeight) || 20;
            var width = height / 5;
            var left = boxRect.left + (boxRect.width - width) / 2;
            var top = boxRect.top + (boxRect.height - height) / 2;
            helper.fillRectWithState(new Rect_1.Rect(left, top, width, height / 5 * 3), context, {
              fillColor: fillColor
            });
            helper.fillRectWithState(new Rect_1.Rect(left, top + height / 5 * 4, width, height / 5), context, {
              fillColor: fillColor
            });
          }

          exports.drawExclamationMarkBox = drawExclamationMarkBox;

          function drawInformationMarkBox(context, style, helper) {
            var bgColor = style.bgColor,
                color = style.color,
                boxWidth = style.boxWidth,
                markHeight = style.markHeight;
            var ctx = context.getContext();
            var rect = context.getRect(); // draw box

            ctx.fillStyle = bgColor;
            var boxRect = rect.copy();
            boxRect.left = boxRect.right - (Number(boxWidth) || 24);
            ctx.fillRect(boxRect.left, boxRect.top, boxRect.width, boxRect.height - 1); // draw i mark

            var fillColor = color;
            var height = Number(markHeight) || 20;
            var width = height / 5;
            var left = boxRect.left + (boxRect.width - width) / 2;
            var top = boxRect.top + (boxRect.height - height) / 2;
            helper.fillRectWithState(new Rect_1.Rect(left, top, width, height / 5), context, {
              fillColor: fillColor
            });
            helper.fillRectWithState(new Rect_1.Rect(left, top + height / 5 * 2, width, height / 5 * 3), context, {
              fillColor: fillColor
            });
          }

          exports.drawInformationMarkBox = drawInformationMarkBox;
          /***/
        },

        /***/
        "./columns/style.js":
        /*!**************************!*\
          !*** ./columns/style.js ***!
          \**************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsStyleJs(module, exports, __nested_webpack_require_367492__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.of = exports.TreeStyle = exports.MenuStyle = exports.MultilineTextStyle = exports.PercentCompleteBarStyle = exports.IconStyle = exports.ImageStyle = exports.ButtonStyle = exports.RadioStyle = exports.CheckStyle = exports.NumberStyle = exports.Style = exports.BaseStyle = exports.EVENT_TYPE = void 0;

          var BaseStyle_1 = __nested_webpack_require_367492__(
          /*! ./style/BaseStyle */
          "./columns/style/BaseStyle.js");

          Object.defineProperty(exports, "BaseStyle", {
            enumerable: true,
            get: function get() {
              return BaseStyle_1.BaseStyle;
            }
          });

          var ButtonStyle_1 = __nested_webpack_require_367492__(
          /*! ./style/ButtonStyle */
          "./columns/style/ButtonStyle.js");

          Object.defineProperty(exports, "ButtonStyle", {
            enumerable: true,
            get: function get() {
              return ButtonStyle_1.ButtonStyle;
            }
          });

          var CheckStyle_1 = __nested_webpack_require_367492__(
          /*! ./style/CheckStyle */
          "./columns/style/CheckStyle.js");

          Object.defineProperty(exports, "CheckStyle", {
            enumerable: true,
            get: function get() {
              return CheckStyle_1.CheckStyle;
            }
          });

          var IconStyle_1 = __nested_webpack_require_367492__(
          /*! ./style/IconStyle */
          "./columns/style/IconStyle.js");

          Object.defineProperty(exports, "IconStyle", {
            enumerable: true,
            get: function get() {
              return IconStyle_1.IconStyle;
            }
          });

          var ImageStyle_1 = __nested_webpack_require_367492__(
          /*! ./style/ImageStyle */
          "./columns/style/ImageStyle.js");

          Object.defineProperty(exports, "ImageStyle", {
            enumerable: true,
            get: function get() {
              return ImageStyle_1.ImageStyle;
            }
          });

          var MenuStyle_1 = __nested_webpack_require_367492__(
          /*! ./style/MenuStyle */
          "./columns/style/MenuStyle.js");

          Object.defineProperty(exports, "MenuStyle", {
            enumerable: true,
            get: function get() {
              return MenuStyle_1.MenuStyle;
            }
          });

          var MultilineTextStyle_1 = __nested_webpack_require_367492__(
          /*! ./style/MultilineTextStyle */
          "./columns/style/MultilineTextStyle.js");

          Object.defineProperty(exports, "MultilineTextStyle", {
            enumerable: true,
            get: function get() {
              return MultilineTextStyle_1.MultilineTextStyle;
            }
          });

          var NumberStyle_1 = __nested_webpack_require_367492__(
          /*! ./style/NumberStyle */
          "./columns/style/NumberStyle.js");

          Object.defineProperty(exports, "NumberStyle", {
            enumerable: true,
            get: function get() {
              return NumberStyle_1.NumberStyle;
            }
          });

          var PercentCompleteBarStyle_1 = __nested_webpack_require_367492__(
          /*! ./style/PercentCompleteBarStyle */
          "./columns/style/PercentCompleteBarStyle.js");

          Object.defineProperty(exports, "PercentCompleteBarStyle", {
            enumerable: true,
            get: function get() {
              return PercentCompleteBarStyle_1.PercentCompleteBarStyle;
            }
          });

          var RadioStyle_1 = __nested_webpack_require_367492__(
          /*! ./style/RadioStyle */
          "./columns/style/RadioStyle.js");

          Object.defineProperty(exports, "RadioStyle", {
            enumerable: true,
            get: function get() {
              return RadioStyle_1.RadioStyle;
            }
          });

          var Style_1 = __nested_webpack_require_367492__(
          /*! ./style/Style */
          "./columns/style/Style.js");

          Object.defineProperty(exports, "Style", {
            enumerable: true,
            get: function get() {
              return Style_1.Style;
            }
          });

          var TreeStyle_1 = __nested_webpack_require_367492__(
          /*! ./style/TreeStyle */
          "./columns/style/TreeStyle.js");

          Object.defineProperty(exports, "TreeStyle", {
            enumerable: true,
            get: function get() {
              return TreeStyle_1.TreeStyle;
            }
          });
          var EVENT_TYPE = BaseStyle_1.BaseStyle.EVENT_TYPE;
          exports.EVENT_TYPE = EVENT_TYPE;

          function of(columnStyle, // eslint-disable-next-line @typescript-eslint/no-explicit-any
          record) {
            var StyleClassDef = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Style_1.Style;

            if (columnStyle) {
              if (columnStyle instanceof BaseStyle_1.BaseStyle) {
                return columnStyle;
              } else if (typeof columnStyle === "function") {
                return of(columnStyle(record), record, StyleClassDef);
              } else if (record && columnStyle in record) {
                return of(record[columnStyle], record, StyleClassDef);
              } // eslint-disable-next-line @typescript-eslint/no-explicit-any


              return new StyleClassDef(columnStyle);
            } else {
              return StyleClassDef.DEFAULT;
            }
          }

          exports.of = of;
          /***/
        },

        /***/
        "./columns/style/BaseStyle.js":
        /*!************************************!*\
          !*** ./columns/style/BaseStyle.js ***!
          \************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsStyleBaseStyleJs(module, exports, __nested_webpack_require_373374__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.BaseStyle = void 0;

          var EventTarget_1 = __nested_webpack_require_373374__(
          /*! ../../core/EventTarget */
          "./core/EventTarget.js");

          var STYLE_EVENT_TYPE = {
            CHANGE_STYLE: "change_style"
          };
          var defaultStyle;

          var BaseStyle = /*#__PURE__*/function (_EventTarget_1$EventT) {
            _inherits(BaseStyle, _EventTarget_1$EventT);

            var _super20 = _createSuper(BaseStyle);

            function BaseStyle() {
              var _this41;

              var _ref26 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
                  bgColor = _ref26.bgColor,
                  visibility = _ref26.visibility,
                  indicatorTopLeft = _ref26.indicatorTopLeft,
                  indicatorTopRight = _ref26.indicatorTopRight,
                  indicatorBottomRight = _ref26.indicatorBottomRight,
                  indicatorBottomLeft = _ref26.indicatorBottomLeft;

              _classCallCheck(this, BaseStyle);

              _this41 = _super20.call(this);
              _this41._bgColor = bgColor;
              _this41._visibility = normalizeVisibility(visibility, undefined);
              _this41._indicatorTopLeft = normalizeIndicator(indicatorTopLeft);
              _this41._indicatorTopRight = normalizeIndicator(indicatorTopRight);
              _this41._indicatorBottomRight = normalizeIndicator(indicatorBottomRight);
              _this41._indicatorBottomLeft = normalizeIndicator(indicatorBottomLeft);
              return _this41;
            }

            _createClass(BaseStyle, [{
              key: "bgColor",
              get: function get() {
                return this._bgColor;
              },
              set: function set(bgColor) {
                this._bgColor = bgColor;
                this.doChangeStyle();
              }
            }, {
              key: "visibility",
              get: function get() {
                return this._visibility;
              },
              set: function set(visibility) {
                var normalized = normalizeVisibility(visibility, this._visibility);

                if (this._visibility === normalized) {
                  return;
                }

                this._visibility = normalized;
                this.doChangeStyle();
              }
            }, {
              key: "indicatorTopLeft",
              get: function get() {
                return this._indicatorTopLeft;
              },
              set: function set(indicatorTopLeft) {
                this._indicatorTopLeft = normalizeIndicator(indicatorTopLeft);
                this.doChangeStyle();
              }
            }, {
              key: "indicatorTopRight",
              get: function get() {
                return this._indicatorTopRight;
              },
              set: function set(indicatorTopRight) {
                this._indicatorTopRight = normalizeIndicator(indicatorTopRight);
                this.doChangeStyle();
              }
            }, {
              key: "indicatorBottomRight",
              get: function get() {
                return this._indicatorBottomRight;
              },
              set: function set(indicatorBottomRight) {
                this._indicatorBottomRight = normalizeIndicator(indicatorBottomRight);
                this.doChangeStyle();
              }
            }, {
              key: "indicatorBottomLeft",
              get: function get() {
                return this._indicatorBottomLeft;
              },
              set: function set(indicatorBottomLeft) {
                this._indicatorBottomLeft = normalizeIndicator(indicatorBottomLeft);
                this.doChangeStyle();
              }
            }, {
              key: "doChangeStyle",
              value: function doChangeStyle() {
                this.fireListeners(STYLE_EVENT_TYPE.CHANGE_STYLE);
              }
            }, {
              key: "clone",
              value: function clone() {
                return new BaseStyle(this);
              }
            }], [{
              key: "EVENT_TYPE",
              get: function get() {
                return STYLE_EVENT_TYPE;
              }
            }, {
              key: "DEFAULT",
              get: function get() {
                return defaultStyle ? defaultStyle : defaultStyle = new BaseStyle();
              }
            }]);

            return BaseStyle;
          }(EventTarget_1.EventTarget);

          exports.BaseStyle = BaseStyle;

          function normalizeIndicator(indicator) {
            if (typeof indicator === "string") {
              return {
                style: indicator
              };
            }

            return indicator;
          }

          function normalizeVisibility(visibility, defaultValue) {
            if (visibility && visibility !== "visible" && visibility !== "hidden") {
              return defaultValue;
            }

            return visibility;
          }
          /***/

        },

        /***/
        "./columns/style/BranchGraphStyle.js":
        /*!*******************************************!*\
          !*** ./columns/style/BranchGraphStyle.js ***!
          \*******************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsStyleBranchGraphStyleJs(module, exports, __nested_webpack_require_379008__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.BranchGraphStyle = void 0;

          var BaseStyle_1 = __nested_webpack_require_379008__(
          /*! ./BaseStyle */
          "./columns/style/BaseStyle.js");

          var defaultStyle;

          var DEFAULT_BRANCH_COLORS = function DEFAULT_BRANCH_COLORS(_name, index) {
            switch (index % 3) {
              case 0:
                return "#979797";

              case 1:
                return "#008fb5";

              case 2:
                return "#f1c109";

              default:
            }

            return "#979797";
          };

          var BranchGraphStyle = /*#__PURE__*/function (_BaseStyle_1$BaseStyl) {
            _inherits(BranchGraphStyle, _BaseStyle_1$BaseStyl);

            var _super21 = _createSuper(BranchGraphStyle);

            function BranchGraphStyle() {
              var _this42;

              var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, BranchGraphStyle);

              _this42 = _super21.call(this, style);
              _this42._branchColors = style.branchColors || DEFAULT_BRANCH_COLORS;
              _this42._margin = style.margin || 4;
              _this42._circleSize = style.circleSize || 16;
              _this42._branchLineWidth = style.branchLineWidth || 4;
              _this42._mergeStyle = style.mergeStyle === "straight" ? "straight" : "bezier";
              return _this42;
            }

            _createClass(BranchGraphStyle, [{
              key: "branchColors",
              get: function get() {
                return this._branchColors;
              },
              set: function set(branchColors) {
                this._branchColors = branchColors;
                this.doChangeStyle();
              }
            }, {
              key: "margin",
              get: function get() {
                return this._margin;
              },
              set: function set(margin) {
                this._margin = margin;
                this.doChangeStyle();
              }
            }, {
              key: "circleSize",
              get: function get() {
                return this._circleSize;
              },
              set: function set(circleSize) {
                this._circleSize = circleSize;
                this.doChangeStyle();
              }
            }, {
              key: "branchLineWidth",
              get: function get() {
                return this._branchLineWidth;
              },
              set: function set(branchLineWidth) {
                this._branchLineWidth = branchLineWidth;
                this.doChangeStyle();
              }
            }, {
              key: "mergeStyle",
              get: function get() {
                return this._mergeStyle;
              },
              set: function set(mergeStyle) {
                this._mergeStyle = mergeStyle;
                this.doChangeStyle();
              }
            }, {
              key: "clone",
              value: function clone() {
                return new BranchGraphStyle(this);
              }
            }], [{
              key: "DEFAULT",
              get: function get() {
                return defaultStyle ? defaultStyle : defaultStyle = new BranchGraphStyle();
              }
            }]);

            return BranchGraphStyle;
          }(BaseStyle_1.BaseStyle);

          exports.BranchGraphStyle = BranchGraphStyle;
          /***/
        },

        /***/
        "./columns/style/ButtonStyle.js":
        /*!**************************************!*\
          !*** ./columns/style/ButtonStyle.js ***!
          \**************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsStyleButtonStyleJs(module, exports, __nested_webpack_require_383028__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.ButtonStyle = void 0;

          var Style_1 = __nested_webpack_require_383028__(
          /*! ./Style */
          "./columns/style/Style.js");

          var utils_1 = __nested_webpack_require_383028__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var defaultStyle;

          var ButtonStyle = /*#__PURE__*/function (_Style_1$Style) {
            _inherits(ButtonStyle, _Style_1$Style);

            var _super22 = _createSuper(ButtonStyle);

            function ButtonStyle() {
              var _this43;

              var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, ButtonStyle);

              _this43 = _super22.call(this, (0, utils_1.defaults)(style, {
                textAlign: "center"
              }));
              var buttonBgColor = style.buttonBgColor;
              _this43._buttonBgColor = buttonBgColor;
              return _this43;
            }

            _createClass(ButtonStyle, [{
              key: "buttonBgColor",
              get: function get() {
                return this._buttonBgColor;
              },
              set: function set(buttonBgColor) {
                this._buttonBgColor = buttonBgColor;
                this.doChangeStyle();
              }
            }, {
              key: "clone",
              value: function clone() {
                return new ButtonStyle(this);
              }
            }], [{
              key: "DEFAULT",
              get: function get() {
                return defaultStyle ? defaultStyle : defaultStyle = new ButtonStyle();
              }
            }]);

            return ButtonStyle;
          }(Style_1.Style);

          exports.ButtonStyle = ButtonStyle;
          /***/
        },

        /***/
        "./columns/style/CheckStyle.js":
        /*!*************************************!*\
          !*** ./columns/style/CheckStyle.js ***!
          \*************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsStyleCheckStyleJs(module, exports, __nested_webpack_require_385363__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.CheckStyle = void 0;

          var StdBaseStyle_1 = __nested_webpack_require_385363__(
          /*! ./StdBaseStyle */
          "./columns/style/StdBaseStyle.js");

          var utils_1 = __nested_webpack_require_385363__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var defaultStyle;

          var CheckStyle = /*#__PURE__*/function (_StdBaseStyle_1$StdBa) {
            _inherits(CheckStyle, _StdBaseStyle_1$StdBa);

            var _super23 = _createSuper(CheckStyle);

            function CheckStyle() {
              var _this44;

              var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, CheckStyle);

              _this44 = _super23.call(this, (0, utils_1.defaults)(style, {
                textAlign: "center"
              }));
              var uncheckBgColor = style.uncheckBgColor,
                  checkBgColor = style.checkBgColor,
                  borderColor = style.borderColor;
              _this44._uncheckBgColor = uncheckBgColor;
              _this44._checkBgColor = checkBgColor;
              _this44._borderColor = borderColor;
              return _this44;
            }

            _createClass(CheckStyle, [{
              key: "uncheckBgColor",
              get: function get() {
                return this._uncheckBgColor;
              },
              set: function set(uncheckBgColor) {
                this._uncheckBgColor = uncheckBgColor;
                this.doChangeStyle();
              }
            }, {
              key: "checkBgColor",
              get: function get() {
                return this._checkBgColor;
              },
              set: function set(checkBgColor) {
                this._checkBgColor = checkBgColor;
                this.doChangeStyle();
              }
            }, {
              key: "borderColor",
              get: function get() {
                return this._borderColor;
              },
              set: function set(borderColor) {
                this._borderColor = borderColor;
                this.doChangeStyle();
              }
            }, {
              key: "clone",
              value: function clone() {
                return new CheckStyle(this);
              }
            }], [{
              key: "DEFAULT",
              get: function get() {
                return defaultStyle ? defaultStyle : defaultStyle = new CheckStyle();
              }
            }]);

            return CheckStyle;
          }(StdBaseStyle_1.StdBaseStyle);

          exports.CheckStyle = CheckStyle;
          /***/
        },

        /***/
        "./columns/style/IconStyle.js":
        /*!************************************!*\
          !*** ./columns/style/IconStyle.js ***!
          \************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsStyleIconStyleJs(module, exports, __nested_webpack_require_388542__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.IconStyle = void 0;

          var Style_1 = __nested_webpack_require_388542__(
          /*! ./Style */
          "./columns/style/Style.js");

          var utils_1 = __nested_webpack_require_388542__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var defaultStyle;

          var IconStyle = /*#__PURE__*/function (_Style_1$Style2) {
            _inherits(IconStyle, _Style_1$Style2);

            var _super24 = _createSuper(IconStyle);

            function IconStyle() {
              var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, IconStyle);

              return _super24.call(this, (0, utils_1.defaults)(style, {
                textAlign: "center"
              }));
            }

            _createClass(IconStyle, [{
              key: "clone",
              value: function clone() {
                return new IconStyle(this);
              }
            }], [{
              key: "DEFAULT",
              get: function get() {
                return defaultStyle ? defaultStyle : defaultStyle = new IconStyle();
              }
            }]);

            return IconStyle;
          }(Style_1.Style);

          exports.IconStyle = IconStyle;
          /***/
        },

        /***/
        "./columns/style/ImageStyle.js":
        /*!*************************************!*\
          !*** ./columns/style/ImageStyle.js ***!
          \*************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsStyleImageStyleJs(module, exports, __nested_webpack_require_390379__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.ImageStyle = void 0;

          var StdBaseStyle_1 = __nested_webpack_require_390379__(
          /*! ./StdBaseStyle */
          "./columns/style/StdBaseStyle.js");

          var utils_1 = __nested_webpack_require_390379__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var defaultStyle;

          var ImageStyle = /*#__PURE__*/function (_StdBaseStyle_1$StdBa2) {
            _inherits(ImageStyle, _StdBaseStyle_1$StdBa2);

            var _super25 = _createSuper(ImageStyle);

            function ImageStyle() {
              var _this45;

              var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, ImageStyle);

              _this45 = _super25.call(this, (0, utils_1.defaults)(style, {
                textAlign: "center"
              }));
              _this45._imageSizing = style.imageSizing;
              _this45._margin = style.margin || 4;
              return _this45;
            }

            _createClass(ImageStyle, [{
              key: "imageSizing",
              get: function get() {
                return this._imageSizing;
              },
              set: function set(imageSizing) {
                this._imageSizing = imageSizing;
                this.doChangeStyle();
              }
            }, {
              key: "margin",
              get: function get() {
                return this._margin;
              },
              set: function set(margin) {
                this._margin = margin;
                this.doChangeStyle();
              }
            }, {
              key: "clone",
              value: function clone() {
                return new ImageStyle(this);
              }
            }], [{
              key: "DEFAULT",
              get: function get() {
                return defaultStyle ? defaultStyle : defaultStyle = new ImageStyle();
              }
            }]);

            return ImageStyle;
          }(StdBaseStyle_1.StdBaseStyle);

          exports.ImageStyle = ImageStyle;
          /***/
        },

        /***/
        "./columns/style/MenuStyle.js":
        /*!************************************!*\
          !*** ./columns/style/MenuStyle.js ***!
          \************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsStyleMenuStyleJs(module, exports, __nested_webpack_require_393007__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.MenuStyle = void 0;

          var Style_1 = __nested_webpack_require_393007__(
          /*! ./Style */
          "./columns/style/Style.js");

          var defaultStyle;

          var MenuStyle = /*#__PURE__*/function (_Style_1$Style3) {
            _inherits(MenuStyle, _Style_1$Style3);

            var _super26 = _createSuper(MenuStyle);

            function MenuStyle() {
              var _this46;

              var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, MenuStyle);

              _this46 = _super26.call(this, style);
              var appearance = style.appearance;
              _this46._appearance = appearance;
              return _this46;
            }

            _createClass(MenuStyle, [{
              key: "appearance",
              get: function get() {
                return this._appearance || "menulist-button";
              },
              set: function set(appearance) {
                this._appearance = appearance;
                this.doChangeStyle();
              }
            }, {
              key: "clone",
              value: function clone() {
                return new MenuStyle(this);
              }
            }], [{
              key: "DEFAULT",
              get: function get() {
                return defaultStyle ? defaultStyle : defaultStyle = new MenuStyle();
              }
            }]);

            return MenuStyle;
          }(Style_1.Style);

          exports.MenuStyle = MenuStyle;
          /***/
        },

        /***/
        "./columns/style/MultilineTextStyle.js":
        /*!*********************************************!*\
          !*** ./columns/style/MultilineTextStyle.js ***!
          \*********************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsStyleMultilineTextStyleJs(module, exports, __nested_webpack_require_395158__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.MultilineTextStyle = void 0;

          var Style_1 = __nested_webpack_require_395158__(
          /*! ./Style */
          "./columns/style/Style.js");

          var utils_1 = __nested_webpack_require_395158__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var defaultStyle;

          var MultilineTextStyle = /*#__PURE__*/function (_Style_1$Style4) {
            _inherits(MultilineTextStyle, _Style_1$Style4);

            var _super27 = _createSuper(MultilineTextStyle);

            function MultilineTextStyle() {
              var _this47;

              var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, MultilineTextStyle);

              _this47 = _super27.call(this, (0, utils_1.defaults)(style, {
                textBaseline: "top"
              }));
              _this47._lineHeight = style.lineHeight || "1em";
              _this47._autoWrapText = style.autoWrapText || false;
              _this47._lineClamp = style.lineClamp;
              return _this47;
            }

            _createClass(MultilineTextStyle, [{
              key: "clone",
              value: function clone() {
                return new MultilineTextStyle(this);
              }
            }, {
              key: "lineHeight",
              get: function get() {
                return this._lineHeight;
              },
              set: function set(lineHeight) {
                this._lineHeight = lineHeight;
                this.doChangeStyle();
              }
            }, {
              key: "lineClamp",
              get: function get() {
                return this._lineClamp;
              },
              set: function set(lineClamp) {
                this._lineClamp = lineClamp;
                this.doChangeStyle();
              }
            }, {
              key: "autoWrapText",
              get: function get() {
                return this._autoWrapText;
              },
              set: function set(autoWrapText) {
                this._autoWrapText = autoWrapText;
                this.doChangeStyle();
              }
            }], [{
              key: "DEFAULT",
              get: function get() {
                return defaultStyle ? defaultStyle : defaultStyle = new MultilineTextStyle();
              }
            }]);

            return MultilineTextStyle;
          }(Style_1.Style);

          exports.MultilineTextStyle = MultilineTextStyle;
          /***/
        },

        /***/
        "./columns/style/NumberStyle.js":
        /*!**************************************!*\
          !*** ./columns/style/NumberStyle.js ***!
          \**************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsStyleNumberStyleJs(module, exports, __nested_webpack_require_398229__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.NumberStyle = void 0;

          var Style_1 = __nested_webpack_require_398229__(
          /*! ./Style */
          "./columns/style/Style.js");

          var utils_1 = __nested_webpack_require_398229__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var defaultStyle;

          var NumberStyle = /*#__PURE__*/function (_Style_1$Style5) {
            _inherits(NumberStyle, _Style_1$Style5);

            var _super28 = _createSuper(NumberStyle);

            function NumberStyle() {
              var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, NumberStyle);

              return _super28.call(this, (0, utils_1.defaults)(style, {
                textAlign: "right"
              }));
            }

            _createClass(NumberStyle, [{
              key: "clone",
              value: function clone() {
                return new NumberStyle(this);
              }
            }], [{
              key: "DEFAULT",
              get: function get() {
                return defaultStyle ? defaultStyle : defaultStyle = new NumberStyle();
              }
            }]);

            return NumberStyle;
          }(Style_1.Style);

          exports.NumberStyle = NumberStyle;
          /***/
        },

        /***/
        "./columns/style/PercentCompleteBarStyle.js":
        /*!**************************************************!*\
          !*** ./columns/style/PercentCompleteBarStyle.js ***!
          \**************************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsStylePercentCompleteBarStyleJs(module, exports, __nested_webpack_require_400154__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.PercentCompleteBarStyle = void 0;

          var Style_1 = __nested_webpack_require_400154__(
          /*! ./Style */
          "./columns/style/Style.js");

          var defaultStyle;

          var DEFAULT_BAR_COLOR = function DEFAULT_BAR_COLOR(num) {
            if (num > 80) {
              return "#20a8d8";
            }

            if (num > 50) {
              return "#4dbd74";
            }

            if (num > 20) {
              return "#ffc107";
            }

            return "#f86c6b";
          };

          var PercentCompleteBarStyle = /*#__PURE__*/function (_Style_1$Style6) {
            _inherits(PercentCompleteBarStyle, _Style_1$Style6);

            var _super29 = _createSuper(PercentCompleteBarStyle);

            function PercentCompleteBarStyle() {
              var _this48;

              var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, PercentCompleteBarStyle);

              _this48 = _super29.call(this, style);
              _this48._barColor = style.barColor || DEFAULT_BAR_COLOR;
              _this48._barBgColor = style.barBgColor || "#f0f3f5";
              _this48._barHeight = style.barHeight || 3;
              return _this48;
            }

            _createClass(PercentCompleteBarStyle, [{
              key: "barColor",
              get: function get() {
                return this._barColor;
              },
              set: function set(barColor) {
                this._barColor = barColor;
                this.doChangeStyle();
              }
            }, {
              key: "barBgColor",
              get: function get() {
                return this._barBgColor;
              },
              set: function set(barBgColor) {
                this._barBgColor = barBgColor;
                this.doChangeStyle();
              }
            }, {
              key: "barHeight",
              get: function get() {
                return this._barHeight;
              },
              set: function set(barHeight) {
                this._barHeight = barHeight;
                this.doChangeStyle();
              }
            }, {
              key: "clone",
              value: function clone() {
                return new PercentCompleteBarStyle(this);
              }
            }], [{
              key: "DEFAULT",
              get: function get() {
                return defaultStyle ? defaultStyle : defaultStyle = new PercentCompleteBarStyle();
              }
            }]);

            return PercentCompleteBarStyle;
          }(Style_1.Style);

          exports.PercentCompleteBarStyle = PercentCompleteBarStyle;
          /***/
        },

        /***/
        "./columns/style/RadioStyle.js":
        /*!*************************************!*\
          !*** ./columns/style/RadioStyle.js ***!
          \*************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsStyleRadioStyleJs(module, exports, __nested_webpack_require_403414__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.RadioStyle = void 0;

          var StdBaseStyle_1 = __nested_webpack_require_403414__(
          /*! ./StdBaseStyle */
          "./columns/style/StdBaseStyle.js");

          var utils_1 = __nested_webpack_require_403414__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var defaultStyle;

          var RadioStyle = /*#__PURE__*/function (_StdBaseStyle_1$StdBa3) {
            _inherits(RadioStyle, _StdBaseStyle_1$StdBa3);

            var _super30 = _createSuper(RadioStyle);

            function RadioStyle() {
              var _this49;

              var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, RadioStyle);

              _this49 = _super30.call(this, (0, utils_1.defaults)(style, {
                textAlign: "center"
              }));
              var checkColor = style.checkColor,
                  uncheckBorderColor = style.uncheckBorderColor,
                  checkBorderColor = style.checkBorderColor,
                  uncheckBgColor = style.uncheckBgColor,
                  checkBgColor = style.checkBgColor;
              _this49._checkColor = checkColor;
              _this49._uncheckBorderColor = uncheckBorderColor;
              _this49._checkBorderColor = checkBorderColor;
              _this49._uncheckBgColor = uncheckBgColor;
              _this49._checkBgColor = checkBgColor;
              return _this49;
            }

            _createClass(RadioStyle, [{
              key: "checkColor",
              get: function get() {
                return this._checkColor;
              },
              set: function set(checkColor) {
                this._checkColor = checkColor;
                this.doChangeStyle();
              }
            }, {
              key: "uncheckBorderColor",
              get: function get() {
                return this._uncheckBorderColor;
              },
              set: function set(uncheckBorderColor) {
                this._uncheckBorderColor = uncheckBorderColor;
                this.doChangeStyle();
              }
            }, {
              key: "checkBorderColor",
              get: function get() {
                return this._checkBorderColor;
              },
              set: function set(checkBorderColor) {
                this._checkBorderColor = checkBorderColor;
                this.doChangeStyle();
              }
            }, {
              key: "uncheckBgColor",
              get: function get() {
                return this._uncheckBgColor;
              },
              set: function set(uncheckBgColor) {
                this._uncheckBgColor = uncheckBgColor;
                this.doChangeStyle();
              }
            }, {
              key: "checkBgColor",
              get: function get() {
                return this._checkBgColor;
              },
              set: function set(checkBgColor) {
                this._checkBgColor = checkBgColor;
                this.doChangeStyle();
              }
            }, {
              key: "clone",
              value: function clone() {
                return new RadioStyle(this);
              }
            }], [{
              key: "DEFAULT",
              get: function get() {
                return defaultStyle ? defaultStyle : defaultStyle = new RadioStyle();
              }
            }]);

            return RadioStyle;
          }(StdBaseStyle_1.StdBaseStyle);

          exports.RadioStyle = RadioStyle;
          /***/
        },

        /***/
        "./columns/style/StdBaseStyle.js":
        /*!***************************************!*\
          !*** ./columns/style/StdBaseStyle.js ***!
          \***************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsStyleStdBaseStyleJs(module, exports, __nested_webpack_require_407503__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.StdBaseStyle = void 0;

          var BaseStyle_1 = __nested_webpack_require_407503__(
          /*! ./BaseStyle */
          "./columns/style/BaseStyle.js");

          var defaultStyle;

          var StdBaseStyle = /*#__PURE__*/function (_BaseStyle_1$BaseStyl2) {
            _inherits(StdBaseStyle, _BaseStyle_1$BaseStyl2);

            var _super31 = _createSuper(StdBaseStyle);

            function StdBaseStyle() {
              var _this50;

              var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, StdBaseStyle);

              _this50 = _super31.call(this, style);
              _this50._textAlign = style.textAlign || "left";
              _this50._textBaseline = style.textBaseline || "middle";
              _this50._padding = style.padding;
              return _this50;
            }

            _createClass(StdBaseStyle, [{
              key: "textAlign",
              get: function get() {
                return this._textAlign;
              },
              set: function set(textAlign) {
                this._textAlign = textAlign;
                this.doChangeStyle();
              }
            }, {
              key: "textBaseline",
              get: function get() {
                return this._textBaseline;
              },
              set: function set(textBaseline) {
                this._textBaseline = textBaseline;
                this.doChangeStyle();
              }
            }, {
              key: "padding",
              get: function get() {
                return this._padding;
              },
              set: function set(padding) {
                this._padding = padding;
                this.doChangeStyle();
              }
            }, {
              key: "clone",
              value: function clone() {
                return new StdBaseStyle(this);
              }
            }], [{
              key: "DEFAULT",
              get: function get() {
                return defaultStyle ? defaultStyle : defaultStyle = new StdBaseStyle();
              }
            }]);

            return StdBaseStyle;
          }(BaseStyle_1.BaseStyle);

          exports.StdBaseStyle = StdBaseStyle;
          /***/
        },

        /***/
        "./columns/style/Style.js":
        /*!********************************!*\
          !*** ./columns/style/Style.js ***!
          \********************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsStyleStyleJs(module, exports, __nested_webpack_require_410293__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.Style = void 0;

          var StdBaseStyle_1 = __nested_webpack_require_410293__(
          /*! ./StdBaseStyle */
          "./columns/style/StdBaseStyle.js");

          var defaultStyle;

          var Style = /*#__PURE__*/function (_StdBaseStyle_1$StdBa4) {
            _inherits(Style, _StdBaseStyle_1$StdBa4);

            var _super32 = _createSuper(Style);

            function Style() {
              var _this51;

              var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, Style);

              _this51 = _super32.call(this, style);
              _this51._color = style.color;
              _this51._font = style.font;
              _this51._textOverflow = style.textOverflow || "clip";
              return _this51;
            }

            _createClass(Style, [{
              key: "color",
              get: function get() {
                return this._color;
              },
              set: function set(color) {
                this._color = color;
                this.doChangeStyle();
              }
            }, {
              key: "font",
              get: function get() {
                return this._font;
              },
              set: function set(font) {
                this._font = font;
                this.doChangeStyle();
              }
            }, {
              key: "textOverflow",
              get: function get() {
                return this._textOverflow;
              },
              set: function set(textOverflow) {
                this._textOverflow = textOverflow;
                this.doChangeStyle();
              }
            }, {
              key: "clone",
              value: function clone() {
                return new Style(this);
              }
            }], [{
              key: "DEFAULT",
              get: function get() {
                return defaultStyle ? defaultStyle : defaultStyle = new Style();
              }
            }]);

            return Style;
          }(StdBaseStyle_1.StdBaseStyle);

          exports.Style = Style;
          /***/
        },

        /***/
        "./columns/style/TreeStyle.js":
        /*!************************************!*\
          !*** ./columns/style/TreeStyle.js ***!
          \************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsStyleTreeStyleJs(module, exports, __nested_webpack_require_412973__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.TreeStyle = void 0;

          var Style_1 = __nested_webpack_require_412973__(
          /*! ./Style */
          "./columns/style/Style.js");

          var defaultStyle;

          var TreeStyle = /*#__PURE__*/function (_Style_1$Style7) {
            _inherits(TreeStyle, _Style_1$Style7);

            var _super33 = _createSuper(TreeStyle);

            function TreeStyle() {
              var _this52;

              var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, TreeStyle);

              _this52 = _super33.call(this, style);
              _this52._lineStyle = style.lineStyle;
              _this52._lineColor = style.lineColor;
              _this52._lineWidth = style.lineWidth;
              _this52._treeIcon = style.treeIcon;
              return _this52;
            }

            _createClass(TreeStyle, [{
              key: "clone",
              value: function clone() {
                return new TreeStyle(this);
              }
            }, {
              key: "lineStyle",
              get: function get() {
                return this._lineStyle;
              },
              set: function set(lineStyle) {
                this._lineStyle = lineStyle;
                this.doChangeStyle();
              }
            }, {
              key: "lineColor",
              get: function get() {
                return this._lineColor;
              },
              set: function set(lineColor) {
                this._lineColor = lineColor;
                this.doChangeStyle();
              }
            }, {
              key: "lineWidth",
              get: function get() {
                return this._lineWidth;
              },
              set: function set(lineWidth) {
                this._lineWidth = lineWidth;
                this.doChangeStyle();
              }
            }, {
              key: "treeIcon",
              get: function get() {
                return this._treeIcon;
              },
              set: function set(treeIcon) {
                this._treeIcon = treeIcon;
                this.doChangeStyle();
              }
            }], [{
              key: "DEFAULT",
              get: function get() {
                return defaultStyle ? defaultStyle : defaultStyle = new TreeStyle();
              }
            }]);

            return TreeStyle;
          }(Style_1.Style);

          exports.TreeStyle = TreeStyle;
          /***/
        },

        /***/
        "./columns/type.js":
        /*!*************************!*\
          !*** ./columns/type.js ***!
          \*************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsTypeJs(module, exports, __nested_webpack_require_415961__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.of = exports.TreeColumn = exports.MultilineTextColumn = exports.MenuColumn = exports.BranchGraphColumn = exports.IconColumn = exports.PercentCompleteBarColumn = exports.ImageColumn = exports.ButtonColumn = exports.RadioColumn = exports.CheckColumn = exports.NumberColumn = exports.Column = void 0;

          var BranchGraphColumn_1 = __nested_webpack_require_415961__(
          /*! ./type/BranchGraphColumn */
          "./columns/type/BranchGraphColumn.js");

          Object.defineProperty(exports, "BranchGraphColumn", {
            enumerable: true,
            get: function get() {
              return BranchGraphColumn_1.BranchGraphColumn;
            }
          });

          var ButtonColumn_1 = __nested_webpack_require_415961__(
          /*! ./type/ButtonColumn */
          "./columns/type/ButtonColumn.js");

          Object.defineProperty(exports, "ButtonColumn", {
            enumerable: true,
            get: function get() {
              return ButtonColumn_1.ButtonColumn;
            }
          });

          var CheckColumn_1 = __nested_webpack_require_415961__(
          /*! ./type/CheckColumn */
          "./columns/type/CheckColumn.js");

          Object.defineProperty(exports, "CheckColumn", {
            enumerable: true,
            get: function get() {
              return CheckColumn_1.CheckColumn;
            }
          });

          var Column_1 = __nested_webpack_require_415961__(
          /*! ./type/Column */
          "./columns/type/Column.js");

          Object.defineProperty(exports, "Column", {
            enumerable: true,
            get: function get() {
              return Column_1.Column;
            }
          });

          var IconColumn_1 = __nested_webpack_require_415961__(
          /*! ./type/IconColumn */
          "./columns/type/IconColumn.js");

          Object.defineProperty(exports, "IconColumn", {
            enumerable: true,
            get: function get() {
              return IconColumn_1.IconColumn;
            }
          });

          var ImageColumn_1 = __nested_webpack_require_415961__(
          /*! ./type/ImageColumn */
          "./columns/type/ImageColumn.js");

          Object.defineProperty(exports, "ImageColumn", {
            enumerable: true,
            get: function get() {
              return ImageColumn_1.ImageColumn;
            }
          });

          var MenuColumn_1 = __nested_webpack_require_415961__(
          /*! ./type/MenuColumn */
          "./columns/type/MenuColumn.js");

          Object.defineProperty(exports, "MenuColumn", {
            enumerable: true,
            get: function get() {
              return MenuColumn_1.MenuColumn;
            }
          });

          var MultilineTextColumn_1 = __nested_webpack_require_415961__(
          /*! ./type/MultilineTextColumn */
          "./columns/type/MultilineTextColumn.js");

          Object.defineProperty(exports, "MultilineTextColumn", {
            enumerable: true,
            get: function get() {
              return MultilineTextColumn_1.MultilineTextColumn;
            }
          });

          var NumberColumn_1 = __nested_webpack_require_415961__(
          /*! ./type/NumberColumn */
          "./columns/type/NumberColumn.js");

          Object.defineProperty(exports, "NumberColumn", {
            enumerable: true,
            get: function get() {
              return NumberColumn_1.NumberColumn;
            }
          });

          var PercentCompleteBarColumn_1 = __nested_webpack_require_415961__(
          /*! ./type/PercentCompleteBarColumn */
          "./columns/type/PercentCompleteBarColumn.js");

          Object.defineProperty(exports, "PercentCompleteBarColumn", {
            enumerable: true,
            get: function get() {
              return PercentCompleteBarColumn_1.PercentCompleteBarColumn;
            }
          });

          var RadioColumn_1 = __nested_webpack_require_415961__(
          /*! ./type/RadioColumn */
          "./columns/type/RadioColumn.js");

          Object.defineProperty(exports, "RadioColumn", {
            enumerable: true,
            get: function get() {
              return RadioColumn_1.RadioColumn;
            }
          });

          var TreeColumn_1 = __nested_webpack_require_415961__(
          /*! ./type/TreeColumn */
          "./columns/type/TreeColumn.js");

          Object.defineProperty(exports, "TreeColumn", {
            enumerable: true,
            get: function get() {
              return TreeColumn_1.TreeColumn;
            }
          });
          var TYPES = {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            DEFAULT: new Column_1.Column(),
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            NUMBER: new NumberColumn_1.NumberColumn(),
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            CHECK: new CheckColumn_1.CheckColumn(),
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            RADIO: new RadioColumn_1.RadioColumn(),
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            BUTTON: new ButtonColumn_1.ButtonColumn(),
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            IMAGE: new ImageColumn_1.ImageColumn(),
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            MULTILINETEXT: new MultilineTextColumn_1.MultilineTextColumn()
          };

          function of(columnType) {
            if (!columnType) {
              return TYPES.DEFAULT;
            } else if (typeof columnType === "string") {
              var key = columnType.toUpperCase();
              return TYPES[key] || of(null);
            } else {
              return columnType;
            }
          }

          exports.of = of;
          /***/
        },

        /***/
        "./columns/type/BaseColumn.js":
        /*!************************************!*\
          !*** ./columns/type/BaseColumn.js ***!
          \************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsTypeBaseColumnJs(module, exports, __nested_webpack_require_422253__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.BaseColumn = void 0;

          var styleContents = __importStar(__nested_webpack_require_422253__(
          /*! ../style */
          "./columns/style.js"));

          var utils_1 = __nested_webpack_require_422253__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var BaseStyle_1 = __nested_webpack_require_422253__(
          /*! ../style/BaseStyle */
          "./columns/style/BaseStyle.js");

          var animate_1 = __nested_webpack_require_422253__(
          /*! ../../internal/animate */
          "./internal/animate.js");

          var symbolManager_1 = __nested_webpack_require_422253__(
          /*! ../../internal/symbolManager */
          "./internal/symbolManager.js");

          var handlers_1 = __nested_webpack_require_422253__(
          /*! ../indicator/handlers */
          "./columns/indicator/handlers.js");

          var setReadonly = utils_1.obj.setReadonly;
          var COLUMN_FADEIN_STATE_ID = (0, symbolManager_1.getColumnFadeinStateId)();

          function isFadeinWhenCallbackInPromise(column, grid) {
            if (column.fadeinWhenCallbackInPromise != null) {
              return column.fadeinWhenCallbackInPromise;
            }

            return !!grid.configure("fadeinWhenCallbackInPromise");
          }

          function getFadeinState(grid) {
            var state = grid[COLUMN_FADEIN_STATE_ID];

            if (!state) {
              state = {
                cells: {}
              };
              setReadonly(grid, COLUMN_FADEIN_STATE_ID, state);
            }

            return state;
          }

          function _generateFadeinPointAction(grid, col, row, context, drawInternal, drawCellBase) {
            return function (point) {
              var state = getFadeinState(grid);
              var stateKey = "".concat(row, ":").concat(col);

              if (point === 1) {
                delete state.cells[stateKey];
              } else {
                state.cells[stateKey] = {
                  opacity: point
                };
              }

              drawCellBase();
              drawInternal();
              var cellState = state.cells[stateKey];

              if (cellState) {
                //
                var ctx = context.getContext();
                ctx.globalAlpha = 1 - cellState.opacity;

                try {
                  drawCellBase();
                } finally {
                  ctx.globalAlpha = 1;
                }
              }
            };
          }

          var fadeinMgr = {
            animate: function animate(grid, col, row, context, drawInternal, drawCellBase) {
              // fadein animation
              var state = getFadeinState(grid);
              var activeFadeins = [_generateFadeinPointAction(grid, col, row, context, drawInternal, drawCellBase)];
              state.activeFadeins = activeFadeins;
              (0, animate_1.animate)(500, function (point) {
                activeFadeins.forEach(function (f) {
                  return f(point);
                });

                if (point === 1) {
                  delete state.activeFadeins;
                }
              });
            },
            margeAnimate: function margeAnimate(grid, col, row, context, drawInternal, drawCellBase) {
              var state = getFadeinState(grid);

              if (state.activeFadeins) {
                state.activeFadeins.push(_generateFadeinPointAction(grid, col, row, context, drawInternal, drawCellBase));
              } else {
                drawInternal();
              }
            }
          };

          var BaseColumn = /*#__PURE__*/function () {
            function BaseColumn(option) {
              _classCallCheck(this, BaseColumn);

              this.onDrawCell = this.onDrawCell.bind(this); //
              //Promisecallback

              this._fadeinWhenCallbackInPromise = option === null || option === void 0 ? void 0 : option.fadeinWhenCallbackInPromise;
            }

            _createClass(BaseColumn, [{
              key: "fadeinWhenCallbackInPromise",
              get: function get() {
                return this._fadeinWhenCallbackInPromise;
              }
            }, {
              key: "StyleClass",
              get: function get() {
                return BaseStyle_1.BaseStyle;
              }
            }, {
              key: "onDrawCell",
              value: function onDrawCell(cellValue, info, context, grid) {
                var _this53 = this;

                var _a;

                var style = info.style,
                    getRecord = info.getRecord,
                    drawCellBase = info.drawCellBase;
                var helper = grid.getGridCanvasHelper();
                drawCellBase();
                var record = getRecord();
                var promise;

                if ((0, utils_1.isPromise)(record)) {
                  promise = record;
                } else if ((0, utils_1.isPromise)(cellValue)) {
                  promise = cellValue;
                } else {
                  var msg = info.getMessage();

                  if ((0, utils_1.isPromise)(msg)) {
                    promise = msg;
                  }
                } //


                if (promise) {
                  var start = Date.now();
                  return Promise.all([record, cellValue, promise.then(function () {
                    return cellValue;
                  }).then(function () {
                    return info.getMessage();
                  })]).then(function (_ref27) {
                    var record = _ref27[0],
                        val = _ref27[1],
                        message = _ref27[2];
                    var currentContext = context.toCurrentContext();
                    var drawRect = currentContext.getDrawRect();

                    if (!drawRect) {
                      return;
                    }

                    var time = Date.now() - start;

                    var drawInternal = function drawInternal() {
                      var currentContext = context.toCurrentContext();
                      var drawRect = currentContext.getDrawRect();

                      if (!drawRect) {
                        return;
                      }

                      var actStyle = styleContents.of(style, record, _this53.StyleClass);

                      _this53.drawInternal(_this53.convertInternal(val), currentContext, actStyle, helper, grid, info);

                      _this53.drawMessageInternal(message, currentContext, actStyle, helper, grid, info);

                      _this53.drawIndicatorsInternal(currentContext, actStyle, helper, grid, info);
                    };

                    if (!isFadeinWhenCallbackInPromise(_this53, grid)) {
                      drawInternal(); //
                    } else {
                      var col = context.col,
                          row = context.row;

                      if (time < 80) {
                        //80msPromiseCallback
                        fadeinMgr.margeAnimate(grid, col, row, context, drawInternal, drawCellBase);
                      } else {
                        //
                        fadeinMgr.animate(grid, col, row, context, drawInternal, drawCellBase);
                      }
                    }
                  });
                } else {
                  var actStyle = styleContents.of(style, record, this.StyleClass);
                  this.drawInternal(this.convertInternal(cellValue), context, actStyle, helper, grid, info);
                  this.drawMessageInternal(info.getMessage(), context, actStyle, helper, grid, info);
                  this.drawIndicatorsInternal(context, actStyle, helper, grid, info); //

                  var col = context.col,
                      row = context.row;
                  var stateKey = "".concat(col, ":").concat(row);
                  var cellState = (_a = grid[COLUMN_FADEIN_STATE_ID]) === null || _a === void 0 ? void 0 : _a.cells[stateKey];

                  if (cellState) {
                    var ctx = context.getContext();
                    ctx.globalAlpha = 1 - cellState.opacity;

                    try {
                      drawCellBase();
                    } finally {
                      ctx.globalAlpha = 1;
                    }
                  }

                  return undefined;
                }
              }
            }, {
              key: "convertInternal",
              value: function convertInternal(value) {
                return value != null ? value : "";
              }
            }, {
              key: "drawMessageInternal",
              value: function drawMessageInternal(message, context, style, helper, grid, info) {
                info.messageHandler.drawCellMessage(message, context, style, helper, grid, info);
              }
            }, {
              key: "drawIndicatorsInternal",
              value: function drawIndicatorsInternal(context, style, helper, grid, info) {
                var _a;

                var indicatorTopLeft = style.indicatorTopLeft,
                    indicatorTopRight = style.indicatorTopRight,
                    indicatorBottomRight = style.indicatorBottomRight,
                    indicatorBottomLeft = style.indicatorBottomLeft;

                for (var _i2 = 0, _arr = [[indicatorTopLeft, 0
                /* DrawIndicatorKind.topLeft */
                ], [indicatorTopRight, 1
                /* DrawIndicatorKind.topRight */
                ], [indicatorBottomRight, 2
                /* DrawIndicatorKind.bottomRight */
                ], [indicatorBottomLeft, 3
                /* DrawIndicatorKind.bottomLeft */
                ]]; _i2 < _arr.length; _i2++) {
                  var _arr$_i = _arr[_i2],
                      indicatorStyle = _arr$_i[0],
                      kind = _arr$_i[1];

                  if (indicatorStyle) {
                    (_a = (0, handlers_1.getDrawIndicator)(indicatorStyle)) === null || _a === void 0 ? void 0 : _a(context, indicatorStyle, kind, helper, grid, info);
                  }
                }
              }
            }, {
              key: "bindGridEvent",
              value: function bindGridEvent(_grid, _cellId) {
                return [];
              }
            }, {
              key: "getCopyCellValue",
              value: function getCopyCellValue(value, _grid, _cell) {
                return value;
              }
            }]);

            return BaseColumn;
          }();

          exports.BaseColumn = BaseColumn;
          /***/
        },

        /***/
        "./columns/type/BranchGraphColumn.js":
        /*!*******************************************!*\
          !*** ./columns/type/BranchGraphColumn.js ***!
          \*******************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsTypeBranchGraphColumnJs(module, exports, __nested_webpack_require_434875__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.BranchGraphColumn = void 0;

          var utils_1 = __nested_webpack_require_434875__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var BaseColumn_1 = __nested_webpack_require_434875__(
          /*! ./BaseColumn */
          "./columns/type/BaseColumn.js");

          var BranchGraphStyle_1 = __nested_webpack_require_434875__(
          /*! ../style/BranchGraphStyle */
          "./columns/style/BranchGraphStyle.js");

          var symbolManager_1 = __nested_webpack_require_434875__(
          /*! ../../internal/symbolManager */
          "./internal/symbolManager.js");

          var _ = (0, symbolManager_1.getBranchGraphColumnStateId)();

          function getAllColumnData(grid, field, callback) {
            var dataSource = grid.dataSource;
            var allData = [];
            var promise;

            var _loop4 = function _loop4(index) {
              var data = dataSource.getField(index, field);

              if ((0, utils_1.isPromise)(data)) {
                var dataIndex = allData.length;
                allData.push(undefined);

                if (!promise) {
                  promise = data.then(function (d) {
                    allData[dataIndex] = d;
                  });
                } else {
                  promise = promise.then(function () {
                    return data;
                  }).then(function (d) {
                    allData[dataIndex] = d;
                  });
                }
              } else {
                allData.push(data);
              }
            };

            for (var index = 0; index < dataSource.length; index++) {
              _loop4(index);
            }

            if (promise) {
              promise.then(function () {
                return callback(allData);
              });
            } else {
              callback(allData);
            }
          }

          var BranchLine = function BranchLine(_ref28) {
            var fromIndex = _ref28.fromIndex,
                toIndex = _ref28.toIndex,
                colorIndex = _ref28.colorIndex,
                point = _ref28.point;

            _classCallCheck(this, BranchLine);

            this.fromIndex = fromIndex;
            this.toIndex = toIndex;
            this.colorIndex = colorIndex;
            this.point = point;
          };

          var BranchPoint = /*#__PURE__*/function () {
            function BranchPoint(_ref29) {
              var index = _ref29.index,
                  _ref29$commit = _ref29.commit,
                  commit = _ref29$commit === void 0 ? false : _ref29$commit,
                  _ref29$lines = _ref29.lines,
                  lines = _ref29$lines === void 0 ? [] : _ref29$lines,
                  tag = _ref29.tag;

              _classCallCheck(this, BranchPoint);

              this.index = index;
              this.commit = commit;
              this.lines = lines;
              this.tag = tag;
            }

            _createClass(BranchPoint, null, [{
              key: "mergeLines",
              value: function mergeLines(lines) {
                var result = lines.filter(function (l) {
                  return l.fromIndex != null && l.toIndex != null;
                });
                var fromList = lines.filter(function (l) {
                  return l.fromIndex != null && l.toIndex == null;
                });
                var toList = lines.filter(function (l) {
                  return l.fromIndex == null && l.toIndex != null;
                });
                fromList.forEach(function (f) {
                  for (var i = 0; i < toList.length; i++) {
                    var t = toList[i];

                    if (t.point) {
                      continue;
                    }

                    if (f.colorIndex === t.colorIndex) {
                      f.toIndex = t.toIndex;
                      toList.splice(i, 1);
                      break;
                    }
                  }

                  result.push(f);
                });
                return result.concat(toList);
              }
            }, {
              key: "merge",
              value: function merge(a, b) {
                if (!a) {
                  return b;
                }

                return new BranchPoint({
                  index: a.index,
                  commit: a.commit || b.commit,
                  lines: BranchPoint.mergeLines(a.lines.concat(b.lines)),
                  tag: a.tag || b.tag
                });
              }
            }]);

            return BranchPoint;
          }();

          function joinLine(timeline, branchIndex) {
            var reverse = _toConsumableArray(timeline).reverse();

            for (var i = 0; i < reverse.length; i++) {
              var f = reverse[i][branchIndex];

              if (f) {
                f.lines = BranchPoint.mergeLines(f.lines.concat([new BranchLine({
                  toIndex: branchIndex,
                  colorIndex: branchIndex
                })]));

                for (var j = 0; j < i; j++) {
                  var tl = reverse[j];
                  tl[branchIndex] = new BranchPoint({
                    index: branchIndex,
                    lines: [new BranchLine({
                      fromIndex: branchIndex,
                      toIndex: branchIndex,
                      colorIndex: branchIndex
                    })]
                  });
                }

                return true;
              }
            }

            return false;
          }

          function branch(_ref30, from, to) {
            var timeline = _ref30.timeline,
                branches = _ref30.branches;
            var fromIndex = from != null ? branches.indexOf(from) : -1;
            var toIndex = branches.indexOf(to);

            if (toIndex < 0) {
              toIndex = branches.length;
              branches.push(to);
            }

            function findBranchRootIndex() {
              for (var index = timeline.length - 1; index >= 0; index--) {
                var tl = timeline[index];
                var _from = tl[fromIndex];

                if (_from && _from.commit) {
                  return index;
                }
              }

              return -1;
            }

            if (fromIndex < 0) {
              return new BranchPoint({
                index: toIndex
              });
            } else {
              var fromTargetIndex = findBranchRootIndex();

              if (fromTargetIndex === -1) {
                return null;
              }

              var branchTargetFromIndex = fromTargetIndex + 1;
              var branchPoint = new BranchPoint({
                index: toIndex,
                lines: [new BranchLine({
                  fromIndex: fromIndex,
                  colorIndex: toIndex
                })]
              });
              var point;
              var result = null;

              if (branchTargetFromIndex < timeline.length) {
                var targetLine = timeline[branchTargetFromIndex];
                point = targetLine[toIndex] = BranchPoint.merge(targetLine[toIndex], branchPoint);
              } else {
                point = branchPoint;
                result = branchPoint;
              }

              var _from2 = timeline[fromTargetIndex][fromIndex];
              _from2.lines = BranchPoint.mergeLines(_from2.lines.concat([new BranchLine({
                toIndex: toIndex,
                colorIndex: toIndex,
                point: point
              })]));
              return result;
            }
          }

          function commit(_ref31, name) {
            var timeline = _ref31.timeline,
                branches = _ref31.branches;
            var index = branches.indexOf(name);

            if (index < 0) {
              return null;
            }

            var result = new BranchPoint({
              index: index,
              commit: true
            });

            if (joinLine(timeline, index)) {
              result.lines = BranchPoint.mergeLines(result.lines.concat([new BranchLine({
                fromIndex: index,
                colorIndex: index
              })]));
            }

            return result;
          }

          function commitTag(_ref32, name, tag) {
            var branches = _ref32.branches;
            var index = branches.indexOf(name);

            if (index < 0) {
              index = branches.length;
              branches.push(name);
            }

            return new BranchPoint({
              index: index,
              tag: tag
            });
          }

          function commitMerge(_ref33, from, to) {
            var timeline = _ref33.timeline,
                branches = _ref33.branches;
            var fromIndex = branches.indexOf(from);
            var toIndex = branches.indexOf(to);

            if (toIndex < 0 || fromIndex < 0) {
              return new BranchPoint({
                index: toIndex,
                commit: true
              });
            }

            var result = new BranchPoint({
              index: toIndex,
              commit: true,
              lines: [new BranchLine({
                fromIndex: fromIndex,
                colorIndex: fromIndex
              }), new BranchLine({
                fromIndex: toIndex,
                colorIndex: toIndex
              })]
            });

            var fromList = _toConsumableArray(timeline);

            var fromTargetLine = fromList.pop();

            if (fromTargetLine) {
              fromTargetLine[fromIndex] = BranchPoint.merge(fromTargetLine[fromIndex], new BranchPoint({
                index: toIndex,
                lines: [new BranchLine({
                  toIndex: toIndex,
                  colorIndex: fromIndex
                })]
              }));
            }

            if (joinLine(fromList, fromIndex) && fromTargetLine) {
              fromTargetLine[fromIndex].lines = BranchPoint.mergeLines(fromTargetLine[fromIndex].lines.concat([new BranchLine({
                fromIndex: fromIndex,
                colorIndex: fromIndex
              })]));
            }

            joinLine(timeline, toIndex);
            return result;
          }

          function calcCommand(info, command) {
            var timeline = info.timeline;
            var timelineData = []; // const last = timeline.length > 0 ? timeline[timeline.length - 1] : null;

            var commands = Array.isArray(command) ? command : [command];
            commands.forEach(function (cmd) {
              if (!cmd) {
                return;
              }

              var point;

              if (cmd.command === "branch") {
                var from = utils_1.obj.isObject(cmd.branch) ? cmd.branch.from : null;
                var to = utils_1.obj.isObject(cmd.branch) ? cmd.branch.to : cmd.branch;
                point = branch(info, from, to);
              } else if (cmd.command === "commit") {
                var _branch = cmd.branch;
                point = commit(info, _branch);
              } else if (cmd.command === "merge") {
                var _cmd$branch = cmd.branch,
                    _from3 = _cmd$branch.from,
                    _to = _cmd$branch.to;
                point = commitMerge(info, _from3, _to);
              } else if (cmd.command === "tag") {
                var _branch2 = cmd.branch,
                    tag = cmd.tag;
                point = commitTag(info, _branch2, tag);
              }

              if (point && point.index > -1) {
                timelineData[point.index] = BranchPoint.merge(timelineData[point.index], point);
              }
            });
            timeline.push(timelineData);
          }

          function calcBranchesInfo(start, grid, field) {
            var result = {
              branches: [],
              timeline: []
            };
            getAllColumnData(grid, field, function (data) {
              if (start !== "top") {
                data = _toConsumableArray(data).reverse();
              }

              data.forEach(function (command) {
                calcCommand(result, command);
              });
            });
            return result;
          }

          function calcBranchXPoints(ctx, left, width, radius, branches, timeline) {
            var w = Math.max(width / branches.length + 1, 5);
            timeline.forEach(function (tl) {
              tl.forEach(function (p, index) {
                if (index <= 0) {
                  // 
                  return;
                }

                if (p.tag) {
                  var textWidth = ctx.measureText(p.tag).width;

                  if (w * index + radius * 2 + 4 + textWidth > width) {
                    w = Math.max((width - radius * 2 - 4 - textWidth) / index, 5);
                  }
                }
              });
            });
            var result = [];
            var x = left;
            branches.forEach(function () {
              result.push(Math.ceil(x + radius));
              x += w;
            });
            return result;
          }

          function renderMerge(grid, ctx, x, y, upLineIndex, downLineIndex, colorIndex, _ref34, _ref35) {
            var branchXPoints = _ref34.branchXPoints,
                branchColors = _ref34.branchColors,
                branchLineWidth = _ref34.branchLineWidth,
                mergeStyle = _ref34.mergeStyle;
            var col = _ref35.col,
                row = _ref35.row,
                branches = _ref35.branches;

            if (upLineIndex != null || downLineIndex != null) {
              ctx.strokeStyle = (0, utils_1.getOrApply)(branchColors, branches[colorIndex], colorIndex);
              ctx.lineWidth = branchLineWidth;
              ctx.lineCap = "round";
              ctx.beginPath();

              if (upLineIndex != null) {
                var upX = branchXPoints[upLineIndex];
                var upRect = grid.getCellRelativeRect(col, row - 1);
                var upY = upRect.top + upRect.height / 2;
                ctx.moveTo(upX, upY);

                if (mergeStyle === "bezier") {
                  ctx.bezierCurveTo(upX, (y + upY) / 2, x, (y + upY) / 2, x, y);
                } else {
                  ctx.lineTo(x, y);
                }
              } else {
                ctx.moveTo(x, y);
              }

              if (downLineIndex != null) {
                var downX = branchXPoints[downLineIndex];
                var downRect = grid.getCellRelativeRect(col, row + 1);
                var downY = downRect.top + downRect.height / 2;

                if (mergeStyle === "bezier") {
                  ctx.bezierCurveTo(x, (y + downY) / 2, downX, (y + downY) / 2, downX, downY);
                } else {
                  ctx.lineTo(downX, downY);
                }
              }

              ctx.stroke();
            }
          }
          /**
           * BranchGraphColumn
           *
           * Data commands
           * - master branch or orphan branch
           *
           * ```js
           * {
           * 	command: 'branch',
           * 	branch: 'branch name A',
           * }
           * ```
           *
           * - commit
           *
           * ```js
           * {
           * 	command: 'commit',
           * 	branch: 'branch name A'
           * }
           * ```
           *
           * - branch
           *
           * ```js
           * {
           * 	command: 'branch',
           * 	branch: {
           * 		from: 'branch name A',
           * 		to: 'branch name B'
           * 	}
           * }
           * ```
           *
           * - merge
           *
           * ```js
           * {
           * 	command: 'merge',
           * 	branch: {
           * 		from: 'branch name B',
           * 		to: 'branch name A'
           * 	}
           * }
           * ```
           *
           * - tag
           *
           * ```js
           * {
           * 	command: 'tag',
           * 	branch: 'branch name A',
           * 	tag: 'tag name'
           * }
           * ```
           *
           * @memberof cheetahGrid.columns.type
           */


          var BranchGraphColumn = /*#__PURE__*/function (_BaseColumn_1$BaseCol) {
            _inherits(BranchGraphColumn, _BaseColumn_1$BaseCol);

            var _super34 = _createSuper(BranchGraphColumn);

            function BranchGraphColumn() {
              var _this54;

              var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, BranchGraphColumn);

              _this54 = _super34.call(this, option);
              _this54._start = option.start || "bottom";
              _this54._cache = option.cache != null ? option.cache : false;
              return _this54;
            }

            _createClass(BranchGraphColumn, [{
              key: "StyleClass",
              get: function get() {
                return BranchGraphStyle_1.BranchGraphStyle;
              }
            }, {
              key: "clearCache",
              value: function clearCache(grid) {
                var internal = grid;
                delete internal[_];
              }
            }, {
              key: "onDrawCell",
              value: function onDrawCell(cellValue, info, context, grid) {
                if (this._cache) {
                  var state = grid[_] || (grid[_] = new Map());
                  var col = context.col,
                      row = context.row;
                  var field = grid.getField(col, row);

                  if (!state.has(field)) {
                    state.set(field, calcBranchesInfo(this._start, grid, field));
                  }
                }

                return _get(_getPrototypeOf(BranchGraphColumn.prototype), "onDrawCell", this).call(this, cellValue, info, context, grid);
              }
            }, {
              key: "clone",
              value: function clone() {
                return new BranchGraphColumn(this);
              }
            }, {
              key: "start",
              get: function get() {
                return this._start;
              }
            }, {
              key: "cache",
              get: function get() {
                return this._cache;
              }
            }, {
              key: "drawInternal",
              value: function drawInternal(_value, context, style, helper, grid, _ref36) {
                var drawCellBase = _ref36.drawCellBase;

                var _a, _b;

                var col = context.col,
                    row = context.row;
                var field = grid.getField(col, row);

                var _ref37 = (_b = this._cache ? (_a = grid[_]) === null || _a === void 0 ? void 0 : _a.get(field) : null) !== null && _b !== void 0 ? _b : calcBranchesInfo(this._start, grid, field),
                    timeline = _ref37.timeline,
                    branches = _ref37.branches;

                var _ref38 = this._start !== "top" ? {
                  upLineIndexKey: "toIndex",
                  downLineIndexKey: "fromIndex"
                } : {
                  upLineIndexKey: "fromIndex",
                  downLineIndexKey: "toIndex"
                },
                    upLineIndexKey = _ref38.upLineIndexKey,
                    downLineIndexKey = _ref38.downLineIndexKey;

                var data = this._start !== "top" ? timeline[timeline.length - (row - grid.frozenRowCount) - 1] : timeline[row - grid.frozenRowCount];
                var branchColors = style.branchColors,
                    branchLineWidth = style.branchLineWidth,
                    circleSize = style.circleSize,
                    mergeStyle = style.mergeStyle,
                    margin = style.margin,
                    bgColor = style.bgColor,
                    visibility = style.visibility;

                if (bgColor) {
                  drawCellBase({
                    bgColor: bgColor
                  });
                }

                if (visibility === "hidden") {
                  return;
                }

                var rect = context.getRect();
                var radius = circleSize / 2;
                var width = rect.width - margin * 2;
                helper.drawWithClip(context, function (ctx) {
                  ctx.textAlign = "left";
                  ctx.textBaseline = "middle";
                  var branchXPoints = calcBranchXPoints(ctx, rect.left + margin, width, radius, branches, timeline);
                  var y = rect.top + rect.height / 2; // draw join lines

                  data.map(function (point, index) {
                    return point ? point.lines.map(function (line) {
                      return {
                        colorIndex: line.colorIndex,
                        upLineIndex: line[upLineIndexKey],
                        downLineIndex: line[downLineIndexKey],
                        pointIndex: index
                      };
                    }) : [];
                  }).reduce(function (p, c) {
                    return p.concat(c);
                  }, []) // flatMap
                  // order of overlap
                  .sort(function (a, b) {
                    return b.colorIndex - a.colorIndex;
                  }).forEach(function (line) {
                    var x = branchXPoints[line.pointIndex];
                    renderMerge(grid, ctx, x, y, line.upLineIndex, line.downLineIndex, line.colorIndex, {
                      margin: margin,
                      branchXPoints: branchXPoints,
                      branchLineWidth: branchLineWidth,
                      branchColors: branchColors,
                      mergeStyle: mergeStyle
                    }, {
                      width: width,
                      col: col,
                      row: row,
                      branches: branches
                    });
                  }); // draw commit points

                  data.forEach(function (p, index) {
                    if (p && p.commit) {
                      var x = branchXPoints[index];
                      ctx.fillStyle = (0, utils_1.getOrApply)(branchColors, branches[index], index);
                      ctx.beginPath();
                      ctx.arc(x, y, radius, 0, Math.PI * 2, true);
                      ctx.fill();
                      ctx.closePath();
                    }
                  }); // draw tags

                  data.forEach(function (p, index) {
                    if (p && p.tag) {
                      ctx.fillStyle = (0, utils_1.getOrApply)(branchColors, branches[index], index);
                      ctx.fillText(p.tag, branchXPoints[index] + radius + 4, y);
                    }
                  });
                });
              }
            }]);

            return BranchGraphColumn;
          }(BaseColumn_1.BaseColumn);

          exports.BranchGraphColumn = BranchGraphColumn;
          /***/
        },

        /***/
        "./columns/type/ButtonColumn.js":
        /*!**************************************!*\
          !*** ./columns/type/ButtonColumn.js ***!
          \**************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsTypeButtonColumnJs(module, exports, __nested_webpack_require_458430__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.ButtonColumn = void 0;

          var utils = __importStar(__nested_webpack_require_458430__(
          /*! ./columnUtils */
          "./columns/type/columnUtils.js"));

          var ButtonStyle_1 = __nested_webpack_require_458430__(
          /*! ../style/ButtonStyle */
          "./columns/style/ButtonStyle.js");

          var Column_1 = __nested_webpack_require_458430__(
          /*! ./Column */
          "./columns/type/Column.js");

          var utils_1 = __nested_webpack_require_458430__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var symbolManager_1 = __nested_webpack_require_458430__(
          /*! ../../internal/symbolManager */
          "./internal/symbolManager.js");

          var BUTTON_COLUMN_STATE_ID = (0, symbolManager_1.getButtonColumnStateId)();

          var ButtonColumn = /*#__PURE__*/function (_Column_1$Column) {
            _inherits(ButtonColumn, _Column_1$Column);

            var _super35 = _createSuper(ButtonColumn);

            function ButtonColumn() {
              var _this55;

              var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, ButtonColumn);

              _this55 = _super35.call(this, option);
              _this55._caption = option.caption;
              return _this55;
            }

            _createClass(ButtonColumn, [{
              key: "StyleClass",
              get: function get() {
                return ButtonStyle_1.ButtonStyle;
              }
            }, {
              key: "caption",
              get: function get() {
                return this._caption;
              }
            }, {
              key: "withCaption",
              value: function withCaption(caption) {
                var c = this.clone();
                c._caption = caption;
                return c;
              }
            }, {
              key: "clone",
              value: function clone() {
                return new ButtonColumn(this);
              }
            }, {
              key: "convertInternal",
              value: function convertInternal(value) {
                return this._caption || _get(_getPrototypeOf(ButtonColumn.prototype), "convertInternal", this).call(this, value);
              }
            }, {
              key: "getCopyCellValue",
              value: function getCopyCellValue(value) {
                return this._caption || value;
              }
            }, {
              key: "drawInternal",
              value: function drawInternal(value, context, style, helper, grid, _ref39) {
                var drawCellBase = _ref39.drawCellBase,
                    getIcon = _ref39.getIcon;
                var textAlign = style.textAlign,
                    textBaseline = style.textBaseline,
                    bgColor = style.bgColor,
                    color = style.color,
                    buttonBgColor = style.buttonBgColor,
                    font = style.font,
                    padding = style.padding,
                    textOverflow = style.textOverflow,
                    visibility = style.visibility;

                if (bgColor) {
                  drawCellBase({
                    bgColor: bgColor
                  });
                }

                if (visibility === "hidden") {
                  return;
                }

                var textValue = value != null ? String(value) : "";
                helper.testFontLoad(font, textValue, context);
                var col = context.col,
                    row = context.row;
                var range = grid.getCellRange(col, row);
                var active = false;
                var state = grid[BUTTON_COLUMN_STATE_ID];

                if (state) {
                  if (state.mouseActiveCell && (0, utils_1.cellInRange)(range, state.mouseActiveCell.col, state.mouseActiveCell.row)) {
                    active = true;
                  } else {
                    var _context$getSelection4 = context.getSelection(),
                        select = _context$getSelection4.select;

                    if ((0, utils_1.cellInRange)(range, select.col, select.row)) {
                      active = true;
                    }
                  }
                }

                utils.loadIcons(getIcon(), context, helper, function (icons, context) {
                  helper.button(textValue, context, {
                    textAlign: textAlign,
                    textBaseline: textBaseline,
                    bgColor: buttonBgColor,
                    color: color,
                    font: font,
                    padding: padding,
                    shadow: active ? {
                      color: "rgba(0, 0, 0, 0.48)",
                      blur: 6,
                      offsetY: 3
                    } : {},
                    textOverflow: textOverflow,
                    icons: icons
                  });
                });
              }
            }]);

            return ButtonColumn;
          }(Column_1.Column);

          exports.ButtonColumn = ButtonColumn;
          /***/
        },

        /***/
        "./columns/type/CheckColumn.js":
        /*!*************************************!*\
          !*** ./columns/type/CheckColumn.js ***!
          \*************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsTypeCheckColumnJs(module, exports, __nested_webpack_require_465469__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.CheckColumn = void 0;

          var BaseColumn_1 = __nested_webpack_require_465469__(
          /*! ./BaseColumn */
          "./columns/type/BaseColumn.js");

          var CheckStyle_1 = __nested_webpack_require_465469__(
          /*! ../style/CheckStyle */
          "./columns/style/CheckStyle.js");

          var symbolManager_1 = __nested_webpack_require_465469__(
          /*! ../../internal/symbolManager */
          "./internal/symbolManager.js");

          var utils_1 = __nested_webpack_require_465469__(
          /*! ../utils */
          "./columns/utils/index.js");

          var CHECK_COLUMN_STATE_ID = (0, symbolManager_1.getCheckColumnStateId)();

          var CheckColumn = /*#__PURE__*/function (_BaseColumn_1$BaseCol2) {
            _inherits(CheckColumn, _BaseColumn_1$BaseCol2);

            var _super36 = _createSuper(CheckColumn);

            function CheckColumn() {
              _classCallCheck(this, CheckColumn);

              return _super36.apply(this, arguments);
            }

            _createClass(CheckColumn, [{
              key: "StyleClass",
              get: function get() {
                return CheckStyle_1.CheckStyle;
              }
            }, {
              key: "clone",
              value: function clone() {
                return new CheckColumn(this);
              }
            }, {
              key: "convertInternal",
              value: function convertInternal(value) {
                return (0, utils_1.toBoolean)(value);
              }
            }, {
              key: "drawInternal",
              value: function drawInternal(value, context, style, helper, grid, _ref40) {
                var drawCellBase = _ref40.drawCellBase;

                var _a;

                var textAlign = style.textAlign,
                    textBaseline = style.textBaseline,
                    padding = style.padding,
                    borderColor = style.borderColor,
                    checkBgColor = style.checkBgColor,
                    uncheckBgColor = style.uncheckBgColor,
                    bgColor = style.bgColor,
                    visibility = style.visibility;

                if (bgColor) {
                  drawCellBase({
                    bgColor: bgColor
                  });
                }

                if (visibility === "hidden") {
                  return;
                }

                var col = context.col,
                    row = context.row;
                var range = grid.getCellRange(col, row);
                var cellKey = "".concat(range.start.col, ":").concat(range.start.row);
                var elapsed = (_a = grid[CHECK_COLUMN_STATE_ID]) === null || _a === void 0 ? void 0 : _a.elapsed[cellKey];
                var opt = {
                  textAlign: textAlign,
                  textBaseline: textBaseline,
                  borderColor: borderColor,
                  checkBgColor: checkBgColor,
                  uncheckBgColor: uncheckBgColor,
                  padding: padding
                };

                if (elapsed != null) {
                  opt.animElapsedTime = elapsed;
                }

                helper.checkbox(value, context, opt);
              }
            }]);

            return CheckColumn;
          }(BaseColumn_1.BaseColumn);

          exports.CheckColumn = CheckColumn;
          /***/
        },

        /***/
        "./columns/type/Column.js":
        /*!********************************!*\
          !*** ./columns/type/Column.js ***!
          \********************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsTypeColumnJs(module, exports, __nested_webpack_require_469338__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.Column = void 0;

          var utils = __importStar(__nested_webpack_require_469338__(
          /*! ./columnUtils */
          "./columns/type/columnUtils.js"));

          var BaseColumn_1 = __nested_webpack_require_469338__(
          /*! ./BaseColumn */
          "./columns/type/BaseColumn.js");

          var Style_1 = __nested_webpack_require_469338__(
          /*! ../style/Style */
          "./columns/style/Style.js");

          var Column = /*#__PURE__*/function (_BaseColumn_1$BaseCol3) {
            _inherits(Column, _BaseColumn_1$BaseCol3);

            var _super37 = _createSuper(Column);

            function Column() {
              _classCallCheck(this, Column);

              return _super37.apply(this, arguments);
            }

            _createClass(Column, [{
              key: "StyleClass",
              get: function get() {
                return Style_1.Style;
              }
            }, {
              key: "clone",
              value: function clone() {
                return new Column(this);
              }
            }, {
              key: "drawInternal",
              value: function drawInternal(value, context, style, helper, _grid, _ref41) {
                var drawCellBase = _ref41.drawCellBase,
                    getIcon = _ref41.getIcon;
                var textAlign = style.textAlign,
                    textBaseline = style.textBaseline,
                    color = style.color,
                    font = style.font,
                    bgColor = style.bgColor,
                    padding = style.padding,
                    textOverflow = style.textOverflow,
                    visibility = style.visibility;

                if (bgColor) {
                  drawCellBase({
                    bgColor: bgColor
                  });
                }

                if (visibility === "hidden") {
                  return;
                }

                var textValue = value != null ? String(value) : "";
                helper.testFontLoad(font, textValue, context);
                utils.loadIcons(getIcon(), context, helper, function (icons, context) {
                  helper.text(textValue, context, {
                    textAlign: textAlign,
                    textBaseline: textBaseline,
                    color: color,
                    font: font,
                    padding: padding,
                    textOverflow: textOverflow,
                    icons: icons
                  });
                });
              }
            }]);

            return Column;
          }(BaseColumn_1.BaseColumn);

          exports.Column = Column;
          /***/
        },

        /***/
        "./columns/type/IconColumn.js":
        /*!************************************!*\
          !*** ./columns/type/IconColumn.js ***!
          \************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsTypeIconColumnJs(module, exports, __nested_webpack_require_473904__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.IconColumn = void 0;

          var icons = __importStar(__nested_webpack_require_473904__(
          /*! ../../internal/icons */
          "./internal/icons.js"));

          var Column_1 = __nested_webpack_require_473904__(
          /*! ./Column */
          "./columns/type/Column.js");

          var IconStyle_1 = __nested_webpack_require_473904__(
          /*! ../style/IconStyle */
          "./columns/style/IconStyle.js");

          function repeatArray(val, count) {
            if (count === Infinity) {
              count = 0;
            }

            var a = [];

            for (var i = 0; i < count; i++) {
              a.push(val);
            }

            return a;
          }

          var IconColumn = /*#__PURE__*/function (_Column_1$Column2) {
            _inherits(IconColumn, _Column_1$Column2);

            var _super38 = _createSuper(IconColumn);

            function IconColumn() {
              var _this56;

              var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, IconColumn);

              _this56 = _super38.call(this, option);
              _this56._tagName = option.tagName || "i";
              _this56._className = option.className;
              _this56._content = option.content;
              _this56._name = option.name;
              _this56._iconWidth = option.iconWidth;
              return _this56;
            }

            _createClass(IconColumn, [{
              key: "StyleClass",
              get: function get() {
                return IconStyle_1.IconStyle;
              }
            }, {
              key: "clone",
              value: function clone() {
                return new IconColumn(this);
              }
            }, {
              key: "tagName",
              get: function get() {
                return this._tagName;
              }
            }, {
              key: "className",
              get: function get() {
                return this._className;
              }
            }, {
              key: "content",
              get: function get() {
                return this._content;
              }
            }, {
              key: "name",
              get: function get() {
                return this._name;
              }
            }, {
              key: "iconWidth",
              get: function get() {
                return this._iconWidth;
              }
            }, {
              key: "drawInternal",
              value: function drawInternal(value, context, style, helper, grid, info) {
                var num = Number(value);

                if (!isNaN(num)) {
                  var icon = {};
                  icons.iconPropKeys.forEach(function (k) {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    icon[k] = style[k];
                  });
                  icon.className = this._className;
                  icon.tagName = this._tagName;

                  if (this._content) {
                    icon.content = this._content;
                  }

                  icon.name = this._name;

                  if (this._iconWidth) {
                    icon.width = this._iconWidth;
                  }

                  info.getIcon = function () {
                    return repeatArray(icon, num);
                  };
                } else {
                  info.getIcon = function () {
                    return null;
                  };
                }

                _get(_getPrototypeOf(IconColumn.prototype), "drawInternal", this).call(this, "", context, style, helper, grid, info);
              }
            }]);

            return IconColumn;
          }(Column_1.Column);

          exports.IconColumn = IconColumn;
          /***/
        },

        /***/
        "./columns/type/ImageColumn.js":
        /*!*************************************!*\
          !*** ./columns/type/ImageColumn.js ***!
          \*************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsTypeImageColumnJs(module, exports, __nested_webpack_require_479646__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.ImageColumn = void 0;

          var BaseColumn_1 = __nested_webpack_require_479646__(
          /*! ./BaseColumn */
          "./columns/type/BaseColumn.js");

          var ImageStyle_1 = __nested_webpack_require_479646__(
          /*! ../style/ImageStyle */
          "./columns/style/ImageStyle.js");

          var Rect_1 = __nested_webpack_require_479646__(
          /*! ../../internal/Rect */
          "./internal/Rect.js");

          var canvases_1 = __nested_webpack_require_479646__(
          /*! ../../internal/canvases */
          "./internal/canvases.js");

          var imgs_1 = __nested_webpack_require_479646__(
          /*! ../../internal/imgs */
          "./internal/imgs.js");

          var MAX_LRU_CACHE_SIZE = 50;

          function getImage(url) {
            return (0, imgs_1.getCacheOrLoad)("ImageColumn", MAX_LRU_CACHE_SIZE, url);
          }

          function calcKeepAspectRatioSize(width, height, maxWidth, maxHeight) {
            var newWidth = width;
            var newHeight = height;

            if (newWidth > maxWidth) {
              newWidth = maxWidth;
              newHeight = newWidth * height / width;
            }

            if (newHeight > maxHeight) {
              newHeight = maxHeight;
              newWidth = newHeight * width / height;
            }

            return {
              width: newWidth,
              height: newHeight
            };
          }

          var ImageColumn = /*#__PURE__*/function (_BaseColumn_1$BaseCol4) {
            _inherits(ImageColumn, _BaseColumn_1$BaseCol4);

            var _super39 = _createSuper(ImageColumn);

            function ImageColumn() {
              _classCallCheck(this, ImageColumn);

              return _super39.apply(this, arguments);
            }

            _createClass(ImageColumn, [{
              key: "StyleClass",
              get: function get() {
                return ImageStyle_1.ImageStyle;
              }
            }, {
              key: "onDrawCell",
              value: function onDrawCell(cellValue, info, context, grid) {
                return _get(_getPrototypeOf(ImageColumn.prototype), "onDrawCell", this).call(this, getImage(cellValue), info, context, grid);
              }
            }, {
              key: "clone",
              value: function clone() {
                return new ImageColumn(this);
              }
            }, {
              key: "drawInternal",
              value: function drawInternal(value, context, style, helper, _grid, _ref42) {
                var drawCellBase = _ref42.drawCellBase;
                var textAlign = style.textAlign,
                    textBaseline = style.textBaseline,
                    padding = style.padding,
                    margin = style.margin,
                    bgColor = style.bgColor,
                    visibility = style.visibility;

                if (bgColor) {
                  drawCellBase({
                    bgColor: bgColor
                  });
                }

                if (visibility === "hidden") {
                  return;
                }

                if (value) {
                  helper.drawWithClip(context, function (ctx) {
                    ctx.textAlign = textAlign;
                    ctx.textBaseline = textBaseline;
                    var rect = context.getRect();

                    if (padding) {
                      var paddingNums = helper.toBoxPixelArray(padding, context, undefined
                      /* font */
                      );
                      var left = rect.left + paddingNums[3];
                      var top = rect.top + paddingNums[0];
                      var width = rect.width - paddingNums[1] - paddingNums[3];
                      var height = rect.height - paddingNums[0] - paddingNums[2];
                      rect = new Rect_1.Rect(left, top, width, height);
                    }

                    if (style.imageSizing === "keep-aspect-ratio") {
                      var _calcKeepAspectRatioS = calcKeepAspectRatioSize(value.width, value.height, rect.width - margin * 2, rect.height - margin * 2),
                          _width = _calcKeepAspectRatioS.width,
                          _height = _calcKeepAspectRatioS.height;

                      var pos = (0, canvases_1.calcStartPosition)(ctx, rect, _width, _height, {
                        offset: margin
                      });
                      ctx.drawImage(value, 0, 0, value.width, value.height, pos.x, pos.y, _width, _height);
                    } else {
                      ctx.drawImage(value, 0, 0, value.width, value.height, rect.left + margin, rect.top + margin, rect.width - margin * 2, rect.height - margin * 2);
                    }
                  });
                }
              }
            }]);

            return ImageColumn;
          }(BaseColumn_1.BaseColumn);

          exports.ImageColumn = ImageColumn;
          /***/
        },

        /***/
        "./columns/type/MenuColumn.js":
        /*!************************************!*\
          !*** ./columns/type/MenuColumn.js ***!
          \************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsTypeMenuColumnJs(module, exports, __nested_webpack_require_485105__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.MenuColumn = void 0;

          var utils = __importStar(__nested_webpack_require_485105__(
          /*! ./columnUtils */
          "./columns/type/columnUtils.js"));

          var BaseColumn_1 = __nested_webpack_require_485105__(
          /*! ./BaseColumn */
          "./columns/type/BaseColumn.js");

          var MenuStyle_1 = __nested_webpack_require_485105__(
          /*! ../style/MenuStyle */
          "./columns/style/MenuStyle.js");

          var menu_items_1 = __nested_webpack_require_485105__(
          /*! ../../internal/menu-items */
          "./internal/menu-items.js");

          var MenuColumn = /*#__PURE__*/function (_BaseColumn_1$BaseCol5) {
            _inherits(MenuColumn, _BaseColumn_1$BaseCol5);

            var _super40 = _createSuper(MenuColumn);

            function MenuColumn() {
              var _this57;

              var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, MenuColumn);

              _this57 = _super40.call(this, option);
              _this57._options = (0, menu_items_1.normalize)(option.options);
              return _this57;
            }

            _createClass(MenuColumn, [{
              key: "StyleClass",
              get: function get() {
                return MenuStyle_1.MenuStyle;
              }
            }, {
              key: "clone",
              value: function clone() {
                return new MenuColumn(this);
              }
            }, {
              key: "options",
              get: function get() {
                return this._options;
              }
            }, {
              key: "withOptions",
              value: function withOptions(options) {
                var c = this.clone();
                c._options = (0, menu_items_1.normalize)(options);
                return c;
              }
            }, {
              key: "drawInternal",
              value: function drawInternal(value, context, style, helper, _grid, _ref43) {
                var drawCellBase = _ref43.drawCellBase,
                    getIcon = _ref43.getIcon;
                var textAlign = style.textAlign,
                    textBaseline = style.textBaseline,
                    font = style.font,
                    bgColor = style.bgColor,
                    padding = style.padding,
                    textOverflow = style.textOverflow,
                    appearance = style.appearance,
                    visibility = style.visibility;
                var color = style.color;

                if (bgColor) {
                  drawCellBase({
                    bgColor: bgColor
                  });
                }

                if (visibility === "hidden") {
                  return;
                }

                var convertedValue = this._convertInternal(value);

                var text = convertedValue != null ? String(convertedValue) : "";
                helper.testFontLoad(font, text, context);
                utils.loadIcons(getIcon(), context, helper, function (icons, context) {
                  var basePadding = helper.toBoxPixelArray(padding || 0, context, font);
                  var textPadding = basePadding.slice(0);
                  textPadding[1] += 26; // icon padding

                  var iconPadding = basePadding.slice(0);
                  iconPadding[1] += 8;

                  if (color == null && (value == null || value === "")) {
                    color = "rgba(0, 0, 0, .38)";
                  }

                  helper.text(text, context, {
                    textAlign: textAlign,
                    textBaseline: textBaseline,
                    color: color,
                    font: font,
                    padding: textPadding,
                    textOverflow: textOverflow,
                    icons: icons
                  });

                  if (appearance === "menulist-button") {
                    // draw dropdown arrow icon
                    helper.text("", context, {
                      textAlign: "right",
                      textBaseline: textBaseline,
                      color: color,
                      font: font,
                      icons: [{
                        path: "M0 2 5 7 10 2z",
                        width: 10,
                        color: "rgba(0, 0, 0, .54)"
                      }],
                      padding: iconPadding
                    });
                  } else if (appearance !== "none") {
                    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                    console.warn("unsupported appearance:".concat(appearance));
                  }
                });
              }
            }, {
              key: "convertInternal",
              value: function convertInternal(value) {
                return value;
              }
            }, {
              key: "_convertInternal",
              value: function _convertInternal(value) {
                var options = this._options;

                for (var i = 0; i < options.length; i++) {
                  var option = options[i];

                  if (option.value === value) {
                    value = option.label;
                    break;
                  }
                }

                return _get(_getPrototypeOf(MenuColumn.prototype), "convertInternal", this).call(this, value);
              }
            }, {
              key: "getCopyCellValue",
              value: function getCopyCellValue(value) {
                return this._convertInternal(value);
              }
            }]);

            return MenuColumn;
          }(BaseColumn_1.BaseColumn);

          exports.MenuColumn = MenuColumn;
          /***/
        },

        /***/
        "./columns/type/MultilineTextColumn.js":
        /*!*********************************************!*\
          !*** ./columns/type/MultilineTextColumn.js ***!
          \*********************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsTypeMultilineTextColumnJs(module, exports, __nested_webpack_require_492817__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.MultilineTextColumn = void 0;

          var utils = __importStar(__nested_webpack_require_492817__(
          /*! ./columnUtils */
          "./columns/type/columnUtils.js"));

          var BaseColumn_1 = __nested_webpack_require_492817__(
          /*! ./BaseColumn */
          "./columns/type/BaseColumn.js");

          var MultilineTextStyle_1 = __nested_webpack_require_492817__(
          /*! ../style/MultilineTextStyle */
          "./columns/style/MultilineTextStyle.js");

          var MultilineTextColumn = /*#__PURE__*/function (_BaseColumn_1$BaseCol6) {
            _inherits(MultilineTextColumn, _BaseColumn_1$BaseCol6);

            var _super41 = _createSuper(MultilineTextColumn);

            function MultilineTextColumn() {
              var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, MultilineTextColumn);

              return _super41.call(this, option);
            }

            _createClass(MultilineTextColumn, [{
              key: "StyleClass",
              get: function get() {
                return MultilineTextStyle_1.MultilineTextStyle;
              }
            }, {
              key: "clone",
              value: function clone() {
                return new MultilineTextColumn(this);
              }
            }, {
              key: "drawInternal",
              value: function drawInternal(value, context, style, helper, _grid, _ref44) {
                var drawCellBase = _ref44.drawCellBase,
                    getIcon = _ref44.getIcon;
                var textAlign = style.textAlign,
                    textBaseline = style.textBaseline,
                    color = style.color,
                    font = style.font,
                    bgColor = style.bgColor,
                    padding = style.padding,
                    lineHeight = style.lineHeight,
                    autoWrapText = style.autoWrapText,
                    lineClamp = style.lineClamp,
                    textOverflow = style.textOverflow,
                    visibility = style.visibility;

                if (bgColor) {
                  drawCellBase({
                    bgColor: bgColor
                  });
                }

                if (visibility === "hidden") {
                  return;
                }

                var textValue = value != null ? String(value) : "";
                var lines = textValue.replace(/\r?\n/g, "\n").replace(/\r/g, "\n").split("\n");
                helper.testFontLoad(font, textValue, context);
                utils.loadIcons(getIcon(), context, helper, function (icons, context) {
                  helper.multilineText(lines, context, {
                    textAlign: textAlign,
                    textBaseline: textBaseline,
                    color: color,
                    font: font,
                    padding: padding,
                    lineHeight: lineHeight,
                    autoWrapText: autoWrapText,
                    lineClamp: lineClamp,
                    textOverflow: textOverflow,
                    icons: icons
                  });
                });
              }
            }]);

            return MultilineTextColumn;
          }(BaseColumn_1.BaseColumn);

          exports.MultilineTextColumn = MultilineTextColumn;
          /***/
        },

        /***/
        "./columns/type/NumberColumn.js":
        /*!**************************************!*\
          !*** ./columns/type/NumberColumn.js ***!
          \**************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsTypeNumberColumnJs(module, exports, __nested_webpack_require_498087__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.NumberColumn = void 0;

          var Column_1 = __nested_webpack_require_498087__(
          /*! ./Column */
          "./columns/type/Column.js");

          var NumberStyle_1 = __nested_webpack_require_498087__(
          /*! ../style/NumberStyle */
          "./columns/style/NumberStyle.js");

          var defaultFormat;

          var NumberColumn = /*#__PURE__*/function (_Column_1$Column3) {
            _inherits(NumberColumn, _Column_1$Column3);

            var _super42 = _createSuper(NumberColumn);

            function NumberColumn() {
              var _this58;

              var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, NumberColumn);

              _this58 = _super42.call(this, option);
              _this58._format = option.format;
              return _this58;
            }

            _createClass(NumberColumn, [{
              key: "StyleClass",
              get: function get() {
                return NumberStyle_1.NumberStyle;
              }
            }, {
              key: "clone",
              value: function clone() {
                return new NumberColumn(this);
              }
            }, {
              key: "format",
              get: function get() {
                return this._format;
              }
            }, {
              key: "withFormat",
              value: function withFormat(format) {
                var c = this.clone();
                c._format = format;
                return c;
              }
            }, {
              key: "convertInternal",
              value: function convertInternal(value) {
                var num = Number(value);

                if (isNaN(num)) {
                  var convertedValue = _get(_getPrototypeOf(NumberColumn.prototype), "convertInternal", this).call(this, value);

                  return convertedValue != null ? String(convertedValue) : "";
                }

                var format = this._format || NumberColumn.defaultFormat;
                return format.format(num);
              }
            }], [{
              key: "defaultFormat",
              get: function get() {
                return defaultFormat || (defaultFormat = new Intl.NumberFormat());
              },
              set: function set(fmt) {
                defaultFormat = fmt;
              }
              /**
               * @deprecated Use defaultFormat instead
               */

            }, {
              key: "defaultFotmat",
              get: function get() {
                return this.defaultFormat;
              }
              /**
               * @deprecated Use defaultFormat instead
               */
              ,
              set: function set(fmt) {
                this.defaultFormat = fmt;
              }
            }]);

            return NumberColumn;
          }(Column_1.Column);

          exports.NumberColumn = NumberColumn;
          /***/
        },

        /***/
        "./columns/type/PercentCompleteBarColumn.js":
        /*!**************************************************!*\
          !*** ./columns/type/PercentCompleteBarColumn.js ***!
          \**************************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsTypePercentCompleteBarColumnJs(module, exports, __nested_webpack_require_501671__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.PercentCompleteBarColumn = void 0;

          var utils_1 = __nested_webpack_require_501671__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var Column_1 = __nested_webpack_require_501671__(
          /*! ./Column */
          "./columns/type/Column.js");

          var PercentCompleteBarStyle_1 = __nested_webpack_require_501671__(
          /*! ../style/PercentCompleteBarStyle */
          "./columns/style/PercentCompleteBarStyle.js");

          var MARGIN = 2;

          var PercentCompleteBarColumn = /*#__PURE__*/function (_Column_1$Column4) {
            _inherits(PercentCompleteBarColumn, _Column_1$Column4);

            var _super43 = _createSuper(PercentCompleteBarColumn);

            function PercentCompleteBarColumn() {
              var _this59;

              var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, PercentCompleteBarColumn);

              _this59 = _super43.call(this, option);
              _this59._min = option.min || 0;
              _this59._max = option.max || _this59._min + 100;

              _this59._formatter = option.formatter || function (v) {
                return v;
              };

              return _this59;
            }

            _createClass(PercentCompleteBarColumn, [{
              key: "StyleClass",
              get: function get() {
                return PercentCompleteBarStyle_1.PercentCompleteBarStyle;
              }
            }, {
              key: "clone",
              value: function clone() {
                return new PercentCompleteBarColumn(this);
              }
            }, {
              key: "min",
              get: function get() {
                return this.min;
              }
            }, {
              key: "max",
              get: function get() {
                return this.max;
              }
            }, {
              key: "formatter",
              get: function get() {
                return this.formatter;
              }
            }, {
              key: "drawInternal",
              value: function drawInternal(value, context, style, helper, grid, info) {
                _get(_getPrototypeOf(PercentCompleteBarColumn.prototype), "drawInternal", this).call(this, this._formatter(value), context, style, helper, grid, info);

                var barColor = style.barColor,
                    barBgColor = style.barBgColor,
                    barHeight = style.barHeight,
                    visibility = style.visibility;

                if (visibility === "hidden") {
                  return;
                }

                var textValue = value != null ? String(value) : "";

                if (utils_1.str.endsWith(textValue, "%")) {
                  textValue = textValue.slice(0, -1);
                }

                var num = Number(textValue);

                if (isNaN(num)) {
                  return;
                }

                var rate = num < this._min ? 0 : num > this._max ? 1 : (num - this._min) / (this._max - this._min);
                helper.drawWithClip(context, function (ctx) {
                  var rect = context.getRect();
                  var barMaxWidth = rect.width - MARGIN * 2 - 1;
                  /**/

                  var barTop = rect.bottom - MARGIN - barHeight - 1;
                  /**/

                  var barLeft = rect.left + MARGIN;
                  ctx.fillStyle = (0, utils_1.getOrApply)(barBgColor, rate * 100) || "#f0f3f5";
                  ctx.beginPath();
                  ctx.rect(barLeft, barTop, barMaxWidth, barHeight);
                  ctx.fill();
                  var barSize = Math.min(barMaxWidth * rate, barMaxWidth);
                  ctx.fillStyle = (0, utils_1.getOrApply)(barColor, rate * 100) || "#20a8d8";
                  ctx.beginPath();
                  ctx.rect(barLeft, barTop, barSize, barHeight);
                  ctx.fill();
                });
              }
            }]);

            return PercentCompleteBarColumn;
          }(Column_1.Column);

          exports.PercentCompleteBarColumn = PercentCompleteBarColumn;
          /***/
        },

        /***/
        "./columns/type/RadioColumn.js":
        /*!*************************************!*\
          !*** ./columns/type/RadioColumn.js ***!
          \*************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsTypeRadioColumnJs(module, exports, __nested_webpack_require_506401__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.RadioColumn = void 0;

          var BaseColumn_1 = __nested_webpack_require_506401__(
          /*! ./BaseColumn */
          "./columns/type/BaseColumn.js");

          var RadioStyle_1 = __nested_webpack_require_506401__(
          /*! ../style/RadioStyle */
          "./columns/style/RadioStyle.js");

          var symbolManager_1 = __nested_webpack_require_506401__(
          /*! ../../internal/symbolManager */
          "./internal/symbolManager.js");

          var utils_1 = __nested_webpack_require_506401__(
          /*! ../utils */
          "./columns/utils/index.js");

          var RADIO_COLUMN_STATE_ID = (0, symbolManager_1.getRadioColumnStateId)();

          var RadioColumn = /*#__PURE__*/function (_BaseColumn_1$BaseCol7) {
            _inherits(RadioColumn, _BaseColumn_1$BaseCol7);

            var _super44 = _createSuper(RadioColumn);

            function RadioColumn() {
              _classCallCheck(this, RadioColumn);

              return _super44.apply(this, arguments);
            }

            _createClass(RadioColumn, [{
              key: "StyleClass",
              get: function get() {
                return RadioStyle_1.RadioStyle;
              }
            }, {
              key: "clone",
              value: function clone() {
                return new RadioColumn(this);
              }
            }, {
              key: "convertInternal",
              value: function convertInternal(value) {
                return (0, utils_1.toBoolean)(value);
              }
            }, {
              key: "drawInternal",
              value: function drawInternal(value, context, style, helper, grid, _ref45) {
                var drawCellBase = _ref45.drawCellBase;

                var _a;

                var textAlign = style.textAlign,
                    textBaseline = style.textBaseline,
                    padding = style.padding,
                    checkColor = style.checkColor,
                    uncheckBorderColor = style.uncheckBorderColor,
                    checkBorderColor = style.checkBorderColor,
                    uncheckBgColor = style.uncheckBgColor,
                    checkBgColor = style.checkBgColor,
                    bgColor = style.bgColor,
                    visibility = style.visibility;

                if (bgColor) {
                  drawCellBase({
                    bgColor: bgColor
                  });
                }

                if (visibility === "hidden") {
                  return;
                }

                var col = context.col,
                    row = context.row;
                var range = grid.getCellRange(col, row);
                var cellKey = "".concat(range.start.col, ":").concat(range.start.row);
                var elapsed = (_a = grid[RADIO_COLUMN_STATE_ID]) === null || _a === void 0 ? void 0 : _a.elapsed[cellKey];
                var opt = {
                  textAlign: textAlign,
                  textBaseline: textBaseline,
                  checkColor: checkColor,
                  uncheckBorderColor: uncheckBorderColor,
                  checkBorderColor: checkBorderColor,
                  uncheckBgColor: uncheckBgColor,
                  checkBgColor: checkBgColor,
                  padding: padding
                };

                if (elapsed != null) {
                  opt.animElapsedTime = elapsed;
                }

                helper.radioButton(value, context, opt);
              }
            }]);

            return RadioColumn;
          }(BaseColumn_1.BaseColumn);

          exports.RadioColumn = RadioColumn;
          /***/
        },

        /***/
        "./columns/type/TreeColumn.js":
        /*!************************************!*\
          !*** ./columns/type/TreeColumn.js ***!
          \************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsTypeTreeColumnJs(module, exports, __nested_webpack_require_510531__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.getTreeNodeInfoAt = exports.TreeColumn = void 0;

          var inlineUtils = __importStar(__nested_webpack_require_510531__(
          /*! ../../element/inlines */
          "./element/inlines.js"));

          var utils = __importStar(__nested_webpack_require_510531__(
          /*! ../../columns/type/columnUtils */
          "./columns/type/columnUtils.js"));

          var Column_1 = __nested_webpack_require_510531__(
          /*! ./Column */
          "./columns/type/Column.js");

          var Rect_1 = __nested_webpack_require_510531__(
          /*! ../../internal/Rect */
          "./internal/Rect.js");

          var TreeStyle_1 = __nested_webpack_require_510531__(
          /*! ../style/TreeStyle */
          "./columns/style/TreeStyle.js");

          var canvases_1 = __nested_webpack_require_510531__(
          /*! ../../internal/canvases */
          "./internal/canvases.js");

          var symbolManager_1 = __nested_webpack_require_510531__(
          /*! ../../internal/symbolManager */
          "./internal/symbolManager.js");

          var utils_1 = __nested_webpack_require_510531__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var _ = (0, symbolManager_1.getTreeColumnStateId)();

          var TreeColumn = /*#__PURE__*/function (_Column_1$Column5) {
            _inherits(TreeColumn, _Column_1$Column5);

            var _super45 = _createSuper(TreeColumn);

            function TreeColumn() {
              var _this60;

              var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, TreeColumn);

              _this60 = _super45.call(this, option);
              _this60._cache = option.cache != null ? option.cache : false;
              return _this60;
            }

            _createClass(TreeColumn, [{
              key: "StyleClass",
              get: function get() {
                return TreeStyle_1.TreeStyle;
              }
            }, {
              key: "clearCache",
              value: function clearCache(grid) {
                var internal = grid;
                if (!internal[_]) return;
                delete internal[_].cache;
              }
            }, {
              key: "drawnIconActionArea",
              get: function get() {
                return function (param) {
                  var internal = param.grid;
                  var state = internal[_];
                  if (!(state === null || state === void 0 ? void 0 : state.drawnIcons)) return false;
                  var drawnIcons = state.drawnIcons;
                  return drawnIcons.area(param);
                };
              }
            }, {
              key: "onDrawCell",
              value: function onDrawCell(cellValue, info, context, grid) {
                var state = grid[_] || (grid[_] = {});

                if (this._cache && !state.cache) {
                  var cache = state.cache || (state.cache = new Map());
                  var col = context.col,
                      row = context.row;
                  var field = grid.getField(col, row);

                  if (!cache.has(field)) {
                    cache.set(field, new TreeColumnInfo(grid, field));
                  }
                }

                return _get(_getPrototypeOf(TreeColumn.prototype), "onDrawCell", this).call(this, cellValue, info, context, grid);
              }
            }, {
              key: "clone",
              value: function clone() {
                return new TreeColumn(this);
              }
            }, {
              key: "cache",
              get: function get() {
                return this._cache;
              }
            }, {
              key: "getCopyCellValue",
              value: function getCopyCellValue(value) {
                var treeData = getTreeDataFromValue(value);
                return treeData.caption;
              }
            }, {
              key: "drawInternal",
              value: function drawInternal(value, context, style, helper, grid, _ref46) {
                var drawCellBase = _ref46.drawCellBase,
                    getIcon = _ref46.getIcon;

                var _a, _b;

                var textAlign = style.textAlign,
                    textBaseline = style.textBaseline,
                    bgColor = style.bgColor,
                    padding = style.padding,
                    color = style.color,
                    font = style.font,
                    textOverflow = style.textOverflow;

                if (bgColor) {
                  drawCellBase({
                    bgColor: bgColor
                  });
                }

                var state = grid[_] || (grid[_] = {});

                if (state.drawnIcons) {
                  var drawnIcons = state.drawnIcons;
                  drawnIcons.delete(context);
                }

                var col = context.col,
                    row = context.row;
                var field = grid.getField(col, row);
                var tci = (_b = this._cache ? (_a = state.cache) === null || _a === void 0 ? void 0 : _a.get(field) : null) !== null && _b !== void 0 ? _b : new TreeColumnInfo(grid, field);
                var info = tci.getInfo(value, row);
                helper.testFontLoad(font, info.caption, context);
                utils.loadIcons(getIcon(), context, helper, function (icons, context) {
                  var rect = context.getRect();
                  var basePadding = helper.toBoxPixelArray(padding || 0, context, font);
                  var nestLevel = info.path.length;
                  helper.drawWithClip(context, function (ctx) {
                    var fontSize = (0, canvases_1.getFontSize)(ctx, font);
                    var indentSize = fontSize.width;
                    var top = rect.top + basePadding[0];
                    var left = rect.left + basePadding[3];
                    var height = rect.height - basePadding[0] - basePadding[2];
                    var lineBaseline = textBaseline !== null && textBaseline !== void 0 ? textBaseline : ctx.textBaseline || "middle"; // Calculate horizontal line position

                    var hLineY = top + height / 2;

                    if (lineBaseline === "bottom" || lineBaseline === "alphabetic" || lineBaseline === "ideographic") {
                      // bottom
                      hLineY = top + height - fontSize.height / 2;
                    } else if (textBaseline === "middle") {
                      hLineY = top + height / 2;
                    } else {
                      // top
                      hLineY = top + fontSize.height / 2;
                    } // Get the tree icon


                    var definedTreeIcon = style.treeIcon || helper.getStyleProperty(helper.theme.tree.treeIcon, col, row, ctx);
                    var treeIcon = definedTreeIcon === "none" ? null : definedTreeIcon === "chevron_right" || definedTreeIcon === "expand_more" ? {
                      name: definedTreeIcon,
                      width: fontSize.width
                    } : definedTreeIcon; // Calculate icon rect

                    var iconRect = null;

                    if (treeIcon) {
                      ctx.save();

                      try {
                        var treeLineLeft = left + indentSize * (nestLevel - 1);
                        var vLineX = treeLineLeft + indentSize / 2;
                        var size = inlineUtils.iconOf(treeIcon).width({
                          ctx: ctx
                        });
                        iconRect = new Rect_1.Rect(vLineX - size / 2, hLineY - size / 2, size, size);
                      } finally {
                        ctx.restore();
                      } // It preserves the position of the drawn icon
                      // because it is used for the `area` option of the `Action` class.


                      var _drawnIcons = state.drawnIcons || (state.drawnIcons = new DrawnIcons());

                      _drawnIcons.set(context, iconRect);
                    } // Get tree line color


                    var lineStyle = style.lineStyle || helper.theme.tree.lineStyle;

                    if (lineStyle !== "none") {
                      var lineWidth = style.lineWidth || helper.theme.tree.lineWidth;
                      var lineColor = style.lineColor || helper.getColor(helper.theme.tree.lineColor, col, row, ctx);
                      ctx.save();

                      try {
                        ctx.strokeStyle = lineColor;
                        ctx.lineWidth = lineWidth;
                        ctx.lineCap = "round";

                        if (iconRect) {
                          // Clip icon area
                          ctx.beginPath();
                          ctx.rect(0, 0, ctx.canvas.width, ctx.canvas.height); // Draw a square in the opposite direction to hollow out the inside.

                          ctx.rect(iconRect.right, iconRect.top, -iconRect.width, iconRect.height); // // For debug
                          // ctx.fillStyle = "#0002";
                          // ctx.fill();

                          ctx.clip();
                        } // Draw tree lines


                        info.getLines().forEach(function (line, index) {
                          var treeLineLeft = left + indentSize * index;
                          var vLineX = treeLineLeft + indentSize / 2;
                          var treeLineRight = treeLineLeft + indentSize;

                          if (line !== 0
                          /* TreeLineKind.none */
                          ) {
                              ctx.beginPath();

                              if (line === 1
                              /* TreeLineKind.vertical */
                              ) {
                                  ctx.moveTo(vLineX, rect.top);
                                  ctx.lineTo(vLineX, rect.bottom);
                                } else if (line === 2
                              /* TreeLineKind.last */
                              ) {
                                  ctx.moveTo(vLineX, rect.top);
                                  ctx.lineTo(vLineX, hLineY);
                                  ctx.lineTo(treeLineRight, hLineY);
                                } else if (line === 3
                              /* TreeLineKind.start */
                              ) {
                                  ctx.moveTo(treeLineRight, hLineY);
                                  ctx.lineTo(vLineX, hLineY);
                                  ctx.lineTo(vLineX, rect.bottom);
                                } else if (line === 4
                              /* TreeLineKind.verticalBranch */
                              ) {
                                  ctx.moveTo(vLineX, rect.top);
                                  ctx.lineTo(vLineX, rect.bottom);
                                  ctx.moveTo(vLineX, hLineY);
                                  ctx.lineTo(treeLineRight, hLineY);
                                } else if (line === 5
                              /* TreeLineKind.horizontal */
                              ) {
                                  ctx.moveTo(treeLineLeft, hLineY);
                                  ctx.lineTo(treeLineRight, hLineY);
                                } else if (line === 6
                              /* TreeLineKind.horizontalBranch */
                              ) {
                                  ctx.moveTo(treeLineLeft, hLineY);
                                  ctx.lineTo(treeLineRight, hLineY);
                                  ctx.moveTo(vLineX, hLineY);
                                  ctx.lineTo(vLineX, rect.bottom);
                                } else if (line === 7
                              /* TreeLineKind.lone */
                              ) {
                                  ctx.moveTo(vLineX, hLineY);
                                  ctx.lineTo(treeLineRight, hLineY);
                                }

                              ctx.stroke();
                            }
                        });
                      } finally {
                        ctx.restore();
                      }
                    }

                    if (treeIcon) {
                      // Draw tree icon
                      var iconLeftOffset = indentSize * (nestLevel - 1);
                      var iconWidth = indentSize;
                      var iconPadding = basePadding.slice(0);
                      iconPadding[3] += iconLeftOffset;
                      iconPadding[1] = rect.width - iconWidth - iconPadding[3]; // padding right

                      helper.text("", context, {
                        textAlign: "center",
                        textBaseline: textBaseline,
                        color: color,
                        font: font,
                        icons: [treeIcon],
                        padding: iconPadding
                      });
                    }

                    var textPadding = basePadding.slice(0);
                    textPadding[3] += nestLevel * indentSize; // Tree indent padding

                    helper.text(info.caption, context, {
                      textAlign: textAlign,
                      textBaseline: textBaseline,
                      color: color,
                      font: font,
                      padding: textPadding,
                      textOverflow: textOverflow,
                      icons: icons
                    });
                  });
                });
              }
            }]);

            return TreeColumn;
          }(Column_1.Column);

          exports.TreeColumn = TreeColumn;
          /**
           * If the cell is a TreeColumn, gets the tree node information from the given cell.
           */

          function getTreeNodeInfoAt(_ref47) {
            var grid = _ref47.grid,
                col = _ref47.col,
                row = _ref47.row;
            var field = grid.getField(col, row);
            if (!field) return {
              hasChildren: false,
              nodeType: "leaf"
            };
            var dataSource = grid.dataSource;
            var currIndex = grid.getRecordIndexByRow(row);
            var value = dataSource.getField(currIndex, field);
            var treeData = getTreeDataFromValue(value);
            var hasChildren = hasChildrenByRecord(treeData, dataSource, field, currIndex);
            return {
              nodeType: hasChildren ? "branch" : treeData.nodeType || "leaf",
              hasChildren: hasChildren
            };
          }

          exports.getTreeNodeInfoAt = getTreeNodeInfoAt;

          function hasChildrenByRecord(treeData, dataSource, field, recordIndex) {
            var next = dataSource.getField(recordIndex + 1, field);
            if (!next || (0, utils_1.isPromise)(next)) return false;
            var nextParentPath = getParentPath(next);
            return treeData.path.length === nextParentPath.length && nextParentPath.every(function (p, i) {
              return p === treeData.path[i];
            });
          }

          var TreeColumnInfo = /*#__PURE__*/function () {
            function TreeColumnInfo(grid, field) {
              _classCallCheck(this, TreeColumnInfo);

              this._cache = {};
              this._grid = grid;
              this._field = field;
            }

            _createClass(TreeColumnInfo, [{
              key: "getInfo",
              value: function getInfo(value, row) {
                var field = this._field,
                    grid = this._grid,
                    cache = this._cache;
                var currIndex = grid.getRecordIndexByRow(row);
                var dataSource = grid.dataSource;
                var treeData = getTreeDataFromValue(value);
                var hasChildren = hasChildrenByRecord(treeData, dataSource, field, currIndex);
                return {
                  caption: treeData.caption,
                  path: treeData.path,
                  getLines: function getLines() {
                    var currPath = [];
                    var parentPath = treeData.path.slice(0, -1);
                    var parentLines = parentPath.map(function (p, index) {
                      currPath.push(p);
                      var isLast = index === parentPath.length - 1;

                      if (hasNextSiblingWithCache(currPath)) {
                        return isLast ? 4
                        /* TreeLineKind.verticalBranch */
                        : 1
                        /* TreeLineKind.vertical */
                        ;
                      } else {
                        return isLast ? 2
                        /* TreeLineKind.last */
                        : 0
                        /* TreeLineKind.none */
                        ;
                      }
                    });
                    var selfLine;

                    if (hasChildren) {
                      selfLine = parentPath.length > 0 ? 6
                      /* TreeLineKind.horizontalBranch */
                      : 3
                      /* TreeLineKind.start */
                      ;
                    } else {
                      selfLine = parentPath.length > 0 ? 5
                      /* TreeLineKind.horizontal */
                      : 7
                      /* TreeLineKind.lone */
                      ;
                    }

                    return parentLines.concat(selfLine);
                  }
                };

                function hasNextSiblingWithCache(parentPath) {
                  var has = hasNextSiblingFromCache(currIndex, parentPath.length);

                  if (has != null) {
                    return has;
                  }

                  var result = hasNextSibling(parentPath);

                  for (var index = currIndex; index < result.end; index++) {
                    setNextSiblingToCache(index, parentPath.length, result.has);
                  }

                  return result.has;
                }

                function hasNextSiblingFromCache(index, level) {
                  var _ref48 = cache[index] || (cache[index] = {
                    hasNextSiblings: []
                  }),
                      hasNextSiblings = _ref48.hasNextSiblings;

                  return hasNextSiblings[level];
                }

                function setNextSiblingToCache(index, level, value) {
                  var _ref49 = cache[index] || (cache[index] = {
                    hasNextSiblings: []
                  }),
                      hasNextSiblings = _ref49.hasNextSiblings;

                  hasNextSiblings[level] = value;
                }

                function hasNextSibling(parentPath) {
                  var startIndex = currIndex + 1;

                  var _loop5 = function _loop5(index) {
                    var data = dataSource.getField(index, field);
                    if ((0, utils_1.isPromise)(data)) return {
                      v: {
                        end: index,
                        has: false
                      }
                    };
                    var nextPath = getParentPath(data);
                    if (!nextPath.length) return {
                      v: {
                        end: index,
                        has: false
                      }
                    };

                    if (parentPath.every(function (p, i) {
                      return p === nextPath[i];
                    })) {
                      // All matches!
                      if (parentPath.length < nextPath.length) {
                        // It's a child.
                        // e.g.
                        //  target
                        //   next
                        var has = hasNextSiblingFromCache(index, parentPath.length);
                        if (has != null) return {
                          v: {
                            end: index,
                            has: has
                          }
                        };
                        return "continue";
                      } // There is next sibling.
                      // e.g.
                      //  target
                      //   x
                      //   x
                      //  next


                      return {
                        v: {
                          end: index,
                          has: true
                        }
                      };
                    } // There is no next sibling.
                    // e.g.
                    //   target
                    //     x
                    //     x
                    //  next


                    return {
                      v: {
                        end: index,
                        has: false
                      }
                    };
                  };

                  for (var index = startIndex; index < dataSource.length; index++) {
                    var _ret = _loop5(index);

                    if (_ret === "continue") continue;
                    if (_typeof(_ret) === "object") return _ret.v;
                  } // There is no next sibling.


                  return {
                    end: dataSource.length,
                    has: false
                  };
                }
              }
            }]);

            return TreeColumnInfo;
          }();

          function getTreeDataFromValue(value) {
            var _a, _b;

            if (value != null) {
              if (Array.isArray(value)) {
                return getTreeDataFromValue({
                  path: value
                });
              } else {
                if (Array.isArray(value.path)) return {
                  caption: String((_b = (_a = value.caption) !== null && _a !== void 0 ? _a : value.path[value.path.length - 1]) !== null && _b !== void 0 ? _b : ""),
                  path: value.path,
                  nodeType: value.nodeType
                };
                if (typeof value.path === "function") return getTreeDataFromValue(Object.assign(Object.assign({}, value), {
                  path: value.path()
                }));
              }
            }

            return {
              caption: String(value !== null && value !== void 0 ? value : ""),
              path: [value]
            };
          }

          function getParentPath(value) {
            return getTreeDataFromValue(value).path.slice(0, -1);
          }

          var DrawnIcons = /*#__PURE__*/function () {
            function DrawnIcons() {
              _classCallCheck(this, DrawnIcons);

              this._drawnIcons = new Map();
            }

            _createClass(DrawnIcons, [{
              key: "set",
              value: function set(cell, clipRect) {
                this._drawnIcons.set("".concat(cell.col, ":").concat(cell.row), clipRect);
              }
            }, {
              key: "delete",
              value: function _delete(cell) {
                this._drawnIcons.delete("".concat(cell.col, ":").concat(cell.row));
              }
            }, {
              key: "area",
              value: function area(_ref50) {
                var col = _ref50.col,
                    row = _ref50.row,
                    point = _ref50.pointInDrawingCanvas;
                var key = "".concat(col, ":").concat(row);

                var rect = this._drawnIcons.get(key);

                if (!rect) {
                  return false;
                }

                return rect.left <= point.x && point.x <= rect.right && rect.top <= point.y && point.y <= rect.bottom;
              }
            }]);

            return DrawnIcons;
          }();
          /***/

        },

        /***/
        "./columns/type/columnUtils.js":
        /*!*************************************!*\
          !*** ./columns/type/columnUtils.js ***!
          \*************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsTypeColumnUtilsJs(module, exports, __nested_webpack_require_536257__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.loadIcons = void 0;

          var icons = __importStar(__nested_webpack_require_536257__(
          /*! ../../internal/icons */
          "./internal/icons.js"));

          var utils_1 = __nested_webpack_require_536257__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          function loadIcons(icon, context, helper, callback) {
            var argIcon = undefined;

            if (icon) {
              if ((0, utils_1.isPromise)(icon)) {
                icon.then(function (i) {
                  loadIcons(i, context.toCurrentContext(), helper, callback);
                });
              } else {
                var iconList = icons.toNormalizeArray(icon);
                iconList.forEach(function (i) {
                  if (i.font && i.content) {
                    helper.testFontLoad(i.font, i.content, context);
                  }
                });
                argIcon = iconList;
              }
            }

            callback(argIcon, context);
          }

          exports.loadIcons = loadIcons;
          /***/
        },

        /***/
        "./columns/utils/index.js":
        /*!********************************!*\
          !*** ./columns/utils/index.js ***!
          \********************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsUtilsIndexJs(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.toBoolean = void 0;

          function toBoolean(val) {
            if (typeof val === "string") {
              if (val === "false") {
                return false;
              } else if (val === "off") {
                return false;
              } else if (/^0+$/.exec(val)) {
                return false;
              }
            }

            return Boolean(val);
          }

          exports.toBoolean = toBoolean;
          /***/
        },

        /***/
        "./core.js":
        /*!*****************!*\
          !*** ./core.js ***!
          \*****************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function coreJs(module, exports, __nested_webpack_require_540157__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.EVENT_TYPE = exports.DrawGrid = void 0;

          var DrawGrid_1 = __nested_webpack_require_540157__(
          /*! ./core/DrawGrid */
          "./core/DrawGrid.js");

          Object.defineProperty(exports, "DrawGrid", {
            enumerable: true,
            get: function get() {
              return DrawGrid_1.DrawGrid;
            }
          });

          var DG_EVENT_TYPE_1 = __nested_webpack_require_540157__(
          /*! ./core/DG_EVENT_TYPE */
          "./core/DG_EVENT_TYPE.js");

          Object.defineProperty(exports, "EVENT_TYPE", {
            enumerable: true,
            get: function get() {
              return DG_EVENT_TYPE_1.DG_EVENT_TYPE;
            }
          });
          /***/
        },

        /***/
        "./core/DG_EVENT_TYPE.js":
        /*!*******************************!*\
          !*** ./core/DG_EVENT_TYPE.js ***!
          \*******************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function coreDG_EVENT_TYPEJs(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.DG_EVENT_TYPE = void 0;
          /**
           * DrawGrid event types
           * @classdesc cheetahGrid.core.EVENT_TYPE
           * @memberof cheetahGrid.core
           */

          exports.DG_EVENT_TYPE = {
            CLICK_CELL: "click_cell",
            DBLCLICK_CELL: "dblclick_cell",
            DBLTAP_CELL: "dbltap_cell",
            MOUSEDOWN_CELL: "mousedown_cell",
            MOUSEUP_CELL: "mouseup_cell",
            SELECTED_CELL: "selected_cell",
            KEYDOWN: "keydown",
            MOUSEMOVE_CELL: "mousemove_cell",
            MOUSEENTER_CELL: "mouseenter_cell",
            MOUSELEAVE_CELL: "mouseleave_cell",
            MOUSEOVER_CELL: "mouseover_cell",
            MOUSEOUT_CELL: "mouseout_cell",
            TOUCHSTART_CELL: "touchstart_cell",
            CONTEXTMENU_CELL: "contextmenu_cell",
            INPUT_CELL: "input_cell",
            PASTE_CELL: "paste_cell",
            DELETE_CELL: "delete_cell",
            EDITABLEINPUT_CELL: "editableinput_cell",
            MODIFY_STATUS_EDITABLEINPUT_CELL: "modify_status_editableinput_cell",
            RESIZE_COLUMN: "resize_column",
            SCROLL: "scroll",
            FOCUS_GRID: "focus_grid",
            BLUR_GRID: "blur_grid"
          };
          /***/
        },

        /***/
        "./core/DrawGrid.js":
        /*!**************************!*\
          !*** ./core/DrawGrid.js ***!
          \**************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function coreDrawGridJs(module, exports, __nested_webpack_require_543174__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.DrawGrid = void 0;

          var calc = __importStar(__nested_webpack_require_543174__(
          /*! ../internal/calc */
          "./internal/calc.js"));

          var hiDPI = __importStar(__nested_webpack_require_543174__(
          /*! ../internal/hiDPI */
          "./internal/hiDPI.js"));

          var style = __importStar(__nested_webpack_require_543174__(
          /*! ../internal/style */
          "./internal/style.js"));

          var utils_1 = __nested_webpack_require_543174__(
          /*! ../internal/utils */
          "./internal/utils.js");

          var paste_utils_1 = __nested_webpack_require_543174__(
          /*! ../internal/paste-utils */
          "./internal/paste-utils.js");

          var DG_EVENT_TYPE_1 = __nested_webpack_require_543174__(
          /*! ./DG_EVENT_TYPE */
          "./core/DG_EVENT_TYPE.js");

          var EventHandler_1 = __nested_webpack_require_543174__(
          /*! ../internal/EventHandler */
          "./internal/EventHandler.js");

          var EventTarget_1 = __nested_webpack_require_543174__(
          /*! ./EventTarget */
          "./core/EventTarget.js");

          var NumberMap_1 = __nested_webpack_require_543174__(
          /*! ../internal/NumberMap */
          "./internal/NumberMap.js");

          var Rect_1 = __nested_webpack_require_543174__(
          /*! ../internal/Rect */
          "./internal/Rect.js");

          var Scrollable_1 = __nested_webpack_require_543174__(
          /*! ../internal/Scrollable */
          "./internal/Scrollable.js");

          var canvases_1 = __nested_webpack_require_543174__(
          /*! ../internal/canvases */
          "./internal/canvases.js"); //protected symbol


          var symbolManager_1 = __nested_webpack_require_543174__(
          /*! ../internal/symbolManager */
          "./internal/symbolManager.js");

          var _utils_1$event = utils_1.event,
              isTouchEvent = _utils_1$event.isTouchEvent,
              getMouseButtons = _utils_1$event.getMouseButtons,
              getKeyCode = _utils_1$event.getKeyCode,
              cancelEvent = _utils_1$event.cancel;
          /** @private */

          var _ = (0, symbolManager_1.getProtectedSymbol)();
          /** @private */


          function createRootElement() {
            var element = document.createElement("div");
            element.classList.add("cheetah-grid");
            return element;
          }
          /** @private */


          var KEY_BS = 8;
          /** @private */

          var KEY_TAB = 9;
          /** @private */

          var KEY_ENTER = 13;
          /** @private */

          var KEY_END = 35;
          /** @private */

          var KEY_HOME = 36;
          /** @private */

          var KEY_LEFT = 37;
          /** @private */

          var KEY_UP = 38;
          /** @private */

          var KEY_RIGHT = 39;
          /** @private */

          var KEY_DOWN = 40;
          /** @private */

          var KEY_DEL = 46;
          /** @private */

          var KEY_ALPHA_A = 65;
          /** @private */

          var KEY_ALPHA_C = 67;
          /** @private */

          var KEY_ALPHA_V = 86; //private methods

          /** @private */

          function _vibrate(e) {
            if (navigator.vibrate && isTouchEvent(e)) {
              navigator.vibrate(50);
            }
          }
          /** @private */


          function _getTargetRowAt(absoluteY) {
            var _this61 = this;

            var internal = this.getTargetRowAtInternal(absoluteY);

            if (internal != null) {
              return internal;
            }

            var findBefore = function findBefore(startRow, startBottom) {
              var bottom = startBottom;

              for (var row = startRow; row >= 0; row--) {
                var height = _getRowHeight.call(_this61, row);

                var top = bottom - height;

                if (top <= absoluteY && absoluteY < bottom) {
                  return {
                    top: top,
                    row: row
                  };
                }

                bottom = top;
              }

              return null;
            };

            var findAfter = function findAfter(startRow, startBottom) {
              var top = startBottom - _getRowHeight.call(_this61, startRow);

              var rowCount = _this61[_].rowCount;

              for (var row = startRow; row < rowCount; row++) {
                var height = _getRowHeight.call(_this61, row);

                var _bottom = top + height;

                if (top <= absoluteY && absoluteY < _bottom) {
                  return {
                    top: top,
                    row: row
                  };
                }

                top = _bottom;
              }

              return null;
            };

            var candidateRow = Math.min(Math.ceil(absoluteY / this[_].defaultRowHeight), this.rowCount - 1);

            var bottom = _getRowsHeight.call(this, 0, candidateRow);

            if (absoluteY >= bottom) {
              return findAfter(candidateRow, bottom);
            } else {
              return findBefore(candidateRow, bottom);
            }
          }
          /** @private */


          function _getTargetColAt(grid, absoluteX) {
            var left = 0;
            var colCount = grid[_].colCount;

            for (var col = 0; col < colCount; col++) {
              var width = _getColWidth(grid, col);

              var right = left + width;

              if (right > absoluteX) {
                return {
                  left: left,
                  col: col
                };
              }

              left = right;
            }

            return null;
          }
          /** @private */


          function _getTargetFrozenRowAt(grid, absoluteY) {
            if (!grid[_].frozenRowCount) {
              return null;
            }

            var top = grid[_].scroll.top;
            var rowCount = grid[_].frozenRowCount;

            for (var row = 0; row < rowCount; row++) {
              var height = _getRowHeight.call(grid, row);

              var bottom = top + height;

              if (bottom > absoluteY) {
                return {
                  top: top,
                  row: row
                };
              }

              top = bottom;
            }

            return null;
          }
          /** @private */


          function _getTargetFrozenColAt(grid, absoluteX) {
            if (!grid[_].frozenColCount) {
              return null;
            }

            var left = grid[_].scroll.left;
            var colCount = grid[_].frozenColCount;

            for (var col = 0; col < colCount; col++) {
              var width = _getColWidth(grid, col);

              var right = left + width;

              if (right > absoluteX) {
                return {
                  left: left,
                  col: col
                };
              }

              left = right;
            }

            return null;
          }
          /** @private */


          function _getFrozenRowsRect(grid) {
            if (!grid[_].frozenRowCount) {
              return null;
            }

            var top = grid[_].scroll.top;
            var height = 0;
            var rowCount = grid[_].frozenRowCount;

            for (var row = 0; row < rowCount; row++) {
              height += _getRowHeight.call(grid, row);
            }

            return new Rect_1.Rect(grid[_].scroll.left, top, grid[_].canvas.width, height);
          }
          /** @private */


          function _getFrozenColsRect(grid) {
            if (!grid[_].frozenColCount) {
              return null;
            }

            var left = grid[_].scroll.left;
            var width = 0;
            var colCount = grid[_].frozenColCount;

            for (var col = 0; col < colCount; col++) {
              width += _getColWidth(grid, col);
            }

            return new Rect_1.Rect(left, grid[_].scroll.top, width, grid[_].canvas.height);
          }
          /** @private */


          function _getCellDrawing(grid, col, row) {
            if (!grid[_].drawCells[row]) {
              return null;
            }

            return grid[_].drawCells[row][col];
          }
          /** @private */


          function _putCellDrawing(grid, col, row, context) {
            if (!grid[_].drawCells[row]) {
              grid[_].drawCells[row] = {};
            }

            grid[_].drawCells[row][col] = context;
          }
          /** @private */


          function _removeCellDrawing(grid, col, row) {
            if (!grid[_].drawCells[row]) {
              return;
            }

            delete grid[_].drawCells[row][col];

            if (Object.keys(grid[_].drawCells[row]).length === 0) {
              delete grid[_].drawCells[row];
            }
          }
          /** @private */


          function _drawCell(ctx, col, absoluteLeft, width, row, absoluteTop, height, visibleRect, skipAbsoluteTop, skipAbsoluteLeft, drawLayers) {
            var _this62 = this;

            var rect = new Rect_1.Rect(absoluteLeft - visibleRect.left, absoluteTop - visibleRect.top, width, height);
            var drawRect = Rect_1.Rect.bounds(Math.max(absoluteLeft, skipAbsoluteLeft) - visibleRect.left, Math.max(absoluteTop, skipAbsoluteTop) - visibleRect.top, rect.right, rect.bottom);

            if (drawRect.height > 0 && drawRect.width > 0) {
              ctx.save();

              try {
                var cellDrawing = _getCellDrawing(this, col, row);

                if (cellDrawing) {
                  cellDrawing.cancel();
                }

                var dcContext = new DrawCellContext(col, row, ctx, rect, drawRect, !!cellDrawing, this[_].selection, drawLayers);
                var p = this.onDrawCell(col, row, dcContext);

                if ((0, utils_1.isPromise)(p)) {
                  //
                  _putCellDrawing(this, col, row, dcContext);

                  var pCol = col;

                  dcContext._delayMode(this, function () {
                    _removeCellDrawing(_this62, pCol, row);
                  });

                  p.then(function () {
                    dcContext.terminate();
                  });
                }
              } finally {
                ctx.restore();
              }
            }
          }
          /** @private */


          function _drawRow(grid, ctx, initFrozenCol, initCol, drawRight, row, absoluteTop, height, visibleRect, skipAbsoluteTop, drawLayers) {
            var colCount = grid[_].colCount;

            var drawOuter = function drawOuter(col, absoluteLeft) {
              //
              if (col >= colCount - 1 && grid[_].canvas.width > absoluteLeft - visibleRect.left) {
                var outerLeft = absoluteLeft - visibleRect.left;
                ctx.save();
                ctx.beginPath();
                ctx.fillStyle = grid.underlayBackgroundColor || "#F6F6F6";
                ctx.rect(outerLeft, absoluteTop - visibleRect.top, grid[_].canvas.width - outerLeft, height);
                ctx.fill();
                ctx.restore();
              }
            };

            var skipAbsoluteLeft = 0;

            if (initFrozenCol) {
              var _absoluteLeft = initFrozenCol.left;
              var count = grid[_].frozenColCount;

              for (var col = initFrozenCol.col; col < count; col++) {
                var width = _getColWidth(grid, col);

                _drawCell.call(grid, ctx, col, _absoluteLeft, width, row, absoluteTop, height, visibleRect, skipAbsoluteTop, 0, drawLayers);

                _absoluteLeft += width;

                if (drawRight <= _absoluteLeft) {
                  //
                  drawOuter(col, _absoluteLeft);
                  return;
                }
              }

              skipAbsoluteLeft = _absoluteLeft;
            }

            var absoluteLeft = initCol.left;

            for (var _col2 = initCol.col; _col2 < colCount; _col2++) {
              var _width2 = _getColWidth(grid, _col2);

              _drawCell.call(grid, ctx, _col2, absoluteLeft, _width2, row, absoluteTop, height, visibleRect, skipAbsoluteTop, skipAbsoluteLeft, drawLayers);

              absoluteLeft += _width2;

              if (drawRight <= absoluteLeft) {
                //
                drawOuter(_col2, absoluteLeft);
                return;
              }
            }

            drawOuter(colCount - 1, absoluteLeft);
          }
          /** @private */


          function _getInitContext() {
            return this._getInitContext();
          }
          /** @private */


          function _invalidateRect(grid, drawRect) {
            var visibleRect = _getVisibleRect(grid);

            var rowCount = grid[_].rowCount;

            var ctx = _getInitContext.call(grid);

            var initRow = _getTargetRowAt.call(grid, Math.max(visibleRect.top, drawRect.top)) || {
              top: _getRowsHeight.call(grid, 0, rowCount - 1),
              row: rowCount
            };
            var initCol = _getTargetColAt(grid, Math.max(visibleRect.left, drawRect.left)) || {
              left: _getColsWidth(grid, 0, grid[_].colCount - 1),
              col: grid[_].colCount
            };
            var drawBottom = Math.min(visibleRect.bottom, drawRect.bottom);
            var drawRight = Math.min(visibleRect.right, drawRect.right);

            var initFrozenRow = _getTargetFrozenRowAt(grid, Math.max(visibleRect.top, drawRect.top));

            var initFrozenCol = _getTargetFrozenColAt(grid, Math.max(visibleRect.left, drawRect.left));

            var drawLayers = new DrawLayers();

            var drawOuter = function drawOuter(row, absoluteTop) {
              //
              if (row >= rowCount - 1 && grid[_].canvas.height > absoluteTop - visibleRect.top) {
                var outerTop = absoluteTop - visibleRect.top;
                ctx.save();
                ctx.beginPath();
                ctx.fillStyle = grid.underlayBackgroundColor || "#F6F6F6";
                ctx.rect(0, outerTop, grid[_].canvas.width, grid[_].canvas.height - outerTop);
                ctx.fill();
                ctx.restore();
              }
            };

            var skipAbsoluteTop = 0;

            if (initFrozenRow) {
              var _absoluteTop = initFrozenRow.top;
              var count = grid[_].frozenRowCount;

              for (var row = initFrozenRow.row; row < count; row++) {
                var height = _getRowHeight.call(grid, row);

                _drawRow(grid, ctx, initFrozenCol, initCol, drawRight, row, _absoluteTop, height, visibleRect, 0, drawLayers);

                _absoluteTop += height;

                if (drawBottom <= _absoluteTop) {
                  //
                  drawOuter(row, _absoluteTop);
                  drawLayers.draw(ctx);
                  return;
                }
              }

              skipAbsoluteTop = _absoluteTop;
            }

            var absoluteTop = initRow.top;

            for (var _row2 = initRow.row; _row2 < rowCount; _row2++) {
              var _height2 = _getRowHeight.call(grid, _row2); //


              _drawRow(grid, ctx, initFrozenCol, initCol, drawRight, _row2, absoluteTop, _height2, visibleRect, skipAbsoluteTop, drawLayers);

              absoluteTop += _height2;

              if (drawBottom <= absoluteTop) {
                //
                drawOuter(_row2, absoluteTop);
                drawLayers.draw(ctx);
                return;
              }
            }

            drawOuter(rowCount - 1, absoluteTop);
            drawLayers.draw(ctx);
          }
          /** @private */


          function _toPxWidth(grid, width) {
            return Math.round(calc.toPx(width, grid[_].calcWidthContext));
          }
          /** @private */


          function _adjustColWidth(grid, col, orgWidth) {
            var limits = _getColWidthLimits(grid, col);

            return Math.max(_applyColWidthLimits(limits, orgWidth), 0);
          }
          /** @private */


          function _applyColWidthLimits(limits, orgWidth) {
            if (!limits) {
              return orgWidth;
            }

            if (limits.min) {
              if (limits.min > orgWidth) {
                return limits.min;
              }
            }

            if (limits.max) {
              if (limits.max < orgWidth) {
                return limits.max;
              }
            }

            return orgWidth;
          }
          /**
           * Gets the definition of the column width.
           * @param {DrawGrid} grid grid instance
           * @param {number} col number of column
           * @returns {string|number} width definition
           * @private
           */


          function _getColWidthDefine(grid, col) {
            var width = grid[_].colWidthsMap.get(col);

            if (width) {
              return width;
            }

            return grid.defaultColWidth;
          }
          /**
           * Gets the column width limits.
           * @param {DrawGrid} grid grid instance
           * @param {number} col number of column
           * @returns {object|null} the column width limits
           * @private
           */


          function _getColWidthLimits(grid, col) {
            var limit = grid[_].colWidthsLimit[col];

            if (!limit) {
              return null;
            }

            var result = {};

            if (limit.min) {
              result.min = _toPxWidth(grid, limit.min);
              result.minDef = limit.min;
            }

            if (limit.max) {
              result.max = _toPxWidth(grid, limit.max);
              result.maxDef = limit.max;
            }

            return result;
          }
          /**
           * Checks if the given width definition is `auto`.
           * @param {string|number} width width definition to check
           * @returns {boolean} `true ` if the given width definition is `auto`
           * @private
           */


          function isAutoDefine(width) {
            return Boolean(width && typeof width === "string" && width.toLowerCase() === "auto");
          }
          /**
           * Creates a formula to calculate the auto width.
           * @param {DrawGrid} grid grid instance
           * @returns {string} formula
           * @private
           */


          function _calcAutoColWidthExpr(grid) {
            var shortCircuit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
            var fullWidth = grid[_].calcWidthContext.full;
            var sumMin = 0;
            var others = [];
            var autoCount = 0;
            var hasLimitsOnAuto = [];

            for (var col = 0; col < grid[_].colCount; col++) {
              var def = _getColWidthDefine(grid, col);

              var limits = _getColWidthLimits(grid, col);

              if (isAutoDefine(def)) {
                if (limits) {
                  hasLimitsOnAuto.push(limits);

                  if (limits.min) {
                    sumMin += limits.min;
                  }
                }

                autoCount++;
              } else {
                var expr = def;

                if (limits) {
                  var orgWidth = _toPxWidth(grid, expr);

                  var newWidth = _applyColWidthLimits(limits, orgWidth);

                  if (orgWidth !== newWidth) {
                    expr = "".concat(newWidth, "px");
                  }

                  sumMin += newWidth;
                }

                others.push(expr);
              }

              if (shortCircuit && sumMin > fullWidth) {
                // Returns 0px because it has consumed the full width.
                return "0px";
              }
            }

            if (hasLimitsOnAuto.length && others.length) {
              var autoPx = (fullWidth - _toPxWidth(grid, "calc(".concat(others.map(function (c) {
                return typeof c === "number" ? "".concat(c, "px") : c;
              }).join(" + "), ")"))) / autoCount;
              hasLimitsOnAuto.forEach(function (limits) {
                if (limits.min && autoPx < limits.min) {
                  others.push(limits.minDef);
                  autoCount--;
                } else if (limits.max && limits.max < autoPx) {
                  others.push(limits.maxDef);
                  autoCount--;
                }
              });

              if (shortCircuit && autoCount <= 0) {
                return "".concat(autoPx, "px");
              }
            }

            if (others.length) {
              var strDefs = [];
              var num = 0;
              others.forEach(function (c) {
                if (typeof c === "number") {
                  num += c;
                } else {
                  strDefs.push(c);
                }
              });
              strDefs.push("".concat(num, "px"));
              return "calc((100% - (".concat(strDefs.join(" + "), ")) / ").concat(autoCount, ")");
            } else {
              return "".concat(100 / autoCount, "%");
            }
          }
          /**
           * Calculate the pixels of width from the definition of width.
           * @param {DrawGrid} grid grid instance
           * @param {string|number} width width definition
           * @returns {number} the pixels of width
           * @private
           */


          function _colWidthDefineToPxWidth(grid, width) {
            if (isAutoDefine(width)) {
              return _toPxWidth(grid, _calcAutoColWidthExpr(grid));
            }

            return _toPxWidth(grid, width);
          }
          /** @private */


          function _getColWidth(grid, col) {
            var width = _getColWidthDefine(grid, col);

            return _adjustColWidth(grid, col, _colWidthDefineToPxWidth(grid, width));
          }
          /** @private */


          function _setColWidth(grid, col, width) {
            if (width != null) {
              grid[_].colWidthsMap.put(col, width);
            } else {
              grid[_].colWidthsMap.remove(col);
            }
          }
          /**
           * Overwrites the definition of a column whose width is set to `auto` with the current auto width formula.
           * @param {DrawGrid} grid grid instance
           * @returns {void}
           * @private
           */


          function _storeAutoColWidthExprs(grid) {
            var expr = null;

            for (var col = 0; col < grid[_].colCount; col++) {
              var def = _getColWidthDefine(grid, col);

              if (isAutoDefine(def)) {
                _setColWidth(grid, col, expr || (expr = _calcAutoColWidthExpr(grid, false)));
              }
            }
          }
          /** @private */


          function _getColsWidth(grid, startCol, endCol) {
            var defaultColPxWidth = _colWidthDefineToPxWidth(grid, grid.defaultColWidth);

            var colCount = endCol - startCol + 1;
            var w = defaultColPxWidth * colCount;

            grid[_].colWidthsMap.each(startCol, endCol, function (width, col) {
              w += _adjustColWidth(grid, col, _colWidthDefineToPxWidth(grid, width)) - defaultColPxWidth;
            });

            for (var col = startCol; col <= endCol; col++) {
              if (grid[_].colWidthsMap.has(col)) {
                continue;
              }

              var adj = _adjustColWidth(grid, col, defaultColPxWidth);

              if (adj !== defaultColPxWidth) {
                w += adj - defaultColPxWidth;
              }
            }

            return w;
          }
          /** @private */


          function _getRowHeight(row) {
            var internal = this.getRowHeightInternal(row);

            if (internal != null) {
              return internal;
            }

            var height = this[_].rowHeightsMap.get(row);

            if (height) {
              return height;
            }

            return this[_].defaultRowHeight;
          }
          /** @private */


          function _setRowHeight(grid, row, height) {
            if (height != null) {
              grid[_].rowHeightsMap.put(row, height);
            } else {
              grid[_].rowHeightsMap.remove(row);
            }
          }
          /** @private */


          function _getRowsHeight(startRow, endRow) {
            var _this63 = this;

            var internal = this.getRowsHeightInternal(startRow, endRow);

            if (internal != null) {
              return internal;
            }

            var rowCount = endRow - startRow + 1;
            var h = this[_].defaultRowHeight * rowCount;

            this[_].rowHeightsMap.each(startRow, endRow, function (height) {
              h += height - _this63[_].defaultRowHeight;
            });

            return h;
          }
          /** @private */


          function _getScrollWidth(grid) {
            return _getColsWidth(grid, 0, grid[_].colCount - 1);
          }
          /** @private */


          function _getScrollHeight(row) {
            var _this64 = this;

            var internal = this.getScrollHeightInternal(row);

            if (internal != null) {
              return internal;
            }

            var h = this[_].defaultRowHeight * this[_].rowCount;

            this[_].rowHeightsMap.each(0, this[_].rowCount - 1, function (height) {
              h += height - _this64[_].defaultRowHeight;
            });

            return h;
          }
          /** @private */


          function _onScroll(grid, _e) {
            var lastLeft = grid[_].scroll.left;
            var lastTop = grid[_].scroll.top;
            var moveX = grid[_].scrollable.scrollLeft - lastLeft;
            var moveY = grid[_].scrollable.scrollTop - lastTop; //

            grid[_].scroll = {
              left: grid[_].scrollable.scrollLeft,
              top: grid[_].scrollable.scrollTop
            }; // If the focus is on the header, recalculate and move the focus position.

            var focus = grid[_].selection.focus;
            var isFrozenCell = grid.isFrozenCell(focus.col, focus.row);

            if (isFrozenCell && ((isFrozenCell === null || isFrozenCell === void 0 ? void 0 : isFrozenCell.col) && moveX || (isFrozenCell === null || isFrozenCell === void 0 ? void 0 : isFrozenCell.row) && moveY)) {
              grid.setFocusCursor(focus.col, focus.row);
            }

            var visibleRect = _getVisibleRect(grid);

            if (Math.abs(moveX) >= visibleRect.width || Math.abs(moveY) >= visibleRect.height) {
              //
              _invalidateRect(grid, visibleRect);
            } else {
              //
              grid[_].context.drawImage(grid[_].canvas, -moveX, -moveY);

              if (moveX !== 0) {
                //
                var redrawRect = visibleRect.copy();

                if (moveX < 0) {
                  redrawRect.width = -moveX;

                  if (grid[_].frozenColCount > 0) {
                    //
                    var frozenRect = _getFrozenColsRect(grid);

                    redrawRect.width += frozenRect.width;
                  }
                } else if (moveX > 0) {
                  redrawRect.left = redrawRect.right - moveX;
                } //


                _invalidateRect(grid, redrawRect);

                if (moveX > 0) {
                  if (grid[_].frozenColCount > 0) {
                    //
                    _invalidateRect(grid, _getFrozenColsRect(grid));
                  }
                }
              }

              if (moveY !== 0) {
                //
                var _redrawRect = visibleRect.copy();

                if (moveY < 0) {
                  _redrawRect.height = -moveY;

                  if (grid[_].frozenRowCount > 0) {
                    //
                    var _frozenRect2 = _getFrozenRowsRect(grid);

                    _redrawRect.height += _frozenRect2.height;
                  }
                } else if (moveY > 0) {
                  _redrawRect.top = _redrawRect.bottom - moveY;
                } //


                _invalidateRect(grid, _redrawRect);

                if (moveY > 0) {
                  if (grid[_].frozenRowCount > 0) {
                    //
                    _invalidateRect(grid, _getFrozenRowsRect(grid));
                  }
                }
              }
            }
          }
          /** @private */
          // eslint-disable-next-line complexity


          function _onKeyDownMove(e) {
            var _a, _b, _c;

            var keyCode = getKeyCode(e);
            var focusCell = e.shiftKey ? this.selection.focus : this.selection.select;
            var ctrlOrMeta = e.ctrlKey || e.metaKey;

            if (keyCode === KEY_LEFT) {
              if (e.altKey) return; // unknown modifier key

              if (ctrlOrMeta) {
                move(this, null, "W", e.shiftKey);
              } else {
                if (!hMove.call(this, "W", e.shiftKey)) {
                  return;
                }
              }

              cancelEvent(e);
            } else if (keyCode === KEY_UP) {
              if (e.altKey) return; // unknown modifier key

              if (ctrlOrMeta) {
                move(this, "N", null, e.shiftKey);
              } else {
                if (!vMove.call(this, "N", e.shiftKey)) {
                  return;
                }
              }

              cancelEvent(e);
            } else if (keyCode === KEY_RIGHT) {
              if (e.altKey) return; // unknown modifier key

              if (ctrlOrMeta) {
                move(this, null, "E", e.shiftKey);
              } else {
                if (!hMove.call(this, "E", e.shiftKey)) {
                  return;
                }
              }

              cancelEvent(e);
            } else if (keyCode === KEY_DOWN) {
              if (e.altKey) return; // unknown modifier key

              if (ctrlOrMeta) {
                move(this, "S", null, e.shiftKey);
              } else {
                if (!vMove.call(this, "S", e.shiftKey)) {
                  return;
                }
              }

              cancelEvent(e);
            } else if (keyCode === KEY_HOME) {
              if (e.altKey) return; // unknown modifier key

              if (ctrlOrMeta) {
                move(this, "N", "W", e.shiftKey);
              } else {
                move(this, null, "W", e.shiftKey);
              }

              cancelEvent(e);
            } else if (keyCode === KEY_END) {
              if (e.altKey) return; // unknown modifier key

              if (ctrlOrMeta) {
                move(this, "S", "E", e.shiftKey);
              } else {
                move(this, null, "E", e.shiftKey);
              }

              cancelEvent(e);
            } else if (((_a = this.keyboardOptions) === null || _a === void 0 ? void 0 : _a.moveCellOnTab) && keyCode === KEY_TAB) {
              if (e.altKey || ctrlOrMeta) return; // unknown modifier key

              var newCell = null;

              if (typeof this.keyboardOptions.moveCellOnTab === "function") {
                newCell = this.keyboardOptions.moveCellOnTab({
                  cell: focusCell,
                  grid: this,
                  event: e
                });
              }

              if (newCell) {
                _moveFocusCell.call(this, newCell.col, newCell.row, false);
              } else if (e.shiftKey) {
                if (!hMove.call(this, "W", false)) {
                  var row = this.getMoveUpRowByKeyDownInternal(focusCell);

                  if (0 > row) {
                    return;
                  }

                  _moveFocusCell.call(this, this.colCount - 1, row, false);
                }
              } else {
                if (!hMove.call(this, "E", false)) {
                  var _row3 = this.getMoveDownRowByKeyDownInternal(focusCell);

                  if (this.rowCount <= _row3) {
                    return;
                  }

                  _moveFocusCell.call(this, 0, _row3, false);
                }
              }

              cancelEvent(e);
            } else if (((_b = this.keyboardOptions) === null || _b === void 0 ? void 0 : _b.moveCellOnEnter) && keyCode === KEY_ENTER) {
              if (e.altKey || ctrlOrMeta) return; // unknown modifier key

              var _newCell = null;

              if (typeof this.keyboardOptions.moveCellOnEnter === "function") {
                _newCell = this.keyboardOptions.moveCellOnEnter({
                  cell: focusCell,
                  grid: this,
                  event: e
                });
              }

              if (_newCell) {
                _moveFocusCell.call(this, _newCell.col, _newCell.row, false);
              } else if (e.shiftKey) {
                if (!vMove.call(this, "N", false)) {
                  var col = this.getMoveLeftColByKeyDownInternal(focusCell);

                  if (0 > col) {
                    return;
                  }

                  _moveFocusCell.call(this, col, this.rowCount - 1, false);
                }
              } else {
                if (!vMove.call(this, "S", false)) {
                  var _col3 = this.getMoveRightColByKeyDownInternal(focusCell);

                  if (this.colCount <= _col3) {
                    return;
                  }

                  _moveFocusCell.call(this, _col3, Math.min(this.frozenRowCount, this.rowCount - 1), false);
                }
              }

              cancelEvent(e);
            } else if (((_c = this.keyboardOptions) === null || _c === void 0 ? void 0 : _c.selectAllOnCtrlA) && keyCode === KEY_ALPHA_A) {
              if (e.altKey || e.shiftKey) return; // unknown modifier key

              if (!ctrlOrMeta) return;
              this.selection.range = {
                start: {
                  col: 0,
                  row: 0
                },
                end: {
                  col: this.colCount - 1,
                  row: this.rowCount - 1
                }
              };
              this.invalidate();
              cancelEvent(e);
            }

            function move(grid, vDir, hDir, shiftKeyFlg) {
              var row = vDir === "S" ? grid.rowCount - 1 : vDir === "N" ? 0 : focusCell.row;
              var col = hDir === "E" ? grid.colCount - 1 : hDir === "W" ? 0 : focusCell.col;

              _moveFocusCell.call(grid, col, row, shiftKeyFlg);
            }

            function vMove(vDir, shiftKeyFlg) {
              var col = focusCell.col;
              var row;

              if (vDir === "S") {
                row = this.getMoveDownRowByKeyDownInternal(focusCell);

                if (this.rowCount <= row) {
                  // Avoids the problem of the scroll position breaking due to a delayed scrolling event if user hold down the arrow keys.
                  this.makeVisibleCell(col, this.rowCount - 1);
                  return false;
                }
              } else {
                row = this.getMoveUpRowByKeyDownInternal(focusCell);

                if (row < 0) {
                  // Avoids the problem of the scroll position breaking due to a delayed scrolling event if user hold down the arrow keys.
                  this.makeVisibleCell(col, 0);
                  return false;
                }
              }

              _moveFocusCell.call(this, col, row, shiftKeyFlg);

              return true;
            }

            function hMove(hDir, shiftKeyFlg) {
              var row = focusCell.row;
              var col;

              if (hDir === "E") {
                col = this.getMoveRightColByKeyDownInternal(focusCell);

                if (this.colCount <= col) {
                  // Avoids the problem of the scroll position breaking due to a delayed scrolling event if user hold down the arrow keys.
                  this.makeVisibleCell(this.colCount - 1, row);
                  return false;
                }
              } else {
                col = this.getMoveLeftColByKeyDownInternal(focusCell);

                if (col < 0) {
                  // Avoids the problem of the scroll position breaking due to a delayed scrolling event if user hold down the arrow keys.
                  this.makeVisibleCell(0, row);
                  return false;
                }
              }

              _moveFocusCell.call(this, col, row, shiftKeyFlg);

              return true;
            }
          }
          /** @private */


          function _moveFocusCell(col, row, shiftKey) {
            var offset = this.getOffsetInvalidateCells();

            function extendRange(range) {
              if (offset > 0) {
                range.start.col -= offset;
                range.start.row -= offset;
                range.end.col += offset;
                range.end.row += offset;
              }

              return range;
            }

            var beforeRange = extendRange(this.selection.range);
            var beforeRect = this.getCellRangeRect(beforeRange);

            this.selection._setFocusCell(col, row, shiftKey);

            this.makeVisibleCell(col, row);
            this.focusCell(col, row);
            var afterRange = extendRange(this.selection.range);
            var afterRect = this.getCellRangeRect(afterRange);

            if (afterRect.intersection(beforeRect)) {
              var invalidateRect = Rect_1.Rect.max(afterRect, beforeRect);

              _invalidateRect(this, invalidateRect);
            } else {
              _invalidateRect(this, beforeRect);

              _invalidateRect(this, afterRect);
            }
          }
          /** @private */


          function _updatedSelection() {
            var focusControl = this[_].focusControl;
            var _this$_$selection$sel = this[_].selection.select,
                selCol = _this$_$selection$sel.col,
                selRow = _this$_$selection$sel.row;
            var results = this.fireListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.EDITABLEINPUT_CELL, {
              col: selCol,
              row: selRow
            });
            var editMode = utils_1.array.findIndex(results, function (v) {
              return !!v;
            }) >= 0;
            focusControl.editMode = editMode;

            if (editMode) {
              focusControl.storeInputStatus();
              focusControl.setDefaultInputStatus();
              this.fireListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.MODIFY_STATUS_EDITABLEINPUT_CELL, {
                col: selCol,
                row: selRow,
                input: focusControl.input
              });
            }
          }
          /** @private */


          function _getMouseAbstractPoint(grid, evt) {
            var e;

            if (isTouchEvent(evt)) {
              e = evt.changedTouches[0];
            } else {
              e = evt;
            }

            var clientX = e.clientX || e.pageX + window.scrollX;
            var clientY = e.clientY || e.pageY + window.scrollY;

            var rect = grid[_].canvas.getBoundingClientRect();

            if (rect.right <= clientX) {
              return null;
            }

            if (rect.bottom <= clientY) {
              return null;
            }

            var x = clientX - rect.left + grid[_].scroll.left;
            var y = clientY - rect.top + grid[_].scroll.top;
            return {
              x: x,
              y: y
            };
          }
          /** @private */


          function _bindEvents() {
            // eslint-disable-next-line consistent-this, @typescript-eslint/no-this-alias
            var grid = this;
            var _grid$_ = grid[_],
                handler = _grid$_.handler,
                element = _grid$_.element,
                scrollable = _grid$_.scrollable;

            var getCellEventArgsSet = function getCellEventArgsSet(e) {
              var abstractPos = _getMouseAbstractPoint(grid, e);

              if (!abstractPos) {
                return {};
              }

              var cell = grid.getCellAt(abstractPos.x, abstractPos.y);

              if (cell.col < 0 || cell.row < 0) {
                return {
                  abstractPos: abstractPos,
                  cell: cell
                };
              }

              var eventArgs = {
                col: cell.col,
                row: cell.row,
                event: e
              };
              return {
                abstractPos: abstractPos,
                cell: cell,
                eventArgs: eventArgs
              };
            };

            var canResizeColumn = function canResizeColumn(col) {
              if (grid[_].disableColumnResize) {
                return false;
              }

              var limit = grid[_].colWidthsLimit[col];

              if (!limit || !limit.min || !limit.max) {
                return true;
              }

              return limit.max !== limit.min;
            };

            handler.on(element, "mousedown", function (e) {
              var eventArgsSet = getCellEventArgsSet(e);
              var abstractPos = eventArgsSet.abstractPos,
                  eventArgs = eventArgsSet.eventArgs;

              if (!abstractPos) {
                return;
              }

              if (eventArgs) {
                var results = grid.fireListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.MOUSEDOWN_CELL, eventArgs);

                if (utils_1.array.findIndex(results, function (v) {
                  return !v;
                }) >= 0) {
                  return;
                }
              }

              if (getMouseButtons(e) !== 1 && // For mobile safari. If we do not post-process here, the keyboard will not start in Mobile Safari.
              e.buttons !== 0) {
                return;
              }

              var resizeCol = _getResizeColAt(grid, abstractPos.x, abstractPos.y);

              if (resizeCol >= 0 && canResizeColumn(resizeCol)) {
                //
                grid[_].columnResizer.start(resizeCol, e);
              } else {
                //
                grid[_].cellSelector.start(e);
              }
            });
            handler.on(element, "mouseup", function (e) {
              if (!grid.hasListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.MOUSEUP_CELL)) {
                return;
              }

              var _getCellEventArgsSet = getCellEventArgsSet(e),
                  eventArgs = _getCellEventArgsSet.eventArgs;

              if (eventArgs) {
                grid.fireListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.MOUSEUP_CELL, eventArgs);
              }
            });
            var doubleTapBefore = null;
            var longTouchId = null;
            var useTouch = null;

            function useTouchStart() {
              if ((useTouch === null || useTouch === void 0 ? void 0 : useTouch.timeoutId) != null) clearTimeout(useTouch.timeoutId);
              useTouch = {};
            }

            function useTouchEnd() {
              if (useTouch) {
                if (useTouch.timeoutId != null) clearTimeout(useTouch.timeoutId);
                useTouch.timeoutId = setTimeout(function () {
                  useTouch = null;
                }, 350);
              }
            }

            handler.on(element, "touchstart", function (e) {
              // Since it is an environment where touch start can be used, it blocks mousemove that occurs after this.
              useTouchStart();

              var _getCellEventArgsSet2 = getCellEventArgsSet(e),
                  eventArgs = _getCellEventArgsSet2.eventArgs;

              if (eventArgs) {
                grid.fireListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.TOUCHSTART_CELL, eventArgs);
              }

              if (!doubleTapBefore) {
                doubleTapBefore = eventArgs;
                setTimeout(function () {
                  doubleTapBefore = null;
                }, 350);
              } else {
                if (eventArgs && eventArgs.col === doubleTapBefore.col && eventArgs.row === doubleTapBefore.row) {
                  grid.fireListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.DBLTAP_CELL, eventArgs);
                }

                doubleTapBefore = null;

                if (e.defaultPrevented) {
                  return;
                }
              }

              if (e.targetTouches.length > 1) {
                // If touchstart with multiple fingers,
                // it is not considered as an operation event.
                return;
              }

              longTouchId = setTimeout(function () {
                //
                longTouchId = null;

                var abstractPos = _getMouseAbstractPoint(grid, e);

                if (!abstractPos) {
                  return;
                }

                var resizeCol = _getResizeColAt(grid, abstractPos.x, abstractPos.y, 15);

                if (resizeCol >= 0 && canResizeColumn(resizeCol)) {
                  //
                  grid[_].columnResizer.start(resizeCol, e);
                } else {
                  //
                  grid[_].cellSelector.start(e);
                }
              }, 500);
            });

            function cancel(_e) {
              if (longTouchId) {
                clearTimeout(longTouchId);
                longTouchId = null;
              }
            }

            handler.on(element, "touchcancel", function (e) {
              cancel(e);
              useTouchEnd();
            });
            handler.on(element, "touchmove", cancel);
            handler.on(element, "touchend", function (e) {
              useTouchEnd();

              if (longTouchId) {
                clearTimeout(longTouchId);

                grid[_].cellSelector.select(e);

                longTouchId = null;
              }
            });
            var isMouseover = false;
            var mouseEnterCell = null;
            var mouseOverCell = null;

            function onMouseenterCell(cell, props) {
              grid.fireListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.MOUSEENTER_CELL, Object.assign(Object.assign({}, props), {
                col: cell.col,
                row: cell.row
              }));
              mouseEnterCell = cell;
            }

            function onMouseleaveCell(props) {
              var beforeMouseCell = mouseEnterCell;
              mouseEnterCell = null;

              if (beforeMouseCell) {
                grid.fireListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.MOUSELEAVE_CELL, Object.assign(Object.assign({}, props), {
                  col: beforeMouseCell.col,
                  row: beforeMouseCell.row
                }));
              }

              return beforeMouseCell || undefined;
            }

            function onMouseoverCell(cell, props) {
              grid.fireListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.MOUSEOVER_CELL, Object.assign(Object.assign({}, props), {
                col: cell.col,
                row: cell.row
              }));
              mouseOverCell = cell;
            }

            function onMouseoutCell(props) {
              var beforeMouseCell = mouseOverCell;
              mouseOverCell = null;

              if (beforeMouseCell) {
                grid.fireListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.MOUSEOUT_CELL, Object.assign(Object.assign({}, props), {
                  col: beforeMouseCell.col,
                  row: beforeMouseCell.row
                }));
              }

              return beforeMouseCell || undefined;
            }

            var scrollElement = scrollable.getElement();
            handler.on(scrollElement, "mouseover", function (_e) {
              isMouseover = true;
            });
            handler.on(scrollElement, "mouseout", function (event) {
              isMouseover = false;
              onMouseoutCell({
                event: event
              });
            });
            handler.on(element, "mouseleave", function (event) {
              onMouseleaveCell({
                event: event
              });
            });
            handler.on(element, "mousemove", function (e) {
              if (useTouch) {
                // Probably a mousemove event triggered by a touchstart. Therefore, this event is blocked.
                return;
              }

              var eventArgsSet = getCellEventArgsSet(e);
              var abstractPos = eventArgsSet.abstractPos,
                  eventArgs = eventArgsSet.eventArgs;

              if (eventArgs) {
                var beforeMouseCell = mouseEnterCell;

                if (beforeMouseCell) {
                  grid.fireListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.MOUSEMOVE_CELL, eventArgs);

                  if (beforeMouseCell.col !== eventArgs.col || beforeMouseCell.row !== eventArgs.row) {
                    var enterCell = {
                      col: eventArgs.col,
                      row: eventArgs.row
                    };
                    var outCell = onMouseoutCell({
                      related: enterCell,
                      event: e
                    });
                    var leaveCell = onMouseleaveCell({
                      related: enterCell,
                      event: e
                    });
                    onMouseenterCell(enterCell, {
                      related: leaveCell,
                      event: e
                    });

                    if (isMouseover) {
                      onMouseoverCell(enterCell, {
                        related: outCell,
                        event: e
                      });
                    }
                  } else if (isMouseover && !mouseOverCell) {
                    onMouseoverCell({
                      col: eventArgs.col,
                      row: eventArgs.row
                    }, {
                      event: e
                    });
                  }
                } else {
                  var _enterCell = {
                    col: eventArgs.col,
                    row: eventArgs.row
                  };
                  onMouseenterCell(_enterCell, {
                    event: e
                  });

                  if (isMouseover) {
                    onMouseoverCell(_enterCell, {
                      event: e
                    });
                  }

                  grid.fireListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.MOUSEMOVE_CELL, eventArgs);
                }
              } else {
                onMouseoutCell({
                  event: e
                });
                onMouseleaveCell({
                  event: e
                });
              }

              if (grid[_].columnResizer.moving(e) || grid[_].cellSelector.moving(e)) {
                return;
              }

              var style = element.style;

              if (!abstractPos) {
                if (style.cursor === "col-resize") {
                  style.cursor = "";
                }

                return;
              }

              var resizeCol = _getResizeColAt(grid, abstractPos.x, abstractPos.y);

              if (resizeCol >= 0 && canResizeColumn(resizeCol)) {
                style.cursor = "col-resize";
              } else {
                if (style.cursor === "col-resize") {
                  style.cursor = "";
                }
              }
            });
            handler.on(element, "click", function (e) {
              if (grid[_].columnResizer.lastMoving(e) || grid[_].cellSelector.lastMoving(e)) {
                return;
              }

              if (!grid.hasListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.CLICK_CELL)) {
                return;
              }

              var _getCellEventArgsSet3 = getCellEventArgsSet(e),
                  eventArgs = _getCellEventArgsSet3.eventArgs;

              if (!eventArgs) {
                return;
              }

              grid.fireListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.CLICK_CELL, eventArgs);
            });
            handler.on(element, "contextmenu", function (e) {
              if (!grid.hasListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.CONTEXTMENU_CELL)) {
                return;
              }

              var _getCellEventArgsSet4 = getCellEventArgsSet(e),
                  eventArgs = _getCellEventArgsSet4.eventArgs;

              if (!eventArgs) {
                return;
              }

              grid.fireListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.CONTEXTMENU_CELL, eventArgs);
            });
            handler.on(element, "dblclick", function (e) {
              if (!grid.hasListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.DBLCLICK_CELL)) {
                return;
              }

              var _getCellEventArgsSet5 = getCellEventArgsSet(e),
                  eventArgs = _getCellEventArgsSet5.eventArgs;

              if (!eventArgs) {
                return;
              }

              grid.fireListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.DBLCLICK_CELL, eventArgs);
            });

            grid[_].focusControl.onKeyDown(function (evt) {
              grid.fireListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.KEYDOWN, evt);
            });

            grid[_].selection.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.SELECTED_CELL, function (data) {
              grid.fireListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.SELECTED_CELL, data, data.selected);
            });

            scrollable.onScroll(function (e) {
              _onScroll(grid, e);

              grid.fireListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.SCROLL, {
                event: e
              });
            });

            grid[_].focusControl.onKeyDownMove(function (e) {
              _onKeyDownMove.call(grid, e);
            });

            grid.listen("copydata", function (range) {
              var copyRange = grid.getCopyRangeInternal(range);
              var copyLines = [];

              for (var row = copyRange.start.row; row <= copyRange.end.row; row++) {
                var copyLine = "";

                for (var col = copyRange.start.col; col <= copyRange.end.col; col++) {
                  var copyCellValue = grid.getCopyCellValue(col, row, copyRange);
                  var strCellValue = void 0;

                  if (typeof copyCellValue === "string") {
                    strCellValue = copyCellValue;
                  } else if (copyCellValue == null || // Asynchronous data is treated as empty.
                  typeof Promise !== "undefined" && copyCellValue instanceof Promise) {
                    strCellValue = "";
                  } else {
                    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                    strCellValue = "".concat(copyCellValue);

                    if (/^\[object .*\]$/.exec(strCellValue)) {
                      // Ignore maybe object
                      strCellValue = "";
                    }
                  }

                  copyLine += /[\t\n]/.test(strCellValue) ? // Need quote
                  "\"".concat(strCellValue.replace(/"/g, '""'), "\"") : strCellValue;

                  if (col < copyRange.end.col) {
                    copyLine += "\t";
                  }
                }

                copyLines.push(copyLine);
              }

              return copyLines.join("\n");
            });

            grid[_].focusControl.onCopy(function (_e) {
              return utils_1.array.find(grid.fireListeners("copydata", grid[_].selection.range), function (r) {
                return r != null;
              });
            });

            grid[_].focusControl.onPaste(function (_ref51) {
              var value = _ref51.value,
                  event = _ref51.event;
              var trimOnPaste = grid.trimOnPaste;
              var normalizedValue = (0, paste_utils_1.normalizePasteValue)(value);
              var _grid$_$selection$sel = grid[_].selection.select,
                  col = _grid$_$selection$sel.col,
                  row = _grid$_$selection$sel.row;
              var multi = /[\r\n\u2028\u2029\t]/.test(normalizedValue); // is multi cell values

              var rangeBoxValues = null;
              var pasteCellEvent = {
                col: col,
                row: row,
                value: value,
                normalizeValue: trimOnPaste ? normalizedValue.trim() : normalizedValue,
                multi: multi,

                get rangeBoxValues() {
                  return rangeBoxValues !== null && rangeBoxValues !== void 0 ? rangeBoxValues : rangeBoxValues = (0, paste_utils_1.parsePasteRangeBoxValues)(normalizedValue, {
                    trimOnPaste: trimOnPaste
                  });
                },

                event: event
              };
              grid.fireListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.PASTE_CELL, pasteCellEvent);
            });

            grid[_].focusControl.onInput(function (value) {
              var _grid$_$selection$sel2 = grid[_].selection.select,
                  col = _grid$_$selection$sel2.col,
                  row = _grid$_$selection$sel2.row;
              grid.fireListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.INPUT_CELL, {
                col: col,
                row: row,
                value: value
              });
            });

            grid[_].focusControl.onDelete(function (event) {
              var _grid$_$selection$sel3 = grid[_].selection.select,
                  col = _grid$_$selection$sel3.col,
                  row = _grid$_$selection$sel3.row;
              grid.fireListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.DELETE_CELL, {
                col: col,
                row: row,
                event: event
              });
            });

            grid[_].focusControl.onFocus(function (e) {
              grid.fireListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.FOCUS_GRID, e);
              grid[_].focusedGrid = true;
              var _grid$_$selection$sel4 = grid[_].selection.select,
                  col = _grid$_$selection$sel4.col,
                  row = _grid$_$selection$sel4.row;
              grid.invalidateCell(col, row);
            });

            grid[_].focusControl.onBlur(function (e) {
              grid.fireListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.BLUR_GRID, e);
              grid[_].focusedGrid = false;
              var _grid$_$selection$sel5 = grid[_].selection.select,
                  col = _grid$_$selection$sel5.col,
                  row = _grid$_$selection$sel5.row;
              grid.invalidateCell(col, row);
            });
          }
          /** @private */


          function _getResizeColAt(grid, abstractX, abstractY) {
            var offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 5;

            if (grid[_].frozenRowCount <= 0) {
              return -1;
            }

            var frozenRect = _getFrozenRowsRect(grid);

            if (!frozenRect.inPoint(abstractX, abstractY)) {
              return -1;
            }

            var cell = grid.getCellAt(abstractX, abstractY);
            var cellRect = grid.getCellRect(cell.col, cell.row);

            if (abstractX < cellRect.left + offset) {
              return cell.col - 1;
            }

            if (cellRect.right - offset < abstractX) {
              return cell.col;
            }

            return -1;
          }
          /** @private */


          function _getVisibleRect(grid) {
            var _grid$_2 = grid[_],
                _grid$_2$scroll = _grid$_2.scroll,
                left = _grid$_2$scroll.left,
                top = _grid$_2$scroll.top,
                _grid$_2$canvas = _grid$_2.canvas,
                width = _grid$_2$canvas.width,
                height = _grid$_2$canvas.height;
            return new Rect_1.Rect(left, top, width, height);
          }
          /** @private */


          function _getScrollableVisibleRect(grid) {
            var frozenColsWidth = 0;

            if (grid[_].frozenColCount > 0) {
              //
              var frozenRect = _getFrozenColsRect(grid);

              frozenColsWidth = frozenRect.width;
            }

            var frozenRowsHeight = 0;

            if (grid[_].frozenRowCount > 0) {
              //
              var _frozenRect3 = _getFrozenRowsRect(grid);

              frozenRowsHeight = _frozenRect3.height;
            }

            return new Rect_1.Rect(grid[_].scrollable.scrollLeft + frozenColsWidth, grid[_].scrollable.scrollTop + frozenRowsHeight, grid[_].canvas.width - frozenColsWidth, grid[_].canvas.height - frozenRowsHeight);
          }
          /** @private */


          function _toRelativeRect(grid, absoluteRect) {
            var rect = absoluteRect.copy();

            var visibleRect = _getVisibleRect(grid);

            rect.offsetLeft(-visibleRect.left);
            rect.offsetTop(-visibleRect.top);
            return rect;
          } //end private methods
          //
          //
          //
          //

          /**
           * managing mouse down moving
           * @private
           */


          var BaseMouseDownMover = /*#__PURE__*/function () {
            function BaseMouseDownMover(grid) {
              _classCallCheck(this, BaseMouseDownMover);

              this._grid = grid;
              this._handler = new EventHandler_1.EventHandler();
              this._events = {};
              this._started = false;
              this._moved = false;
            }

            _createClass(BaseMouseDownMover, [{
              key: "moving",
              value: function moving(_e) {
                return !!this._started;
              }
            }, {
              key: "lastMoving",
              value: function lastMoving(e) {
                // mouseupclick
                if (this.moving(e)) {
                  return true;
                }

                var last = this._mouseEndPoint;

                if (!last) {
                  return false;
                }

                var pt = _getMouseAbstractPoint(this._grid, e);

                return pt != null && pt.x === last.x && pt.y === last.y;
              }
            }, {
              key: "_bindMoveAndUp",
              value: function _bindMoveAndUp(e) {
                var _this65 = this;

                var events = this._events;
                var handler = this._handler;

                if (!isTouchEvent(e)) {
                  events.mousemove = handler.on(document.body, "mousemove", function (e) {
                    return _this65._mouseMove(e);
                  });
                  events.mouseup = handler.on(document.body, "mouseup", function (e) {
                    return _this65._mouseUp(e);
                  });
                } else {
                  events.touchmove = handler.on(document.body, "touchmove", function (e) {
                    return _this65._mouseMove(e);
                  }, {
                    passive: false
                  });
                  events.touchend = handler.on(document.body, "touchend", function (e) {
                    return _this65._mouseUp(e);
                  });
                  events.touchcancel = handler.on(document.body, "touchcancel", function (e) {
                    return _this65._mouseUp(e);
                  });
                }

                this._started = true;
                this._moved = false;
              }
            }, {
              key: "_mouseMove",
              value: function _mouseMove(e) {
                if (!isTouchEvent(e)) {
                  if (getMouseButtons(e) !== 1) {
                    this._mouseUp(e);

                    return;
                  }
                }

                this._moved = this._moveInternal(e) || this._moved
                /*calculation on after*/
                ;
                cancelEvent(e);
              }
            }, {
              key: "_moveInternal",
              value: function _moveInternal(_e) {
                //protected
                return false;
              }
            }, {
              key: "_mouseUp",
              value: function _mouseUp(e) {
                var _this66 = this;

                var events = this._events;
                var handler = this._handler;
                handler.off(events.mousemove);
                handler.off(events.touchmove);
                handler.off(events.mouseup);
                handler.off(events.touchend); // handler.off(this._events.mouseleave);

                handler.off(events.touchcancel);
                this._started = false;

                this._upInternal(e); // mouseupclick


                if (this._moved) {
                  //
                  this._mouseEndPoint = _getMouseAbstractPoint(this._grid, e);
                  setTimeout(function () {
                    _this66._mouseEndPoint = null;
                  }, 10);
                }
              }
            }, {
              key: "_upInternal",
              value: function _upInternal(_e) {//protected
              }
            }, {
              key: "dispose",
              value: function dispose() {
                this._handler.dispose();
              }
            }]);

            return BaseMouseDownMover;
          }();
          /**
           * managing cell selection operation with mouse
           * @private
           */


          var CellSelector = /*#__PURE__*/function (_BaseMouseDownMover) {
            _inherits(CellSelector, _BaseMouseDownMover);

            var _super46 = _createSuper(CellSelector);

            function CellSelector() {
              _classCallCheck(this, CellSelector);

              return _super46.apply(this, arguments);
            }

            _createClass(CellSelector, [{
              key: "start",
              value: function start(e) {
                var cell = this._getTargetCell(e);

                if (!cell) {
                  return;
                }

                _moveFocusCell.call(this._grid, cell.col, cell.row, e.shiftKey);

                this._bindMoveAndUp(e);

                this._cell = cell;
                cancelEvent(e);

                _vibrate(e);
              }
            }, {
              key: "select",
              value: function select(e) {
                var cell = this._getTargetCell(e);

                if (!cell) {
                  return;
                }

                _moveFocusCell.call(this._grid, cell.col, cell.row, e.shiftKey);

                this._cell = cell;
              }
            }, {
              key: "_moveInternal",
              value: function _moveInternal(e) {
                var cell = this._getTargetCell(e);

                if (!cell) {
                  return false;
                }

                var _this$_cell = this._cell,
                    oldCol = _this$_cell.col,
                    oldRow = _this$_cell.row;
                var newCol = cell.col,
                    newRow = cell.row;

                if (oldCol === newCol && oldRow === newRow) {
                  return false;
                }

                var grid = this._grid;

                _moveFocusCell.call(grid, newCol, newRow, true); //make visible


                var makeVisibleCol = function () {
                  if (newCol < oldCol && 0 < newCol) {
                    // move left
                    return newCol - 1;
                  } else if (oldCol < newCol && newCol + 1 < grid.colCount) {
                    // move right
                    return newCol + 1;
                  }

                  return newCol;
                }();

                var makeVisibleRow = function () {
                  if (newRow < oldRow && 0 < newRow) {
                    // move up
                    return newRow - 1;
                  } else if (oldRow < newRow && newRow + 1 < grid.rowCount) {
                    // move down
                    return newRow + 1;
                  }

                  return newRow;
                }();

                if (makeVisibleCol !== newCol || makeVisibleRow !== newRow) {
                  grid.makeVisibleCell(makeVisibleCol, makeVisibleRow);
                }

                this._cell = cell;
                return true;
              }
            }, {
              key: "_getTargetCell",
              value: function _getTargetCell(e) {
                var grid = this._grid;

                var abstractPos = _getMouseAbstractPoint(grid, e);

                if (!abstractPos) {
                  return null;
                }

                var cell = grid.getCellAt(abstractPos.x, abstractPos.y);

                if (cell.col < 0 || cell.row < 0) {
                  return null;
                }

                return cell;
              }
            }]);

            return CellSelector;
          }(BaseMouseDownMover);
          /**
           * managing row width changing operation with mouse
           * @private
           */


          var ColumnResizer = /*#__PURE__*/function (_BaseMouseDownMover2) {
            _inherits(ColumnResizer, _BaseMouseDownMover2);

            var _super47 = _createSuper(ColumnResizer);

            function ColumnResizer(grid) {
              var _this67;

              _classCallCheck(this, ColumnResizer);

              _this67 = _super47.call(this, grid);
              _this67._x = -1;
              _this67._preX = -1;
              _this67._invalidateAbsoluteLeft = -1;
              _this67._targetCol = -1;
              return _this67;
            }

            _createClass(ColumnResizer, [{
              key: "start",
              value: function start(col, e) {
                var pageX;

                if (!isTouchEvent(e)) {
                  pageX = e.pageX;
                } else {
                  pageX = e.changedTouches[0].pageX;
                }

                this._x = pageX;
                this._preX = 0;

                this._bindMoveAndUp(e);

                this._targetCol = col;
                this._invalidateAbsoluteLeft = _getColsWidth(this._grid, 0, col - 1);
                cancelEvent(e);

                _vibrate(e);
              }
            }, {
              key: "_moveInternal",
              value: function _moveInternal(e) {
                var pageX = isTouchEvent(e) ? e.changedTouches[0].pageX : e.pageX;
                var x = pageX - this._x;
                var moveX = x - this._preX;
                this._preX = x;

                var pre = this._grid.getColWidth(this._targetCol);

                var afterSize = _adjustColWidth(this._grid, this._targetCol, pre + moveX);

                if (afterSize < 10 && moveX < 0) {
                  afterSize = 10;
                }

                _storeAutoColWidthExprs(this._grid);

                _setColWidth(this._grid, this._targetCol, afterSize);

                var rect = _getVisibleRect(this._grid);

                rect.left = this._invalidateAbsoluteLeft;

                _invalidateRect(this._grid, rect);

                this._grid.fireListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.RESIZE_COLUMN, {
                  col: this._targetCol
                });

                return true;
              }
            }, {
              key: "_upInternal",
              value: function _upInternal(_e) {
                var grid = this._grid;

                if (grid.updateScroll()) {
                  grid.invalidate();
                }
              }
            }]);

            return ColumnResizer;
          }(BaseMouseDownMover);
          /** @private */


          function setSafeInputValue(input, value) {
            var type = input.type;
            input.type = "";
            input.value = value;

            if (type) {
              input.type = type;
            }
          }

          var IGNORE_STORE_ATTRS = ["style", "readonly"];
          /**
           * Manage focus
           * @private
           */

          var FocusControl = /*#__PURE__*/function (_EventTarget_1$EventT2) {
            _inherits(FocusControl, _EventTarget_1$EventT2);

            var _super48 = _createSuper(FocusControl);

            function FocusControl(grid, parentElement, scrollable, selection) {
              var _this68;

              _classCallCheck(this, FocusControl);

              _this68 = _super48.call(this);
              _this68._grid = grid;
              _this68._scrollable = scrollable;
              var handler = _this68._handler = new EventHandler_1.EventHandler();
              var input = _this68._input = document.createElement("input");
              input.classList.add("grid-focus-control");
              input.readOnly = true;
              parentElement.appendChild(input);
              handler.on(input, "compositionstart", function (_e) {
                input.classList.add("composition");
                input.style.font = grid.font || "16px sans-serif";
                _this68._isComposition = true;

                if (_this68._compositionEnd) {
                  clearTimeout(_this68._compositionEnd);
                  delete _this68._compositionEnd;
                }

                grid.focus();
              });
              var lastInputValue;

              var inputClear = function inputClear(storeLastInputValue) {
                lastInputValue = input.value;

                if (_this68._isComposition) {
                  return;
                }

                if (lastInputValue !== "") {
                  setSafeInputValue(input, "");
                }

                if (!storeLastInputValue) {
                  lastInputValue = "";
                }
              };

              var handleCompositionEnd = function handleCompositionEnd() {
                _this68._isComposition = false;
                input.classList.remove("composition");
                input.style.font = "";
                var value = input.value;
                inputClear(false);

                if (!input.readOnly) {
                  _this68.fireListeners("input", value);
                }

                if (_this68._compositionEnd) {
                  clearTimeout(_this68._compositionEnd);
                  delete _this68._compositionEnd;
                }
              };

              handler.on(input, "compositionend", function (_e) {
                _this68._compositionEnd = setTimeout(handleCompositionEnd, 1);
              });
              selection.listen("before_hook", function () {
                if (_this68._compositionEnd) {
                  handleCompositionEnd();
                }
              });
              handler.on(input, "keypress", function (e) {
                if (_this68._isComposition) {
                  return;
                }

                if (!input.readOnly && e.key && e.key.length === 1) {
                  if (e.ctrlKey || e.metaKey) {
                    if (e.key === "c") {//copy! for Firefox & Safari
                    } else if (e.key === "v") {//paste! for Firefox & Safari
                    }
                  } else {
                    if (e.key === " ") {
                      // Since the full-width space cannot be determined, it is processed by "input".
                      return;
                    }

                    _this68.fireListeners("input", e.key);

                    cancelEvent(e);
                  }
                }

                inputClear(true);
              });
              handler.on(input, "keydown", function (e) {
                var _a;

                if (_this68._isComposition) {
                  if (_this68._compositionEnd) {
                    handleCompositionEnd();
                    cancelEvent(e);
                  }

                  return;
                }

                var keyCode = getKeyCode(e);
                var stopCellMove = false;
                var evt = {
                  keyCode: keyCode,
                  event: e,
                  stopCellMoving: function stopCellMoving() {
                    stopCellMove = true;
                  }
                };

                _this68.fireListeners("keydown", evt);

                if (!input.readOnly && lastInputValue) {
                  // for Safari
                  _this68.fireListeners("input", lastInputValue);
                }

                if (!stopCellMove) _this68.fireKeyDownMove(keyCode, e);

                if (((_a = _this68._grid.keyboardOptions) === null || _a === void 0 ? void 0 : _a.deleteCellValueOnDel) && (keyCode === KEY_DEL || keyCode === KEY_BS)) {
                  _this68.fireListeners("delete", e);
                }

                inputClear(true);
              });
              handler.on(input, "keyup", function (_e) {
                if (_this68._isComposition) {
                  if (_this68._compositionEnd) {
                    handleCompositionEnd();
                  }
                }

                inputClear(true);
              });
              handler.on(input, "input", function (e) {
                if (e.data === " " || e.data === "") {
                  // Since the full-width space cannot be determined on "keypress", it is processed by "input".
                  _this68.fireListeners("input", e.data);
                }

                inputClear(true);
              });

              if (utils_1.browser.IE) {
                handler.on(document, "keydown", function (e) {
                  if (e.target !== input) {
                    return;
                  }

                  var keyCode = getKeyCode(e);

                  if (keyCode === KEY_ALPHA_C && e.ctrlKey) {
                    // When text is not selected copy-event is not emit, on IE.
                    setSafeInputValue(input, "dummy");
                    input.select();
                    setTimeout(function () {
                      setSafeInputValue(input, "");
                    }, 100);
                  } else if (keyCode === KEY_ALPHA_V && e.ctrlKey) {
                    // When input is read-only paste-event is not emit, on IE.
                    if (input.readOnly) {
                      input.readOnly = false;
                      setTimeout(function () {
                        input.readOnly = true;
                        setSafeInputValue(input, "");
                      }, 10);
                    }
                  }
                });
              }

              if (utils_1.browser.Edge) {
                handler.once(document, "keydown", function (e) {
                  var _a;

                  if (!(0, utils_1.isDescendantElement)(parentElement, e.target)) {
                    return;
                  } // When the input has focus on the first page opening, the paste-event and copy-event is not emit, on Edge.


                  var dummyInput = document.createElement("input");
                  grid.getElement().appendChild(dummyInput);
                  dummyInput.focus();
                  input.focus();
                  (_a = dummyInput.parentElement) === null || _a === void 0 ? void 0 : _a.removeChild(dummyInput);
                });
              }

              handler.on(document, "paste", function (e) {
                if (!(0, utils_1.isDescendantElement)(parentElement, e.target)) {
                  return;
                }

                var pasteText = undefined;

                if (utils_1.browser.IE) {
                  // IE
                  // eslint-disable-next-line @typescript-eslint/no-explicit-any
                  pasteText = window.clipboardData.getData("Text");
                } else {
                  var clipboardData = e.clipboardData;

                  if (clipboardData.items) {
                    // Chrome & Firefox & Edge
                    pasteText = clipboardData.getData("text/plain");
                  } else {
                    // Safari
                    if (-1 !== Array.prototype.indexOf.call(clipboardData.types, "text/plain")) {
                      pasteText = clipboardData.getData("Text");
                    }
                  }
                }

                if (pasteText != null && pasteText.length) {
                  _this68.fireListeners("paste", {
                    value: pasteText,
                    event: e
                  });
                }
              });
              handler.on(document, "copy", function (e) {
                if (_this68._isComposition) {
                  return;
                }

                if (!(0, utils_1.isDescendantElement)(parentElement, e.target)) {
                  return;
                }

                setSafeInputValue(input, "");
                var data = utils_1.array.find(_this68.fireListeners("copy"), function (r) {
                  return r != null;
                });

                if (data != null) {
                  cancelEvent(e);

                  if (utils_1.browser.IE) {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    window.clipboardData.setData("Text", data); // IE
                  } else {
                    e.clipboardData.setData("text/plain", data); // Chrome, Firefox
                  }
                }
              });
              handler.on(input, "focus", function (e) {
                _this68.fireListeners("focus", e);
              });
              handler.on(input, "blur", function (e) {
                _this68.fireListeners("blur", e);
              });
              return _this68;
            }

            _createClass(FocusControl, [{
              key: "fireKeyDownMove",
              value: function fireKeyDownMove(keyCode, e) {
                var _a, _b, _c;

                var fn = this._keyDownMoveCallback;

                if (!fn) {
                  return;
                }

                if (this._isComposition) {
                  return;
                }

                if (keyCode === KEY_LEFT || keyCode === KEY_UP || keyCode === KEY_RIGHT || keyCode === KEY_DOWN || keyCode === KEY_HOME || keyCode === KEY_END) {
                  fn(e);
                } else if (((_a = this._grid.keyboardOptions) === null || _a === void 0 ? void 0 : _a.moveCellOnTab) && keyCode === KEY_TAB) {
                  fn(e);
                } else if (((_b = this._grid.keyboardOptions) === null || _b === void 0 ? void 0 : _b.moveCellOnEnter) && keyCode === KEY_ENTER) {
                  fn(e);
                } else if (((_c = this._grid.keyboardOptions) === null || _c === void 0 ? void 0 : _c.selectAllOnCtrlA) && keyCode === KEY_ALPHA_A && (e.ctrlKey || e.metaKey)) {
                  fn(e);
                }
              }
            }, {
              key: "onKeyDownMove",
              value: function onKeyDownMove(fn) {
                this._keyDownMoveCallback = fn;
              }
            }, {
              key: "onKeyDown",
              value: function onKeyDown(fn) {
                return this.listen("keydown", fn);
              }
            }, {
              key: "onInput",
              value: function onInput(fn) {
                return this.listen("input", fn);
              }
            }, {
              key: "onDelete",
              value: function onDelete(fn) {
                return this.listen("delete", fn);
              }
            }, {
              key: "onCopy",
              value: function onCopy(fn) {
                return this.listen("copy", fn);
              }
            }, {
              key: "onPaste",
              value: function onPaste(fn) {
                return this.listen("paste", fn);
              }
            }, {
              key: "onFocus",
              value: function onFocus(fn) {
                return this.listen("focus", fn);
              }
            }, {
              key: "onBlur",
              value: function onBlur(fn) {
                return this.listen("blur", fn);
              }
            }, {
              key: "focus",
              value: function focus() {
                // this._input.value = '';
                this._input.focus();
              }
            }, {
              key: "setFocusRect",
              value: function setFocusRect(rect) {
                var input = this._input;

                var top = this._scrollable.calcTop(rect.top);

                input.style.top = "".concat((top - style.getScrollBarSize()).toFixed(), "px"); //position:relative IE position:relative

                input.style.left = "".concat(rect.left.toFixed(), "px");
                input.style.width = "".concat(rect.width.toFixed(), "px");
                input.style.height = "".concat(rect.height.toFixed(), "px");
              }
            }, {
              key: "editMode",
              get: function get() {
                return !this._input.readOnly;
              },
              set: function set(editMode) {
                this._input.readOnly = !editMode;
              }
            }, {
              key: "resetInputStatus",
              value: function resetInputStatus() {
                var _a;

                var el = this._input;

                if (!el.classList.contains("grid-focus-control--stored-status")) {
                  return;
                }

                var composition = el.classList.contains("composition");
                var attrs = el.attributes;
                var removeNames = [];

                for (var i = 0, n = attrs.length; i < n; i++) {
                  var attr = attrs[i];
                  if (IGNORE_STORE_ATTRS.indexOf(attr.name) >= 0) continue;

                  if (!((_a = this._inputStatus) === null || _a === void 0 ? void 0 : _a.hasOwnProperty(attr.nodeName))) {
                    removeNames.push(attr.name);
                  }
                }

                removeNames.forEach(function (removeName) {
                  el.removeAttribute(removeName);
                });

                for (var name in this._inputStatus) {
                  el.setAttribute(name, this._inputStatus[name]);
                }

                if (composition) {
                  el.classList.add("composition");
                  el.style.font = this._grid.font || "16px sans-serif";
                } else {
                  el.classList.remove("composition");
                }

                el.classList.remove("grid-focus-control--stored-status");
              }
            }, {
              key: "storeInputStatus",
              value: function storeInputStatus() {
                var el = this._input;

                if (el.classList.contains("grid-focus-control--stored-status")) {
                  return;
                }

                var inputStatus = this._inputStatus = {};
                var attrs = el.attributes;

                for (var i = 0, n = attrs.length; i < n; i++) {
                  var attr = attrs[i];
                  if (IGNORE_STORE_ATTRS.indexOf(attr.name) >= 0) continue;
                  inputStatus[attr.name] = attr.value;
                }

                el.classList.add("grid-focus-control--stored-status");
              }
            }, {
              key: "setDefaultInputStatus",
              value: function setDefaultInputStatus() {// 
                // this._input.style.font = this._grid.font || '16px sans-serif';
              }
            }, {
              key: "input",
              get: function get() {
                return this._input;
              }
            }, {
              key: "dispose",
              value: function dispose() {
                _get(_getPrototypeOf(FocusControl.prototype), "dispose", this).call(this);

                this._handler.dispose();
              }
            }]);

            return FocusControl;
          }(EventTarget_1.EventTarget);
          /**
           * Selected area management
           */


          var Selection = /*#__PURE__*/function (_EventTarget_1$EventT3) {
            _inherits(Selection, _EventTarget_1$EventT3);

            var _super49 = _createSuper(Selection);

            function Selection(grid) {
              var _this69;

              _classCallCheck(this, Selection);

              _this69 = _super49.call(this);
              _this69._grid = grid;
              _this69._sel = {
                col: 0,
                row: 0
              };
              _this69._focus = {
                col: 0,
                row: 0
              };
              _this69._start = {
                col: 0,
                row: 0
              };
              _this69._end = {
                col: 0,
                row: 0
              };
              return _this69;
            }

            _createClass(Selection, [{
              key: "range",
              get: function get() {
                var start = this._start;
                var end = this._end;
                var startCol = Math.min(start.col, end.col);
                var startRow = Math.min(start.row, end.row);
                var endCol = Math.max(start.col, end.col);
                var endRow = Math.max(start.row, end.row);
                return {
                  start: {
                    col: startCol,
                    row: startRow
                  },
                  end: {
                    col: endCol,
                    row: endRow
                  }
                };
              },
              set: function set(range) {
                var _this70 = this;

                this._callBeforeHooks();

                var startCol = Math.min(range.start.col, range.end.col);
                var startRow = Math.min(range.start.row, range.end.row);
                var endCol = Math.max(range.start.col, range.end.col);
                var endRow = Math.max(range.start.row, range.end.row);

                this._wrapFireSelectedEvent(function () {
                  _this70._sel = {
                    col: startCol,
                    row: startRow
                  };
                  _this70._focus = {
                    col: startCol,
                    row: startRow
                  };
                  _this70._start = {
                    col: startCol,
                    row: startRow
                  };
                  _this70._end = {
                    col: endCol,
                    row: endRow
                  };

                  _updatedSelection.call(_this70._grid);
                });
              }
            }, {
              key: "focus",
              get: function get() {
                var _this$_focus = this._focus,
                    col = _this$_focus.col,
                    row = _this$_focus.row;
                return {
                  col: col,
                  row: row
                };
              }
            }, {
              key: "select",
              get: function get() {
                var _this$_sel = this._sel,
                    col = _this$_sel.col,
                    row = _this$_sel.row;
                return {
                  col: col,
                  row: row
                };
              },
              set: function set(cell) {
                var _this71 = this;

                this._callBeforeHooks();

                this._wrapFireSelectedEvent(function () {
                  var _cell$col = cell.col,
                      col = _cell$col === void 0 ? 0 : _cell$col,
                      _cell$row = cell.row,
                      row = _cell$row === void 0 ? 0 : _cell$row;

                  _this71._setSelectCell(col, row);

                  _this71._setFocusCell(col, row, true, true);

                  _updatedSelection.call(_this71._grid);
                });
              }
            }, {
              key: "_setSelectCell",
              value: function _setSelectCell(col, row) {
                var _this72 = this;

                this._wrapFireSelectedEvent(function () {
                  _this72._sel = {
                    col: col,
                    row: row
                  };
                  _this72._start = {
                    col: col,
                    row: row
                  };
                });
              }
            }, {
              key: "_setFocusCell",
              value: function _setFocusCell(col, row, keepSelect, ignoreBeforeHook) {
                var _this73 = this;

                if (!ignoreBeforeHook) this._callBeforeHooks();

                this._wrapFireSelectedEvent(function () {
                  if (!keepSelect) {
                    _this73._setSelectCell(col, row);
                  }

                  _this73._focus = {
                    col: col,
                    row: row
                  };
                  _this73._end = {
                    col: col,
                    row: row
                  };
                });
              }
            }, {
              key: "_wrapFireSelectedEvent",
              value: function _wrapFireSelectedEvent(callback) {
                if (this._isWrapped) {
                  callback();
                } else {
                  this._isWrapped = true;

                  try {
                    var before = {
                      col: this._sel.col,
                      row: this._sel.row,
                      selected: false,
                      after: null
                    };
                    callback();
                    var after = {
                      col: this._sel.col,
                      row: this._sel.row,
                      selected: true,
                      before: {
                        col: before.col,
                        row: before.row
                      }
                    };
                    before.after = {
                      col: after.col,
                      row: after.row
                    };
                    this.fireListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.SELECTED_CELL, before);
                    this.fireListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.SELECTED_CELL, after);
                  } finally {
                    this._isWrapped = false;
                  }
                }
              }
            }, {
              key: "_updateGridRange",
              value: function _updateGridRange() {
                var _this$_grid = this._grid,
                    rowCount = _this$_grid.rowCount,
                    colCount = _this$_grid.colCount;
                var points = [this._sel, this._focus, this._start, this._end];
                var needChange = false;

                for (var i = 0; i < points.length; i++) {
                  if (colCount <= points[i].col || rowCount <= points[i].row) {
                    needChange = true;
                    break;
                  }
                }

                if (!needChange) {
                  return false;
                }

                this._wrapFireSelectedEvent(function () {
                  points.forEach(function (p) {
                    p.col = Math.min(colCount - 1, p.col);
                    p.row = Math.min(rowCount - 1, p.row);
                  });
                });

                return true;
              }
            }, {
              key: "_callBeforeHooks",
              value: function _callBeforeHooks() {
                this.fireListeners("before_hook");
              }
            }]);

            return Selection;
          }(EventTarget_1.EventTarget);
          /**
           * This class manages the drawing process for each layer
           */

          /** @private */


          var DrawLayers = /*#__PURE__*/function () {
            function DrawLayers() {
              _classCallCheck(this, DrawLayers);

              this._layers = {};
            }

            _createClass(DrawLayers, [{
              key: "addDraw",
              value: function addDraw(level, fn) {
                var l = this._layers[level] || (this._layers[level] = new DrawLayer(level));
                l.addDraw(fn);
              }
            }, {
              key: "draw",
              value: function draw(ctx) {
                var list = [];

                for (var k in this._layers) {
                  list.push(this._layers[k]);
                }

                list.sort(function (a, b) {
                  return a.level - b.level;
                });
                list.forEach(function (l) {
                  return l.draw(ctx);
                });
              }
            }]);

            return DrawLayers;
          }();
          /** @private */


          var DrawLayer = /*#__PURE__*/function () {
            function DrawLayer(level) {
              _classCallCheck(this, DrawLayer);

              this._level = level;
              this._list = [];
            }

            _createClass(DrawLayer, [{
              key: "level",
              get: function get() {
                return this._level;
              }
            }, {
              key: "addDraw",
              value: function addDraw(fn) {
                this._list.push(fn);
              }
            }, {
              key: "draw",
              value: function draw(ctx) {
                this._list.forEach(function (fn) {
                  ctx.save();

                  try {
                    fn(ctx);
                  } finally {
                    ctx.restore();
                  }
                });
              }
            }]);

            return DrawLayer;
          }();
          /**
           * Context of cell drawing
           * @private
           */


          var DrawCellContext = /*#__PURE__*/function () {
            //  private _grid: any;
            //  private _onTerminate: any;

            /**
             * constructor
             * @param {number} col index of column
             * @param {number} row index of row
             * @param {CanvasRenderingContext2D} ctx context
             * @param {Rect} rect rect of cell area
             * @param {Rect} drawRect rect of drawing area
             * @param {boolean} drawing `true` if drawing is in progress
             * @param {object} selection the selection
             * @param {Array} drawLayers array of draw layers
             * @private
             */
            function DrawCellContext(col, row, ctx, rect, drawRect, drawing, selection, drawLayers) {
              _classCallCheck(this, DrawCellContext);

              this._rectFilter = null;
              this._col = col;
              this._row = row;
              this._mode = 0;
              this._ctx = ctx;
              this._rect = rect;
              this._drawRect = drawRect;
              this._drawing = drawing;
              this._selection = selection;
              this._drawLayers = drawLayers;
              this._childContexts = [];
            }

            _createClass(DrawCellContext, [{
              key: "drawing",
              get: function get() {
                if (this._mode === 0) {
                  return this._drawing;
                } else {
                  return true;
                }
              }
            }, {
              key: "row",
              get: function get() {
                return this._row;
              }
            }, {
              key: "col",
              get: function get() {
                return this._col;
              }
            }, {
              key: "cancel",
              value: function cancel() {
                this._cancel = true;

                this._childContexts.forEach(function (ctx) {
                  ctx.cancel();
                });
              }
              /**
               * select status.
               * @return {object} select status
               */

            }, {
              key: "getSelection",
              value: function getSelection() {
                return {
                  select: this._selection.select,
                  range: this._selection.range
                };
              }
              /**
               * Canvas context.
               * @return {CanvasRenderingContext2D} Canvas context.
               */

            }, {
              key: "getContext",
              value: function getContext() {
                if (this._mode === 0) {
                  return this._ctx;
                } else {
                  return _getInitContext.call(this._grid);
                }
              }
              /**
               * Rectangle of cell.
               * @return {Rect} rect Rectangle of cell.
               */

            }, {
              key: "getRect",
              value: function getRect() {
                var rectFilter = this._rectFilter;
                return rectFilter ? rectFilter(this._getRectInternal()) : this._getRectInternal();
              }
            }, {
              key: "setRectFilter",
              value: function setRectFilter(rectFilter) {
                this._rectFilter = rectFilter;
              }
              /**
               * Rectangle of Drawing range.
               * @return {Rect} Rectangle of Drawing range.
               */

            }, {
              key: "getDrawRect",
              value: function getDrawRect() {
                if (this._cancel) {
                  return null;
                }

                if (this._mode === 0) {
                  return this._drawRect;
                } else {
                  if (this._isOutOfRange()) {
                    return null;
                  }

                  var absoluteRect = this._grid.getCellRect(this._col, this._row);

                  return this._toRelativeDrawRect(absoluteRect);
                }
              }
            }, {
              key: "_isOutOfRange",
              value: function _isOutOfRange() {
                var _this$_grid2 = this._grid,
                    colCount = _this$_grid2.colCount,
                    rowCount = _this$_grid2.rowCount;
                return colCount <= this._col || rowCount <= this._row;
              }
              /**
               * get Context of current state
               * @return {DrawCellContext} current DrawCellContext.
               */

            }, {
              key: "toCurrentContext",
              value: function toCurrentContext() {
                if (this._mode === 0) {
                  return this;
                } else {
                  var absoluteRect = this._grid.getCellRect(this._col, this._row);

                  var rect = _toRelativeRect(this._grid, absoluteRect);

                  var drawRect = this._isOutOfRange() ? null : this._toRelativeDrawRect(absoluteRect);
                  var context = new DrawCellContext(this._col, this._row, this.getContext(), rect, drawRect, this.drawing, this._selection, this._drawLayers); // toCurrentContext  toCurrentContext

                  context.toCurrentContext = this.toCurrentContext.bind(this);

                  this._childContexts.push(context);

                  if (this._cancel) {
                    context.cancel();
                  }

                  context._rectFilter = this._rectFilter;
                  return context;
                }
              }
            }, {
              key: "addLayerDraw",
              value: function addLayerDraw(level, fn) {
                this._drawLayers.addDraw(level, fn);
              }
            }, {
              key: "_toRelativeDrawRect",
              value: function _toRelativeDrawRect(absoluteRect) {
                var visibleRect = _getVisibleRect(this._grid);

                var rect = absoluteRect.copy();

                if (!rect.intersection(visibleRect)) {
                  return null;
                }

                var grid = this._grid;
                var isFrozenCell = grid.isFrozenCell(this._col, this._row);

                if (grid.frozenColCount >= 0 && (!isFrozenCell || !isFrozenCell.col)) {
                  var fRect = grid.getCellRect(grid.frozenColCount - 1, this._row);
                  rect = Rect_1.Rect.bounds(Math.max(rect.left, fRect.right), rect.top, rect.right, rect.bottom);
                }

                if (grid.frozenRowCount >= 0 && (!isFrozenCell || !isFrozenCell.row)) {
                  var _fRect = grid.getCellRect(this._col, grid.frozenRowCount - 1);

                  rect = Rect_1.Rect.bounds(rect.left, Math.max(rect.top, _fRect.bottom), rect.right, rect.bottom);
                }

                if (!rect.intersection(visibleRect)) {
                  return null;
                }

                rect.offsetLeft(-visibleRect.left);
                rect.offsetTop(-visibleRect.top);
                return rect;
              }
            }, {
              key: "_delayMode",
              value: function _delayMode(grid, onTerminate) {
                this._mode = 1;
                this._ctx = null;
                this._rect = null;
                this._drawRect = null;
                this._grid = grid;
                this._onTerminate = onTerminate;
              }
              /**
               * terminate
               * @return {void}
               */

            }, {
              key: "terminate",
              value: function terminate() {
                var _a;

                if (this._mode !== 0) {
                  (_a = this._onTerminate) === null || _a === void 0 ? void 0 : _a.call(this);
                }
              }
            }, {
              key: "_getRectInternal",
              value: function _getRectInternal() {
                if (this._mode === 0) {
                  return this._rect;
                } else {
                  if (this._rect) {
                    return this._rect;
                  }

                  return this._grid.getCellRelativeRect(this._col, this._row);
                }
              }
            }]);

            return DrawCellContext;
          }();
          /** @private */


          var protectedKey = _;
          /**
           * DrawGrid
           * @classdesc cheetahGrid.core.DrawGrid
           * @memberof cheetahGrid.core
           */

          var DrawGrid = /*#__PURE__*/function (_EventTarget_1$EventT4) {
            _inherits(DrawGrid, _EventTarget_1$EventT4);

            var _super50 = _createSuper(DrawGrid);

            function DrawGrid() {
              var _this74;

              var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, DrawGrid);

              _this74 = _super50.call(this);
              var _options$rowCount = options.rowCount,
                  rowCount = _options$rowCount === void 0 ? 10 : _options$rowCount,
                  _options$colCount = options.colCount,
                  colCount = _options$colCount === void 0 ? 10 : _options$colCount,
                  _options$frozenColCou = options.frozenColCount,
                  frozenColCount = _options$frozenColCou === void 0 ? 0 : _options$frozenColCou,
                  _options$frozenRowCou = options.frozenRowCount,
                  frozenRowCount = _options$frozenRowCou === void 0 ? 0 : _options$frozenRowCou,
                  _options$defaultRowHe = options.defaultRowHeight,
                  defaultRowHeight = _options$defaultRowHe === void 0 ? 40 : _options$defaultRowHe,
                  _options$defaultColWi = options.defaultColWidth,
                  defaultColWidth = _options$defaultColWi === void 0 ? 80 : _options$defaultColWi,
                  font = options.font,
                  underlayBackgroundColor = options.underlayBackgroundColor,
                  keyboardOptions = options.keyboardOptions,
                  parentElement = options.parentElement,
                  disableColumnResize = options.disableColumnResize,
                  trimOnPaste = options.trimOnPaste;
              var protectedSpace = _this74[_] = {};
              style.initDocument();
              protectedSpace.element = createRootElement();
              protectedSpace.scrollable = new Scrollable_1.Scrollable();
              protectedSpace.handler = new EventHandler_1.EventHandler();
              protectedSpace.selection = new Selection(_assertThisInitialized(_this74));
              protectedSpace.focusControl = new FocusControl(_assertThisInitialized(_this74), protectedSpace.scrollable.getElement(), protectedSpace.scrollable, protectedSpace.selection);
              protectedSpace.canvas = hiDPI.transform(document.createElement("canvas"));
              protectedSpace.context = protectedSpace.canvas.getContext("2d", {
                alpha: false
              });
              protectedSpace.rowCount = rowCount;
              protectedSpace.colCount = colCount;
              protectedSpace.frozenColCount = frozenColCount;
              protectedSpace.frozenRowCount = frozenRowCount;
              protectedSpace.defaultRowHeight = defaultRowHeight;
              protectedSpace.defaultColWidth = defaultColWidth;
              protectedSpace.font = font;
              protectedSpace.underlayBackgroundColor = underlayBackgroundColor;
              protectedSpace.keyboardOptions = keyboardOptions;
              protectedSpace.disableColumnResize = disableColumnResize;
              protectedSpace.trimOnPaste = trimOnPaste !== null && trimOnPaste !== void 0 ? trimOnPaste : false; /////

              protectedSpace.rowHeightsMap = new NumberMap_1.NumberMap();
              protectedSpace.colWidthsMap = new NumberMap_1.NumberMap();
              protectedSpace.colWidthsLimit = {};
              protectedSpace.calcWidthContext = {
                _: protectedSpace,

                get full() {
                  return this._.canvas.width;
                },

                get em() {
                  return (0, canvases_1.getFontSize)(this._.context, this._.font).width;
                }

              };
              protectedSpace.columnResizer = new ColumnResizer(_assertThisInitialized(_this74));
              protectedSpace.cellSelector = new CellSelector(_assertThisInitialized(_this74));
              protectedSpace.drawCells = {};
              protectedSpace.cellTextOverflows = {};
              protectedSpace.focusedGrid = false;
              protectedSpace.element.appendChild(protectedSpace.canvas);
              protectedSpace.element.appendChild(protectedSpace.scrollable.getElement());
              protectedSpace.scroll = {
                left: 0,
                top: 0
              };

              _this74.updateScroll();

              if (parentElement) {
                parentElement.appendChild(protectedSpace.element);

                _this74.updateSize();
              } else {
                _this74.updateSize();
              }

              _bindEvents.call(_assertThisInitialized(_this74));

              _this74.bindEventsInternal();

              return _this74;
            }
            /**
             * Get root element.
             * @returns {HTMLElement} root element
             */


            _createClass(DrawGrid, [{
              key: "getElement",
              value: function getElement() {
                return this[_].element;
              }
              /**
               * Get canvas element.
               */

            }, {
              key: "canvas",
              get: function get() {
                return this[_].canvas;
              }
              /**
               * Focus the grid.
               * @return {void}
               */

            }, {
              key: "focus",
              value: function focus() {
                var _this$_$selection$sel2 = this[_].selection.select,
                    col = _this$_$selection$sel2.col,
                    row = _this$_$selection$sel2.row;
                this.focusCell(col, row);
              }
            }, {
              key: "hasFocusGrid",
              value: function hasFocusGrid() {
                return this[_].focusedGrid;
              }
              /**
               * Get the selection instance.
               */

            }, {
              key: "selection",
              get: function get() {
                return this[_].selection;
              }
              /**
               * Get the number of rows.
               */

            }, {
              key: "rowCount",
              get: function get() {
                return this[_].rowCount;
              }
              /**
               * Set the number of rows.
               */
              ,
              set: function set(rowCount) {
                this[_].rowCount = rowCount;
                this.updateScroll();

                if (this[_].selection._updateGridRange()) {
                  var _this$_$selection$foc = this[_].selection.focus,
                      col = _this$_$selection$foc.col,
                      row = _this$_$selection$foc.row;
                  this.makeVisibleCell(col, row);
                  this.setFocusCursor(col, row);
                }
              }
              /**
               * Get the number of columns.
               */

            }, {
              key: "colCount",
              get: function get() {
                return this[_].colCount;
              }
              /**
               * Set the number of columns.
               */
              ,
              set: function set(colCount) {
                this[_].colCount = colCount;
                this.updateScroll();

                if (this[_].selection._updateGridRange()) {
                  var _this$_$selection$foc2 = this[_].selection.focus,
                      col = _this$_$selection$foc2.col,
                      row = _this$_$selection$foc2.row;
                  this.makeVisibleCell(col, row);
                  this.setFocusCursor(col, row);
                }
              }
              /**
               * Get the number of frozen columns.
               */

            }, {
              key: "frozenColCount",
              get: function get() {
                return this[_].frozenColCount;
              }
              /**
               * Set the number of frozen columns.
               */
              ,
              set: function set(frozenColCount) {
                this[_].frozenColCount = frozenColCount;
              }
              /**
               * Get the number of frozen rows.
               */

            }, {
              key: "frozenRowCount",
              get: function get() {
                return this[_].frozenRowCount;
              }
              /**
               * Set the number of frozen rows.
               */
              ,
              set: function set(frozenRowCount) {
                this[_].frozenRowCount = frozenRowCount;
              }
              /**
               * Get the default row height.
               *
               */

            }, {
              key: "defaultRowHeight",
              get: function get() {
                return this[_].defaultRowHeight;
              }
              /**
               * Set the default row height.
               */
              ,
              set: function set(defaultRowHeight) {
                this[_].defaultRowHeight = defaultRowHeight;
              }
              /**
               * Get the default column width.
               */

            }, {
              key: "defaultColWidth",
              get: function get() {
                return this[_].defaultColWidth;
              }
              /**
               * Set the default column width.
               */
              ,
              set: function set(defaultColWidth) {
                this[_].defaultColWidth = defaultColWidth;
              }
              /**
               * Get the font definition as a string.
               */

            }, {
              key: "font",
              get: function get() {
                return this[_].font;
              }
              /**
               * Set the font definition with the given string.
               */
              ,
              set: function set(font) {
                this[_].font = font;
              }
              /**
               * Get the background color of the underlay.
               */

            }, {
              key: "underlayBackgroundColor",
              get: function get() {
                return this[_].underlayBackgroundColor;
              }
              /**
               * Set the background color of the underlay.
               */
              ,
              set: function set(underlayBackgroundColor) {
                this[_].underlayBackgroundColor = underlayBackgroundColor;
              }
              /**
               * If set to true, trim the pasted text on pasting.
               */

            }, {
              key: "trimOnPaste",
              get: function get() {
                return this[_].trimOnPaste;
              },
              set: function set(trimOnPaste) {
                this[_].trimOnPaste = trimOnPaste;
              }
            }, {
              key: "keyboardOptions",
              get: function get() {
                var _a;

                return (_a = this[_].keyboardOptions) !== null && _a !== void 0 ? _a : null;
              },
              set: function set(keyboardOptions) {
                this[_].keyboardOptions = keyboardOptions !== null && keyboardOptions !== void 0 ? keyboardOptions : undefined;
              } // eslint-disable-next-line @typescript-eslint/no-explicit-any

            }, {
              key: "configure",
              value: function configure(name, value) {
                var cfg = this[_].config || (this[_].config = {});

                if (value != null) {
                  cfg[name] = value;
                }

                return cfg[name];
              }
              /**
               * Apply the changed size.
               * @return {void}
               */

            }, {
              key: "updateSize",
              value: function updateSize() {
                //
                var canvas = this[_].canvas;
                canvas.style.width = "";
                canvas.style.height = "";
                var width = Math.floor(canvas.offsetWidth || canvas.parentElement.offsetWidth - style.getScrollBarSize()
                /*for legacy*/
                );
                var height = Math.floor(canvas.offsetHeight || canvas.parentElement.offsetHeight - style.getScrollBarSize()
                /*for legacy*/
                );
                canvas.width = width;
                canvas.height = height; //style

                canvas.style.width = "".concat(width, "px");
                canvas.style.height = "".concat(height, "px");
                var focus = this[_].selection.focus;

                this[_].focusControl.setFocusRect(this.getCellRect(focus.col, focus.row));
              }
              /**
               * Apply the changed scroll size.
               * @return {boolean} `true` if there was a change in the scroll size
               */

            }, {
              key: "updateScroll",
              value: function updateScroll() {
                var scrollable = this[_].scrollable;

                var newHeight = _getScrollHeight.call(this);

                var newWidth = _getScrollWidth(this);

                if (newHeight === scrollable.scrollHeight && newWidth === scrollable.scrollWidth) {
                  return false;
                }

                scrollable.setScrollSize(newWidth, newHeight);
                this[_].scroll = {
                  left: scrollable.scrollLeft,
                  top: scrollable.scrollTop
                };
                var focus = this[_].selection.focus;

                this[_].focusControl.setFocusRect(this.getCellRect(focus.col, focus.row));

                return true;
              }
              /**
               * Get the row height of the given the row index.
               * @param  {number} row The row index
               * @return {number} The row height
               */

            }, {
              key: "getRowHeight",
              value: function getRowHeight(row) {
                return _getRowHeight.call(this, row);
              }
              /**
               * Set the row height of the given the row index.
               * @param  {number} row The row index
               * @param  {number} height The row height
               * @return {void}
               */

            }, {
              key: "setRowHeight",
              value: function setRowHeight(row, height) {
                _setRowHeight(this, row, height);
              }
              /**
               * Get the column width of the given the column index.
               * @param  {number} col The column index
               * @return {number} The column width
               */

            }, {
              key: "getColWidth",
              value: function getColWidth(col) {
                return _getColWidth(this, col);
              }
              /**
               * Set the column width of the given the column index.
               * @param  {number} col The column index
               * @param  {number} width The column width
               * @return {void}
               */

            }, {
              key: "setColWidth",
              value: function setColWidth(col, width) {
                _setColWidth(this, col, width);
              }
              /**
               * Get the column max width of the given the column index.
               * @param  {number} col The column index
               * @return {number} The column max width
               */

            }, {
              key: "getMaxColWidth",
              value: function getMaxColWidth(col) {
                var obj = this[_].colWidthsLimit[col];
                return obj && obj.max || undefined;
              }
              /**
               * Set the column max width of the given the column index.
               * @param  {number} col The column index
               * @param  {number} maxwidth The column max width
               * @return {void}
               */

            }, {
              key: "setMaxColWidth",
              value: function setMaxColWidth(col, maxwidth) {
                var obj = this[_].colWidthsLimit[col] || (this[_].colWidthsLimit[col] = {});

                if (maxwidth != null) {
                  obj.max = maxwidth;
                } else {
                  delete obj.max;
                }
              }
              /**
               * Get the column min width of the given the column index.
               * @param  {number} col The column index
               * @return {number} The column min width
               */

            }, {
              key: "getMinColWidth",
              value: function getMinColWidth(col) {
                var obj = this[_].colWidthsLimit[col];
                return obj && obj.min || undefined;
              }
              /**
               * Set the column min width of the given the column index.
               * @param  {number} col The column index
               * @param  {number} minwidth The column min width
               * @return {void}
               */

            }, {
              key: "setMinColWidth",
              value: function setMinColWidth(col, minwidth) {
                var obj = this[_].colWidthsLimit[col] || (this[_].colWidthsLimit[col] = {});

                if (minwidth != null) {
                  obj.min = minwidth;
                } else {
                  delete obj.min;
                }
              }
              /**
               * Get the rect of the cell.
               * @param {number} col index of column, of the cell
               * @param {number} row index of row, of the cell
               * @returns {Rect} the rect of the cell.
               */

            }, {
              key: "getCellRect",
              value: function getCellRect(col, row) {
                var isFrozenCell = this.isFrozenCell(col, row);

                var absoluteLeft = _getColsWidth(this, 0, col - 1);

                var width = _getColWidth(this, col);

                if (isFrozenCell && isFrozenCell.col) {
                  absoluteLeft += this[_].scroll.left;
                }

                var absoluteTop = _getRowsHeight.call(this, 0, row - 1);

                var height = _getRowHeight.call(this, row);

                if (isFrozenCell && isFrozenCell.row) {
                  absoluteTop += this[_].scroll.top;
                }

                return new Rect_1.Rect(absoluteLeft, absoluteTop, width, height);
              }
              /**
               * Get the relative rectangle of the cell.
               * @param {number} col index of column, of the cell
               * @param {number} row index of row, of the cell
               * @returns {Rect} the rect of the cell.
               */

            }, {
              key: "getCellRelativeRect",
              value: function getCellRelativeRect(col, row) {
                return _toRelativeRect(this, this.getCellRect(col, row));
              }
              /**
               * Get the rectangle of the cells area.
               * @param {number} startCol index of the starting column, of the cell
               * @param {number} startRow index of the starting row, of the cell
               * @param {number} endCol index of the ending column, of the cell
               * @param {number} endRow index of the ending row, of the cell
               * @returns {Rect} the rect of the cells.
               */

            }, {
              key: "getCellsRect",
              value: function getCellsRect(startCol, startRow, endCol, endRow) {
                var isFrozenStartCell = this.isFrozenCell(startCol, startRow);
                var isFrozenEndCell = this.isFrozenCell(endCol, endRow);

                var absoluteLeft = _getColsWidth(this, 0, startCol - 1);

                var width = _getColsWidth(this, startCol, endCol);

                if (isFrozenStartCell && isFrozenStartCell.col) {
                  var scrollLeft = this[_].scroll.left;
                  absoluteLeft += scrollLeft;

                  if (!isFrozenEndCell || !isFrozenEndCell.col) {
                    width -= scrollLeft;
                    width = Math.max(width, _getColsWidth(this, startCol, this.frozenColCount - 1));
                  }
                }

                var absoluteTop = _getRowsHeight.call(this, 0, startRow - 1);

                var height = _getRowsHeight.call(this, startRow, endRow);

                if (isFrozenStartCell && isFrozenStartCell.row) {
                  var scrollTop = this[_].scroll.top;
                  absoluteTop += scrollTop;

                  if (!isFrozenEndCell || !isFrozenEndCell.row) {
                    height -= scrollTop;
                    height = Math.max(height, _getColsWidth(this, startRow, this.frozenRowCount - 1));
                  }
                }

                return new Rect_1.Rect(absoluteLeft, absoluteTop, width, height);
              }
            }, {
              key: "getCellRangeRect",
              value: function getCellRangeRect(range) {
                return this.getCellsRect(range.start.col, range.start.row, range.end.col, range.end.row);
              }
            }, {
              key: "isFrozenCell",
              value: function isFrozenCell(col, row) {
                var _this$_ = this[_],
                    frozenRowCount = _this$_.frozenRowCount,
                    frozenColCount = _this$_.frozenColCount;
                var isFrozenRow = frozenRowCount > 0 && row < frozenRowCount;
                var isFrozenCol = frozenColCount > 0 && col < frozenColCount;

                if (isFrozenRow || isFrozenCol) {
                  return {
                    row: isFrozenRow,
                    col: isFrozenCol
                  };
                } else {
                  return null;
                }
              }
            }, {
              key: "getRowAt",
              value: function getRowAt(absoluteY) {
                var frozen = _getTargetFrozenRowAt(this, absoluteY);

                if (frozen) {
                  return frozen.row;
                }

                var row = _getTargetRowAt.call(this, absoluteY);

                return row ? row.row : -1;
              }
            }, {
              key: "getColAt",
              value: function getColAt(absoluteX) {
                var frozen = _getTargetFrozenColAt(this, absoluteX);

                if (frozen) {
                  return frozen.col;
                }

                var col = _getTargetColAt(this, absoluteX);

                return col ? col.col : -1;
              }
            }, {
              key: "getCellAt",
              value: function getCellAt(absoluteX, absoluteY) {
                return {
                  row: this.getRowAt(absoluteY),
                  col: this.getColAt(absoluteX)
                };
              }
              /**
               * Scroll to where cell is visible.
               * @param  {number} col The column index.
               * @param  {number} row The row index
               * @return {void}
               */

            }, {
              key: "makeVisibleCell",
              value: function makeVisibleCell(col, row) {
                var isFrozenCell = this.isFrozenCell(col, row);

                if (isFrozenCell && isFrozenCell.col && isFrozenCell.row) {
                  return;
                }

                var rect = this.getCellRect(col, row);

                var visibleRect = _getScrollableVisibleRect(this);

                if (visibleRect.contains(rect)) {
                  return;
                }

                var scrollable = this[_].scrollable;

                if (!isFrozenCell || !isFrozenCell.col) {
                  if (rect.left < visibleRect.left) {
                    scrollable.scrollLeft -= visibleRect.left - rect.left;
                  } else if (visibleRect.right < rect.right) {
                    scrollable.scrollLeft -= visibleRect.right - rect.right;
                  }
                }

                if (!isFrozenCell || !isFrozenCell.row) {
                  if (rect.top < visibleRect.top) {
                    scrollable.scrollTop -= visibleRect.top - rect.top;
                  } else if (visibleRect.bottom < rect.bottom) {
                    scrollable.scrollTop -= visibleRect.bottom - rect.bottom;
                  }
                }
              }
              /**
               * Moves the focus cursor to the given cell.
               * @param  {number} col The column index.
               * @param  {number} row The row index
               * @return {void}
               */

            }, {
              key: "setFocusCursor",
              value: function setFocusCursor(col, row) {
                var focusControl = this[_].focusControl;
                var oldEditMode = focusControl.editMode;
                focusControl.setFocusRect(this.getCellRect(col, row));

                _updatedSelection.call(this);

                if (oldEditMode && !focusControl.editMode) {
                  focusControl.resetInputStatus();
                }
              }
              /**
               * Focus the cell.
               * @param  {number} col The column index.
               * @param  {number} row The row index
               * @return {void}
               */

            }, {
              key: "focusCell",
              value: function focusCell(col, row) {
                this.setFocusCursor(col, row); // Failure occurs in IE if focus is not last

                this[_].focusControl.focus();
              }
              /**
               * Redraws the range of the given cell.
               * @param  {number} col The column index of cell.
               * @param  {number} row The row index of cell.
               * @return {void}
               */

            }, {
              key: "invalidateCell",
              value: function invalidateCell(col, row) {
                this.invalidateGridRect(col, row);
              }
              /**
               * Redraws the range of the given cells.
               * @param {number} startCol index of the starting column, of the cell
               * @param {number} startRow index of the starting row, of the cell
               * @param {number} endCol index of the ending column, of the cell
               * @param {number} endRow index of the ending row, of the cell
               * @return {void}
               */

            }, {
              key: "invalidateGridRect",
              value: function invalidateGridRect(startCol, startRow) {
                var endCol = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : startCol;
                var endRow = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : startRow;
                var offset = this.getOffsetInvalidateCells();

                if (offset > 0) {
                  startCol -= offset;
                  startRow -= offset;
                  endCol += offset;
                  endRow += offset;
                }

                var visibleRect = _getVisibleRect(this);

                var cellsRect = this.getCellsRect(startCol, startRow, endCol, endRow);
                var invalidateTarget = visibleRect.intersection(cellsRect);

                if (invalidateTarget) {
                  var _this$_2 = this[_],
                      frozenColCount = _this$_2.frozenColCount,
                      frozenRowCount = _this$_2.frozenRowCount;

                  if (frozenColCount > 0 && endCol >= frozenColCount) {
                    var frozenRect = _getFrozenColsRect(this);

                    if (frozenRect.intersection(invalidateTarget)) {
                      invalidateTarget.left = Math.min(frozenRect.right - 1, invalidateTarget.left);
                    }
                  }

                  if (frozenRowCount > 0 && endRow >= frozenRowCount) {
                    var _frozenRect4 = _getFrozenRowsRect(this);

                    if (_frozenRect4.intersection(invalidateTarget)) {
                      invalidateTarget.top = Math.min(_frozenRect4.bottom - 1, invalidateTarget.top);
                    }
                  }

                  _invalidateRect(this, invalidateTarget);
                }
              }
            }, {
              key: "invalidateCellRange",
              value: function invalidateCellRange(range) {
                this.invalidateGridRect(range.start.col, range.start.row, range.end.col, range.end.row);
              }
              /**
               * Redraws the whole grid.
               * @return {void}
               */

            }, {
              key: "invalidate",
              value: function invalidate() {
                var visibleRect = _getVisibleRect(this);

                _invalidateRect(this, visibleRect);
              }
              /**
               * Get the number of scrollable rows fully visible in the grid. visibleRowCount does not include the frozen rows counted by the frozenRowCount property. It does not include any partially visible rows on the bottom of the grid.
               * @returns {number}
               */

            }, {
              key: "visibleRowCount",
              get: function get() {
                var frozenRowCount = this.frozenRowCount;

                var visibleRect = _getVisibleRect(this);

                var visibleTop = frozenRowCount > 0 ? visibleRect.top + _getRowsHeight.call(this, 0, frozenRowCount - 1) : visibleRect.top;

                var initRow = _getTargetRowAt.call(this, visibleTop);

                if (!initRow) {
                  return 0;
                }

                var startRow = Math.max(initRow.top >= visibleTop ? initRow.row : initRow.row + 1, frozenRowCount);

                var absoluteTop = _getRowsHeight.call(this, 0, startRow - 1);

                var count = 0;
                var rowCount = this.rowCount;

                for (var row = startRow; row < rowCount; row++) {
                  var height = _getRowHeight.call(this, row);

                  var bottom = absoluteTop + height;

                  if (visibleRect.bottom < bottom) {
                    break;
                  }

                  count++;
                  absoluteTop = bottom;
                }

                return count;
              }
              /**
               * Get the number of scrollable columns fully visible in the grid. visibleColCount does not include the frozen columns counted by the frozenColCount property. It does not include any partially visible columns on the right of the grid.
               * @returns {number}
               */

            }, {
              key: "visibleColCount",
              get: function get() {
                var frozenColCount = this.frozenColCount;

                var visibleRect = _getVisibleRect(this);

                var visibleLeft = frozenColCount > 0 ? visibleRect.left + _getColsWidth(this, 0, frozenColCount - 1) : visibleRect.left;

                var initCol = _getTargetColAt(this, visibleLeft);

                if (!initCol) {
                  return 0;
                }

                var startCol = Math.max(initCol.left >= visibleLeft ? initCol.col : initCol.col + 1, frozenColCount);

                var absoluteLeft = _getColsWidth(this, 0, startCol - 1);

                var count = 0;
                var colCount = this.colCount;

                for (var col = startCol; col < colCount; col++) {
                  var width = _getColWidth(this, col);

                  var right = absoluteLeft + width;

                  if (visibleRect.right < right) {
                    break;
                  }

                  count++;
                  absoluteLeft = right;
                }

                return count;
              }
              /**
               * Get the index of the first row in the scrollable region that is visible.
               * @returns {number}
               */

            }, {
              key: "topRow",
              get: function get() {
                var frozenRowCount = this.frozenRowCount;

                var visibleRect = _getVisibleRect(this);

                var visibleTop = frozenRowCount > 0 ? visibleRect.top + _getRowsHeight.call(this, 0, frozenRowCount - 1) : visibleRect.top;

                var initRow = _getTargetRowAt.call(this, visibleTop);

                if (!initRow) {
                  return 0;
                }

                return Math.max(initRow.top >= visibleTop ? initRow.row : initRow.row + 1, frozenRowCount);
              }
              /**
               * Get the index of the first column in the scrollable region that is visible.
               * @returns {number}
               */

            }, {
              key: "leftCol",
              get: function get() {
                var frozenColCount = this.frozenColCount;

                var visibleRect = _getVisibleRect(this);

                var visibleLeft = frozenColCount > 0 ? visibleRect.left + _getColsWidth(this, 0, frozenColCount - 1) : visibleRect.left;

                var initCol = _getTargetColAt(this, visibleLeft);

                if (!initCol) {
                  return 0;
                }

                return Math.max(initCol.left >= visibleLeft ? initCol.col : initCol.col + 1, frozenColCount);
              }
              /**
               * gets or sets the number of pixels that an element's content is scrolled vertically
               */

            }, {
              key: "scrollTop",
              get: function get() {
                return this[_].scrollable.scrollTop;
              },
              set: function set(scrollTop) {
                this[_].scrollable.scrollTop = scrollTop;
              }
              /**
               * gets or sets the number of pixels that an element's content is scrolled from its left edge
               */

            }, {
              key: "scrollLeft",
              get: function get() {
                return this[_].scrollable.scrollLeft;
              },
              set: function set(scrollLeft) {
                this[_].scrollable.scrollLeft = scrollLeft;
              }
              /**
               * Get the value of cell with the copy action.
               * <p>
               * Please implement
               * </p>
               *
               * @protected
               * @param col Column index of cell.
               * @param row Row index of cell.
               * @param range Copy range.
               * @return {string} the value of cell
               */

            }, {
              key: "getCopyCellValue",
              value: function getCopyCellValue(_col, _row, _range) {
                //Please implement get cell value!!
                return undefined;
              }
              /**
               * Get the overflowed text in the cell rectangle, from the given cell.
               * @param  {number} col The column index.
               * @param  {number} row The row index
               * @return {string | null} The text overflowing the cell rect.
               */

            }, {
              key: "getCellOverflowText",
              value: function getCellOverflowText(col, row) {
                var key = "".concat(col, ":").concat(row);
                return this[_].cellTextOverflows[key] || null;
              }
              /**
               * Set the overflowed text in the cell rectangle, to the given cell.
               * @param  {number} col The column index.
               * @param  {number} row The row index
               * @param  {string} overflowText The overflowed text in the cell rectangle.
               * @return {void}
               */

            }, {
              key: "setCellOverflowText",
              value: function setCellOverflowText(col, row, overflowText) {
                var key = "".concat(col, ":").concat(row);

                if (overflowText) {
                  this[_].cellTextOverflows[key] = typeof overflowText === "string" ? overflowText.trim() : overflowText;
                } else {
                  delete this[_].cellTextOverflows[key];
                }
              }
            }, {
              key: "addDisposable",
              value: function addDisposable(disposable) {
                if (!disposable || !disposable.dispose || typeof disposable.dispose !== "function") {
                  throw new Error("not disposable!");
                }

                var disposables = this[_].disposables = this[_].disposables || [];
                disposables.push(disposable);
              }
              /**
               * Dispose the grid instance.
               * @returns {void}
               */

            }, {
              key: "dispose",
              value: function dispose() {
                _get(_getPrototypeOf(DrawGrid.prototype), "dispose", this).call(this);

                var protectedSpace = this[_];
                protectedSpace.handler.dispose();
                protectedSpace.scrollable.dispose();
                protectedSpace.focusControl.dispose();
                protectedSpace.columnResizer.dispose();
                protectedSpace.cellSelector.dispose();

                if (protectedSpace.disposables) {
                  protectedSpace.disposables.forEach(function (disposable) {
                    return disposable.dispose();
                  });
                  protectedSpace.disposables = null;
                }

                var parentElement = protectedSpace.element.parentElement;

                if (parentElement) {
                  parentElement.removeChild(protectedSpace.element);
                }
              }
            }, {
              key: "getAttachCellsArea",
              value: function getAttachCellsArea(range) {
                return {
                  element: this.getElement(),
                  rect: _toRelativeRect(this, this.getCellRangeRect(range))
                };
              }
            }, {
              key: "onKeyDownMove",
              value: function onKeyDownMove(evt) {
                _onKeyDownMove.call(this, evt);
              }
            }, {
              key: "bindEventsInternal",
              value: function bindEventsInternal() {//nop
              }
            }, {
              key: "getTargetRowAtInternal",
              value: function getTargetRowAtInternal(_absoluteY) {// 
              }
            }, {
              key: "getRowsHeightInternal",
              value: function getRowsHeightInternal(_startRow, _endRow) {// 
              }
            }, {
              key: "getRowHeightInternal",
              value: function getRowHeightInternal(_row) {// 
              }
            }, {
              key: "getScrollHeightInternal",
              value: function getScrollHeightInternal(_row) {// 
              }
            }, {
              key: "getMoveLeftColByKeyDownInternal",
              value: function getMoveLeftColByKeyDownInternal(_ref52) {
                var col = _ref52.col;
                return col - 1;
              }
            }, {
              key: "getMoveRightColByKeyDownInternal",
              value: function getMoveRightColByKeyDownInternal(_ref53) {
                var col = _ref53.col;
                return col + 1;
              }
            }, {
              key: "getMoveUpRowByKeyDownInternal",
              value: function getMoveUpRowByKeyDownInternal(_ref54) {
                var row = _ref54.row;
                return row - 1;
              }
            }, {
              key: "getMoveDownRowByKeyDownInternal",
              value: function getMoveDownRowByKeyDownInternal(_ref55) {
                var row = _ref55.row;
                return row + 1;
              }
            }, {
              key: "getOffsetInvalidateCells",
              value: function getOffsetInvalidateCells() {
                return 0;
              }
            }, {
              key: "getCopyRangeInternal",
              value: function getCopyRangeInternal(range) {
                return range;
              }
            }, {
              key: "_getInitContext",
              value: function _getInitContext() {
                var ctx = this[_].context; //

                ctx.fillStyle = "white";
                ctx.strokeStyle = "black";
                ctx.textAlign = "left";
                ctx.textBaseline = "top";
                ctx.lineWidth = 1;
                ctx.font = this.font || "16px sans-serif";
                return ctx;
              }
            }, {
              key: "fireListeners",
              value: function fireListeners(type) {
                var _get3;

                for (var _len4 = arguments.length, event = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
                  event[_key4 - 1] = arguments[_key4];
                }

                return (_get3 = _get(_getPrototypeOf(DrawGrid.prototype), "fireListeners", this)).call.apply(_get3, [this, type].concat(event));
              }
            }], [{
              key: "EVENT_TYPE",
              get: function get() {
                return DG_EVENT_TYPE_1.DG_EVENT_TYPE;
              }
            }]);

            return DrawGrid;
          }(EventTarget_1.EventTarget);

          exports.DrawGrid = DrawGrid;
          /***/
        },

        /***/
        "./core/EventTarget.js":
        /*!*****************************!*\
          !*** ./core/EventTarget.js ***!
          \*****************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function coreEventTargetJs(module, exports, __nested_webpack_require_693349__) {
          "use strict";

          var _a;

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.EventTarget = void 0;

          var utils_1 = __nested_webpack_require_693349__(
          /*! ../internal/utils */
          "./internal/utils.js");

          var symbolManager_1 = __nested_webpack_require_693349__(
          /*! ../internal/symbolManager */
          "./internal/symbolManager.js"); //private symbol

          /** @private */


          var _ = (0, symbolManager_1.get)();
          /** @private */


          var nextId = 1;
          /**
           * event target.
           */

          var EventTarget = /*#__PURE__*/function () {
            function EventTarget() {
              _classCallCheck(this, EventTarget);

              this[_a] = {
                listeners: {},
                listenerData: {}
              };
            }
            /**
             * Adds an event listener.
             * @param  {string} type The event type id.
             * @param  {function} listener Callback method.
             * @return {number} unique id for the listener.
             */


            _createClass(EventTarget, [{
              key: "listen",
              value: function listen(type, listener) {
                var _this75 = this;

                var list = this[_].listeners[type] || (this[_].listeners[type] = []);
                list.push(listener);
                var id = nextId++;
                this[_].listenerData[id] = {
                  type: type,
                  listener: listener,
                  remove: function remove() {
                    delete _this75[_].listenerData[id];
                    var index = list.indexOf(listener);
                    list.splice(index, 1);

                    if (!_this75[_].listeners[type].length) {
                      delete _this75[_].listeners[type];
                    }
                  }
                };
                return id;
              }
              /**
               * Removes an event listener which was added with listen() by the id returned by listen().
               * @param  {number} id the id returned by listen().
               * @return {void}
               */

            }, {
              key: "unlisten",
              value: function unlisten(id) {
                if (!this[_]) {
                  return;
                }

                this[_].listenerData[id].remove();
              }
            }, {
              key: "addEventListener",
              value: function addEventListener(type, listener) {
                this.listen(type, listener);
              }
            }, {
              key: "removeEventListener",
              value: function removeEventListener(type, listener) {
                var _this76 = this;

                if (!this[_]) {
                  return;
                }

                (0, utils_1.each)(this[_].listenerData, function (obj, id) {
                  if (obj.type === type && obj.listener === listener) {
                    _this76.unlisten(id);
                  }
                });
              }
            }, {
              key: "hasListeners",
              value: function hasListeners(type) {
                if (!this[_]) {
                  return false;
                }

                return !!this[_].listeners[type];
              }
              /**
               * Fires all registered listeners
               * @param  {string}    type The type of the listeners to fire.
               * @param  {...*} args fire arguments
               * @return {*} the result of the last listener
               */
              // eslint-disable-next-line @typescript-eslint/no-explicit-any

            }, {
              key: "fireListeners",
              value: function fireListeners(type) {
                var _this77 = this;

                for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
                  args[_key5 - 1] = arguments[_key5];
                }

                if (!this[_]) {
                  return [];
                }

                var list = this[_].listeners[type];

                if (!list) {
                  return [];
                }

                return list.map(function (listener) {
                  return listener.call.apply(listener, [_this77].concat(args));
                }).filter(function (r) {
                  return r != null;
                });
              }
            }, {
              key: "dispose",
              value: function dispose() {
                // @ts-expect-error -- ignore
                delete this[_];
              }
            }]);

            return EventTarget;
          }();

          exports.EventTarget = EventTarget;
          _a = _;
          /***/
        },

        /***/
        "./data.js":
        /*!*****************!*\
          !*** ./data.js ***!
          \*****************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function dataJs(module, exports, __nested_webpack_require_698578__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.FilterDataSource = exports.CachedDataSource = exports.DataSource = void 0;

          var DataSource_1 = __nested_webpack_require_698578__(
          /*! ./data/DataSource */
          "./data/DataSource.js");

          Object.defineProperty(exports, "DataSource", {
            enumerable: true,
            get: function get() {
              return DataSource_1.DataSource;
            }
          });

          var CachedDataSource_1 = __nested_webpack_require_698578__(
          /*! ./data/CachedDataSource */
          "./data/CachedDataSource.js");

          Object.defineProperty(exports, "CachedDataSource", {
            enumerable: true,
            get: function get() {
              return CachedDataSource_1.CachedDataSource;
            }
          });

          var FilterDataSource_1 = __nested_webpack_require_698578__(
          /*! ./data/FilterDataSource */
          "./data/FilterDataSource.js");

          Object.defineProperty(exports, "FilterDataSource", {
            enumerable: true,
            get: function get() {
              return FilterDataSource_1.FilterDataSource;
            }
          });
          /***/
        },

        /***/
        "./data/CachedDataSource.js":
        /*!**********************************!*\
          !*** ./data/CachedDataSource.js ***!
          \**********************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function dataCachedDataSourceJs(module, exports, __nested_webpack_require_700252__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.CachedDataSource = void 0;

          var DataSource_1 = __nested_webpack_require_700252__(
          /*! ./DataSource */
          "./data/DataSource.js");
          /** @private */


          function _setFieldCache( // eslint-disable-next-line @typescript-eslint/no-explicit-any
          fCache, index, field, // eslint-disable-next-line @typescript-eslint/no-explicit-any
          value) {
            var recCache = fCache[index] || (fCache[index] = new Map());
            recCache.set(field, value);
          }
          /**
           * grid data source for caching Promise data
           *
           * @classdesc cheetahGrid.data.CachedDataSource
           * @memberof cheetahGrid.data
           */


          var CachedDataSource = /*#__PURE__*/function (_DataSource_1$DataSou) {
            _inherits(CachedDataSource, _DataSource_1$DataSou);

            var _super51 = _createSuper(CachedDataSource);

            function CachedDataSource(opt) {
              var _this78;

              _classCallCheck(this, CachedDataSource);

              _this78 = _super51.call(this, opt);
              _this78._rCache = {};
              _this78._fCache = {};
              return _this78;
            }

            _createClass(CachedDataSource, [{
              key: "getOriginal",
              value: function getOriginal(index) {
                if (this._rCache && this._rCache[index]) {
                  return this._rCache[index];
                }

                return _get(_getPrototypeOf(CachedDataSource.prototype), "getOriginal", this).call(this, index);
              }
            }, {
              key: "getOriginalField",
              value: function getOriginalField(index, field) {
                var rowCache = this._fCache && this._fCache[index];

                if (rowCache) {
                  var cache = rowCache.get(field);

                  if (cache) {
                    return cache;
                  }
                }

                return _get(_getPrototypeOf(CachedDataSource.prototype), "getOriginalField", this).call(this, index, field);
              }
            }, {
              key: "setOriginalField",
              value: function setOriginalField(index, field, // eslint-disable-next-line @typescript-eslint/no-explicit-any
              value) {
                var fCache = this._fCache;

                if (fCache && fCache[index]) {
                  delete fCache[index]; // clear row cache
                }

                return _get(_getPrototypeOf(CachedDataSource.prototype), "setOriginalField", this).call(this, index, field, value);
              }
            }, {
              key: "clearCache",
              value: function clearCache() {
                if (this._rCache) {
                  this._rCache = {};
                }

                if (this._fCache) {
                  this._fCache = {};
                }
              }
            }, {
              key: "fieldPromiseCallBackInternal",
              value: function fieldPromiseCallBackInternal(index, field, // eslint-disable-next-line @typescript-eslint/no-explicit-any
              value) {
                _setFieldCache(this._fCache, index, field, value);
              }
            }, {
              key: "recordPromiseCallBackInternal",
              value: function recordPromiseCallBackInternal(index, // eslint-disable-next-line @typescript-eslint/no-explicit-any
              record) {
                this._rCache[index] = record;
              }
            }, {
              key: "dispose",
              value: function dispose() {
                _get(_getPrototypeOf(CachedDataSource.prototype), "dispose", this).call(this);
              }
            }], [{
              key: "EVENT_TYPE",
              get: function get() {
                return DataSource_1.DataSource.EVENT_TYPE;
              }
            }, {
              key: "ofArray",
              value: function ofArray(array) {
                return new CachedDataSource({
                  get: function get(index) {
                    return array[index];
                  },
                  length: array.length,
                  source: array
                });
              }
            }]);

            return CachedDataSource;
          }(DataSource_1.DataSource);

          exports.CachedDataSource = CachedDataSource;
          /***/
        },

        /***/
        "./data/DataSource.js":
        /*!****************************!*\
          !*** ./data/DataSource.js ***!
          \****************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function dataDataSourceJs(module, exports, __nested_webpack_require_705181__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.DataSource = void 0;

          var _sort = __importStar(__nested_webpack_require_705181__(
          /*! ../internal/sort */
          "./internal/sort.js"));

          var utils_1 = __nested_webpack_require_705181__(
          /*! ../internal/utils */
          "./internal/utils.js");

          var EventTarget_1 = __nested_webpack_require_705181__(
          /*! ../core/EventTarget */
          "./core/EventTarget.js");
          /** @private */


          function isFieldAssessor(field) {
            if (utils_1.obj.isObject(field)) {
              if (field.get && field.set) {
                return true;
              }
            }

            return false;
          }
          /** @private */


          var EVENT_TYPE = {
            UPDATE_LENGTH: "update_length",
            UPDATED_LENGTH: "updated_length",
            UPDATED_ORDER: "updated_order"
          };
          /** @private */

          function ascOrderFn(v1, v2) {
            if (v1 === v2) {
              return 0;
            }

            if (v1 == null) {
              return v2 == null ? // If both are nullish, consider a match.
              0 : // Nulls first
              -1;
            }

            if (v2 == null) {
              // Nulls first
              return 1;
            }

            return v1 > v2 ? 1 : -1;
          }

          function descOrderFn(v1, v2) {
            return ascOrderFn(v1, v2) * -1;
          }
          /** @private */


          function getValue(value, setPromiseBack) {
            var maybePromiseValue = (0, utils_1.getOrApply)(value);

            if ((0, utils_1.isPromise)(maybePromiseValue)) {
              var promiseValue = maybePromiseValue.then(function (r) {
                setPromiseBack(r);
                return r;
              }); //

              setPromiseBack(promiseValue);
              return promiseValue;
            } else {
              return maybePromiseValue;
            }
          }
          /** @private */


          function getField(record, field, // eslint-disable-next-line @typescript-eslint/no-explicit-any
          setPromiseBack) {
            if (record == null) {
              return undefined;
            }

            if ((0, utils_1.isPromise)(record)) {
              return record.then(function (r) {
                return getField(r, field, setPromiseBack);
              });
            }

            var fieldGet = isFieldAssessor(field) ? field.get : field;

            if (fieldGet in record) {
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              var _fieldResult = record[fieldGet]; // eslint-disable-next-line @typescript-eslint/no-explicit-any

              return getValue(_fieldResult, setPromiseBack);
            }

            if (typeof fieldGet === "function") {
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              var _fieldResult2 = fieldGet(record);

              return getValue(_fieldResult2, setPromiseBack);
            } // eslint-disable-next-line @typescript-eslint/restrict-template-expressions


            var ss = String(fieldGet).split(".");

            if (ss.length <= 1) {
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              var _fieldResult3 = record[fieldGet];
              return getValue(_fieldResult3, setPromiseBack);
            }

            var fieldResult = (0, utils_1.applyChainSafe).apply(void 0, [record, // eslint-disable-next-line @typescript-eslint/no-explicit-any
            function (val, name) {
              return getField(val, name, utils_1.emptyFn);
            }].concat(_toConsumableArray(ss)));
            return getValue(fieldResult, setPromiseBack);
          }
          /** @private */


          function setField(record, field, // eslint-disable-next-line @typescript-eslint/no-explicit-any
          value) {
            if (record == null) {
              return false;
            }

            var fieldSet = isFieldAssessor(field) ? field.set : field;

            if (fieldSet in record) {
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              record[fieldSet] = value;
            } else if (typeof fieldSet === "function") {
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              return fieldSet(record, value);
            } else if (typeof fieldSet === "string") {
              var ss = "".concat(fieldSet).split("."); // eslint-disable-next-line @typescript-eslint/no-explicit-any

              var obj = record;
              var length = ss.length;

              for (var i = 0; i < length; i++) {
                var f = ss[i];

                if (i === length - 1) {
                  obj[f] = value;
                } else {
                  obj = obj[f] || (obj[f] = {});
                }
              }
            } else {
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              record[fieldSet] = value;
            }

            return true;
          }
          /** @private */


          function _getIndex(sortedIndexMap, index) {
            if (!sortedIndexMap) {
              return index;
            }

            var mapIndex = sortedIndexMap[index];
            return mapIndex != null ? mapIndex : index;
          }
          /**
           * grid data source
           *
           * @classdesc cheetahGrid.data.DataSource
           * @memberof cheetahGrid.data
           */


          var DataSource = /*#__PURE__*/function (_EventTarget_1$EventT5) {
            _inherits(DataSource, _EventTarget_1$EventT5);

            var _super52 = _createSuper(DataSource);

            function DataSource(obj) {
              var _this79;

              _classCallCheck(this, DataSource);

              var _a;

              _this79 = _super52.call(this);
              _this79._sortedIndexMap = null; // eslint-disable-next-line @typescript-eslint/no-explicit-any

              _this79._get = (obj === null || obj === void 0 ? void 0 : obj.get.bind(obj)) || undefined;
              _this79._length = (obj === null || obj === void 0 ? void 0 : obj.length) || 0;
              _this79._source = (_a = obj === null || obj === void 0 ? void 0 : obj.source) !== null && _a !== void 0 ? _a : obj;
              return _this79;
            } // eslint-disable-next-line @typescript-eslint/no-explicit-any


            _createClass(DataSource, [{
              key: "source",
              get: function get() {
                return this._source;
              }
            }, {
              key: "get",
              value: function get(index) {
                return this.getOriginal(_getIndex(this._sortedIndexMap, index));
              }
            }, {
              key: "getField",
              value: function getField(index, field) {
                return this.getOriginalField(_getIndex(this._sortedIndexMap, index), field);
              } // eslint-disable-next-line @typescript-eslint/no-explicit-any

            }, {
              key: "hasField",
              value: function hasField(index, field) {
                return this.hasOriginalField(_getIndex(this._sortedIndexMap, index), field);
              }
            }, {
              key: "setField",
              value: function setField(index, field, // eslint-disable-next-line @typescript-eslint/no-explicit-any
              value) {
                return this.setOriginalField(_getIndex(this._sortedIndexMap, index), field, value);
              }
            }, {
              key: "sort",
              value: function sort(field, order) {
                var _this80 = this;

                var sortedIndexMap = new Array(this._length);
                var orderFn = order !== "desc" ? ascOrderFn : descOrderFn;
                return _sort.sortPromise(function (index) {
                  return sortedIndexMap[index] != null ? sortedIndexMap[index] : sortedIndexMap[index] = index;
                }, function (index, rel) {
                  sortedIndexMap[index] = rel;
                }, this._length, orderFn, function (index) {
                  return _this80.getOriginalField(index, field);
                }).then(function () {
                  _this80._sortedIndexMap = sortedIndexMap;

                  _this80.fireListeners(EVENT_TYPE.UPDATED_ORDER);
                });
              }
            }, {
              key: "length",
              get: function get() {
                return this._length;
              },
              set: function set(length) {
                if (this._length === length) {
                  return;
                }

                var results = this.fireListeners(EVENT_TYPE.UPDATE_LENGTH, length);

                if (utils_1.array.findIndex(results, function (v) {
                  return !v;
                }) >= 0) {
                  return;
                }

                this._length = length;
                this.fireListeners(EVENT_TYPE.UPDATED_LENGTH, this._length);
              }
            }, {
              key: "dataSource",
              get: function get() {
                return this;
              }
            }, {
              key: "dispose",
              value: function dispose() {
                _get(_getPrototypeOf(DataSource.prototype), "dispose", this).call(this);
              }
            }, {
              key: "getOriginal",
              value: function getOriginal(index) {
                var _this81 = this;

                return getValue(this._get(index), function (val) {
                  _this81.recordPromiseCallBackInternal(index, val);
                });
              }
            }, {
              key: "getOriginalField",
              value: function getOriginalField(index, field) {
                var _this82 = this;

                if (field == null) {
                  return undefined;
                }

                var record = this.getOriginal(index);
                return getField(record, field, function (val) {
                  _this82.fieldPromiseCallBackInternal(index, field, val);
                });
              }
            }, {
              key: "hasOriginalField",
              value: function hasOriginalField(index, field) {
                if (field == null) {
                  return false;
                }

                if (typeof field === "function") {
                  return true;
                }

                var record = this.getOriginal(index);
                return Boolean(record && field in record);
              }
            }, {
              key: "setOriginalField",
              value: function setOriginalField(index, field, // eslint-disable-next-line @typescript-eslint/no-explicit-any
              value) {
                if (field == null) {
                  return false;
                }

                var record = this.getOriginal(index);

                if ((0, utils_1.isPromise)(record)) {
                  return record.then(function (r) {
                    return setField(r, field, value);
                  });
                }

                return setField(record, field, value);
              }
            }, {
              key: "fieldPromiseCallBackInternal",
              value: function fieldPromiseCallBackInternal(_index, _field, // eslint-disable-next-line @typescript-eslint/no-explicit-any
              _value) {//
              }
            }, {
              key: "recordPromiseCallBackInternal",
              value: function recordPromiseCallBackInternal(_index, _record) {//
              }
            }], [{
              key: "EVENT_TYPE",
              get: function get() {
                return EVENT_TYPE;
              }
            }, {
              key: "ofArray",
              value: function ofArray(array) {
                return new DataSource({
                  get: function get(index) {
                    return array[index];
                  },
                  length: array.length,
                  source: array
                });
              }
            }]);

            return DataSource;
          }(EventTarget_1.EventTarget);

          exports.DataSource = DataSource; // eslint-disable-next-line @typescript-eslint/no-explicit-any

          DataSource.EMPTY = new DataSource({
            get: function get() {
              /*noop */
            },
            length: 0
          });
          /***/
        },

        /***/
        "./data/FilterDataSource.js":
        /*!**********************************!*\
          !*** ./data/FilterDataSource.js ***!
          \**********************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function dataFilterDataSourceJs(module, exports, __nested_webpack_require_719641__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.FilterDataSource = void 0;

          var utils_1 = __nested_webpack_require_719641__(
          /*! ../internal/utils */
          "./internal/utils.js");

          var DataSource_1 = __nested_webpack_require_719641__(
          /*! ./DataSource */
          "./data/DataSource.js");

          var EventHandler_1 = __nested_webpack_require_719641__(
          /*! ../internal/EventHandler */
          "./internal/EventHandler.js");
          /** @private */


          var DataSourceIterator = /*#__PURE__*/function () {
            function DataSourceIterator(dataSource) {
              _classCallCheck(this, DataSourceIterator);

              this._dataSource = dataSource;
              this._curIndex = -1;
              this._data = [];
            }

            _createClass(DataSourceIterator, [{
              key: "hasNext",
              value: function hasNext() {
                var next = this._curIndex + 1;
                return this._dataSource.length > next;
              }
            }, {
              key: "next",
              value: function next() {
                var next = this._curIndex + 1;

                var data = this._getIndexData(next);

                this._curIndex = next;
                return data;
              }
            }, {
              key: "movePrev",
              value: function movePrev() {
                this._curIndex--;
              }
            }, {
              key: "_getIndexData",
              value: function _getIndexData(index, nest) {
                var dataSource = this._dataSource;
                var data = this._data;

                if (index < data.length) {
                  return data[index];
                }

                if (dataSource.length <= index) {
                  return undefined;
                }

                var record = this._dataSource.get(index);

                data[index] = record;

                if ((0, utils_1.isPromise)(record)) {
                  record.then(function (val) {
                    data[index] = val;
                  });

                  if (!nest) {
                    for (var i = 1; i <= 100; i++) {
                      this._getIndexData(index + i, true);
                    }
                  }
                }

                return record;
              }
            }]);

            return DataSourceIterator;
          }();
          /** @private */


          var FilterData = /*#__PURE__*/function () {
            function FilterData(dc, original, filter) {
              _classCallCheck(this, FilterData);

              this._cancel = false;
              this._owner = dc;
              this._dataSourceItr = new DataSourceIterator(original);
              this._filter = filter;
              this._filteredList = [];
              this._queues = [];
            }

            _createClass(FilterData, [{
              key: "get",
              value: function get(index) {
                if (this._cancel) {
                  return undefined;
                }

                var filteredList = this._filteredList;

                if (index < filteredList.length) {
                  return filteredList[index];
                }

                var queues = this._queues;
                var indexQueue = queues[index];

                if (indexQueue) {
                  return indexQueue;
                }

                return queues[index] || this._findIndex(index);
              }
            }, {
              key: "cancel",
              value: function cancel() {
                this._cancel = true;
              }
            }, {
              key: "_findIndex",
              value: function _findIndex(index) {
                if (window.Promise) {
                  var timeout = Date.now() + 100;
                  var count = 0;
                  return this._findIndexWithTimeout(index, function () {
                    count++;

                    if (count >= 100) {
                      count = 0;
                      return timeout < Date.now();
                    }

                    return false;
                  });
                }

                return this._findIndexWithTimeout(index, function () {
                  return false;
                });
              }
            }, {
              key: "_findIndexWithTimeout",
              value: function _findIndexWithTimeout(index, testTimeout) {
                var _this83 = this;

                var filteredList = this._filteredList;
                var filter = this._filter;
                var dataSourceItr = this._dataSourceItr;
                var queues = this._queues;

                while (dataSourceItr.hasNext()) {
                  if (this._cancel) {
                    return undefined;
                  }

                  var record = dataSourceItr.next();

                  if ((0, utils_1.isPromise)(record)) {
                    dataSourceItr.movePrev();
                    var queue = record.then(function (_value) {
                      queues[index] = null;
                      return _this83.get(index);
                    });
                    queues[index] = queue;
                    return queue;
                  }

                  if (filter(record)) {
                    filteredList.push(record);

                    if (index < filteredList.length) {
                      return filteredList[index];
                    }
                  }

                  if (testTimeout()) {
                    var promise = new Promise(function (resolve) {
                      setTimeout(function () {
                        resolve();
                      }, 300);
                    });

                    var _queue = promise.then(function () {
                      queues[index] = null;
                      return _this83.get(index);
                    });

                    queues[index] = _queue;
                    return _queue;
                  }
                }

                var dc = this._owner;
                dc.length = filteredList.length;
                return undefined;
              }
            }]);

            return FilterData;
          }();
          /**
           * grid data source for filter
           *
           * @classdesc cheetahGrid.data.FilterDataSource
           * @memberof cheetahGrid.data
           */


          var FilterDataSource = /*#__PURE__*/function (_DataSource_1$DataSou2) {
            _inherits(FilterDataSource, _DataSource_1$DataSou2);

            var _super53 = _createSuper(FilterDataSource);

            function FilterDataSource(dataSource, filter) {
              var _this84;

              _classCallCheck(this, FilterDataSource);

              _this84 = _super53.call(this, dataSource);
              _this84._filterData = null;
              _this84._dataSource = dataSource;
              _this84.filter = filter;
              var handler = _this84._handler = new EventHandler_1.EventHandler();
              handler.on(dataSource, DataSource_1.DataSource.EVENT_TYPE.UPDATED_ORDER, function () {
                // reset
                // eslint-disable-next-line no-self-assign
                _this84.filter = _this84.filter;
              });
              (0, utils_1.each)(DataSource_1.DataSource.EVENT_TYPE, function (type) {
                handler.on(dataSource, type, function () {
                  var _this85;

                  for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
                    args[_key6] = arguments[_key6];
                  }

                  return (_this85 = _this84).fireListeners.apply(_this85, [type].concat(args));
                });
              });
              return _this84;
            }

            _createClass(FilterDataSource, [{
              key: "filter",
              get: function get() {
                var _a;

                return ((_a = this._filterData) === null || _a === void 0 ? void 0 : _a._filter) || null;
              },
              set: function set(filter) {
                if (this._filterData) {
                  this._filterData.cancel();
                }

                this._filterData = filter ? new FilterData(this, this._dataSource, filter) : null;
                this.length = this._dataSource.length;
              }
            }, {
              key: "getOriginal",
              value: function getOriginal(index) {
                if (!this._filterData) {
                  return _get(_getPrototypeOf(FilterDataSource.prototype), "getOriginal", this).call(this, index);
                }

                return this._filterData.get(index);
              }
            }, {
              key: "sort",
              value: function sort(field, order) {
                return this._dataSource.sort(field, order);
              } // eslint-disable-next-line @typescript-eslint/no-explicit-any

            }, {
              key: "source",
              get: function get() {
                return this._dataSource.source;
              }
            }, {
              key: "dataSource",
              get: function get() {
                return this._dataSource;
              }
            }, {
              key: "dispose",
              value: function dispose() {
                this._handler.dispose();

                _get(_getPrototypeOf(FilterDataSource.prototype), "dispose", this).call(this);
              }
            }], [{
              key: "EVENT_TYPE",
              get: function get() {
                return DataSource_1.DataSource.EVENT_TYPE;
              }
            }]);

            return FilterDataSource;
          }(DataSource_1.DataSource);

          exports.FilterDataSource = FilterDataSource;
          /***/
        },

        /***/
        "./element/Inline.js":
        /*!***************************!*\
          !*** ./element/Inline.js ***!
          \***************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function elementInlineJs(module, exports, __nested_webpack_require_729979__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.Inline = void 0;

          var utils_1 = __nested_webpack_require_729979__(
          /*! ../internal/utils */
          "./internal/utils.js");

          function getWidth(ctx, content) {
            return ctx.measureText(content).width;
          }

          function breakWidth(ctx, content, itr, candidateIndex, width) {
            var chars = [];
            var ret = itr.next();

            for (var i = 0; i < candidateIndex && ret !== null; i++, ret = itr.next()) {
              chars.push(ret);
            }

            var beforeWidth = getWidth(ctx, chars.join(""));

            if (beforeWidth > width) {
              while (chars.length) {
                var c = chars.pop();
                beforeWidth -= getWidth(ctx, c || "");

                if (beforeWidth <= width) {
                  break;
                }
              }
            } else if (beforeWidth < width) {
              while (ret !== null) {
                var charWidth = getWidth(ctx, ret);

                if (beforeWidth + charWidth > width) {
                  break;
                }

                chars.push(ret);
                beforeWidth += charWidth;
                ret = itr.next();
              }
            }

            var beforeContent = chars.join("").replace(/\s+$/, "");
            var afterContent = content.slice(beforeContent.length).replace(/^\s+/, "");
            return {
              before: beforeContent ? new Inline(beforeContent) : null,
              after: afterContent ? new Inline(afterContent) : null
            };
          }

          var Inline = /*#__PURE__*/function () {
            function Inline(content) {
              _classCallCheck(this, Inline);

              this._content = content != null ? content : "";
            }

            _createClass(Inline, [{
              key: "width",
              value: function width(_ref56) {
                var ctx = _ref56.ctx;
                return getWidth(ctx, this._content);
              }
            }, {
              key: "font",
              value: function font() {
                return null;
              }
            }, {
              key: "color",
              value: function color() {
                return null;
              }
            }, {
              key: "canDraw",
              value: function canDraw() {
                return true;
              } // eslint-disable-next-line @typescript-eslint/no-empty-function

            }, {
              key: "onReady",
              value: function onReady(_callback) {}
            }, {
              key: "draw",
              value: function draw(_ref57) {
                var ctx = _ref57.ctx,
                    canvashelper = _ref57.canvashelper,
                    rect = _ref57.rect,
                    offset = _ref57.offset,
                    offsetLeft = _ref57.offsetLeft,
                    offsetRight = _ref57.offsetRight,
                    offsetTop = _ref57.offsetTop,
                    offsetBottom = _ref57.offsetBottom;
                canvashelper.fillTextRect(ctx, this._content, rect.left, rect.top, rect.width, rect.height, {
                  offset: offset + 1,
                  padding: {
                    left: offsetLeft,
                    right: offsetRight,
                    top: offsetTop,
                    bottom: offsetBottom
                  }
                });
              }
            }, {
              key: "canBreak",
              value: function canBreak() {
                return !!this._content;
              }
            }, {
              key: "splitIndex",
              value: function splitIndex(index) {
                var content = this._content;
                var itr = utils_1.str.genChars(content);
                var chars = [];
                var ret = itr.next();

                for (var i = 0; i < index && ret !== null; i++, ret = itr.next()) {
                  chars.push(ret);
                }

                var beforeContent = chars.join("");
                var afterContent = content.slice(beforeContent.length);
                return {
                  before: beforeContent ? new Inline(beforeContent) : null,
                  after: afterContent ? new Inline(afterContent) : null
                };
              }
            }, {
              key: "breakWord",
              value: function breakWord(ctx, width) {
                var content = this._content;
                var allWidth = this.width({
                  ctx: ctx
                });
                var candidate = Math.floor(this._content.length * width / allWidth);
                var itr = utils_1.str.genWords(content);
                return breakWidth(ctx, content, itr, candidate, width);
              }
            }, {
              key: "breakAll",
              value: function breakAll(ctx, width) {
                var content = this._content;
                var allWidth = this.width({
                  ctx: ctx
                });
                var candidate = Math.floor(this._content.length * width / allWidth);
                var itr = utils_1.str.genChars(content);
                return breakWidth(ctx, content, itr, candidate, width);
              }
            }, {
              key: "toString",
              value: function toString() {
                return this._content;
              }
            }]);

            return Inline;
          }();

          exports.Inline = Inline;
          /***/
        },

        /***/
        "./element/InlineDrawer.js":
        /*!*********************************!*\
          !*** ./element/InlineDrawer.js ***!
          \*********************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function elementInlineDrawerJs(module, exports, __nested_webpack_require_736037__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.InlineDrawer = void 0;

          var Inline_1 = __nested_webpack_require_736037__(
          /*! ./Inline */
          "./element/Inline.js");

          var InlineDrawer = /*#__PURE__*/function (_Inline_1$Inline) {
            _inherits(InlineDrawer, _Inline_1$Inline);

            var _super54 = _createSuper(InlineDrawer);

            function InlineDrawer(_ref58) {
              var _this86;

              var draw = _ref58.draw,
                  width = _ref58.width,
                  color = _ref58.color;

              _classCallCheck(this, InlineDrawer);

              _this86 = _super54.call(this);
              _this86._draw = draw;
              _this86._width = width; // this._height = height;

              _this86._color = color;
              return _this86;
            }

            _createClass(InlineDrawer, [{
              key: "width",
              value: function width(_arg) {
                return this._width;
              }
            }, {
              key: "font",
              value: function font() {
                return null;
              }
            }, {
              key: "color",
              value: function color() {
                var _a;

                return (_a = this._color) !== null && _a !== void 0 ? _a : null;
              }
            }, {
              key: "canDraw",
              value: function canDraw() {
                return true;
              } // eslint-disable-next-line @typescript-eslint/no-empty-function

            }, {
              key: "onReady",
              value: function onReady(_callback) {}
            }, {
              key: "draw",
              value: function draw(_ref59) {
                var ctx = _ref59.ctx,
                    canvashelper = _ref59.canvashelper,
                    rect = _ref59.rect,
                    offset = _ref59.offset,
                    offsetLeft = _ref59.offsetLeft,
                    offsetRight = _ref59.offsetRight,
                    offsetTop = _ref59.offsetTop,
                    offsetBottom = _ref59.offsetBottom;

                this._draw({
                  ctx: ctx,
                  canvashelper: canvashelper,
                  rect: rect,
                  offset: offset,
                  offsetLeft: offsetLeft,
                  offsetRight: offsetRight,
                  offsetTop: offsetTop,
                  offsetBottom: offsetBottom
                });
              }
            }, {
              key: "canBreak",
              value: function canBreak() {
                return false;
              }
            }, {
              key: "toString",
              value: function toString() {
                return "";
              }
            }]);

            return InlineDrawer;
          }(Inline_1.Inline);

          exports.InlineDrawer = InlineDrawer;
          /***/
        },

        /***/
        "./element/InlineIcon.js":
        /*!*******************************!*\
          !*** ./element/InlineIcon.js ***!
          \*******************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function elementInlineIconJs(module, exports, __nested_webpack_require_739439__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.InlineIcon = void 0;

          var fonts = __importStar(__nested_webpack_require_739439__(
          /*! ../internal/fonts */
          "./internal/fonts.js"));

          var Inline_1 = __nested_webpack_require_739439__(
          /*! ./Inline */
          "./element/Inline.js");

          var InlineIcon = /*#__PURE__*/function (_Inline_1$Inline2) {
            _inherits(InlineIcon, _Inline_1$Inline2);

            var _super55 = _createSuper(InlineIcon);

            function InlineIcon(icon) {
              var _this87;

              _classCallCheck(this, InlineIcon);

              _this87 = _super55.call(this);
              _this87._icon = icon || {};
              return _this87;
            }

            _createClass(InlineIcon, [{
              key: "width",
              value: function width(_ref60) {
                var ctx = _ref60.ctx;
                var icon = this._icon;

                if (icon.width) {
                  return icon.width;
                }

                if (icon.font && fonts.check(icon.font, icon.content || "")) {
                  ctx.save();
                  ctx.canvas.style.letterSpacing = "normal";

                  try {
                    ctx.font = icon.font || ctx.font;
                    return ctx.measureText(icon.content || "").width;
                  } finally {
                    ctx.canvas.style.letterSpacing = "";
                    ctx.restore();
                  }
                }

                return 0; //unknown
              }
            }, {
              key: "font",
              value: function font() {
                var _a;

                return (_a = this._icon.font) !== null && _a !== void 0 ? _a : null;
              }
            }, {
              key: "color",
              value: function color() {
                var _a;

                return (_a = this._icon.color) !== null && _a !== void 0 ? _a : null;
              }
            }, {
              key: "canDraw",
              value: function canDraw() {
                var icon = this._icon;
                return icon.font ? fonts.check(icon.font, icon.content || "") : true;
              }
            }, {
              key: "onReady",
              value: function onReady(callback) {
                var icon = this._icon;

                if (icon.font && !fonts.check(icon.font, icon.content || "")) {
                  fonts.load(icon.font, icon.content || "", callback);
                }
              }
            }, {
              key: "draw",
              value: function draw(_ref61) {
                var ctx = _ref61.ctx,
                    canvashelper = _ref61.canvashelper,
                    rect = _ref61.rect,
                    offset = _ref61.offset,
                    offsetLeft = _ref61.offsetLeft,
                    offsetRight = _ref61.offsetRight,
                    offsetTop = _ref61.offsetTop,
                    offsetBottom = _ref61.offsetBottom;
                var icon = this._icon;

                if (icon.content) {
                  ctx.canvas.style.letterSpacing = "normal";

                  try {
                    // eslint-disable-next-line no-self-assign
                    ctx.font = ctx.font; // To apply letterSpacing, we need to reset it.

                    canvashelper.fillTextRect(ctx, icon.content, rect.left, rect.top, rect.width, rect.height, {
                      offset: offset + 1,
                      padding: {
                        left: offsetLeft + (this._icon.offsetLeft || 0),
                        right: offsetRight,
                        top: offsetTop + (this._icon.offsetTop || 0),
                        bottom: offsetBottom
                      }
                    });
                  } finally {
                    ctx.canvas.style.letterSpacing = "";
                  }
                }
              }
            }, {
              key: "canBreak",
              value: function canBreak() {
                return false;
              }
            }, {
              key: "toString",
              value: function toString() {
                return "";
              }
            }]);

            return InlineIcon;
          }(Inline_1.Inline);

          exports.InlineIcon = InlineIcon;
          /***/
        },

        /***/
        "./element/InlineImage.js":
        /*!********************************!*\
          !*** ./element/InlineImage.js ***!
          \********************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function elementInlineImageJs(module, exports, __nested_webpack_require_745655__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.InlineImage = void 0;

          var Inline_1 = __nested_webpack_require_745655__(
          /*! ./Inline */
          "./element/Inline.js");

          var imgs_1 = __nested_webpack_require_745655__(
          /*! ../internal/imgs */
          "./internal/imgs.js");

          var utils_1 = __nested_webpack_require_745655__(
          /*! ../internal/utils */
          "./internal/utils.js");

          var InlineImage = /*#__PURE__*/function (_Inline_1$Inline3) {
            _inherits(InlineImage, _Inline_1$Inline3);

            var _super56 = _createSuper(InlineImage);

            function InlineImage(_ref62) {
              var _this88;

              var src = _ref62.src,
                  width = _ref62.width,
                  height = _ref62.height,
                  imageLeft = _ref62.imageLeft,
                  imageTop = _ref62.imageTop,
                  imageWidth = _ref62.imageWidth,
                  imageHeight = _ref62.imageHeight;

              _classCallCheck(this, InlineImage);

              _this88 = _super56.call(this);
              _this88._inlineImgPromise = null;
              _this88._inlineImg = null;
              _this88._src = src;
              _this88._width = width;
              _this88._height = height;
              _this88._imageLeft = imageLeft;
              _this88._imageTop = imageTop;
              _this88._imageWidth = imageWidth;
              _this88._imageHeight = imageHeight;
              _this88._onloaded = [];

              if ((0, utils_1.isPromise)(src)) {
                src.then(function (s) {
                  _this88._src = s;

                  _this88._loadImage(s);
                });
              } else {
                _this88._loadImage(src);
              }

              return _this88;
            }

            _createClass(InlineImage, [{
              key: "_loadImage",
              value: function _loadImage(src) {
                var _this89 = this;

                var img = this._inlineImgPromise = (0, imgs_1.getCacheOrLoad)("InlineImage", 50, src);

                if ((0, utils_1.isPromise)(img)) {
                  img.then(function (i) {
                    _this89._inlineImg = i;

                    _this89._onloaded.forEach(function (fn) {
                      return fn();
                    });
                  });
                } else {
                  this._inlineImg = img;
                }
              }
            }, {
              key: "width",
              value: function width(_arg) {
                var _a, _b;

                return this._width || ((_b = (_a = this._inlineImg) === null || _a === void 0 ? void 0 : _a.width) !== null && _b !== void 0 ? _b : 0);
              }
            }, {
              key: "font",
              value: function font() {
                return null;
              }
            }, {
              key: "color",
              value: function color() {
                return null;
              }
            }, {
              key: "canDraw",
              value: function canDraw() {
                return !!this._inlineImg;
              }
            }, {
              key: "onReady",
              value: function onReady(callback) {
                if ((0, utils_1.isPromise)(this._src) || (0, utils_1.isPromise)(this._inlineImgPromise)) {
                  this._onloaded.push(function () {
                    return callback();
                  });
                }
              }
            }, {
              key: "draw",
              value: function draw(_ref63) {
                var ctx = _ref63.ctx,
                    canvashelper = _ref63.canvashelper,
                    rect = _ref63.rect,
                    offset = _ref63.offset,
                    offsetLeft = _ref63.offsetLeft,
                    offsetRight = _ref63.offsetRight,
                    offsetTop = _ref63.offsetTop,
                    offsetBottom = _ref63.offsetBottom;
                var img = this._inlineImg;
                canvashelper.drawInlineImageRect(ctx, img, this._imageLeft || 0, this._imageTop || 0, this._imageWidth || img.width, this._imageHeight || img.height, this._width || img.width, this._height || img.height, rect.left, rect.top, rect.width, rect.height, {
                  offset: offset + 1,
                  padding: {
                    left: offsetLeft,
                    right: offsetRight,
                    top: offsetTop,
                    bottom: offsetBottom
                  }
                });
              }
            }, {
              key: "canBreak",
              value: function canBreak() {
                return false;
              }
            }, {
              key: "toString",
              value: function toString() {
                return "";
              }
            }]);

            return InlineImage;
          }(Inline_1.Inline);

          exports.InlineImage = InlineImage;
          /***/
        },

        /***/
        "./element/InlinePath2D.js":
        /*!*********************************!*\
          !*** ./element/InlinePath2D.js ***!
          \*********************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function elementInlinePath2DJs(module, exports, __nested_webpack_require_751140__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.InlinePath2D = void 0;

          var path2DManager = __importStar(__nested_webpack_require_751140__(
          /*! ../internal/path2DManager */
          "./internal/path2DManager.js"));

          var Inline_1 = __nested_webpack_require_751140__(
          /*! ./Inline */
          "./element/Inline.js");

          var canvases_1 = __nested_webpack_require_751140__(
          /*! ../internal/canvases */
          "./internal/canvases.js");

          var InlinePath2D = /*#__PURE__*/function (_Inline_1$Inline4) {
            _inherits(InlinePath2D, _Inline_1$Inline4);

            var _super57 = _createSuper(InlinePath2D);

            function InlinePath2D(_ref64) {
              var _this90;

              var path = _ref64.path,
                  width = _ref64.width,
                  height = _ref64.height,
                  color = _ref64.color;

              _classCallCheck(this, InlinePath2D);

              _this90 = _super57.call(this); // IEPath2Dpolyfill

              var Path2D = path2DManager.getPath2D();
              _this90._path = new Path2D(path);
              _this90._width = width;
              _this90._height = height;
              _this90._color = color;
              return _this90;
            }

            _createClass(InlinePath2D, [{
              key: "width",
              value: function width(_arg) {
                return this._width;
              }
            }, {
              key: "font",
              value: function font() {
                return null;
              }
            }, {
              key: "color",
              value: function color() {
                var _a;

                return (_a = this._color) !== null && _a !== void 0 ? _a : null;
              }
            }, {
              key: "canDraw",
              value: function canDraw() {
                return true;
              } // eslint-disable-next-line @typescript-eslint/no-empty-function

            }, {
              key: "onReady",
              value: function onReady(_callback) {}
            }, {
              key: "draw",
              value: function draw(_ref65) {
                var ctx = _ref65.ctx,
                    rect = _ref65.rect,
                    offset = _ref65.offset,
                    offsetLeft = _ref65.offsetLeft,
                    offsetRight = _ref65.offsetRight,
                    offsetTop = _ref65.offsetTop,
                    offsetBottom = _ref65.offsetBottom;
                offset++;
                var padding = {
                  left: offsetLeft,
                  right: offsetRight,
                  top: offsetTop,
                  bottom: offsetBottom
                };
                ctx.save();

                try {
                  ctx.beginPath();
                  ctx.rect(rect.left, rect.top, rect.width, rect.height); //clip

                  ctx.clip(); //

                  var pos = (0, canvases_1.calcStartPosition)(ctx, rect, this._width, this._height, {
                    offset: offset,
                    padding: padding
                  });
                  ctx.translate(pos.x, pos.y);
                  ctx.fill(this._path);
                } finally {
                  ctx.restore();
                }
              }
            }, {
              key: "canBreak",
              value: function canBreak() {
                return false;
              }
            }, {
              key: "toString",
              value: function toString() {
                return "";
              }
            }]);

            return InlinePath2D;
          }(Inline_1.Inline);

          exports.InlinePath2D = InlinePath2D;
          /***/
        },

        /***/
        "./element/InlineSvg.js":
        /*!******************************!*\
          !*** ./element/InlineSvg.js ***!
          \******************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function elementInlineSvgJs(module, exports, __nested_webpack_require_756734__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.InlineSvg = void 0;

          var utils_1 = __nested_webpack_require_756734__(
          /*! ../internal/utils */
          "./internal/utils.js");

          var InlineImage_1 = __nested_webpack_require_756734__(
          /*! ./InlineImage */
          "./element/InlineImage.js");

          function buildSvgDataUrl(svg) {
            var data = typeof svg === "string" ? svg : new XMLSerializer().serializeToString(svg);
            var url = "data:image/svg+xml;charset=utf-8,".concat(encodeURIComponent(data)); //svgbase64

            return url;
          }

          function getSvgElement(svg) {
            if (typeof svg === "string") {
              var parser = new DOMParser();
              return parser.parseFromString(svg, "image/svg+xml").children[0];
            } else {
              return svg;
            }
          }

          var InlineSvg = /*#__PURE__*/function (_InlineImage_1$Inline) {
            _inherits(InlineSvg, _InlineImage_1$Inline);

            var _super58 = _createSuper(InlineSvg);

            function InlineSvg(_ref66) {
              var svg = _ref66.svg,
                  width = _ref66.width,
                  height = _ref66.height;

              _classCallCheck(this, InlineSvg);

              var _a, _b;

              var svgElem = (0, utils_1.then)(svg, getSvgElement);
              var elmWidth = !(0, utils_1.isPromise)(svgElem) ? (_a = svgElem.getAttribute("width")) !== null && _a !== void 0 ? _a : undefined : undefined;
              var elmHeight = !(0, utils_1.isPromise)(svgElem) ? (_b = svgElem.getAttribute("height")) !== null && _b !== void 0 ? _b : undefined : undefined;
              var numElmWidth = elmWidth != null ? Number(elmWidth) : undefined;
              var numElmHeight = elmHeight != null ? Number(elmHeight) : undefined;
              return _super58.call(this, {
                src: (0, utils_1.then)(svg, buildSvgDataUrl),
                width: width || numElmWidth,
                height: height || numElmHeight,
                imageWidth: numElmWidth,
                imageHeight: numElmHeight
              });
            }

            _createClass(InlineSvg, [{
              key: "canBreak",
              value: function canBreak() {
                return false;
              }
            }, {
              key: "toString",
              value: function toString() {
                return "";
              }
            }]);

            return InlineSvg;
          }(InlineImage_1.InlineImage);

          exports.InlineSvg = InlineSvg;
          /***/
        },

        /***/
        "./element/inlines.js":
        /*!****************************!*\
          !*** ./element/inlines.js ***!
          \****************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function elementInlinesJs(module, exports, __nested_webpack_require_759814__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.string = exports.buildInlines = exports.of = exports.iconOf = void 0;

          var icons = __importStar(__nested_webpack_require_759814__(
          /*! ../icons */
          "./icons.js"));

          var path2DManager = __importStar(__nested_webpack_require_759814__(
          /*! ../internal/path2DManager */
          "./internal/path2DManager.js"));

          var Inline_1 = __nested_webpack_require_759814__(
          /*! ./Inline */
          "./element/Inline.js");

          var InlineDrawer_1 = __nested_webpack_require_759814__(
          /*! ./InlineDrawer */
          "./element/InlineDrawer.js");

          var InlineIcon_1 = __nested_webpack_require_759814__(
          /*! ./InlineIcon */
          "./element/InlineIcon.js");

          var InlineImage_1 = __nested_webpack_require_759814__(
          /*! ./InlineImage */
          "./element/InlineImage.js");

          var InlinePath2D_1 = __nested_webpack_require_759814__(
          /*! ./InlinePath2D */
          "./element/InlinePath2D.js");

          var InlineSvg_1 = __nested_webpack_require_759814__(
          /*! ./InlineSvg */
          "./element/InlineSvg.js");

          var canvases_1 = __nested_webpack_require_759814__(
          /*! ../internal/canvases */
          "./internal/canvases.js");

          function drawRegisteredIcon(ctx, icon, drawWidth, drawHeight, left, top, width, height) {
            var _ref67 = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : {},
                _ref67$offset = _ref67.offset,
                offset = _ref67$offset === void 0 ? 2 : _ref67$offset,
                padding = _ref67.padding;

            var rect = {
              left: left,
              top: top,
              width: width,
              height: height,
              right: left + width,
              bottom: top + height
            };
            ctx.save();

            try {
              ctx.beginPath();
              ctx.rect(rect.left, rect.top, rect.width, rect.height); //clip

              ctx.clip(); //

              var pos = (0, canvases_1.calcStartPosition)(ctx, rect, drawWidth, drawHeight, {
                offset: offset,
                padding: padding
              });
              path2DManager.fill(icon, ctx, pos.x, pos.y, drawWidth, drawHeight);
            } finally {
              ctx.restore();
            }
          }

          function isIconConstructorOption(icon) {
            if (icon.font && icon.content) {
              return true;
            }

            return false;
          }

          function isInlineImageConstructorOption(icon) {
            if (icon.src) {
              return true;
            }

            return false;
          }

          function isInlineSvgConstructorOption(icon) {
            if (icon.path) {
              return true;
            }

            return false;
          }

          function iconOf(icon) {
            if (icon instanceof Inline_1.Inline) {
              return icon;
            }

            if (!icon) {
              return null;
            }

            if (isIconConstructorOption(icon)) {
              return new InlineIcon_1.InlineIcon(icon);
            }

            if (isInlineImageConstructorOption(icon)) {
              return new InlineImage_1.InlineImage({
                src: icon.src,
                width: icon.width,
                height: icon.width
              });
            }

            if (icon.svg) {
              return new InlineSvg_1.InlineSvg({
                svg: icon.svg,
                width: icon.width,
                height: icon.width
              });
            }

            if (isInlineSvgConstructorOption(icon)) {
              return new InlinePath2D_1.InlinePath2D({
                path: icon.path,
                width: icon.width,
                height: icon.width,
                color: icon.color
              });
            }

            var registeredIcons = icons.get();

            if (icon.name && registeredIcons[icon.name]) {
              var registeredIcon = registeredIcons[icon.name];
              var width = icon.width || Math.max(registeredIcon.width, registeredIcon.height);
              return new InlineDrawer_1.InlineDrawer({
                draw: function draw(_ref68) {
                  var ctx = _ref68.ctx,
                      rect = _ref68.rect,
                      offset = _ref68.offset,
                      offsetLeft = _ref68.offsetLeft,
                      offsetRight = _ref68.offsetRight,
                      offsetTop = _ref68.offsetTop,
                      offsetBottom = _ref68.offsetBottom;
                  drawRegisteredIcon(ctx, registeredIcon, width, width, rect.left, rect.top, rect.width, rect.height, {
                    offset: offset + 1,
                    padding: {
                      left: offsetLeft,
                      right: offsetRight,
                      top: offsetTop,
                      bottom: offsetBottom
                    }
                  });
                },
                width: width,
                height: width,
                color: icon.color
              });
            }

            return new InlineIcon_1.InlineIcon(icon);
          }

          exports.iconOf = iconOf;

          function of(content) {
            if (content == null) {
              return null;
            }

            if (content instanceof Inline_1.Inline) {
              return content;
            }

            return new Inline_1.Inline(content);
          }

          exports.of = of;

          function buildInlines(icons, inline) {
            var result = [];

            if (icons) {
              result.push.apply(result, _toConsumableArray(icons.map(function (icon) {
                return iconOf(icon);
              }).filter(function (i) {
                return i != null;
              })));
            }

            if (Array.isArray(inline) // && inline.filter(il => il instanceof Inline).length <- ?
            ) {
                result.push.apply(result, _toConsumableArray(inline.map(function (il) {
                  return of(il);
                }).filter(function (i) {
                  return i != null;
                })));
              } else {
              var il = of(inline);

              if (il) {
                result.push(il);
              }
            }

            return result;
          }

          exports.buildInlines = buildInlines;

          function string(inline) {
            return buildInlines(undefined, inline).join("");
          }

          exports.string = string;
          /***/
        },

        /***/
        "./get-internal.js":
        /*!*************************!*\
          !*** ./get-internal.js ***!
          \*************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function getInternalJs(module, exports, __nested_webpack_require_768264__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.getInternal = void 0;

          function getInternal() {
            console.warn("use internal!!");
            return {
              color: __nested_webpack_require_768264__(
              /*! ./internal/color */
              "./internal/color.js"),
              sort: __nested_webpack_require_768264__(
              /*! ./internal/sort */
              "./internal/sort.js"),
              calc: __nested_webpack_require_768264__(
              /*! ./internal/calc */
              "./internal/calc.js"),
              symbolManager: __nested_webpack_require_768264__(
              /*! ./internal/symbolManager */
              "./internal/symbolManager.js"),
              path2DManager: __nested_webpack_require_768264__(
              /*! ./internal/path2DManager */
              "./internal/path2DManager.js"),
              pasteUtils: __nested_webpack_require_768264__(
              /*! ./internal/paste-utils */
              "./internal/paste-utils.js")
            };
          }

          exports.getInternal = getInternal;
          /***/
        },

        /***/
        "./header/action.js":
        /*!**************************!*\
          !*** ./header/action.js ***!
          \**************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function headerActionJs(module, exports, __nested_webpack_require_769762__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.ofCell = exports.of = exports.CheckHeaderAction = exports.SortHeaderAction = exports.BaseAction = exports.ACTIONS = void 0;

          var BaseAction_1 = __nested_webpack_require_769762__(
          /*! ./action/BaseAction */
          "./header/action/BaseAction.js");

          Object.defineProperty(exports, "BaseAction", {
            enumerable: true,
            get: function get() {
              return BaseAction_1.BaseAction;
            }
          });

          var CheckHeaderAction_1 = __nested_webpack_require_769762__(
          /*! ./action/CheckHeaderAction */
          "./header/action/CheckHeaderAction.js");

          Object.defineProperty(exports, "CheckHeaderAction", {
            enumerable: true,
            get: function get() {
              return CheckHeaderAction_1.CheckHeaderAction;
            }
          });

          var SortHeaderAction_1 = __nested_webpack_require_769762__(
          /*! ./action/SortHeaderAction */
          "./header/action/SortHeaderAction.js");

          Object.defineProperty(exports, "SortHeaderAction", {
            enumerable: true,
            get: function get() {
              return SortHeaderAction_1.SortHeaderAction;
            }
          });

          var ImmutableSortHeaderAction = /*#__PURE__*/function (_SortHeaderAction_1$S) {
            _inherits(ImmutableSortHeaderAction, _SortHeaderAction_1$S);

            var _super59 = _createSuper(ImmutableSortHeaderAction);

            function ImmutableSortHeaderAction() {
              _classCallCheck(this, ImmutableSortHeaderAction);

              return _super59.apply(this, arguments);
            }

            _createClass(ImmutableSortHeaderAction, [{
              key: "disabled",
              get: function get() {
                return this._disabled;
              }
            }]);

            return ImmutableSortHeaderAction;
          }(SortHeaderAction_1.SortHeaderAction);

          var ImmutableCheckHeaderAction = /*#__PURE__*/function (_CheckHeaderAction_1$) {
            _inherits(ImmutableCheckHeaderAction, _CheckHeaderAction_1$);

            var _super60 = _createSuper(ImmutableCheckHeaderAction);

            function ImmutableCheckHeaderAction() {
              _classCallCheck(this, ImmutableCheckHeaderAction);

              return _super60.apply(this, arguments);
            }

            _createClass(ImmutableCheckHeaderAction, [{
              key: "disabled",
              get: function get() {
                return this._disabled;
              }
            }]);

            return ImmutableCheckHeaderAction;
          }(CheckHeaderAction_1.CheckHeaderAction);

          exports.ACTIONS = {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            SORT: new ImmutableSortHeaderAction(),
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            CHECK: new ImmutableCheckHeaderAction()
          };

          function of(headerAction) {
            if (!headerAction) {
              return undefined;
            } else if (typeof headerAction === "string") {
              var key = headerAction.toUpperCase();
              return exports.ACTIONS[key] || of(null);
            } else {
              return headerAction;
            }
          }

          exports.of = of;

          function ofCell(headerCell) {
            if (headerCell.sort) {
              if (typeof headerCell.sort === "function") {
                var sortMethod = headerCell.sort; // 0.9.0 Backward compatibility

                var sort = function sort(_ref69) {
                  var order = _ref69.order,
                      col = _ref69.col,
                      grid = _ref69.grid;
                  return sortMethod.call(headerCell, order, col, grid);
                };

                return new ImmutableSortHeaderAction({
                  sort: sort
                });
              }

              if (typeof headerCell.sort === "string") {
                return new ImmutableSortHeaderAction({
                  sort: headerCell.sort
                });
              }

              return exports.ACTIONS.SORT;
            }

            return of(headerCell.headerAction);
          }

          exports.ofCell = ofCell;
          /***/
        },

        /***/
        "./header/action/BaseAction.js":
        /*!*************************************!*\
          !*** ./header/action/BaseAction.js ***!
          \*************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function headerActionBaseActionJs(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.BaseAction = void 0;

          var BaseAction = /*#__PURE__*/function () {
            function BaseAction() {
              var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, BaseAction);

              this._disabled = !!option.disabled || false;
            }

            _createClass(BaseAction, [{
              key: "disabled",
              get: function get() {
                return this._disabled;
              },
              set: function set(disabled) {
                this._disabled = disabled;
                this.onChangeDisabledInternal();
              }
            }, {
              key: "clone",
              value: function clone() {
                return new BaseAction(this);
              }
            }, {
              key: "bindGridEvent",
              value: function bindGridEvent(_grid, _cellId) {
                return [];
              }
            }, {
              key: "onChangeDisabledInternal",
              value: function onChangeDisabledInternal() {// impl
              }
            }]);

            return BaseAction;
          }();

          exports.BaseAction = BaseAction;
          /***/
        },

        /***/
        "./header/action/CheckHeaderAction.js":
        /*!********************************************!*\
          !*** ./header/action/CheckHeaderAction.js ***!
          \********************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function headerActionCheckHeaderActionJs(module, exports, __nested_webpack_require_776429__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.CheckHeaderAction = void 0;

          var actionBind_1 = __nested_webpack_require_776429__(
          /*! ./actionBind */
          "./header/action/actionBind.js");

          var BaseAction_1 = __nested_webpack_require_776429__(
          /*! ./BaseAction */
          "./header/action/BaseAction.js");

          var animate_1 = __nested_webpack_require_776429__(
          /*! ../../internal/animate */
          "./internal/animate.js");

          var symbolManager_1 = __nested_webpack_require_776429__(
          /*! ../../internal/symbolManager */
          "./internal/symbolManager.js");

          var utils_1 = __nested_webpack_require_776429__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var CHECK_HEADER_STATE_ID = (0, symbolManager_1.getCheckHeaderStateId)();

          function getState(grid) {
            var state = grid[CHECK_HEADER_STATE_ID];

            if (!state) {
              state = {
                elapsed: {},
                block: {}
              };
              utils_1.obj.setReadonly(grid, CHECK_HEADER_STATE_ID, state);
            }

            return state;
          }

          var CheckHeaderAction = /*#__PURE__*/function (_BaseAction_1$BaseAct3) {
            _inherits(CheckHeaderAction, _BaseAction_1$BaseAct3);

            var _super61 = _createSuper(CheckHeaderAction);

            function CheckHeaderAction() {
              _classCallCheck(this, CheckHeaderAction);

              return _super61.apply(this, arguments);
            }

            _createClass(CheckHeaderAction, [{
              key: "clone",
              value: function clone() {
                return new CheckHeaderAction(this);
              }
            }, {
              key: "bindGridEvent",
              value: function bindGridEvent(grid, cellId) {
                var _this91 = this;

                var state = getState(grid);

                var action = function action(_ref70) {
                  var col = _ref70.col,
                      row = _ref70.row;
                  var range = grid.getCellRange(col, row);
                  var cellKey = "".concat(range.start.col, ":").concat(range.start.row);

                  if (_this91.disabled || state.block[cellKey]) {
                    return;
                  }

                  var checked = grid.getHeaderValue(range.start.col, range.start.row);
                  grid.setHeaderValue(range.start.col, range.start.row, !checked);

                  var onChange = function onChange() {
                    // checkbox animation
                    (0, animate_1.animate)(200, function (point) {
                      if (point === 1) {
                        delete state.elapsed[cellKey];
                      } else {
                        state.elapsed[cellKey] = point;
                      }

                      grid.invalidateCellRange(range);
                    });
                  };

                  onChange();
                };

                return [].concat(_toConsumableArray((0, actionBind_1.bindCellClickAction)(grid, cellId, {
                  action: action,
                  mouseOver: function mouseOver(e) {
                    if (_this91.disabled) {
                      return false;
                    }

                    state.mouseActiveCell = {
                      col: e.col,
                      row: e.row
                    };
                    var range = grid.getCellRange(e.col, e.row);
                    grid.invalidateCellRange(range);
                    return true;
                  },
                  mouseOut: function mouseOut(e) {
                    delete state.mouseActiveCell;
                    var range = grid.getCellRange(e.col, e.row);
                    grid.invalidateCellRange(range);
                  }
                })), _toConsumableArray((0, actionBind_1.bindCellKeyAction)(grid, cellId, {
                  action: action
                })));
              }
            }]);

            return CheckHeaderAction;
          }(BaseAction_1.BaseAction);

          exports.CheckHeaderAction = CheckHeaderAction;
          /***/
        },

        /***/
        "./header/action/SortHeaderAction.js":
        /*!*******************************************!*\
          !*** ./header/action/SortHeaderAction.js ***!
          \*******************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function headerActionSortHeaderActionJs(module, exports, __nested_webpack_require_781147__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.SortHeaderAction = void 0;

          var BaseAction_1 = __nested_webpack_require_781147__(
          /*! ./BaseAction */
          "./header/action/BaseAction.js");

          var actionBind_1 = __nested_webpack_require_781147__(
          /*! ./actionBind */
          "./header/action/actionBind.js");

          var SortHeaderAction = /*#__PURE__*/function (_BaseAction_1$BaseAct4) {
            _inherits(SortHeaderAction, _BaseAction_1$BaseAct4);

            var _super62 = _createSuper(SortHeaderAction);

            function SortHeaderAction() {
              var _this92;

              var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, SortHeaderAction);

              var _a;

              _this92 = _super62.call(this, option);
              _this92._sort = (_a = option.sort) !== null && _a !== void 0 ? _a : true;
              return _this92;
            }

            _createClass(SortHeaderAction, [{
              key: "sort",
              get: function get() {
                return this._sort;
              },
              set: function set(sort) {
                this._sort = sort;
                this.onChangeDisabledInternal();
              }
            }, {
              key: "clone",
              value: function clone() {
                return new SortHeaderAction(this);
              }
            }, {
              key: "_executeSort",
              value: function _executeSort(newState, grid) {
                if (typeof this._sort === "function") {
                  this._sort({
                    order: newState.order || "asc",
                    col: newState.col,
                    row: newState.row,
                    grid: grid
                  });
                } else if (typeof this._sort === "string" && ( // v1.6.3 Backward compatibility
                this._sort !== "true" || hasTrueField(grid))) {
                  var field = this._sort;
                  grid.dataSource.sort(field, newState.order || "asc");
                } else {
                  var fieldRow = Math.min(grid.recordRowCount - 1, newState.row) + grid.frozenRowCount;

                  var _field3 = grid.getField(newState.col, fieldRow);

                  if (_field3 == null) {
                    return;
                  }

                  grid.dataSource.sort(_field3, newState.order || "asc");
                }
              }
            }, {
              key: "bindGridEvent",
              value: function bindGridEvent(grid, cellId) {
                var _this93 = this;

                function isTarget(col, row) {
                  return grid.getLayoutCellId(col, row) === cellId;
                }

                var action = function action(cell) {
                  if (_this93.disabled) {
                    return;
                  }

                  var state = grid.sortState;
                  var newState;
                  var range = grid.getCellRange(cell.col, cell.row);

                  if (isTarget(state.col, cell.row)) {
                    newState = {
                      col: range.start.col,
                      row: range.start.row,
                      order: state.order === "asc" ? "desc" : "asc"
                    };
                  } else {
                    newState = {
                      col: range.start.col,
                      row: range.start.row,
                      order: "asc"
                    };
                  }

                  grid.sortState = newState;

                  _this93._executeSort(newState, grid);

                  grid.invalidateGridRect(0, 0, grid.colCount - 1, grid.rowCount - 1);
                };

                return _toConsumableArray((0, actionBind_1.bindCellClickAction)(grid, cellId, {
                  action: action,
                  mouseOver: function mouseOver(_e) {
                    if (_this93.disabled) {
                      return false;
                    }

                    return true;
                  }
                }));
              }
            }]);

            return SortHeaderAction;
          }(BaseAction_1.BaseAction);

          exports.SortHeaderAction = SortHeaderAction;

          function hasTrueField(grid) {
            if (grid.dataSource.length > 0) {
              var record = grid.dataSource.get(0);
              return record != null && "true" in record;
            }

            return false;
          }
          /***/

        },

        /***/
        "./header/action/actionBind.js":
        /*!*************************************!*\
          !*** ./header/action/actionBind.js ***!
          \*************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function headerActionActionBindJs(module, exports, __nested_webpack_require_786222__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.bindCellKeyAction = exports.bindCellClickAction = void 0;

          var DG_EVENT_TYPE_1 = __nested_webpack_require_786222__(
          /*! ../../core/DG_EVENT_TYPE */
          "./core/DG_EVENT_TYPE.js");

          var utils_1 = __nested_webpack_require_786222__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var KEY_ENTER = 13;
          var KEY_SPACE = 32;

          function bindCellClickAction(grid, cellId, _ref71) {
            var action = _ref71.action,
                mouseOver = _ref71.mouseOver,
                mouseOut = _ref71.mouseOut;

            function isTarget(col, row) {
              return grid.getLayoutCellId(col, row) === cellId;
            }

            var inMouse;
            return [// click
            grid.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.CLICK_CELL, function (e) {
              if (!isTarget(e.col, e.row)) {
                return;
              }

              action({
                col: e.col,
                row: e.row
              });
            }), // mouse move
            grid.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.MOUSEOVER_CELL, function (e) {
              if (!isTarget(e.col, e.row)) {
                return;
              }

              if (mouseOver) {
                if (!mouseOver({
                  col: e.col,
                  row: e.row
                })) {
                  return;
                }
              }

              grid.getElement().style.cursor = "pointer";
              inMouse = true;
            }), //MOUSEENTER'col-resize'move
            grid.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.MOUSEMOVE_CELL, function (e) {
              if (!isTarget(e.col, e.row)) {
                return;
              }

              if (inMouse && !grid.getElement().style.cursor) {
                grid.getElement().style.cursor = "pointer";
              }
            }), grid.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.MOUSEOUT_CELL, function (e) {
              if (!isTarget(e.col, e.row)) {
                return;
              }

              if (mouseOut) {
                mouseOut({
                  col: e.col,
                  row: e.row
                });
              }

              grid.getElement().style.cursor = "";
              inMouse = false;
            })];
          }

          exports.bindCellClickAction = bindCellClickAction;

          function bindCellKeyAction(grid, cellId, _ref72) {
            var action = _ref72.action,
                _ref72$acceptKeys = _ref72.acceptKeys,
                acceptKeys = _ref72$acceptKeys === void 0 ? [] : _ref72$acceptKeys;

            function isTarget(col, row) {
              return grid.getLayoutCellId(col, row) === cellId;
            }

            acceptKeys = [].concat(_toConsumableArray(acceptKeys), [KEY_ENTER, KEY_SPACE]);
            return [// enter key down
            grid.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.KEYDOWN, function (e) {
              var _a;

              if (acceptKeys.indexOf(e.keyCode) === -1) {
                return;
              }

              if (((_a = grid.keyboardOptions) === null || _a === void 0 ? void 0 : _a.moveCellOnEnter) && e.keyCode === KEY_ENTER) {
                // When moving with the enter key, no action is taken with the enter key.
                return;
              }

              var sel = grid.selection.select;

              if (!isTarget(sel.col, sel.row)) {
                return;
              }

              action({
                col: sel.col,
                row: sel.row
              });
              utils_1.event.cancel(e.event);
            })];
          }

          exports.bindCellKeyAction = bindCellKeyAction;
          /***/
        },

        /***/
        "./header/style.js":
        /*!*************************!*\
          !*** ./header/style.js ***!
          \*************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function headerStyleJs(module, exports, __nested_webpack_require_790463__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.of = exports.MultilineTextHeaderStyle = exports.CheckHeaderStyle = exports.SortHeaderStyle = exports.Style = exports.BaseStyle = void 0;

          var BaseStyle_1 = __nested_webpack_require_790463__(
          /*! ./style/BaseStyle */
          "./header/style/BaseStyle.js");

          Object.defineProperty(exports, "BaseStyle", {
            enumerable: true,
            get: function get() {
              return BaseStyle_1.BaseStyle;
            }
          });

          var CheckHeaderStyle_1 = __nested_webpack_require_790463__(
          /*! ./style/CheckHeaderStyle */
          "./header/style/CheckHeaderStyle.js");

          Object.defineProperty(exports, "CheckHeaderStyle", {
            enumerable: true,
            get: function get() {
              return CheckHeaderStyle_1.CheckHeaderStyle;
            }
          });

          var MultilineTextHeaderStyle_1 = __nested_webpack_require_790463__(
          /*! ./style/MultilineTextHeaderStyle */
          "./header/style/MultilineTextHeaderStyle.js");

          Object.defineProperty(exports, "MultilineTextHeaderStyle", {
            enumerable: true,
            get: function get() {
              return MultilineTextHeaderStyle_1.MultilineTextHeaderStyle;
            }
          });

          var SortHeaderStyle_1 = __nested_webpack_require_790463__(
          /*! ./style/SortHeaderStyle */
          "./header/style/SortHeaderStyle.js");

          Object.defineProperty(exports, "SortHeaderStyle", {
            enumerable: true,
            get: function get() {
              return SortHeaderStyle_1.SortHeaderStyle;
            }
          });

          var Style_1 = __nested_webpack_require_790463__(
          /*! ./style/Style */
          "./header/style/Style.js");

          Object.defineProperty(exports, "Style", {
            enumerable: true,
            get: function get() {
              return Style_1.Style;
            }
          });

          function of(headerStyle, StyleClass) {
            if (headerStyle) {
              if (headerStyle instanceof Style_1.Style) {
                return headerStyle;
              } else if (typeof headerStyle === "function") {
                return of(headerStyle(), StyleClass);
              }

              return new StyleClass(headerStyle);
            } else {
              return StyleClass.DEFAULT;
            }
          }

          exports.of = of;
          /***/
        },

        /***/
        "./header/style/BaseStyle.js":
        /*!***********************************!*\
          !*** ./header/style/BaseStyle.js ***!
          \***********************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function headerStyleBaseStyleJs(module, exports, __nested_webpack_require_793398__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.BaseStyle = void 0;

          var EventTarget_1 = __nested_webpack_require_793398__(
          /*! ../../core/EventTarget */
          "./core/EventTarget.js");

          var EVENT_TYPE = {
            CHANGE_STYLE: "change_style"
          };
          var defaultStyle;

          var BaseStyle = /*#__PURE__*/function (_EventTarget_1$EventT6) {
            _inherits(BaseStyle, _EventTarget_1$EventT6);

            var _super63 = _createSuper(BaseStyle);

            function BaseStyle() {
              var _this94;

              var _ref73 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
                  bgColor = _ref73.bgColor;

              _classCallCheck(this, BaseStyle);

              _this94 = _super63.call(this);
              _this94._bgColor = bgColor;
              return _this94;
            }

            _createClass(BaseStyle, [{
              key: "bgColor",
              get: function get() {
                return this._bgColor;
              },
              set: function set(bgColor) {
                this._bgColor = bgColor;
                this.doChangeStyle();
              }
            }, {
              key: "doChangeStyle",
              value: function doChangeStyle() {
                this.fireListeners(EVENT_TYPE.CHANGE_STYLE);
              }
            }, {
              key: "clone",
              value: function clone() {
                return new BaseStyle(this);
              }
            }], [{
              key: "EVENT_TYPE",
              get: function get() {
                return EVENT_TYPE;
              }
            }, {
              key: "DEFAULT",
              get: function get() {
                return defaultStyle ? defaultStyle : defaultStyle = new BaseStyle();
              }
            }]);

            return BaseStyle;
          }(EventTarget_1.EventTarget);

          exports.BaseStyle = BaseStyle;
          /***/
        },

        /***/
        "./header/style/CheckHeaderStyle.js":
        /*!******************************************!*\
          !*** ./header/style/CheckHeaderStyle.js ***!
          \******************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function headerStyleCheckHeaderStyleJs(module, exports, __nested_webpack_require_795923__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.CheckHeaderStyle = void 0;

          var StdTextBaseStyle_1 = __nested_webpack_require_795923__(
          /*! ./StdTextBaseStyle */
          "./header/style/StdTextBaseStyle.js");

          var utils_1 = __nested_webpack_require_795923__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var defaultStyle;

          var CheckHeaderStyle = /*#__PURE__*/function (_StdTextBaseStyle_1$S) {
            _inherits(CheckHeaderStyle, _StdTextBaseStyle_1$S);

            var _super64 = _createSuper(CheckHeaderStyle);

            function CheckHeaderStyle() {
              var _this95;

              var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, CheckHeaderStyle);

              _this95 = _super64.call(this, (0, utils_1.defaults)(style, {
                textAlign: "center"
              }));
              var uncheckBgColor = style.uncheckBgColor,
                  checkBgColor = style.checkBgColor,
                  borderColor = style.borderColor;
              _this95._uncheckBgColor = uncheckBgColor;
              _this95._checkBgColor = checkBgColor;
              _this95._borderColor = borderColor;
              return _this95;
            }

            _createClass(CheckHeaderStyle, [{
              key: "uncheckBgColor",
              get: function get() {
                return this._uncheckBgColor;
              },
              set: function set(uncheckBgColor) {
                this._uncheckBgColor = uncheckBgColor;
                this.doChangeStyle();
              }
            }, {
              key: "checkBgColor",
              get: function get() {
                return this._checkBgColor;
              },
              set: function set(checkBgColor) {
                this._checkBgColor = checkBgColor;
                this.doChangeStyle();
              }
            }, {
              key: "borderColor",
              get: function get() {
                return this._borderColor;
              },
              set: function set(borderColor) {
                this._borderColor = borderColor;
                this.doChangeStyle();
              }
            }, {
              key: "clone",
              value: function clone() {
                return new CheckHeaderStyle(this);
              }
            }], [{
              key: "DEFAULT",
              get: function get() {
                return defaultStyle ? defaultStyle : defaultStyle = new CheckHeaderStyle();
              }
            }]);

            return CheckHeaderStyle;
          }(StdTextBaseStyle_1.StdTextBaseStyle);

          exports.CheckHeaderStyle = CheckHeaderStyle;
          /***/
        },

        /***/
        "./header/style/MultilineTextHeaderStyle.js":
        /*!**************************************************!*\
          !*** ./header/style/MultilineTextHeaderStyle.js ***!
          \**************************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function headerStyleMultilineTextHeaderStyleJs(module, exports, __nested_webpack_require_799263__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.MultilineTextHeaderStyle = void 0;

          var StdMultilineTextBaseStyle_1 = __nested_webpack_require_799263__(
          /*! ./StdMultilineTextBaseStyle */
          "./header/style/StdMultilineTextBaseStyle.js");

          var defaultStyle;

          var MultilineTextHeaderStyle = /*#__PURE__*/function (_StdMultilineTextBase) {
            _inherits(MultilineTextHeaderStyle, _StdMultilineTextBase);

            var _super65 = _createSuper(MultilineTextHeaderStyle);

            function MultilineTextHeaderStyle() {
              var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, MultilineTextHeaderStyle);

              return _super65.call(this, style);
            }

            _createClass(MultilineTextHeaderStyle, [{
              key: "clone",
              value: function clone() {
                return new MultilineTextHeaderStyle(this);
              }
            }], [{
              key: "DEFAULT",
              get: function get() {
                return defaultStyle ? defaultStyle : defaultStyle = new MultilineTextHeaderStyle();
              }
            }]);

            return MultilineTextHeaderStyle;
          }(StdMultilineTextBaseStyle_1.StdMultilineTextBaseStyle);

          exports.MultilineTextHeaderStyle = MultilineTextHeaderStyle;
          /***/
        },

        /***/
        "./header/style/SortHeaderStyle.js":
        /*!*****************************************!*\
          !*** ./header/style/SortHeaderStyle.js ***!
          \*****************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function headerStyleSortHeaderStyleJs(module, exports, __nested_webpack_require_801215__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.SortHeaderStyle = void 0;

          var StdMultilineTextBaseStyle_1 = __nested_webpack_require_801215__(
          /*! ./StdMultilineTextBaseStyle */
          "./header/style/StdMultilineTextBaseStyle.js");

          var defaultStyle;

          var SortHeaderStyle = /*#__PURE__*/function (_StdMultilineTextBase2) {
            _inherits(SortHeaderStyle, _StdMultilineTextBase2);

            var _super66 = _createSuper(SortHeaderStyle);

            function SortHeaderStyle() {
              var _this96;

              var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, SortHeaderStyle);

              _this96 = _super66.call(this, style);
              _this96._sortArrowColor = style.sortArrowColor;
              _this96._multiline = style.multiline;
              return _this96;
            }

            _createClass(SortHeaderStyle, [{
              key: "sortArrowColor",
              get: function get() {
                return this._sortArrowColor;
              },
              set: function set(sortArrowColor) {
                this._sortArrowColor = sortArrowColor;
                this.doChangeStyle();
              }
            }, {
              key: "multiline",
              get: function get() {
                return !!this._multiline;
              },
              set: function set(multiline) {
                this._multiline = multiline;
                this.doChangeStyle();
              }
            }, {
              key: "clone",
              value: function clone() {
                return new SortHeaderStyle(this);
              }
            }], [{
              key: "DEFAULT",
              get: function get() {
                return defaultStyle ? defaultStyle : defaultStyle = new SortHeaderStyle();
              }
            }]);

            return SortHeaderStyle;
          }(StdMultilineTextBaseStyle_1.StdMultilineTextBaseStyle);

          exports.SortHeaderStyle = SortHeaderStyle;
          /***/
        },

        /***/
        "./header/style/StdBaseStyle.js":
        /*!**************************************!*\
          !*** ./header/style/StdBaseStyle.js ***!
          \**************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function headerStyleStdBaseStyleJs(module, exports, __nested_webpack_require_803820__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.StdBaseStyle = void 0;

          var BaseStyle_1 = __nested_webpack_require_803820__(
          /*! ./BaseStyle */
          "./header/style/BaseStyle.js");

          var defaultStyle;

          var StdBaseStyle = /*#__PURE__*/function (_BaseStyle_1$BaseStyl3) {
            _inherits(StdBaseStyle, _BaseStyle_1$BaseStyl3);

            var _super67 = _createSuper(StdBaseStyle);

            function StdBaseStyle() {
              var _this97;

              var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, StdBaseStyle);

              _this97 = _super67.call(this, style);
              _this97._textAlign = style.textAlign || "left";
              _this97._textBaseline = style.textBaseline || "middle";
              return _this97;
            }

            _createClass(StdBaseStyle, [{
              key: "textAlign",
              get: function get() {
                return this._textAlign;
              },
              set: function set(textAlign) {
                this._textAlign = textAlign;
                this.doChangeStyle();
              }
            }, {
              key: "textBaseline",
              get: function get() {
                return this._textBaseline;
              },
              set: function set(textBaseline) {
                this._textBaseline = textBaseline;
                this.doChangeStyle();
              }
            }, {
              key: "clone",
              value: function clone() {
                return new StdBaseStyle(this);
              }
            }], [{
              key: "DEFAULT",
              get: function get() {
                return defaultStyle ? defaultStyle : defaultStyle = new StdBaseStyle();
              }
            }]);

            return StdBaseStyle;
          }(BaseStyle_1.BaseStyle);

          exports.StdBaseStyle = StdBaseStyle;
          /***/
        },

        /***/
        "./header/style/StdMultilineTextBaseStyle.js":
        /*!***************************************************!*\
          !*** ./header/style/StdMultilineTextBaseStyle.js ***!
          \***************************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function headerStyleStdMultilineTextBaseStyleJs(module, exports, __nested_webpack_require_806380__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.StdMultilineTextBaseStyle = void 0;

          var StdTextBaseStyle_1 = __nested_webpack_require_806380__(
          /*! ./StdTextBaseStyle */
          "./header/style/StdTextBaseStyle.js");

          var defaultStyle;

          var StdMultilineTextBaseStyle = /*#__PURE__*/function (_StdTextBaseStyle_1$S2) {
            _inherits(StdMultilineTextBaseStyle, _StdTextBaseStyle_1$S2);

            var _super68 = _createSuper(StdMultilineTextBaseStyle);

            function StdMultilineTextBaseStyle() {
              var _this98;

              var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, StdMultilineTextBaseStyle);

              _this98 = _super68.call(this, style);
              _this98._lineHeight = style.lineHeight || "1em";
              _this98._autoWrapText = style.autoWrapText || false;
              _this98._lineClamp = style.lineClamp;
              return _this98;
            }

            _createClass(StdMultilineTextBaseStyle, [{
              key: "clone",
              value: function clone() {
                return new StdMultilineTextBaseStyle(this);
              }
            }, {
              key: "lineHeight",
              get: function get() {
                return this._lineHeight;
              },
              set: function set(lineHeight) {
                this._lineHeight = lineHeight;
                this.doChangeStyle();
              }
            }, {
              key: "lineClamp",
              get: function get() {
                return this._lineClamp;
              },
              set: function set(lineClamp) {
                this._lineClamp = lineClamp;
                this.doChangeStyle();
              }
            }, {
              key: "autoWrapText",
              get: function get() {
                return this._autoWrapText;
              },
              set: function set(autoWrapText) {
                this._autoWrapText = autoWrapText;
                this.doChangeStyle();
              }
            }], [{
              key: "DEFAULT",
              get: function get() {
                return defaultStyle ? defaultStyle : defaultStyle = new StdMultilineTextBaseStyle();
              }
            }]);

            return StdMultilineTextBaseStyle;
          }(StdTextBaseStyle_1.StdTextBaseStyle);

          exports.StdMultilineTextBaseStyle = StdMultilineTextBaseStyle;
          /***/
        },

        /***/
        "./header/style/StdTextBaseStyle.js":
        /*!******************************************!*\
          !*** ./header/style/StdTextBaseStyle.js ***!
          \******************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function headerStyleStdTextBaseStyleJs(module, exports, __nested_webpack_require_809427__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.StdTextBaseStyle = void 0;

          var StdBaseStyle_1 = __nested_webpack_require_809427__(
          /*! ./StdBaseStyle */
          "./header/style/StdBaseStyle.js");

          var defaultStyle;

          var StdTextBaseStyle = /*#__PURE__*/function (_StdBaseStyle_1$StdBa5) {
            _inherits(StdTextBaseStyle, _StdBaseStyle_1$StdBa5);

            var _super69 = _createSuper(StdTextBaseStyle);

            function StdTextBaseStyle() {
              var _this99;

              var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, StdTextBaseStyle);

              _this99 = _super69.call(this, style);
              _this99._color = style.color;
              _this99._font = style.font;
              _this99._padding = style.padding;
              _this99._textOverflow = style.textOverflow || "ellipsis";
              return _this99;
            }

            _createClass(StdTextBaseStyle, [{
              key: "color",
              get: function get() {
                return this._color;
              },
              set: function set(color) {
                this._color = color;
                this.doChangeStyle();
              }
            }, {
              key: "font",
              get: function get() {
                return this._font;
              },
              set: function set(font) {
                this._font = font;
                this.doChangeStyle();
              }
            }, {
              key: "padding",
              get: function get() {
                return this._padding;
              },
              set: function set(padding) {
                this._padding = padding;
                this.doChangeStyle();
              }
            }, {
              key: "textOverflow",
              get: function get() {
                return this._textOverflow;
              },
              set: function set(textOverflow) {
                this._textOverflow = textOverflow;
                this.doChangeStyle();
              }
            }, {
              key: "clone",
              value: function clone() {
                return new StdTextBaseStyle(this);
              }
            }], [{
              key: "DEFAULT",
              get: function get() {
                return defaultStyle ? defaultStyle : defaultStyle = new StdTextBaseStyle();
              }
            }]);

            return StdTextBaseStyle;
          }(StdBaseStyle_1.StdBaseStyle);

          exports.StdTextBaseStyle = StdTextBaseStyle;
          /***/
        },

        /***/
        "./header/style/Style.js":
        /*!*******************************!*\
          !*** ./header/style/Style.js ***!
          \*******************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function headerStyleStyleJs(module, exports, __nested_webpack_require_812541__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.Style = void 0;

          var StdMultilineTextBaseStyle_1 = __nested_webpack_require_812541__(
          /*! ./StdMultilineTextBaseStyle */
          "./header/style/StdMultilineTextBaseStyle.js");

          var defaultStyle;

          var Style = /*#__PURE__*/function (_StdMultilineTextBase3) {
            _inherits(Style, _StdMultilineTextBase3);

            var _super70 = _createSuper(Style);

            function Style() {
              var _this100;

              var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, Style);

              _this100 = _super70.call(this, style);
              _this100._multiline = style.multiline;
              return _this100;
            }

            _createClass(Style, [{
              key: "multiline",
              get: function get() {
                return !!this._multiline;
              },
              set: function set(multiline) {
                this._multiline = multiline;
                this.doChangeStyle();
              }
            }, {
              key: "clone",
              value: function clone() {
                return new Style(this);
              }
            }], [{
              key: "DEFAULT",
              get: function get() {
                return defaultStyle ? defaultStyle : defaultStyle = new Style();
              }
            }]);

            return Style;
          }(StdMultilineTextBaseStyle_1.StdMultilineTextBaseStyle);

          exports.Style = Style;
          /***/
        },

        /***/
        "./header/type.js":
        /*!************************!*\
          !*** ./header/type.js ***!
          \************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function headerTypeJs(module, exports, __nested_webpack_require_814588__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.ofCell = exports.of = exports.MultilineTextHeader = exports.CheckHeader = exports.SortHeader = exports.Header = exports.BaseHeader = void 0;

          var BaseHeader_1 = __nested_webpack_require_814588__(
          /*! ./type/BaseHeader */
          "./header/type/BaseHeader.js");

          Object.defineProperty(exports, "BaseHeader", {
            enumerable: true,
            get: function get() {
              return BaseHeader_1.BaseHeader;
            }
          });

          var CheckHeader_1 = __nested_webpack_require_814588__(
          /*! ./type/CheckHeader */
          "./header/type/CheckHeader.js");

          Object.defineProperty(exports, "CheckHeader", {
            enumerable: true,
            get: function get() {
              return CheckHeader_1.CheckHeader;
            }
          });

          var Header_1 = __nested_webpack_require_814588__(
          /*! ./type/Header */
          "./header/type/Header.js");

          Object.defineProperty(exports, "Header", {
            enumerable: true,
            get: function get() {
              return Header_1.Header;
            }
          });

          var MultilineTextHeader_1 = __nested_webpack_require_814588__(
          /*! ./type/MultilineTextHeader */
          "./header/type/MultilineTextHeader.js");

          Object.defineProperty(exports, "MultilineTextHeader", {
            enumerable: true,
            get: function get() {
              return MultilineTextHeader_1.MultilineTextHeader;
            }
          });

          var SortHeader_1 = __nested_webpack_require_814588__(
          /*! ./type/SortHeader */
          "./header/type/SortHeader.js");

          Object.defineProperty(exports, "SortHeader", {
            enumerable: true,
            get: function get() {
              return SortHeader_1.SortHeader;
            }
          });
          var TYPES = {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            DEFAULT: new Header_1.Header(),
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            SORT: new SortHeader_1.SortHeader(),
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            CHECK: new CheckHeader_1.CheckHeader(),
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            MULTILINETEXT: new MultilineTextHeader_1.MultilineTextHeader()
          };

          function of(headerType) {
            if (!headerType) {
              return TYPES.DEFAULT;
            } else if (typeof headerType === "string") {
              var key = headerType.toUpperCase();
              return TYPES[key] || of(null);
            } else {
              return headerType;
            }
          }

          exports.of = of;

          function ofCell(headerCell) {
            if (headerCell.sort) {
              return TYPES.SORT;
            }

            return of(headerCell.headerType);
          }

          exports.ofCell = ofCell;
          /***/
        },

        /***/
        "./header/type/BaseHeader.js":
        /*!***********************************!*\
          !*** ./header/type/BaseHeader.js ***!
          \***********************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function headerTypeBaseHeaderJs(module, exports, __nested_webpack_require_818104__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.BaseHeader = void 0;

          var styleContents = __importStar(__nested_webpack_require_818104__(
          /*! ../style */
          "./header/style.js"));

          var BaseStyle_1 = __nested_webpack_require_818104__(
          /*! ../style/BaseStyle */
          "./header/style/BaseStyle.js");

          var BaseHeader = /*#__PURE__*/function () {
            function BaseHeader() {
              var _options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, BaseHeader);

              this.onDrawCell = this.onDrawCell.bind(this); //
            }

            _createClass(BaseHeader, [{
              key: "StyleClass",
              get: function get() {
                return BaseStyle_1.BaseStyle;
              }
            }, {
              key: "onDrawCell",
              value: function onDrawCell(cellValue, info, context, grid) {
                var style = info.style,
                    drawCellBase = info.drawCellBase;
                var helper = grid.getGridCanvasHelper();
                drawCellBase(); //

                this.drawInternal(this.convertInternal(cellValue), context, styleContents.of(style, this.StyleClass), helper, grid, info);
              }
            }, {
              key: "convertInternal",
              value: function convertInternal(value) {
                if (typeof value === "function") {
                  value = value();
                } // eslint-disable-next-line @typescript-eslint/restrict-template-expressions


                return value != null ? "".concat(value) : "";
              }
            }, {
              key: "bindGridEvent",
              value: function bindGridEvent(_grid, _cellId) {
                return [];
              }
            }, {
              key: "getCopyCellValue",
              value: function getCopyCellValue(value, _grid, _cell) {
                if (typeof value === "function") {
                  value = value();
                }

                return value != null ? value : "";
              }
            }]);

            return BaseHeader;
          }();

          exports.BaseHeader = BaseHeader;
          /***/
        },

        /***/
        "./header/type/CheckHeader.js":
        /*!************************************!*\
          !*** ./header/type/CheckHeader.js ***!
          \************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function headerTypeCheckHeaderJs(module, exports, __nested_webpack_require_822250__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.CheckHeader = void 0;

          var inlineUtils = __importStar(__nested_webpack_require_822250__(
          /*! ../../element/inlines */
          "./element/inlines.js"));

          var utils = __importStar(__nested_webpack_require_822250__(
          /*! ../../columns/type/columnUtils */
          "./columns/type/columnUtils.js"));

          var BaseHeader_1 = __nested_webpack_require_822250__(
          /*! ./BaseHeader */
          "./header/type/BaseHeader.js");

          var CheckHeaderStyle_1 = __nested_webpack_require_822250__(
          /*! ../style/CheckHeaderStyle */
          "./header/style/CheckHeaderStyle.js");

          var symbolManager_1 = __nested_webpack_require_822250__(
          /*! ../../internal/symbolManager */
          "./internal/symbolManager.js");

          var utils_1 = __nested_webpack_require_822250__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var CHECK_HEADER_STATE_ID = (0, symbolManager_1.getCheckHeaderStateId)(); // eslint-disable-next-line @typescript-eslint/no-explicit-any

          function getState(grid) {
            var state = grid[CHECK_HEADER_STATE_ID];

            if (!state) {
              state = {
                elapsed: {},
                block: {}
              };
              utils_1.obj.setReadonly(grid, CHECK_HEADER_STATE_ID, state);
            }

            return state;
          }

          var CheckHeader = /*#__PURE__*/function (_BaseHeader_1$BaseHea) {
            _inherits(CheckHeader, _BaseHeader_1$BaseHea);

            var _super71 = _createSuper(CheckHeader);

            function CheckHeader() {
              _classCallCheck(this, CheckHeader);

              return _super71.apply(this, arguments);
            }

            _createClass(CheckHeader, [{
              key: "StyleClass",
              get: function get() {
                return CheckHeaderStyle_1.CheckHeaderStyle;
              }
            }, {
              key: "clone",
              value: function clone() {
                return new CheckHeader(this);
              }
            }, {
              key: "drawInternal",
              value: function drawInternal(value, context, style, helper, // eslint-disable-next-line @typescript-eslint/no-explicit-any
              grid, _ref74) {
                var drawCellBase = _ref74.drawCellBase,
                    getIcon = _ref74.getIcon;
                var textAlign = style.textAlign,
                    textBaseline = style.textBaseline,
                    borderColor = style.borderColor,
                    checkBgColor = style.checkBgColor,
                    uncheckBgColor = style.uncheckBgColor,
                    bgColor = style.bgColor,
                    padding = style.padding,
                    color = style.color,
                    font = style.font,
                    textOverflow = style.textOverflow;

                if (bgColor) {
                  drawCellBase({
                    bgColor: bgColor
                  });
                }

                var col = context.col,
                    row = context.row;
                var range = grid.getCellRange(col, row);
                var cellKey = "".concat(range.start.col, ":").concat(range.start.row);

                var _getState = getState(grid),
                    elapsed = _getState.elapsed[cellKey];

                var checked = grid.getHeaderValue(range.start.col, range.start.row);
                var opt = {
                  textAlign: textAlign,
                  textBaseline: textBaseline,
                  borderColor: borderColor,
                  checkBgColor: checkBgColor,
                  uncheckBgColor: uncheckBgColor
                };

                if (elapsed != null) {
                  opt.animElapsedTime = elapsed;
                }

                var inlineCheck = helper.buildCheckBoxInline(!!checked, context, opt);
                utils.loadIcons(getIcon(), context, helper, function (icons, context) {
                  var contents = [inlineCheck];
                  contents = contents.concat(inlineUtils.buildInlines(icons, value != null ? String(value) : ""));
                  helper.text(contents, context, {
                    textAlign: textAlign,
                    textBaseline: textBaseline,
                    color: color,
                    font: font,
                    padding: padding,
                    textOverflow: textOverflow
                  });
                });
              }
            }]);

            return CheckHeader;
          }(BaseHeader_1.BaseHeader);

          exports.CheckHeader = CheckHeader;
          /***/
        },

        /***/
        "./header/type/Header.js":
        /*!*******************************!*\
          !*** ./header/type/Header.js ***!
          \*******************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function headerTypeHeaderJs(module, exports, __nested_webpack_require_828780__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.Header = void 0;

          var utils = __importStar(__nested_webpack_require_828780__(
          /*! ../../columns/type/columnUtils */
          "./columns/type/columnUtils.js"));

          var BaseHeader_1 = __nested_webpack_require_828780__(
          /*! ./BaseHeader */
          "./header/type/BaseHeader.js");

          var Style_1 = __nested_webpack_require_828780__(
          /*! ../style/Style */
          "./header/style/Style.js");

          var Header = /*#__PURE__*/function (_BaseHeader_1$BaseHea2) {
            _inherits(Header, _BaseHeader_1$BaseHea2);

            var _super72 = _createSuper(Header);

            function Header() {
              _classCallCheck(this, Header);

              return _super72.apply(this, arguments);
            }

            _createClass(Header, [{
              key: "StyleClass",
              get: function get() {
                return Style_1.Style;
              }
            }, {
              key: "drawInternal",
              value: function drawInternal(value, context, style, helper, _grid, _ref75) {
                var drawCellBase = _ref75.drawCellBase,
                    getIcon = _ref75.getIcon;
                var textAlign = style.textAlign,
                    textBaseline = style.textBaseline,
                    color = style.color,
                    font = style.font,
                    bgColor = style.bgColor,
                    padding = style.padding,
                    textOverflow = style.textOverflow,
                    lineHeight = style.lineHeight,
                    autoWrapText = style.autoWrapText,
                    lineClamp = style.lineClamp,
                    multiline = style.multiline;

                if (bgColor) {
                  drawCellBase({
                    bgColor: bgColor
                  });
                }

                var textValue = value != null ? String(value) : "";
                utils.loadIcons(getIcon(), context, helper, function (icons, context) {
                  if (multiline) {
                    var multilines = textValue.replace(/\r?\n/g, "\n").replace(/\r/g, "\n").split("\n");
                    helper.multilineText(multilines, context, {
                      textAlign: textAlign,
                      textBaseline: textBaseline,
                      color: color,
                      font: font,
                      padding: padding,
                      lineHeight: lineHeight,
                      autoWrapText: autoWrapText,
                      lineClamp: lineClamp,
                      textOverflow: textOverflow,
                      icons: icons
                    });
                  } else {
                    helper.text(textValue, context, {
                      textAlign: textAlign,
                      textBaseline: textBaseline,
                      color: color,
                      font: font,
                      padding: padding,
                      textOverflow: textOverflow,
                      icons: icons
                    });
                  }
                });
              }
            }]);

            return Header;
          }(BaseHeader_1.BaseHeader);

          exports.Header = Header;
          /***/
        },

        /***/
        "./header/type/MultilineTextHeader.js":
        /*!********************************************!*\
          !*** ./header/type/MultilineTextHeader.js ***!
          \********************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function headerTypeMultilineTextHeaderJs(module, exports, __nested_webpack_require_833979__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.MultilineTextHeader = void 0;

          var utils = __importStar(__nested_webpack_require_833979__(
          /*! ../../columns/type/columnUtils */
          "./columns/type/columnUtils.js"));

          var BaseHeader_1 = __nested_webpack_require_833979__(
          /*! ./BaseHeader */
          "./header/type/BaseHeader.js");

          var MultilineTextHeaderStyle_1 = __nested_webpack_require_833979__(
          /*! ../style/MultilineTextHeaderStyle */
          "./header/style/MultilineTextHeaderStyle.js");

          var MultilineTextHeader = /*#__PURE__*/function (_BaseHeader_1$BaseHea3) {
            _inherits(MultilineTextHeader, _BaseHeader_1$BaseHea3);

            var _super73 = _createSuper(MultilineTextHeader);

            function MultilineTextHeader() {
              _classCallCheck(this, MultilineTextHeader);

              return _super73.apply(this, arguments);
            }

            _createClass(MultilineTextHeader, [{
              key: "StyleClass",
              get: function get() {
                return MultilineTextHeaderStyle_1.MultilineTextHeaderStyle;
              }
            }, {
              key: "clone",
              value: function clone() {
                return new MultilineTextHeader(this);
              }
            }, {
              key: "drawInternal",
              value: function drawInternal(value, context, style, helper, _grid, _ref76) {
                var drawCellBase = _ref76.drawCellBase,
                    getIcon = _ref76.getIcon;
                var textAlign = style.textAlign,
                    textBaseline = style.textBaseline,
                    color = style.color,
                    font = style.font,
                    bgColor = style.bgColor,
                    padding = style.padding,
                    lineHeight = style.lineHeight,
                    autoWrapText = style.autoWrapText,
                    lineClamp = style.lineClamp,
                    textOverflow = style.textOverflow;

                if (bgColor) {
                  drawCellBase({
                    bgColor: bgColor
                  });
                }

                var textValue = value != null ? String(value) : "";
                var multilines = textValue.replace(/\r?\n/g, "\n").replace(/\r/g, "\n").split("\n");
                helper.testFontLoad(font, textValue, context);
                utils.loadIcons(getIcon(), context, helper, function (icons, context) {
                  helper.multilineText(multilines, context, {
                    textAlign: textAlign,
                    textBaseline: textBaseline,
                    color: color,
                    font: font,
                    padding: padding,
                    lineHeight: lineHeight,
                    autoWrapText: autoWrapText,
                    lineClamp: lineClamp,
                    textOverflow: textOverflow,
                    icons: icons
                  });
                });
              }
            }]);

            return MultilineTextHeader;
          }(BaseHeader_1.BaseHeader);

          exports.MultilineTextHeader = MultilineTextHeader;
          /***/
        },

        /***/
        "./header/type/SortHeader.js":
        /*!***********************************!*\
          !*** ./header/type/SortHeader.js ***!
          \***********************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function headerTypeSortHeaderJs(module, exports, __nested_webpack_require_839050__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.SortHeader = void 0;

          var utils = __importStar(__nested_webpack_require_839050__(
          /*! ../../columns/type/columnUtils */
          "./columns/type/columnUtils.js"));

          var BaseHeader_1 = __nested_webpack_require_839050__(
          /*! ./BaseHeader */
          "./header/type/BaseHeader.js");

          var SortHeaderStyle_1 = __nested_webpack_require_839050__(
          /*! ../style/SortHeaderStyle */
          "./header/style/SortHeaderStyle.js");

          var utils_1 = __nested_webpack_require_839050__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var canvases_1 = __nested_webpack_require_839050__(
          /*! ../../internal/canvases */
          "./internal/canvases.js");

          var SortHeader = /*#__PURE__*/function (_BaseHeader_1$BaseHea4) {
            _inherits(SortHeader, _BaseHeader_1$BaseHea4);

            var _super74 = _createSuper(SortHeader);

            function SortHeader() {
              _classCallCheck(this, SortHeader);

              return _super74.apply(this, arguments);
            }

            _createClass(SortHeader, [{
              key: "StyleClass",
              get: function get() {
                return SortHeaderStyle_1.SortHeaderStyle;
              }
            }, {
              key: "drawInternal",
              value: function drawInternal(value, context, style, helper, grid, _ref77) {
                var drawCellBase = _ref77.drawCellBase,
                    getIcon = _ref77.getIcon;
                var textAlign = style.textAlign,
                    _style$textBaseline = style.textBaseline,
                    textBaseline = _style$textBaseline === void 0 ? "middle" : _style$textBaseline,
                    color = style.color,
                    bgColor = style.bgColor,
                    font = style.font,
                    padding = style.padding,
                    textOverflow = style.textOverflow,
                    lineHeight = style.lineHeight,
                    autoWrapText = style.autoWrapText,
                    lineClamp = style.lineClamp,
                    sortArrowColor = style.sortArrowColor,
                    multiline = style.multiline;

                if (bgColor) {
                  drawCellBase({
                    bgColor: bgColor
                  });
                }

                var textValue = value != null ? String(value) : "";
                helper.testFontLoad(font, textValue, context);
                utils.loadIcons(getIcon(), context, helper, function (icons, context) {
                  var state = grid.sortState;
                  var order = undefined;
                  var col = context.col,
                      row = context.row;
                  var range = grid.getCellRange(col, row);

                  if ((0, utils_1.cellInRange)(range, state.col, state.row)) {
                    order = state.order;
                  }

                  var ctx = context.getContext();
                  var arrowSize = (0, canvases_1.getFontSize)(ctx, font).width * 1.2;
                  var trailingIcon = {
                    name: order != null ? order === "asc" ? "arrow_downward" : "arrow_upward" : undefined,
                    width: arrowSize,
                    color: helper.getColor(sortArrowColor || helper.theme.header.sortArrowColor, col, row, ctx) || "rgba(0, 0, 0, 0.38)"
                  };

                  if (multiline) {
                    var lines = textValue.replace(/\r?\n/g, "\n").replace(/\r/g, "\n").split("\n");
                    helper.multilineText(lines, context, {
                      textAlign: textAlign,
                      textBaseline: textBaseline,
                      color: color,
                      font: font,
                      padding: padding,
                      lineHeight: lineHeight,
                      autoWrapText: autoWrapText,
                      lineClamp: lineClamp,
                      textOverflow: textOverflow,
                      icons: icons,
                      trailingIcon: trailingIcon
                    });
                  } else {
                    helper.text(textValue, context, {
                      textAlign: textAlign,
                      textBaseline: textBaseline,
                      color: color,
                      font: font,
                      padding: padding,
                      textOverflow: textOverflow,
                      icons: icons,
                      trailingIcon: trailingIcon
                    });
                  }
                });
              }
            }]);

            return SortHeader;
          }(BaseHeader_1.BaseHeader);

          exports.SortHeader = SortHeader;
          /***/
        },

        /***/
        "./headers.js":
        /*!********************!*\
          !*** ./headers.js ***!
          \********************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function headersJs(module, exports, __nested_webpack_require_845633__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.style = exports.type = exports.action = void 0;

          var action = __importStar(__nested_webpack_require_845633__(
          /*! ./header/action */
          "./header/action.js"));

          exports.action = action;

          var style = __importStar(__nested_webpack_require_845633__(
          /*! ./header/style */
          "./header/style.js"));

          exports.style = style;

          var type = __importStar(__nested_webpack_require_845633__(
          /*! ./header/type */
          "./header/type.js"));

          exports.type = type;
          /***/
        },

        /***/
        "./icons.js":
        /*!******************!*\
          !*** ./icons.js ***!
          \******************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function iconsJs(module, exports, __nested_webpack_require_848026__) {
          "use strict";
          /*eslint-disable camelcase*/

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.get = void 0;

          var utils_1 = __nested_webpack_require_848026__(
          /*! ./internal/utils */
          "./internal/utils.js");

          var icons_1 = __nested_webpack_require_848026__(
          /*! ./plugins/icons */
          "./plugins/icons.js");

          var builtins = {
            get arrow_upward() {
              // return require("cheetah-grid-icon-svg-loader!material-design-icons/navigation/svg/production/ic_arrow_upward_48px.svg");
              return {
                d: "M8 24l2.83 2.83L22 15.66V40h4V15.66l11.17 11.17L40 24 24 8 8 24z",
                width: 48,
                height: 48
              };
            },

            get arrow_downward() {
              // return require("cheetah-grid-icon-svg-loader!material-design-icons/navigation/svg/production/ic_arrow_downward_48px.svg");
              return {
                d: "M40 24l-2.82-2.82L26 32.34V8h-4v24.34L10.84 21.16 8 24l16 16 16-16z",
                width: 48,
                height: 48
              };
            },

            get edit() {
              // return require("cheetah-grid-icon-svg-loader!material-design-icons/image/svg/production/ic_edit_48px.svg");
              return {
                d: "M6 34.5V42h7.5l22.13-22.13-7.5-7.5L6 34.5zm35.41-20.41c.78-.78.78-2.05 0-2.83l-4.67-4.67c-.78-.78-2.05-.78-2.83 0l-3.66 3.66 7.5 7.5 3.66-3.66z",
                width: 48,
                height: 48
              };
            },

            get add() {
              // return require("cheetah-grid-icon-svg-loader!material-design-icons/content/svg/production/ic_add_48px.svg");
              return {
                d: "M38 26H26v12h-4V26H10v-4h12V10h4v12h12v4z",
                width: 48,
                height: 48
              };
            },

            get star() {
              // return require("cheetah-grid-icon-svg-loader!material-design-icons/toggle/svg/production/ic_star_24px.svg");
              return {
                d: "M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z",
                width: 24,
                height: 24
              };
            },

            get star_border() {
              // return require("cheetah-grid-icon-svg-loader!material-design-icons/toggle/svg/production/ic_star_border_24px.svg");
              return {
                d: "M22 9.24l-7.19-.62L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21 12 17.27 18.18 21l-1.63-7.03L22 9.24zM12 15.4l-3.76 2.27 1-4.28-3.32-2.88 4.38-.38L12 6.1l1.71 4.04 4.38.38-3.32 2.88 1 4.28L12 15.4z",
                width: 24,
                height: 24
              };
            },

            get star_half() {
              // return require("cheetah-grid-icon-svg-loader!material-design-icons/toggle/svg/production/ic_star_half_24px.svg");
              return {
                d: "M22 9.24l-7.19-.62L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21 12 17.27 18.18 21l-1.63-7.03L22 9.24zM12 15.4V6.1l1.71 4.04 4.38.38-3.32 2.88 1 4.28L12 15.4z",
                width: 24,
                height: 24
              };
            },

            get keyboard_arrow_down() {
              // return require("cheetah-grid-icon-svg-loader!material-design-icons/hardware/svg/production/ic_keyboard_arrow_down_48px.svg");
              return {
                d: "M14.83 16.42L24 25.59l9.17-9.17L36 19.25l-12 12-12-12z",
                width: 48,
                height: 48
              };
            },

            get keyboard_arrow_left() {
              // return require("cheetah-grid-icon-svg-loader!material-design-icons/hardware/svg/production/ic_keyboard_arrow_left_48px.svg");
              return {
                d: "M30.83 32.67l-9.17-9.17 9.17-9.17L28 11.5l-12 12 12 12z",
                width: 48,
                height: 48
              };
            },

            get keyboard_arrow_right() {
              // return require("cheetah-grid-icon-svg-loader!material-design-icons/hardware/svg/production/ic_keyboard_arrow_right_48px.svg");
              return {
                d: "M17.17 32.92l9.17-9.17-9.17-9.17L20 11.75l12 12-12 12z",
                width: 48,
                height: 48
              };
            },

            get keyboard_arrow_up() {
              // return require("cheetah-grid-icon-svg-loader!material-design-icons/hardware/svg/production/ic_keyboard_arrow_up_48px.svg");
              return {
                d: "M14.83 30.83L24 21.66l9.17 9.17L36 28 24 16 12 28z",
                width: 48,
                height: 48
              };
            },

            get chevron_left() {
              // return require("cheetah-grid-icon-svg-loader!material-design-icons/navigation/svg/production/ic_chevron_left_48px.svg");
              return {
                d: "M14.83 30.83L24 21.66l9.17 9.17L36 28 24 16 12 28z",
                width: 48,
                height: 48
              };
            },

            get chevron_right() {
              // return require("cheetah-grid-icon-svg-loader!material-design-icons/navigation/svg/production/ic_chevron_right_48px.svg");
              return {
                d: "M20 12l-2.83 2.83L26.34 24l-9.17 9.17L20 36l12-12z",
                width: 48,
                height: 48
              };
            },

            get expand_less() {
              // return require("cheetah-grid-icon-svg-loader!material-design-icons/navigation/svg/production/ic_expand_less_48px.svg");
              return {
                d: "M24 16L12 28l2.83 2.83L24 21.66l9.17 9.17L36 28z",
                width: 48,
                height: 48
              };
            },

            get expand_more() {
              // return require("cheetah-grid-icon-svg-loader!material-design-icons/navigation/svg/production/ic_expand_more_48px.svg");
              return {
                d: "M33.17 17.17L24 26.34l-9.17-9.17L12 20l12 12 12-12z",
                width: 48,
                height: 48
              };
            }

          };

          function get() {
            return (0, utils_1.extend)(builtins, icons_1.icons);
          }

          exports.get = get;
          /***/
        },

        /***/
        "./internal/EventHandler.js":
        /*!**********************************!*\
          !*** ./internal/EventHandler.js ***!
          \**********************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function internalEventHandlerJs(module, exports, __nested_webpack_require_854745__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.EventHandler = void 0;

          var utils_1 = __nested_webpack_require_854745__(
          /*! ./utils */
          "./internal/utils.js");
          /** @private */


          var nextId = 1;

          var EventHandler = /*#__PURE__*/function () {
            function EventHandler() {
              _classCallCheck(this, EventHandler);

              this._listeners = {};
            }

            _createClass(EventHandler, [{
              key: "on",
              value: function on(target, type, listener) {
                for (var _len7 = arguments.length, options = new Array(_len7 > 3 ? _len7 - 3 : 0), _key7 = 3; _key7 < _len7; _key7++) {
                  options[_key7 - 3] = arguments[_key7];
                }

                if (target.addEventListener) {
                  target.addEventListener.apply(target, [type, listener].concat(options));
                }

                var obj = {
                  target: target,
                  type: type,
                  listener: listener,
                  options: options
                };
                var id = nextId++;
                this._listeners[id] = obj;
                return id;
              }
            }, {
              key: "once",
              value: function once(target, type, listener) {
                var _this101 = this;

                for (var _len8 = arguments.length, options = new Array(_len8 > 3 ? _len8 - 3 : 0), _key8 = 3; _key8 < _len8; _key8++) {
                  options[_key8 - 3] = arguments[_key8];
                }

                var id = this.on.apply(this, [target, type, function () {
                  _this101.off(id);

                  listener.apply(void 0, arguments);
                }].concat(options));
                return id;
              }
            }, {
              key: "tryWithOffEvents",
              value: function tryWithOffEvents(target, type, call) {
                var list = [];

                try {
                  (0, utils_1.each)(this._listeners, function (obj) {
                    if (obj.target === target && obj.type === type) {
                      if (obj.target.removeEventListener) {
                        var _obj$target;

                        (_obj$target = obj.target).removeEventListener.apply(_obj$target, [obj.type, obj.listener].concat(_toConsumableArray(obj.options)));
                      }

                      list.push(obj);
                    }
                  });
                  call();
                } finally {
                  list.forEach(function (obj) {
                    if (obj.target.addEventListener) {
                      var _obj$target2;

                      (_obj$target2 = obj.target).addEventListener.apply(_obj$target2, [obj.type, obj.listener].concat(_toConsumableArray(obj.options)));
                    }
                  });
                }
              }
            }, {
              key: "off",
              value: function off(id) {
                if (id == null) {
                  return;
                }

                var obj = this._listeners[id];

                if (!obj) {
                  return;
                }

                delete this._listeners[id];

                if (obj.target.removeEventListener) {
                  var _obj$target3;

                  (_obj$target3 = obj.target).removeEventListener.apply(_obj$target3, [obj.type, obj.listener].concat(_toConsumableArray(obj.options)));
                }
              } // eslint-disable-next-line @typescript-eslint/no-explicit-any

            }, {
              key: "fire",
              value: function fire(target, type) {
                for (var _len9 = arguments.length, args = new Array(_len9 > 2 ? _len9 - 2 : 0), _key9 = 2; _key9 < _len9; _key9++) {
                  args[_key9 - 2] = arguments[_key9];
                }

                (0, utils_1.each)(this._listeners, function (obj) {
                  if (obj.target === target && obj.type === type) {
                    var _obj$listener;

                    (_obj$listener = obj.listener).call.apply(_obj$listener, [obj.target].concat(args));
                  }
                });
              }
            }, {
              key: "hasListener",
              value: function hasListener(target, type) {
                var result = false;
                (0, utils_1.each)(this._listeners, function (obj) {
                  if (obj.target === target && obj.type === type) {
                    result = true;
                  }
                });
                return result;
              }
            }, {
              key: "clear",
              value: function clear() {
                (0, utils_1.each)(this._listeners, function (obj) {
                  if (obj.target.removeEventListener) {
                    var _obj$target4;

                    (_obj$target4 = obj.target).removeEventListener.apply(_obj$target4, [obj.type, obj.listener].concat(_toConsumableArray(obj.options)));
                  }
                });
                this._listeners = {};
              }
            }, {
              key: "dispose",
              value: function dispose() {
                this.clear(); // eslint-disable-next-line @typescript-eslint/no-explicit-any

                this._listeners = null;
              }
            }]);

            return EventHandler;
          }();

          exports.EventHandler = EventHandler;
          /***/
        },

        /***/
        "./internal/LRUCache.js":
        /*!******************************!*\
          !*** ./internal/LRUCache.js ***!
          \******************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function internalLRUCacheJs(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.LRUCache = void 0;

          var LRUCache = /*#__PURE__*/function () {
            function LRUCache(cacheSize) {
              _classCallCheck(this, LRUCache);

              this._list = [];
              this._map = {};
              this._cacheSize = cacheSize || 50;
            }

            _createClass(LRUCache, [{
              key: "get",
              value: function get(key) {
                var val = this._map[key];

                if (val) {
                  var list = this._list;
                  var idx = list.indexOf(key);
                  list.splice(idx, 1);
                  list.push(key);
                }

                return val;
              }
            }, {
              key: "put",
              value: function put(key, value) {
                var list = this._list;
                var map = this._map;

                if (map[key]) {
                  var idx = list.indexOf(key);
                  list.splice(idx, 1);
                }

                map[key] = value;
                list.push(key);

                if (list.length > this._cacheSize) {
                  var remKey = list.shift() || "";
                  delete map[remKey];
                }
              }
            }]);

            return LRUCache;
          }();

          exports.LRUCache = LRUCache;
          /***/
        },

        /***/
        "./internal/NumberMap.js":
        /*!*******************************!*\
          !*** ./internal/NumberMap.js ***!
          \*******************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function internalNumberMapJs(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.NumberMap = void 0;

          var indexFirst = function indexFirst(arr, elm) {
            var low = 0;
            var high = arr.length - 1;

            while (low <= high) {
              var i = Math.floor((low + high) / 2);

              if (arr[i] === elm) {
                return i;
              } else if (arr[i] > elm) {
                high = i - 1;
              } else {
                low = i + 1;
              }
            }

            return high < 0 ? 0 : high;
          };

          var NumberMap = /*#__PURE__*/function () {
            function NumberMap() {
              _classCallCheck(this, NumberMap);

              this._keys = [];
              this._vals = {};
              this._sorted = false;
            }

            _createClass(NumberMap, [{
              key: "put",
              value: function put(key, value) {
                if (!(key in this._vals)) {
                  this._keys.push(key);

                  this._sorted = false;
                }

                this._vals[key] = value;
              }
            }, {
              key: "remove",
              value: function remove(key) {
                delete this._vals[key];

                var index = this._keys.indexOf(key);

                if (index < 0) {
                  return;
                }

                this._keys.splice(index, 1);

                this._sorted = false;
              }
            }, {
              key: "get",
              value: function get(key) {
                return this._vals[key];
              }
            }, {
              key: "has",
              value: function has(key) {
                return this._vals[key] != null;
              }
            }, {
              key: "each",
              value: function each(keyFrom, keyTo, fn) {
                var keys = this._keys;
                var length = keys.length;

                if (!this._sorted) {
                  keys.sort(function (a, b) {
                    if (a < b) {
                      return -1;
                    }

                    if (a > b) {
                      return 1;
                    }

                    return 0;
                  });
                  this._sorted = true;
                }

                for (var i = indexFirst(keys, keyFrom); i < length; i++) {
                  var key = keys[i];

                  if (keyFrom <= key && key <= keyTo) {
                    fn(this.get(key), key);
                  } else if (keyTo < key) {
                    return;
                  }
                }
              }
            }]);

            return NumberMap;
          }();

          exports.NumberMap = NumberMap;
          /***/
        },

        /***/
        "./internal/Rect.js":
        /*!**************************!*\
          !*** ./internal/Rect.js ***!
          \**************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function internalRectJs(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.Rect = void 0;

          var Rect = /*#__PURE__*/function () {
            function Rect(left, top, width, height) {
              _classCallCheck(this, Rect);

              this._left = left;
              this._top = top;
              this._width = width;
              this._height = height;
            }

            _createClass(Rect, [{
              key: "left",
              get: function get() {
                return this._left;
              },
              set: function set(left) {
                var right = this.right;
                this._left = left;
                this.right = right;
              }
            }, {
              key: "top",
              get: function get() {
                return this._top;
              },
              set: function set(top) {
                var bottom = this.bottom;
                this._top = top;
                this.bottom = bottom;
              }
            }, {
              key: "width",
              get: function get() {
                return this._width;
              },
              set: function set(width) {
                this._width = width;
                this._right = undefined;
              }
            }, {
              key: "height",
              get: function get() {
                return this._height;
              },
              set: function set(height) {
                this._height = height;
                this._bottom = undefined;
              }
            }, {
              key: "right",
              get: function get() {
                return this._right !== undefined ? this._right : this._right = this.left + this.width;
              },
              set: function set(right) {
                this._right = right;
                this.width = right - this.left;
              }
            }, {
              key: "bottom",
              get: function get() {
                return this._bottom !== undefined ? this._bottom : this._bottom = this.top + this.height;
              },
              set: function set(bottom) {
                this._bottom = bottom;
                this.height = bottom - this.top;
              }
            }, {
              key: "offsetLeft",
              value: function offsetLeft(offset) {
                this._left += offset;
                this._right = undefined;
              }
            }, {
              key: "offsetTop",
              value: function offsetTop(offset) {
                this._top += offset;
                this._bottom = undefined;
              }
            }, {
              key: "copy",
              value: function copy() {
                return new Rect(this.left, this.top, this.width, this.height);
              }
            }, {
              key: "intersection",
              value: function intersection(rect) {
                var x0 = Math.max(this.left, rect.left);
                var x1 = Math.min(this.left + this.width, rect.left + rect.width);

                if (x0 <= x1) {
                  var y0 = Math.max(this.top, rect.top);
                  var y1 = Math.min(this.top + this.height, rect.top + rect.height);

                  if (y0 <= y1) {
                    return Rect.bounds(x0, y0, x1, y1);
                  }
                }

                return null;
              }
            }, {
              key: "contains",
              value: function contains(another) {
                return this.left <= another.left && this.left + this.width >= another.left + another.width && this.top <= another.top && this.top + this.height >= another.top + another.height;
              }
            }, {
              key: "inPoint",
              value: function inPoint(x, y) {
                return this.left <= x && this.left + this.width >= x && this.top <= y && this.top + this.height >= y;
              }
            }], [{
              key: "bounds",
              value: function bounds(left, top, right, bottom) {
                return new Rect(left, top, right - left, bottom - top);
              }
            }, {
              key: "max",
              value: function max(rect1, rect2) {
                return Rect.bounds(Math.min(rect1.left, rect2.left), Math.min(rect1.top, rect2.top), Math.max(rect1.right, rect2.right), Math.max(rect1.bottom, rect2.bottom));
              }
            }]);

            return Rect;
          }();

          exports.Rect = Rect;
          /***/
        },

        /***/
        "./internal/Scrollable.js":
        /*!********************************!*\
          !*** ./internal/Scrollable.js ***!
          \********************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function internalScrollableJs(module, exports, __nested_webpack_require_870906__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.Scrollable = void 0;

          var style = __importStar(__nested_webpack_require_870906__(
          /*! ./style */
          "./internal/style.js"));

          var EventHandler_1 = __nested_webpack_require_870906__(
          /*! ./EventHandler */
          "./internal/EventHandler.js");

          var utils_1 = __nested_webpack_require_870906__(
          /*! ./utils */
          "./internal/utils.js");

          var MAX_SCROLL = utils_1.browser.heightLimit - 1000;

          var Scrollable = /*#__PURE__*/function () {
            function Scrollable() {
              _classCallCheck(this, Scrollable);

              this._p = 1;
              this._handler = new EventHandler_1.EventHandler();
              this._scrollable = document.createElement("div");

              this._scrollable.classList.add("grid-scrollable");

              this._height = 0;
              this._width = 0;
              this._endPointElement = document.createElement("div");

              this._endPointElement.classList.add("grid-scroll-end-point");

              this._update();

              this._scrollable.appendChild(this._endPointElement); // const mousewheelevt = (/Firefox/i.test(navigator.userAgent)) ? 'DOMMouseScroll' : 'mousewheel'; //FF doesn't recognize mousewheel as of FF3.x
              // this._handler.on(this._scrollable, mousewheelevt, (evt) => {
              // const delta = evt.detail ? evt.detail * (-120) : evt.wheelDelta;
              // const point = Math.min(Math.abs(delta) / 12, this.scrollHeight / 5);
              // this.scrollTop += delta < 0 ? point : -point;
              // });

            }

            _createClass(Scrollable, [{
              key: "calcTop",
              value: function calcTop(top) {
                var relativeTop = top - this.scrollTop;
                return this._scrollable.scrollTop + relativeTop;
              }
            }, {
              key: "getElement",
              value: function getElement() {
                return this._scrollable;
              }
            }, {
              key: "setScrollSize",
              value: function setScrollSize(width, height) {
                this._width = width;
                this._height = height;

                this._update();
              }
            }, {
              key: "scrollWidth",
              get: function get() {
                return this._width;
              },
              set: function set(width) {
                this._width = width;

                this._update();
              }
            }, {
              key: "scrollHeight",
              get: function get() {
                return this._height;
              },
              set: function set(height) {
                this._height = height;

                this._update();
              }
            }, {
              key: "scrollLeft",
              get: function get() {
                return Math.max(Math.ceil(this._scrollable.scrollLeft), 0);
              },
              set: function set(scrollLeft) {
                this._scrollable.scrollLeft = scrollLeft;
              }
            }, {
              key: "scrollTop",
              get: function get() {
                return Math.max(Math.ceil(this._scrollable.scrollTop / this._p), 0);
              },
              set: function set(scrollTop) {
                this._scrollable.scrollTop = scrollTop * this._p;
              }
            }, {
              key: "onScroll",
              value: function onScroll(fn) {
                this._handler.on(this._scrollable, "scroll", fn);
              }
            }, {
              key: "dispose",
              value: function dispose() {
                this._handler.dispose();
              }
            }, {
              key: "_update",
              value: function _update() {
                var domHeight;
                var _this$_scrollable = this._scrollable,
                    offsetHeight = _this$_scrollable.offsetHeight,
                    offsetWidth = _this$_scrollable.offsetWidth;

                if (this._height > MAX_SCROLL) {
                  var sbSize = style.getScrollBarSize();
                  var vScrollRange = MAX_SCROLL - offsetHeight + sbSize;
                  var rScrollRange = this._height - offsetHeight + sbSize;
                  this._p = vScrollRange / rScrollRange;
                  domHeight = MAX_SCROLL;
                } else {
                  this._p = 1;
                  domHeight = this._height;
                }

                this._endPointElement.style.top = "".concat(domHeight.toFixed(), "px");
                this._endPointElement.style.left = "".concat(this._width.toFixed(), "px"); // Sets the maximum value to the scroll position
                // if the current scroll position exceeds the maximum value.

                if (this.scrollTop > this.scrollHeight - offsetHeight) {
                  this.scrollTop = this.scrollHeight - offsetHeight;
                }

                if (this.scrollLeft > this.scrollWidth - offsetWidth) {
                  this.scrollLeft = this.scrollWidth - offsetWidth;
                }
              }
            }]);

            return Scrollable;
          }();

          exports.Scrollable = Scrollable;
          /***/
        },

        /***/
        "./internal/animate.js":
        /*!*****************************!*\
          !*** ./internal/animate.js ***!
          \*****************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function internalAnimateJs(module, exports, __nested_webpack_require_878081__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.animate = void 0;

          var utils_1 = __nested_webpack_require_878081__(
          /*! ./utils */
          "./internal/utils.js");

          function cubicBezier(x2, y2, x3, y3) {
            var step;
            var err = 0.0001;
            x2 *= 3;
            y2 *= 3;
            x3 *= 3;
            y3 *= 3;
            return function (t) {
              var p, a, b, c, d, x, s;

              if (t < 0 || 1 < t) {
                throw new Error("".concat(t));
              }

              p = step || t;

              do {
                a = 1 - p;
                b = a * a;
                c = p * p;
                d = c * p;
                x = x2 * b * p + x3 * a * c + d;
                s = t - x;
                p += s * 0.5;
              } while (err < Math.abs(s));

              step = p;
              return y2 * b * p + y3 * a * c + d;
            };
          }

          var EASINGS = {
            linear: function linear(p) {
              return p;
            },
            easeIn: cubicBezier(0.42, 0.0, 1.0, 1.0),
            easeOut: cubicBezier(0.0, 0.0, 0.58, 1.0),
            easeInOut: cubicBezier(0.42, 0.0, 0.58, 1.0)
          };
          var raf = utils_1.isNode ? function () {} : window.requestAnimationFrame || // eslint-disable-next-line @typescript-eslint/no-explicit-any
          function (fn) {
            return setTimeout(fn, 1);
          };

          function now() {
            return Date.now();
          }
          /**
           * <pre>
           * Animates.
           * </pre>
           * @function
           * @param {number} duration animation time.
           * @param {function} step step
           * @param {function|string} easing easing
           * @returns {object} Deferred object.
           */


          function animate(duration, step, easing) {
            var startedAt = now();
            var easingFn = easing == null ? EASINGS.easeInOut : typeof easing === "string" ? EASINGS[easing] : easing;
            var canceledFlg = false;

            var createAnim = function createAnim(resolve, reject) {
              var anim = function anim() {
                var point = now() - startedAt;

                if (canceledFlg) {
                  //cancel
                  if (reject) {
                    reject();
                  }
                } else if (point >= duration) {
                  //end
                  step(1);

                  if (resolve) {
                    resolve();
                  }
                } else {
                  step(easingFn(point / duration));
                  raf(anim);
                }
              };

              return anim;
            };

            var cancel = function cancel() {
              canceledFlg = true;
            };

            if (typeof Promise !== "undefined") {
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              var result = new Promise(function (resolve, reject) {
                var anim = createAnim(resolve, reject);
                step(0);
                anim();
              });
              result.cancel = cancel;
              return result;
            } else {
              var anim = createAnim(function () {}, function () {});
              step(0);
              anim();
              return {
                cancel: cancel
              };
            }
          }

          exports.animate = animate;
          /***/
        },

        /***/
        "./internal/calc.js":
        /*!**************************!*\
          !*** ./internal/calc.js ***!
          \**************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function internalCalcJs(module, exports, __nested_webpack_require_882068__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.toPx = void 0;

          var utils_1 = __nested_webpack_require_882068__(
          /*! ./utils */
          "./internal/utils.js");

          var TYPE_PAREN = 0;
          var TYPE_UNIT = 1;
          var TYPE_OPERATOR = 2;
          var TYPE_NUMBER = 3;
          var NODE_TYPE_UNIT = 10;
          var NODE_TYPE_BINARY_EXPRESSION = 11;
          var NODE_TYPE_NUMBER = 12;
          var TABULATION = 0x09;
          var CARRIAGE_RETURN = 0x0d;
          var LINE_FEED = 0x0a;
          var FORM_FEED = 0x0c;
          var SPACE = 0x20;
          var PERCENT = 0x25;
          var FULL_STOP = 0x2e;
          var DIGIT_0 = 0x30;
          var DIGIT_9 = 0x39;
          var LATIN_CAPITAL_A = 0x41;
          var LATIN_CAPITAL_Z = 0x5a;
          var LATIN_SMALL_A = 0x61;
          var LATIN_SMALL_Z = 0x7a;

          function isUpperLetter(cp) {
            return cp >= LATIN_CAPITAL_A && cp <= LATIN_CAPITAL_Z;
          }

          function isLowerLetter(cp) {
            return cp >= LATIN_SMALL_A && cp <= LATIN_SMALL_Z;
          }

          function isLetter(cp) {
            return isLowerLetter(cp) || isUpperLetter(cp);
          }

          function isWhitespace(cp) {
            return cp === TABULATION || cp === LINE_FEED || cp === FORM_FEED || cp === CARRIAGE_RETURN || cp === SPACE;
          }

          function isDigit(cp) {
            return cp >= DIGIT_0 && cp <= DIGIT_9;
          }

          function isDot(cp) {
            return cp === FULL_STOP;
          }

          function isUnit(cp) {
            return isLetter(cp) || cp === PERCENT;
          }

          function createError(calc) {
            return new Error("calc parse error: ".concat(calc));
          }
          /**
           * tokenize
           * @param {string} calc calc expression
           * @returns {Array} tokens
           * @private
           */


          function tokenize(calc) {
            var exp = calc.replace(/calc\(/g, "(").trim();
            var tokens = [];
            var len = exp.length;

            for (var index = 0; index < len; index++) {
              var c = exp[index];
              var cp = c.charCodeAt(0);

              if (c === "(" || c === ")") {
                tokens.push({
                  value: c,
                  type: TYPE_PAREN
                });
              } else if (c === "*" || c === "/") {
                tokens.push({
                  value: c,
                  type: TYPE_OPERATOR
                });
              } else if (c === "+" || c === "-") {
                index = parseSign(c, index + 1) - 1;
              } else if (isDigit(cp) || isDot(cp)) {
                index = parseNum(c, index + 1) - 1;
              } else if (isWhitespace(cp)) {// skip
              } else {
                throw createError(calc);
              }
            }

            function parseSign(sign, start) {
              if (start < len) {
                var _c3 = exp[start];

                var _cp = _c3.charCodeAt(0);

                if (isDigit(_cp) || isDot(_cp)) {
                  return parseNum(sign + _c3, start + 1);
                }
              }

              tokens.push({
                value: sign,
                type: TYPE_OPERATOR
              });
              return start;
            }

            function parseNum(num, start) {
              var index = start;

              for (; index < len; index++) {
                var _c4 = exp[index];

                var _cp2 = _c4.charCodeAt(0);

                if (isDigit(_cp2)) {
                  num += _c4;
                } else if (_c4 === ".") {
                  if (num.indexOf(".") >= 0) {
                    throw createError(calc);
                  }

                  num += _c4;
                } else if (isUnit(_cp2)) {
                  return parseUnit(num, _c4, index + 1);
                } else {
                  break;
                }
              }

              if (num === ".") {
                throw createError(calc);
              }

              tokens.push({
                value: parseFloat(num),
                type: TYPE_NUMBER
              });
              return index;
            }

            function parseUnit(num, unit, start) {
              var index = start;

              for (; index < len; index++) {
                var _c5 = exp[index];

                var _cp3 = _c5.charCodeAt(0);

                if (isUnit(_cp3)) {
                  unit += _c5;
                } else {
                  break;
                }
              }

              tokens.push({
                value: parseFloat(num),
                unit: unit,
                type: TYPE_UNIT
              });
              return index;
            }

            return tokens;
          }

          var PRECEDENCE = {
            "*": 3,
            "/": 3,
            "+": 2,
            "-": 2
          };

          function lex(tokens, calc) {
            function buildBinaryExpNode(stack) {
              var right = stack.pop();
              var op = stack.pop();
              var left = stack.pop();

              if (!left || !left.nodeType || !op || op.type !== TYPE_OPERATOR || !right || !right.nodeType) {
                throw createError(calc);
              }

              return {
                nodeType: NODE_TYPE_BINARY_EXPRESSION,
                left: left,
                op: op,
                right: right
              };
            }

            var stack = [];

            while (tokens.length) {
              var token = tokens.shift();

              if (token.type === TYPE_PAREN && token.value === "(") {
                (function () {
                  var deep = 0;
                  var closeIndex = utils_1.array.findIndex(tokens, function (t) {
                    if (t.type === TYPE_PAREN && t.value === "(") {
                      deep++;
                    } else if (t.type === TYPE_PAREN && t.value === ")") {
                      if (!deep) {
                        return true;
                      }

                      deep--;
                    }

                    return false;
                  });

                  if (closeIndex === -1) {
                    throw createError(calc);
                  }

                  stack.push(lex(tokens.splice(0, closeIndex), calc));
                  tokens.shift();
                })();
              } else if (token.type === TYPE_OPERATOR) {
                if (stack.length >= 3) {
                  var beforeOp = stack[stack.length - 2].value;

                  if (PRECEDENCE[token.value] <= PRECEDENCE[beforeOp]) {
                    stack.push(buildBinaryExpNode(stack));
                  }
                }

                stack.push(token);
              } else if (token.type === TYPE_UNIT) {
                var num = token.value,
                    unit = token.unit;
                stack.push({
                  nodeType: NODE_TYPE_UNIT,
                  value: num,
                  unit: unit
                });
              } else if (token.type === TYPE_NUMBER) {
                stack.push({
                  nodeType: NODE_TYPE_NUMBER,
                  value: token.value
                });
              }
            }

            while (stack.length > 1) {
              stack.push(buildBinaryExpNode(stack));
            }

            return stack[0];
          }

          function parse(calcStr) {
            var tokens = tokenize(calcStr);
            return lex(tokens, calcStr);
          }

          function calcNode(node, context) {
            if (node.nodeType === NODE_TYPE_BINARY_EXPRESSION) {
              var left = calcNode(node.left, context);
              var right = calcNode(node.right, context);

              switch (node.op.value) {
                case "+":
                  return left + right;

                case "-":
                  return left - right;

                case "*":
                  return left * right;

                case "/":
                  return left / right;

                default:
                  // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                  throw new Error("calc error. unknown operator: ".concat(node.op.value));
              }
            } else if (node.nodeType === NODE_TYPE_UNIT) {
              switch (node.unit) {
                case "%":
                  return node.value * context.full / 100;

                case "em":
                  return node.value * context.em;

                case "px":
                  return node.value;

                default:
                  throw new Error("calc error. unknown unit: ".concat(node.unit));
              }
            } else if (node.nodeType === NODE_TYPE_NUMBER) {
              return node.value;
            }

            throw new Error("calc error.");
          }

          function toPxInternal(value, context) {
            var ast = parse(value);
            return calcNode(ast, context);
          }

          function toPx(value, context) {
            if (typeof value === "string") {
              return toPxInternal(value.trim(), context);
            }

            return value - 0;
          }

          exports.toPx = toPx;
          /***/
        },

        /***/
        "./internal/canvases.js":
        /*!******************************!*\
          !*** ./internal/canvases.js ***!
          \******************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function internalCanvasesJs(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.calcStartPosition = exports.calcBasePosition = exports.getFontSize = void 0;
          var fontSizeCache = {};

          function getFontSize(ctx, font) {
            var fontName = font || ctx.font;

            if (fontSizeCache[fontName]) {
              return fontSizeCache[fontName];
            }

            var bk = ctx.font;

            try {
              ctx.font = fontName;
              var em = ctx.measureText("").width;
              return fontSizeCache[fontName] = {
                width: em,
                height: em
              };
            } finally {
              ctx.font = bk;
            }
          }

          exports.getFontSize = getFontSize;

          function calcBasePosition(ctx, rect) {
            var _ref78 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
                _ref78$offset = _ref78.offset,
                offset = _ref78$offset === void 0 ? 0 : _ref78$offset,
                _ref78$padding = _ref78.padding;

            _ref78$padding = _ref78$padding === void 0 ? {} : _ref78$padding;
            var _ref78$padding$left = _ref78$padding.left,
                paddingLeft = _ref78$padding$left === void 0 ? 0 : _ref78$padding$left,
                _ref78$padding$right = _ref78$padding.right,
                paddingRight = _ref78$padding$right === void 0 ? 0 : _ref78$padding$right,
                _ref78$padding$top = _ref78$padding.top,
                paddingTop = _ref78$padding$top === void 0 ? 0 : _ref78$padding$top,
                _ref78$padding$bottom = _ref78$padding.bottom,
                paddingBottom = _ref78$padding$bottom === void 0 ? 0 : _ref78$padding$bottom;
            return calcStartPosition(ctx, rect, 0, 0, {
              offset: offset,
              padding: {
                left: paddingLeft,
                right: paddingRight,
                top: paddingTop,
                bottom: paddingBottom
              }
            });
          }

          exports.calcBasePosition = calcBasePosition;

          function calcStartPosition(ctx, rect, width, height) {
            var _ref79 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {},
                _ref79$offset = _ref79.offset,
                offset = _ref79$offset === void 0 ? 0 : _ref79$offset,
                _ref79$padding = _ref79.padding;

            _ref79$padding = _ref79$padding === void 0 ? {} : _ref79$padding;
            var _ref79$padding$left = _ref79$padding.left,
                paddingLeft = _ref79$padding$left === void 0 ? 0 : _ref79$padding$left,
                _ref79$padding$right = _ref79$padding.right,
                paddingRight = _ref79$padding$right === void 0 ? 0 : _ref79$padding$right,
                _ref79$padding$top = _ref79$padding.top,
                paddingTop = _ref79$padding$top === void 0 ? 0 : _ref79$padding$top,
                _ref79$padding$bottom = _ref79$padding.bottom,
                paddingBottom = _ref79$padding$bottom === void 0 ? 0 : _ref79$padding$bottom;
            var textAlign = ctx.textAlign || "left";
            var textBaseline = ctx.textBaseline || "middle";
            ctx.textAlign = textAlign;
            ctx.textBaseline = textBaseline;
            var x = rect.left + offset + paddingLeft;

            if (textAlign === "right" || textAlign === "end") {
              x = rect.right - width - offset - paddingRight;
            } else if (textAlign === "center") {
              x = rect.left + (rect.width - width + paddingLeft - paddingRight) / 2;
            }

            var y = rect.top + offset + paddingTop;

            if (textBaseline === "bottom" || textBaseline === "alphabetic" || textBaseline === "ideographic") {
              y = rect.bottom - height - offset - paddingBottom;
            } else if (textBaseline === "middle") {
              y = rect.top + (rect.height - height + paddingTop - paddingBottom) / 2;
            }

            return {
              x: x,
              y: y
            };
          }

          exports.calcStartPosition = calcStartPosition;
          /***/
        },

        /***/
        "./internal/color.js":
        /*!***************************!*\
          !*** ./internal/color.js ***!
          \***************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function internalColorJs(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.colorToRGB = void 0;
          var rgbMap = {};

          function styleColorToRGB(color) {
            var dummy = document.createElement("div");
            var style = dummy.style;
            style.color = color;
            style.position = "fixed";
            style.height = "1px";
            style.width = "1px";
            style.opacity = "0";
            document.body.appendChild(dummy);

            var _getComputedStyle = (document.defaultView || window).getComputedStyle(dummy, ""),
                styleColor = _getComputedStyle.color;

            document.body.removeChild(dummy);
            return colorToRGB0(styleColor || "");
          }

          function hexToNum(hex) {
            return parseInt(hex, 16);
          }

          function createRGB(r, g, b) {
            var a = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
            return {
              r: r,
              g: g,
              b: b,
              a: a
            };
          }

          function tripleHexToRGB(_ref80) {
            var r = _ref80[1],
                g = _ref80[2],
                b = _ref80[3];
            return createRGB(hexToNum(r + r), hexToNum(g + g), hexToNum(b + b));
          }

          function sextupleHexToRGB(_ref81) {
            var r1 = _ref81[1],
                r2 = _ref81[2],
                g1 = _ref81[3],
                g2 = _ref81[4],
                b1 = _ref81[5],
                b2 = _ref81[6];
            return createRGB(hexToNum(r1 + r2), hexToNum(g1 + g2), hexToNum(b1 + b2));
          }

          function testRGB(_ref82) {
            var r = _ref82.r,
                g = _ref82.g,
                b = _ref82.b,
                a = _ref82.a;
            return 0 <= r && r <= 255 && 0 <= g && g <= 255 && 0 <= b && b <= 255 && 0 <= a && a <= 1;
          }

          function rateToByte(r) {
            return Math.ceil(r * 255 / 100);
          }

          var numberPattern = /((?:\+|-)?(?:\d+(?:\.\d+)?|\.\d+))/.source;
          var percentPattern = "".concat(numberPattern, "%");
          var maybePercentPattern = "".concat(numberPattern, "(%?)");

          function buildRgbWithCommaRegExp(bytePattern) {
            return new RegExp("^rgba?\\(\\s*".concat(bytePattern, "\\s*,\\s*").concat(bytePattern, "\\s*,\\s*").concat(bytePattern, "\\s*\\)$"), "i");
          }

          function buildRgbLv4RegExp(bytePattern) {
            return new RegExp("^rgba?\\(\\s*".concat(bytePattern, "\\s+").concat(bytePattern, "\\s+").concat(bytePattern, "\\s*\\)$"), "i");
          }

          function buildRgbaWithCommaRegExp(bytePattern, alphaPattern) {
            return new RegExp("^rgba?\\(\\s*".concat(bytePattern, "\\s*,\\s*").concat(bytePattern, "\\s*,\\s*").concat(bytePattern, "\\s*,\\s*").concat(alphaPattern, "\\s*\\)$"), "i");
          }

          function buildRgbaLv4RegExp(bytePattern, alphaPattern) {
            return new RegExp("^rgba?\\(\\s*".concat(bytePattern, "\\s+").concat(bytePattern, "\\s+").concat(bytePattern, "\\s*/\\s*").concat(alphaPattern, "\\s*\\)$"), "i");
          }

          function colorToRGB0(color) {
            if (/^#[0-9a-f]{3}$/i.exec(color)) {
              return tripleHexToRGB(color);
            }

            if (/^#[0-9a-f]{6}$/i.exec(color)) {
              return sextupleHexToRGB(color);
            }

            var ret = buildRgbWithCommaRegExp(numberPattern).exec(color) || buildRgbLv4RegExp(numberPattern).exec(color);

            if (ret) {
              var rgb = createRGB(Number(ret[1]), Number(ret[2]), Number(ret[3]));

              if (testRGB(rgb)) {
                return rgb;
              }
            }

            ret = buildRgbWithCommaRegExp(percentPattern).exec(color) || buildRgbLv4RegExp(percentPattern).exec(color);

            if (ret) {
              var _rgb = createRGB(rateToByte(Number(ret[1])), rateToByte(Number(ret[2])), rateToByte(Number(ret[3])));

              if (testRGB(_rgb)) {
                return _rgb;
              }
            }

            ret = buildRgbaWithCommaRegExp(numberPattern, maybePercentPattern).exec(color) || buildRgbaLv4RegExp(numberPattern, maybePercentPattern).exec(color);

            if (ret) {
              var _rgb2 = createRGB(Number(ret[1]), Number(ret[2]), Number(ret[3]), Number(ret[4]) / (ret[5]
              /* % */
              ? 100 : 1));

              if (testRGB(_rgb2)) {
                return _rgb2;
              }
            }

            ret = buildRgbaWithCommaRegExp(percentPattern, maybePercentPattern).exec(color) || buildRgbaLv4RegExp(percentPattern, maybePercentPattern).exec(color);

            if (ret) {
              var _rgb3 = createRGB(rateToByte(Number(ret[1])), rateToByte(Number(ret[2])), rateToByte(Number(ret[3])), Number(ret[4]) / (ret[5]
              /* % */
              ? 100 : 1));

              if (testRGB(_rgb3)) {
                return _rgb3;
              }
            }

            return null;
          }

          function colorToRGB(color) {
            if (typeof color !== "string") {
              return createRGB(0, 0, 0, 0);
            }

            color = color.toLowerCase().trim();

            if (rgbMap[color]) {
              return rgbMap[color];
            }

            return colorToRGB0(color) || (rgbMap[color] = styleColorToRGB(color));
          }

          exports.colorToRGB = colorToRGB;
          /***/
        },

        /***/
        "./internal/dom.js":
        /*!*************************!*\
          !*** ./internal/dom.js ***!
          \*************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function internalDomJs(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.findNextSiblingFocusable = exports.findPrevSiblingFocusable = exports.isFocusable = exports.enableFocus = exports.disableFocus = exports.appendHtml = exports.toNodeList = exports.empty = exports.createElement = void 0;

          function createElement(tagName) {
            var _ref83 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
                classList = _ref83.classList,
                text = _ref83.text,
                html = _ref83.html;

            var element = document.createElement(tagName);

            if (classList) {
              if (Array.isArray(classList)) {
                var _element$classList;

                (_element$classList = element.classList).add.apply(_element$classList, _toConsumableArray(classList));
              } else {
                element.classList.add(classList);
              }
            }

            if (text) {
              element.textContent = text;
            } else if (html) {
              element.innerHTML = html;
            }

            return element;
          }

          exports.createElement = createElement;

          function empty(dom) {
            var c;

            while (c = dom.firstChild) {
              dom.removeChild(c);
            }
          }

          exports.empty = empty;

          function isNode(arg) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            return !!(arg.nodeType && arg.nodeName);
          }

          function toNode(arg) {
            if (isNode(arg)) {
              return arg;
            }

            var dom = createElement("div", {
              html: arg
            });
            return Array.prototype.slice.call(dom.childNodes);
          }

          function toNodeList(arg) {
            if (Array.isArray(arg)) {
              var result = [];
              arg.forEach(function (e) {
                result.push.apply(result, _toConsumableArray(toNodeList(e)));
              });
              return result;
            }

            var node = toNode(arg);
            return Array.isArray(node) ? node : [node];
          }

          exports.toNodeList = toNodeList;

          function appendHtml(dom, inner) {
            toNodeList(inner).forEach(function (node) {
              dom.appendChild(node);
            });
          }

          exports.appendHtml = appendHtml;

          function disableFocus(el) {
            el.dataset.disableBeforeTabIndex = "".concat(el.tabIndex);
            el.tabIndex = -1;
            Array.prototype.slice.call(el.children, 0).forEach(disableFocus);
          }

          exports.disableFocus = disableFocus;

          function enableFocus(el) {
            if ("disableBeforeTabIndex" in el.dataset) {
              el.tabIndex = Number(el.dataset.disableBeforeTabIndex);
            }

            Array.prototype.slice.call(el.children, 0).forEach(enableFocus);
          }

          exports.enableFocus = enableFocus;

          function isFocusable(el) {
            return el.tabIndex != null && el.tabIndex > -1;
          }

          exports.isFocusable = isFocusable;

          function findPrevSiblingFocusable(el) {
            var n = el.previousSibling;

            while (n && !isFocusable(n)) {
              n = n.previousSibling;
            }

            return n;
          }

          exports.findPrevSiblingFocusable = findPrevSiblingFocusable;

          function findNextSiblingFocusable(el) {
            var n = el.nextSibling;

            while (n && !isFocusable(n)) {
              n = n.nextSibling;
            }

            return n;
          }

          exports.findNextSiblingFocusable = findNextSiblingFocusable;
          /***/
        },

        /***/
        "./internal/fonts.js":
        /*!***************************!*\
          !*** ./internal/fonts.js ***!
          \***************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function internalFontsJs(module, exports, __nested_webpack_require_906781__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.load = exports.check = void 0;

          var utils_1 = __nested_webpack_require_906781__(
          /*! ./utils */
          "./internal/utils.js");

          var loads = {};
          var load;
          exports.load = load;
          var check;
          exports.check = check;

          if (utils_1.isNode) {
            exports.load = load = function load(_font, _testStr, callback) {
              callback();
            };

            exports.check = check = function check() {
              return false;
            };
          } else {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            var fontFaceSet = document.fonts;
            var legacy = !fontFaceSet;
            exports.load = load = legacy ? function (font, testStr, callback) {
              //for legacy(IE)
              if (loads["".concat(font, " @ ").concat(testStr)]) {
                callback();
                return;
              } // eslint-disable-next-line @typescript-eslint/no-var-requires


              __nested_webpack_require_906781__(
              /*! ./legacy/fontwatch/FontWatchRunner */
              "./internal/legacy/fontwatch/FontWatchRunner.js").load(font, testStr, function () {
                loads["".concat(font, " @ ").concat(testStr)] = true;
                callback();
              }, function () {
                loads["".concat(font, " @ ").concat(testStr)] = true;
                callback();
              });
            } : function (font, _testStr, callback) {
              if (loads.all || loads[font]) {
                callback();
                return;
              }

              fontFaceSet.ready.then(function () {
                loads.all = true;
              });
              fontFaceSet.load(font).then(function () {
                loads[font] = true;
                callback();
              });
            };
            exports.check = check = legacy ? function (font, testStr) {
              //for legacy(IE)
              if (loads["".concat(font, " @ ").concat(testStr)]) {
                return true;
              }

              load(font, testStr, function () {});
              return false;
            } : function (font, testStr) {
              if (loads.all || loads[font]) {
                return true;
              }

              if (!fontFaceSet.check(font)) {
                load(font, testStr, function () {});
                return false;
              }

              return true;
            };
          }
          /***/

        },

        /***/
        "./internal/hiDPI.js":
        /*!***************************!*\
          !*** ./internal/hiDPI.js ***!
          \***************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function internalHiDPIJs(module, exports, __nested_webpack_require_909820__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.transform = void 0;

          var EventHandler_1 = __nested_webpack_require_909820__(
          /*! ./EventHandler */
          "./internal/EventHandler.js");

          var utils_1 = __nested_webpack_require_909820__(
          /*! ./utils */
          "./internal/utils.js");

          var handler = new EventHandler_1.EventHandler();
          var ratio = 1;

          function setRatio() {
            if (utils_1.isNode) {
              ratio = 1;
            } else {
              ratio = Math.ceil(window.devicePixelRatio || 1);

              if (ratio > 1 && ratio % 2 !== 0) {
                ratio += 1;
              }
            }
          }

          setRatio();

          if (!utils_1.isNode) {
            handler.on(window, "resize", setRatio);
          }

          function transform(canvas) {
            var ctx = canvas.getContext("2d");
            var getAttribute = canvas.getAttribute,
                setAttribute = canvas.setAttribute;

            canvas.getAttribute = function (name) {
              var result = getAttribute.call(this, name);

              if (name === "width" || name === "height") {
                result = "".concat(Number(result) / ratio);
              }

              return result;
            };

            canvas.setAttribute = function (name, val) {
              var wh = name === "width" || name === "height";

              if (wh) {
                val = "".concat(Number(val) * ratio);
              }

              var result = setAttribute.call(this, name, val);

              if (wh) {
                ctx.scale(ratio, ratio);
              }

              return result;
            };

            Object.defineProperty(canvas, "width", {
              get: function get() {
                return Number(canvas.getAttribute("width"));
              },
              set: function set(val) {
                canvas.setAttribute("width", "".concat(Math.floor(val)));
              },
              configurable: true,
              enumerable: true
            });
            Object.defineProperty(canvas, "height", {
              get: function get() {
                return Number(canvas.getAttribute("height"));
              },
              set: function set(val) {
                canvas.setAttribute("height", "".concat(Math.floor(val)));
              },
              configurable: true,
              enumerable: true
            });
            var drawImage = ctx.drawImage; // eslint-disable-next-line @typescript-eslint/no-explicit-any

            ctx.drawImage = function (img) {
              for (var _len10 = arguments.length, args = new Array(_len10 > 1 ? _len10 - 1 : 0), _key10 = 1; _key10 < _len10; _key10++) {
                args[_key10 - 1] = arguments[_key10];
              }

              if (img !== canvas || ratio === 1) {
                return drawImage.call.apply(drawImage, [this, img].concat(args));
              }

              this.save();

              try {
                this.scale(1 / ratio, 1 / ratio);

                if (args.length > 4) {
                  args[4] *= ratio;
                  args[5] *= ratio;
                } else {
                  args[0] *= ratio;
                  args[1] *= ratio;
                }

                return drawImage.call.apply(drawImage, [this, img].concat(args));
              } finally {
                this.restore();
              }
            };

            return canvas;
          }

          exports.transform = transform;
          /***/
        },

        /***/
        "./internal/icons.js":
        /*!***************************!*\
          !*** ./internal/icons.js ***!
          \***************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function internalIconsJs(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.iconPropKeys = exports.toNormalizeArray = exports.getIconProps = void 0;
          var ICON_PROP_KEYS = ["content", "font", "color", "className", "tagName", "isLiga", "width", "src", "svg", "name", "path", "offsetTop", "offsetLeft"];

          function quote(name) {
            var quoted = [];
            var split = name.split(/,\s*/);

            for (var i = 0; i < split.length; i++) {
              var part = split[i].replace(/['"]/g, "");

              if (part.indexOf(" ") === -1 && !/^\d/.test(part)) {
                quoted.push(part);
              } else {
                quoted.push("'".concat(part, "'"));
              }
            }

            return quoted.join(",");
          }

          var doms = {};
          var props = {};

          function getIconProps(tagName, className) {
            var tagProps = props[tagName] || (props[tagName] = {});

            if (tagProps[className]) {
              return tagProps[className];
            }

            var dom = doms[tagName] || (doms[tagName] = document.createElement(tagName)); // `classList.add()` cannot be used because it may be separated by spaces.

            dom.className = className;
            dom.classList.add("cheetah-grid-icon");
            document.body.appendChild(dom);

            try {
              var beforeStyle = (document.defaultView || window).getComputedStyle(dom, "::before");
              var content = beforeStyle.getPropertyValue("content");

              if (content.length >= 3 && (content[0] === '"' || content[0] === "'")) {
                if (content[0] === content[content.length - 1]) {
                  content = content.slice(1, -1);
                }
              }

              var font = beforeStyle.getPropertyValue("font");

              if (!font) {
                font = "".concat(beforeStyle.getPropertyValue("font-style"), " ").concat(beforeStyle.getPropertyValue("font-variant"), " ").concat(beforeStyle.getPropertyValue("font-weight"), " ").concat(beforeStyle.getPropertyValue("font-size"), "/").concat(beforeStyle.getPropertyValue("line-height"), " ").concat(quote(beforeStyle.getPropertyValue("font-family")));
              }

              var color = beforeStyle.getPropertyValue("color");
              var width = dom.clientWidth;
              var isLiga = (beforeStyle.getPropertyValue("font-feature-settings") || "").indexOf("liga") > -1;
              return tagProps[className] = {
                content: content,
                font: font,
                color: color,
                width: width,
                isLiga: isLiga
              };
            } finally {
              document.body.removeChild(dom);
            }
          }

          exports.getIconProps = getIconProps;

          function toPropArray(prop, count) {
            var result = [];

            if (Array.isArray(prop)) {
              result.push.apply(result, _toConsumableArray(prop));

              for (var i = prop.length; i < count; i++) {
                result.push(null);
              }
            } else {
              for (var _i3 = 0; _i3 < count; _i3++) {
                result.push(prop);
              }
            }

            return result;
          }

          function toSimpleArray(iconProps) {
            if (!iconProps) {
              return iconProps;
            } else if (Array.isArray(iconProps)) {
              return iconProps;
            }

            var workData = {};
            var count = 0;
            ICON_PROP_KEYS.forEach(function (k) {
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              var prop = iconProps[k];

              if (prop) {
                if (Array.isArray(prop)) {
                  count = Math.max(count, prop.length);
                } else {
                  count = Math.max(count, 1);
                }
              }
            });
            ICON_PROP_KEYS.forEach(function (k) {
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              var arr = toPropArray(iconProps[k], count); // eslint-disable-next-line @typescript-eslint/no-explicit-any

              workData[k] = arr;
            });
            var result = [];

            var _loop6 = function _loop6(i) {
              var data = {};
              ICON_PROP_KEYS.forEach(function (k) {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                var val = workData[k][i]; // eslint-disable-next-line @typescript-eslint/no-explicit-any

                data[k] = val;
              });
              result.push(data);
            };

            for (var i = 0; i < count; i++) {
              _loop6(i);
            }

            return result;
          }

          function normalize(iconProps) {
            var data = {};

            for (var k in iconProps) {
              if (k === "className") {
                continue;
              }

              if (isIconKey(k)) {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                data[k] = iconProps[k];
              }
            }

            if (iconProps.className) {
              var prop = getIconProps(iconProps.tagName || "i", iconProps.className);

              for (var _k2 in prop) {
                if (isIconKey(_k2)) {
                  if (iconProps[_k2] == null) {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    data[_k2] = prop[_k2];
                  }
                }
              }
            }

            return data;
          }

          function toNormalizeArray(iconProps) {
            var icons = toSimpleArray(iconProps);

            if (!icons) {
              return icons;
            }

            return icons.map(function (icon) {
              return normalize(icon);
            });
          }

          exports.toNormalizeArray = toNormalizeArray;
          exports.iconPropKeys = ICON_PROP_KEYS;

          function isIconKey(k) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            return ICON_PROP_KEYS.indexOf(k) >= 0;
          }
          /***/

        },

        /***/
        "./internal/imgs.js":
        /*!**************************!*\
          !*** ./internal/imgs.js ***!
          \**************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function internalImgsJs(module, exports, __nested_webpack_require_920588__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.getCacheOrLoad = exports.loadImage = void 0;

          var LRUCache_1 = __nested_webpack_require_920588__(
          /*! ./LRUCache */
          "./internal/LRUCache.js");

          var utils_1 = __nested_webpack_require_920588__(
          /*! ./utils */
          "./internal/utils.js");

          var allCache = {};

          function loadImage(src) {
            if (typeof Promise === "undefined") {
              console.error("Promise is not loaded. load Promise before this process.");
              return {
                then: function then() {
                  return this;
                } // eslint-disable-next-line @typescript-eslint/no-explicit-any

              };
            }

            var img = new Image();
            var result = new Promise(function (resolve) {
              img.onload = function () {
                resolve(img);
              };
            });

            img.onerror = function () {
              var url = src.length > 200 ? "".concat(src.slice(0, 200), "...") : src;
              console.warn("cannot load: ".concat(url));
              throw new Error("IMAGE LOAD ERROR: ".concat(url));
            };

            img.src = src;
            return result;
          }

          exports.loadImage = loadImage;

          function getCacheOrLoad0(cache, src) {
            return (0, utils_1.then)(src, function (src) {
              var c = cache.get(src);

              if (c) {
                return c;
              }

              var result = loadImage(src).then(function (img) {
                cache.put(src, img);
                return img;
              });
              cache.put(src, result);
              return result;
            });
          }

          function getCacheOrLoad(cacheName, cacheSize, src) {
            var cache = allCache[cacheName] || (allCache[cacheName] = new LRUCache_1.LRUCache(cacheSize));
            return getCacheOrLoad0(cache, src);
          }

          exports.getCacheOrLoad = getCacheOrLoad;
          /***/
        },

        /***/
        "./internal/legacy/canvas/Path2DShim.js":
        /*!**********************************************!*\
          !*** ./internal/legacy/canvas/Path2DShim.js ***!
          \**********************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function internalLegacyCanvasPath2DShimJs(module, exports, __nested_webpack_require_923209__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.Path2DShim = void 0;

          var PathCommandsParser_1 = __nested_webpack_require_923209__(
          /*! ./PathCommandsParser */
          "./internal/legacy/canvas/PathCommandsParser.js");

          var parser = new PathCommandsParser_1.PathCommandsParser();

          var Path2DShim = /*#__PURE__*/function () {
            function Path2DShim(arg) {
              _classCallCheck(this, Path2DShim);

              this._ops = [];

              if (arg === undefined) {
                return;
              }

              if (typeof arg === "string") {
                // try {
                this._ops = parser.parse(arg); // } catch (e) {
                // 	throw e;
                // }
              } else if (arg.hasOwnProperty("_ops")) {
                this._ops = _toConsumableArray(arg._ops);
              } else {
                throw new Error("Error: ".concat(_typeof(arg), " is not a valid argument to Path"));
              }
            }

            _createClass(Path2DShim, [{
              key: "arc",
              value: function arc() {
                for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
                  args[_key11] = arguments[_key11];
                }

                this._ops.push({
                  op: "arc",
                  args: args
                });
              }
            }, {
              key: "arcTo",
              value: function arcTo() {
                for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
                  args[_key12] = arguments[_key12];
                }

                this._ops.push({
                  op: "arcTo",
                  args: args
                });
              }
            }, {
              key: "bezierCurveTo",
              value: function bezierCurveTo() {
                for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {
                  args[_key13] = arguments[_key13];
                }

                this._ops.push({
                  op: "bezierCurveTo",
                  args: args
                });
              }
            }, {
              key: "closePath",
              value: function closePath() {
                for (var _len14 = arguments.length, args = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {
                  args[_key14] = arguments[_key14];
                }

                this._ops.push({
                  op: "closePath",
                  args: args
                });
              }
            }, {
              key: "ellipse",
              value: function ellipse() {
                for (var _len15 = arguments.length, args = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {
                  args[_key15] = arguments[_key15];
                }

                this._ops.push({
                  op: "ellipse",
                  args: args
                });
              }
            }, {
              key: "lineTo",
              value: function lineTo() {
                for (var _len16 = arguments.length, args = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {
                  args[_key16] = arguments[_key16];
                }

                this._ops.push({
                  op: "lineTo",
                  args: args
                });
              }
            }, {
              key: "moveTo",
              value: function moveTo() {
                for (var _len17 = arguments.length, args = new Array(_len17), _key17 = 0; _key17 < _len17; _key17++) {
                  args[_key17] = arguments[_key17];
                }

                this._ops.push({
                  op: "moveTo",
                  args: args
                });
              }
            }, {
              key: "quadraticCurveTo",
              value: function quadraticCurveTo() {
                for (var _len18 = arguments.length, args = new Array(_len18), _key18 = 0; _key18 < _len18; _key18++) {
                  args[_key18] = arguments[_key18];
                }

                this._ops.push({
                  op: "quadraticCurveTo",
                  args: args
                });
              }
            }, {
              key: "rect",
              value: function rect() {
                for (var _len19 = arguments.length, args = new Array(_len19), _key19 = 0; _key19 < _len19; _key19++) {
                  args[_key19] = arguments[_key19];
                }

                this._ops.push({
                  op: "rect",
                  args: args
                });
              }
            }, {
              key: "roundRect",
              value: function roundRect(_x, _y, _w, _h, _radii) {
                throw new Error("Method not implemented.");
              }
            }]);

            return Path2DShim;
          }();

          exports.Path2DShim = Path2DShim;
          var CanvasRenderingContext2D = window.CanvasRenderingContext2D;
          var originalFill = CanvasRenderingContext2D.prototype.fill; // eslint-disable-next-line @typescript-eslint/no-explicit-any

          CanvasRenderingContext2D.prototype.fill = function () {
            var _this102 = this;

            for (var _len20 = arguments.length, args = new Array(_len20), _key20 = 0; _key20 < _len20; _key20++) {
              args[_key20] = arguments[_key20];
            }

            if (args[0] instanceof Path2DShim) {
              var path = args[0];
              this.beginPath();

              path._ops.forEach(function (op) {
                var fn = _this102[op.op];
                fn.apply(_this102, op.args);
              });

              originalFill.apply(this, Array.prototype.slice.call(args, 1));
            } else {
              originalFill.apply(this, args);
            }
          };
          /***/

        },

        /***/
        "./internal/legacy/canvas/PathCommands.js":
        /*!************************************************!*\
          !*** ./internal/legacy/canvas/PathCommands.js ***!
          \************************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function internalLegacyCanvasPathCommandsJs(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.PathCommands = void 0;
          /*eslint new-cap: "off"*/

          function mag(v) {
            return Math.sqrt(Math.pow(v[0], 2) + Math.pow(v[1], 2));
          }

          function dot(u, v) {
            return u[0] * v[0] + u[1] * v[1];
          }

          function ratio(u, v) {
            return dot(u, v) / (mag(u) * mag(v));
          }

          function clamp(value, min, max) {
            return Math.min(Math.max(value, min), max);
          }

          function angle(u, v) {
            var sign = 1.0;

            if (u[0] * v[1] - u[1] * v[0] < 0) {
              sign = -1.0;
            }

            return sign * Math.acos(clamp(ratio(u, v), -1, 1));
          }

          function rotClockwise(v, angle) {
            var cost = Math.cos(angle);
            var sint = Math.sin(angle);
            return [cost * v[0] + sint * v[1], -1 * sint * v[0] + cost * v[1]];
          }

          function rotCounterClockwise(v, angle) {
            var cost = Math.cos(angle);
            var sint = Math.sin(angle);
            return [cost * v[0] - sint * v[1], sint * v[0] + cost * v[1]];
          }

          function midPoint(u, v) {
            return [(u[0] - v[0]) / 2.0, (u[1] - v[1]) / 2.0];
          }

          function meanVec(u, v) {
            return [(u[0] + v[0]) / 2.0, (u[1] + v[1]) / 2.0];
          }

          function pointMul(u, v) {
            return [u[0] * v[0], u[1] * v[1]];
          }

          function scale(c, v) {
            return [c * v[0], c * v[1]];
          }

          function sum(u, v) {
            return [u[0] + v[0], u[1] + v[1]];
          } // Convert an SVG elliptical arc to a series of canvas commands.
          //
          // x1, y1, x2, y2: start and stop coordinates of the ellipse.
          // rx, ry: radii of the ellipse.
          // phi: rotation of the ellipse.
          // fA: large arc flag.
          // fS: sweep flag.


          function ellipseFromEllipticalArc(ctx, x1, y1, rx, ry, phi, fA, fS, x2, y2) {
            // Convert from endpoint to center parametrization, as detailed in:
            //   http://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes
            if (rx === 0 || ry === 0) {
              ctx.lineTo(x2, x1);
              return;
            }

            phi *= Math.PI / 180.0;
            rx = Math.abs(rx);
            ry = Math.abs(ry);
            var xPrime = rotClockwise(midPoint([x1, y1], [x2, y2]), phi); // F.6.5.1

            var xPrime2 = pointMul(xPrime, xPrime);
            var rx2 = Math.pow(rx, 2);
            var ry2 = Math.pow(ry, 2);
            var lambda = Math.sqrt(xPrime2[0] / rx2 + xPrime2[1] / ry2);

            if (lambda > 1) {
              rx *= lambda;
              ry *= lambda;
              rx2 = Math.pow(rx, 2);
              ry2 = Math.pow(ry, 2);
            }

            var factor = Math.sqrt(Math.abs(rx2 * ry2 - rx2 * xPrime2[1] - ry2 * xPrime2[0]) / (rx2 * xPrime2[1] + ry2 * xPrime2[0]));

            if (fA === fS) {
              factor *= -1.0;
            }

            var cPrime = scale(factor, [rx * xPrime[1] / ry, -ry * xPrime[0] / rx]); // F.6.5.2

            var c = sum(rotCounterClockwise(cPrime, phi), meanVec([x1, y1], [x2, y2])); // F.6.5.3

            var x1UnitVector = [(xPrime[0] - cPrime[0]) / rx, (xPrime[1] - cPrime[1]) / ry];
            var x2UnitVector = [(-1.0 * xPrime[0] - cPrime[0]) / rx, (-1.0 * xPrime[1] - cPrime[1]) / ry];
            var theta = angle([1, 0], x1UnitVector); // F.6.5.5

            var deltaTheta = angle(x1UnitVector, x2UnitVector); // F.6.5.6

            var start = theta;
            var end = theta + deltaTheta;
            ctx.save();
            ctx.translate(c[0], c[1]);
            ctx.rotate(phi);
            ctx.scale(rx, ry);
            ctx.arc(0, 0, 1, start, end, !fS);
            ctx.restore();
          }

          var PathCommands = function PathCommands(ctx) {
            var _this103 = this;

            _classCallCheck(this, PathCommands);

            var lMx;
            var lMy;
            var lx = 0;
            var ly = 0;
            var reflected;
            var lastCommand = "";

            function makeReflected() {
              if ("CcSsQqTt".indexOf(lastCommand) < 0) {
                return {
                  x: lx,
                  y: ly
                };
              }

              return reflected;
            }

            this.M = function (px, py) {
              ctx.moveTo(px, py);
              lMx = px;
              lMy = py;
              lx = px;
              ly = py;
              lastCommand = "M";
              return _this103;
            };

            this.m = function (px, py) {
              return _this103.M(px + lx, py + ly);
            };

            this.L = function (px, py) {
              ctx.lineTo(px, py);
              lx = px;
              ly = py;
              lastCommand = "L";
              return _this103;
            };

            this.l = function (px, py) {
              return _this103.L(px + lx, py + ly);
            };

            this.H = function (px) {
              return _this103.L(px, ly);
            };

            this.h = function (px) {
              return _this103.H(px + lx);
            };

            this.V = function (py) {
              return _this103.L(lx, py);
            };

            this.v = function (py) {
              return _this103.V(py + ly);
            };

            this.Z = function () {
              ctx.closePath();
              lx = lMx;
              ly = lMy;
              lastCommand = "Z";
              return _this103;
            };

            this.z = function () {
              return _this103.Z();
            }; //C x1 y1, x2 y2, x y (or c dx1 dy1, dx2 dy2, dx dy)


            this.C = function (cp1x, cp1y, cp2x, cp2y, px, py) {
              ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, px, py);
              lx = px;
              ly = py;
              reflected = {
                x: 2 * px - cp2x,
                y: 2 * py - cp2y
              };
              lastCommand = "C";
              return _this103;
            };

            this.c = function (cp1x, cp1y, cp2x, cp2y, px, py) {
              return _this103.C(cp1x + lx, cp1y + ly, cp2x + lx, cp2y + ly, px + lx, py + ly);
            }; //S x2 y2, x y (or s dx2 dy2, dx dy)


            this.S = function (cpx, cpy, px, py) {
              var _makeReflected = makeReflected(),
                  cp1x = _makeReflected.x,
                  cp1y = _makeReflected.y;

              return _this103.C(cp1x, cp1y, cpx, cpy, px, py);
            };

            this.s = function (cpx, cpy, px, py) {
              return _this103.S(cpx + lx, cpy + ly, px + lx, py + ly);
            }; //Q x1 y1, x y (or q dx1 dy1, dx dy)


            this.Q = function (cpx, cpy, px, py) {
              ctx.quadraticCurveTo(cpx, cpy, px, py);
              lx = px;
              ly = py;
              reflected = {
                x: 2 * px - cpx,
                y: 2 * py - cpy
              };
              lastCommand = "Q";
              return _this103;
            };

            this.q = function (cpx, cpy, px, py) {
              return _this103.Q(cpx + lx, cpy + ly, px + lx, py + ly);
            }; //T x y (or t dx dy)


            this.T = function (px, py) {
              var _makeReflected2 = makeReflected(),
                  cpx = _makeReflected2.x,
                  cpy = _makeReflected2.y;

              return _this103.Q(cpx, cpy, px, py);
            };

            this.t = function (px, py) {
              return _this103.T(px + lx, py + ly);
            }; //A rx ry x-axis-rotation large-arc-flag sweep-flag x y


            this.A = function (rx, ry, xAxisRotation, largeArcFlag, sweepFlag, px, py) {
              var x1 = lx;
              var y1 = ly;
              ellipseFromEllipticalArc(ctx, x1, y1, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, px, py);
              lx = px;
              ly = py;
              lastCommand = "A";
              return _this103;
            }; //a rx ry x-axis-rotation large-arc-flag sweep-flag dx dy


            this.a = function (rx, ry, xAxisRotation, largeArcFlag, sweepFlag, px, py) {
              return _this103.A(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, px + lx, py + ly);
            };
          };

          exports.PathCommands = PathCommands;
          /***/
        },

        /***/
        "./internal/legacy/canvas/PathCommandsParser.js":
        /*!******************************************************!*\
          !*** ./internal/legacy/canvas/PathCommandsParser.js ***!
          \******************************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function internalLegacyCanvasPathCommandsParserJs(module, exports, __nested_webpack_require_938892__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.PathCommandsParser = void 0;

          var PathCommands_1 = __nested_webpack_require_938892__(
          /*! ./PathCommands */
          "./internal/legacy/canvas/PathCommands.js");

          function pathTokens(d) {
            var idx = 0;
            return {
              next: function next() {
                var s = "";

                while (d.length > idx) {
                  var c = d[idx];
                  idx++;

                  if (" ,\n\r\t".indexOf(c) > -1) {
                    if (s) {
                      return s;
                    }
                  } else {
                    var type = ".+-1234567890".indexOf(c) > -1 ? "num" : "str";

                    if (type === "str") {
                      if (s) {
                        idx--;
                        return s;
                      }

                      return c;
                    }

                    if ("-+".indexOf(c) > -1) {
                      if (s) {
                        idx--;
                        return s;
                      }
                    }

                    if (c === ".") {
                      if (s.indexOf(".") > -1) {
                        idx--;
                        return s;
                      }
                    }

                    s += c;
                  }
                }

                return s || null;
              }
            };
          }

          function command(builder, cmd, argsProvider) {
            if (cmd.toUpperCase() === "M" || cmd.toUpperCase() === "L" || cmd.toUpperCase() === "T") {
              builder.command(cmd, argsProvider.next(), argsProvider.next());
              return cmd === "M" ? "L" : cmd === "m" ? "l" : cmd;
            } else if (cmd.toUpperCase() === "H" || cmd.toUpperCase() === "V") {
              builder.command(cmd, argsProvider.next());
              return cmd;
            } else if (cmd.toUpperCase() === "Z") {
              builder.command(cmd);
              return cmd;
            } else if (cmd.toUpperCase() === "C") {
              builder.command(cmd, argsProvider.next(), argsProvider.next(), argsProvider.next(), argsProvider.next(), argsProvider.next(), argsProvider.next());
              return cmd;
            } else if (cmd.toUpperCase() === "S" || cmd.toUpperCase() === "Q") {
              builder.command(cmd, argsProvider.next(), argsProvider.next(), argsProvider.next(), argsProvider.next());
              return cmd;
            } else if (cmd.toUpperCase() === "A") {
              builder.command(cmd, argsProvider.next(), argsProvider.next(), argsProvider.next(), argsProvider.next(), argsProvider.next(), argsProvider.next(), argsProvider.next());
              return cmd;
            } else {
              // https://developer.mozilla.org/ja/docs/Web/SVG/Tutorial/Paths
              console.warn("unsupported:".concat(cmd));
            }

            return null;
          }

          var PathCommandsParser = /*#__PURE__*/function () {
            function PathCommandsParser() {
              var _this104 = this;

              _classCallCheck(this, PathCommandsParser);

              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              this._ops = [];
              this._commands = new PathCommands_1.PathCommands(this);

              var buildPush = function buildPush(op) {
                return (// eslint-disable-next-line @typescript-eslint/no-explicit-any
                  function () {
                    for (var _len21 = arguments.length, args = new Array(_len21), _key21 = 0; _key21 < _len21; _key21++) {
                      args[_key21] = arguments[_key21];
                    }

                    _this104._ops.push({
                      op: op,
                      args: args
                    });
                  }
                );
              };

              this.moveTo = buildPush("moveTo");
              this.lineTo = buildPush("lineTo");
              this.closePath = buildPush("closePath");
              this.bezierCurveTo = buildPush("bezierCurveTo");
              this.quadraticCurveTo = buildPush("quadraticCurveTo");
              this.save = buildPush("save");
              this.translate = buildPush("translate");
              this.rotate = buildPush("rotate");
              this.scale = buildPush("scale");
              this.arc = buildPush("arc");
              this.restore = buildPush("restore");
              this.arcTo = buildPush("arcTo");
              this.ellipse = buildPush("ellipse");
              this.rect = buildPush("rect");
            } // eslint-disable-next-line @typescript-eslint/no-explicit-any


            _createClass(PathCommandsParser, [{
              key: "command",
              value: function command(name) {
                for (var _len22 = arguments.length, args = new Array(_len22 > 1 ? _len22 - 1 : 0), _key22 = 1; _key22 < _len22; _key22++) {
                  args[_key22 - 1] = arguments[_key22];
                }

                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                var numArgs = args || [];

                for (var i = 0; i < args.length; i++) {
                  numArgs[i] -= 0;
                }

                var command = this._commands[name]; // eslint-disable-next-line @typescript-eslint/no-explicit-any

                command.apply(this, numArgs);
              } // eslint-disable-next-line @typescript-eslint/no-explicit-any

            }, {
              key: "parse",
              value: function parse(d) {
                var _this105 = this;

                var ops = this._ops = [];
                var tokens = pathTokens(d);

                try {
                  (function () {
                    var cmd;
                    var subsequentCommand = "Z";

                    while (cmd = tokens.next()) {
                      if (!isNaN(Number(cmd))) {
                        (function () {
                          var fst = true;
                          var argsProvider = {
                            next: function next() {
                              if (fst) {
                                fst = false;
                                return cmd;
                              }

                              return tokens.next();
                            }
                          };
                          subsequentCommand = command(_this105, subsequentCommand, argsProvider) || "Z";
                        })();
                      } else {
                        subsequentCommand = command(_this105, cmd, tokens) || "Z";
                      }
                    }
                  })();
                } catch (e) {
                  console.log("Error: ".concat(d));
                  throw e;
                }

                return ops;
              }
            }]);

            return PathCommandsParser;
          }();

          exports.PathCommandsParser = PathCommandsParser;
          /***/
        },

        /***/
        "./internal/legacy/fontwatch/FontRuler.js":
        /*!************************************************!*\
          !*** ./internal/legacy/fontwatch/FontRuler.js ***!
          \************************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function internalLegacyFontwatchFontRulerJs(module, exports, __webpack_require__) {
          "use strict"; //see https://github.com/typekit/webfontloader

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.FontRuler = void 0;

          function computeStyle(font) {
            return [{
              display: "block",
              position: "absolute",
              top: "-9999px",
              left: "-9999px",
              width: "auto",
              height: "auto",
              margin: "0",
              padding: "0",
              "white-space": "nowrap",
              font: font
            }, {
              "font-variant": "normal",
              "font-size": "300px",
              "font-style": "normal",
              "font-weight": "400",
              "line-height": "normal"
            }];
          }

          var FontRuler = /*#__PURE__*/function () {
            function FontRuler(font, testStr) {
              _classCallCheck(this, FontRuler);

              var e = document.createElement("span");
              e.setAttribute("aria-hidden", "true");
              e.textContent = testStr || "BESbswy";
              computeStyle(font).forEach(function (style) {
                for (var k in style) {
                  var key = k; // eslint-disable-next-line @typescript-eslint/no-explicit-any

                  e.style[key] = style[key];
                }
              });
              document.body.appendChild(e);
              this.el_ = e;
            }

            _createClass(FontRuler, [{
              key: "getWidth",
              value: function getWidth() {
                return this.el_.offsetWidth;
              }
            }, {
              key: "remove",
              value: function remove() {
                document.body.removeChild(this.el_);
              }
            }]);

            return FontRuler;
          }();

          exports.FontRuler = FontRuler;
          /***/
        },

        /***/
        "./internal/legacy/fontwatch/FontWatchRunner.js":
        /*!******************************************************!*\
          !*** ./internal/legacy/fontwatch/FontWatchRunner.js ***!
          \******************************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function internalLegacyFontwatchFontWatchRunnerJs(module, exports, __nested_webpack_require_948989__) {
          "use strict"; //see https://github.com/typekit/webfontloader
          //http://defghi1977.html.xdomain.jp/tech/canvasMemo/canvasMemo.htm

          var FontRuler_1 = __nested_webpack_require_948989__(
          /*! ./FontRuler */
          "./internal/legacy/fontwatch/FontRuler.js");

          var LastResortFonts = {
            SERIF: "serif",
            SANS_SERIF: "sans-serif"
          };
          var watchRunners = {};

          var FontWatchRunner = /*#__PURE__*/function () {
            function FontWatchRunner(font, testStr) {
              _classCallCheck(this, FontWatchRunner);

              this.activeCallbacks = [];
              this.inactiveCallbacks = [];
              this.status = null;
              this.lastResortWidths_ = {};
              this.fontRulerA_ = new FontRuler_1.FontRuler("".concat(font, ",").concat(LastResortFonts.SERIF), testStr);
              this.fontRulerB_ = new FontRuler_1.FontRuler("".concat(font, ",").concat(LastResortFonts.SANS_SERIF), testStr);
              var lastResortRulerA = new FontRuler_1.FontRuler("4px ".concat(LastResortFonts.SERIF), testStr);
              var lastResortRulerB = new FontRuler_1.FontRuler("4px ".concat(LastResortFonts.SANS_SERIF), testStr); //start

              this.lastResortWidths_[LastResortFonts.SERIF] = lastResortRulerA.getWidth();
              this.lastResortWidths_[LastResortFonts.SANS_SERIF] = lastResortRulerB.getWidth();
              lastResortRulerA.remove();
              lastResortRulerB.remove();
              this.started_ = Date.now();
              this.check_();
            }

            _createClass(FontWatchRunner, [{
              key: "then",
              value: function then(activeCallback, inactiveCallback) {
                if (this.status) {
                  if (this.status !== "ng") {
                    activeCallback();
                  } else {
                    inactiveCallback();
                  }
                } else {
                  this.activeCallbacks.push(activeCallback);
                  this.inactiveCallbacks.push(inactiveCallback);
                }
              }
            }, {
              key: "check_",
              value: function check_() {
                var _this106 = this;

                var widthA = this.fontRulerA_.getWidth();
                var widthB = this.fontRulerB_.getWidth();

                if (this.isFallbackFont_(widthA, widthB) || this.isLastResortFont_(widthA, widthB)) {
                  if (Date.now() - this.started_ >= 3000) {
                    // timeout
                    if (this.isLastResortFont_(widthA, widthB)) {
                      this.finish_(this.activeCallbacks);
                      this.status = "ok";
                    } else {
                      this.finish_(this.inactiveCallbacks);
                      this.status = "ng";
                    }
                  } else {
                    setTimeout(function () {
                      _this106.check_();
                    }, 50);
                  }
                } else {
                  this.finish_(this.activeCallbacks);
                  this.status = "ok";
                }
              }
            }, {
              key: "isFallbackFont_",
              value: function isFallbackFont_(a, b) {
                return this.widthMatches_(a, LastResortFonts.SERIF) && this.widthMatches_(b, LastResortFonts.SANS_SERIF);
              }
            }, {
              key: "widthsMatchLastResortWidths_",
              value: function widthsMatchLastResortWidths_(a, b) {
                for (var font in LastResortFonts) {
                  if (LastResortFonts.hasOwnProperty(font)) {
                    if (this.widthMatches_(a, LastResortFonts[font]) && this.widthMatches_(b, LastResortFonts[font])) {
                      return true;
                    }
                  }
                }

                return false;
              }
            }, {
              key: "widthMatches_",
              value: function widthMatches_(width, lastResortFont) {
                return width === this.lastResortWidths_[lastResortFont];
              }
            }, {
              key: "isLastResortFont_",
              value: function isLastResortFont_(a, b) {
                return hasWebKitFallbackBug() && this.widthsMatchLastResortWidths_(a, b);
              }
            }, {
              key: "finish_",
              value: function finish_(callbacks) {
                var _this107 = this;

                setTimeout(function () {
                  _this107.fontRulerA_.remove();

                  _this107.fontRulerB_.remove();

                  callbacks.forEach(function (cb) {
                    return cb();
                  });
                }, 0);
              }
            }], [{
              key: "load",
              value: function load(font, testStr, activeCallback, inactiveCallback) {
                var c = watchRunners[font] || (watchRunners[font] = {});
                testStr += "";
                var runner;

                if (c[testStr]) {
                  runner = c[testStr];
                } else {
                  runner = c[testStr] = new FontWatchRunner(font, testStr);
                }

                runner.then(activeCallback, inactiveCallback);
              }
            }]);

            return FontWatchRunner;
          }();

          var HAS_WEBKIT_FALLBACK_BUG = null;

          function hasWebKitFallbackBug() {
            if (HAS_WEBKIT_FALLBACK_BUG === null) {
              var match = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(window.navigator.userAgent);
              HAS_WEBKIT_FALLBACK_BUG = !!match && (parseInt(match[1], 10) < 536 || parseInt(match[1], 10) === 536 && parseInt(match[2], 10) <= 11);
            }

            return HAS_WEBKIT_FALLBACK_BUG;
          }

          module.exports = FontWatchRunner;
          /***/
        },

        /***/
        "./internal/menu-items.js":
        /*!********************************!*\
          !*** ./internal/menu-items.js ***!
          \********************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function internalMenuItemsJs(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.normalizeToFn = exports.normalize = void 0;
          /** @private */

          function extend(a, b) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            var o = {};

            for (var k in a) {
              o[k] = a[k];
            }

            for (var _k3 in b) {
              o[_k3] = b[_k3];
            }

            return o;
          }
          /**
           * Normalize the given menu options.
           * @param {*} options menu options to given
           * @returns {Array} Normalized options
           * @private
           */


          function normalize(options) {
            if (!options) {
              return [];
            }

            if (Array.isArray(options)) {
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              return options.map( // eslint-disable-next-line @typescript-eslint/no-explicit-any
              function (e) {
                return extend(e, {
                  label: e.caption || e.label
                });
              });
            }

            if (typeof options === "string") {
              return normalize(JSON.parse(options));
            }

            var result = [];

            for (var k in options) {
              result.push({
                value: k,
                label: options[k]
              });
            }

            return result;
          }

          exports.normalize = normalize;
          /**
           * Normalize the given menu options.
           * @param {*} options menu options to given
           * @returns {Array} Normalized options
           * @private
           */

          function normalizeToFn(options) {
            if (typeof options === "function") {
              return function (record) {
                return normalize(options(record));
              };
            }

            return function () {
              return normalize(options);
            };
          }

          exports.normalizeToFn = normalizeToFn;
          /***/
        },

        /***/
        "./internal/paste-utils.js":
        /*!*********************************!*\
          !*** ./internal/paste-utils.js ***!
          \*********************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function internalPasteUtilsJs(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.parsePasteRangeBoxValues = exports.normalizePasteValue = void 0;

          function normalizePasteValue(text) {
            return text[text.length - 1] !== "\n" ? text : text[text.length - 2] === "\r" ? text.slice(0, -2) : text.slice(0, -1);
          }

          exports.normalizePasteValue = normalizePasteValue;

          function parsePasteRangeBoxValues(value, option) {
            var normalizedValue = normalizePasteValue(value);

            var _parseValues = parseValues(normalizedValue, option),
                values = _parseValues.values,
                colCount = _parseValues.colCount;

            return {
              colCount: colCount,
              rowCount: values.length,
              getCellValue: function getCellValue(offsetCol, offsetRow) {
                var _a, _b;

                return (_b = (_a = values[offsetRow]) === null || _a === void 0 ? void 0 : _a[offsetCol]) !== null && _b !== void 0 ? _b : "";
              }
            };
          }

          exports.parsePasteRangeBoxValues = parsePasteRangeBoxValues;

          function parseValues(text, _ref84) {
            var trimOnPaste = _ref84.trimOnPaste;
            var len = text.length;
            var adjustCell = trimOnPaste ? function (cell) {
              return cell.trim();
            } : function (cell) {
              return cell;
            };
            var colCount = 1;
            var line = [];
            var values = [line];
            var cell = "";

            for (var index = 0; index < len; index++) {
              var char = text[index];

              if (char === "\t") {
                line.push(adjustCell(cell));
                cell = "";
                continue;
              }

              if (char === "\n") {
                // End of line
                cell = adjustCell(cell);

                if (cell[cell.length - 1] === "\r") {
                  cell = cell.slice(0, -1);
                }

                line.push(cell);
                colCount = Math.max(colCount, line.length);
                line = [];
                values.push(line);
                cell = "";
                continue;
              }

              if (char === '"' && !cell.trim()) {
                var quoted = processQuotedCell(index + 1);

                if (quoted) {
                  cell = quoted.cell;
                  index = quoted.next - 1;
                  continue;
                }
              }

              cell += char;
            } // End of text


            line.push(adjustCell(cell));
            colCount = Math.max(colCount, line.length);
            return {
              values: values,
              colCount: colCount
            };

            function processQuotedCell(start) {
              var cell = "";
              var index = start;

              while (index < len) {
                var _char = text[index];

                if (_char !== '"') {
                  cell += _char;
                  index++;
                  continue;
                }

                if (text[index + 1] === '"') {
                  // Escape
                  cell += '"';
                  index += 2;
                  continue;
                } // Maybe end quote


                var next = index + 1;

                while (next < len) {
                  var c = text[next];

                  if (c.trim()) {
                    // Not quoted. e.g. "A"B
                    return null;
                  }

                  if (c === "\t" || c === "\n") {
                    break;
                  } // Allow spaces


                  next++;
                } // End quote


                return {
                  cell: cell,
                  next: next
                };
              }

              return null;
            }
          }
          /***/

        },

        /***/
        "./internal/path2DManager.js":
        /*!***********************************!*\
          !*** ./internal/path2DManager.js ***!
          \***********************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function internalPath2DManagerJs(module, exports, __nested_webpack_require_962373__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.fill = exports.getPath2D = void 0;

          var utils_1 = __nested_webpack_require_962373__(
          /*! ./utils */
          "./internal/utils.js");

          function getPath2D() {
            if (typeof Path2D !== "undefined" && !utils_1.browser.Edge) {
              return Path2D;
            } // eslint-disable-next-line @typescript-eslint/no-var-requires


            return __nested_webpack_require_962373__(
            /*! ./legacy/canvas/Path2DShim */
            "./internal/legacy/canvas/Path2DShim.js").Path2DShim;
          }

          exports.getPath2D = getPath2D;

          function fill(pathModule, ctx, x, y, w, h) {
            ctx.save();

            try {
              var width = pathModule.width,
                  height = pathModule.height;
              var upsideDown = pathModule.ud,
                  _pathModule$x = pathModule.x,
                  offsetX = _pathModule$x === void 0 ? 0 : _pathModule$x,
                  _pathModule$y = pathModule.y,
                  offsetY = _pathModule$y === void 0 ? 0 : _pathModule$y;
              w = w || width;
              h = h || height;
              var xrate = w / width;
              var yrate = h / (upsideDown ? -height : height);
              x = x || 0;
              y = upsideDown ? (y || 0) + -height * yrate : y || 0;
              ctx.translate(x, y);
              ctx.scale(xrate, yrate);

              if (offsetX !== 0 || offsetY !== 0) {
                ctx.translate(offsetX, offsetY);
              }

              var _Path2D = getPath2D();

              var path2d = pathModule.path2d = pathModule.path2d || new _Path2D(pathModule.d);
              ctx.fill(path2d);
            } finally {
              ctx.restore();
            }
          }

          exports.fill = fill;
          /***/
        },

        /***/
        "./internal/sort.js":
        /*!**************************!*\
          !*** ./internal/sort.js ***!
          \**************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function internalSortJs(module, exports, __nested_webpack_require_964678__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.sortPromise = exports.sort = exports.sortArray = void 0;

          var utils_1 = __nested_webpack_require_964678__(
          /*! ./utils */
          "./internal/utils.js");

          function createArray(get, length) {
            var array = new Array(length);

            for (var i = 0; i < length; i++) {
              array[i] = get(i);
            }

            return array;
          }

          function createArrayPromise(get, getField, length // eslint-disable-next-line @typescript-eslint/no-explicit-any
          ) {
            return new Promise(function (resolve) {
              var plist = [];
              var array = new Array(length);

              var _loop7 = function _loop7(i) {
                var data = get(i);
                var record = {
                  v: data,
                  f: data
                };
                array[i] = record;

                if ((0, utils_1.isPromise)(data)) {
                  plist.push(data.then(function (v) {
                    record.v = v;
                    record.f = v;
                  }));
                }
              };

              for (var i = 0; i < length; i++) {
                _loop7(i);
              }

              Promise.all(plist).then(function () {
                return getField == null ? // eslint-disable-next-line @typescript-eslint/no-explicit-any
                array : // eslint-disable-next-line @typescript-eslint/no-explicit-any
                setArrayField(array, getField);
              }).then(resolve);
            });
          }

          function setArrayField(array, getField) {
            return new Promise(function (resolve) {
              var length = array.length;
              var plist = [];

              var _loop8 = function _loop8(i) {
                var record = array[i];
                var f = getField(record.v);

                if ((0, utils_1.isPromise)(f)) {
                  plist.push(f.then(function (v) {
                    record.f = v;
                  }));
                } else {
                  record.f = f;
                }
              };

              for (var i = 0; i < length; i++) {
                _loop8(i);
              }

              Promise.all(plist).then(function () {
                return resolve(array);
              });
            });
          }

          function sortArray(array, compare) {
            Array.prototype.sort.call(array, compare);
          }

          exports.sortArray = sortArray;

          function sort(get, set, length, compare, getField) {
            var old = createArray(get, length);

            if (getField != null) {
              old.sort(function (r1, r2) {
                return compare(getField(r1), getField(r2));
              });
            } else {
              old.sort(compare);
            }

            for (var i = 0; i < length; i++) {
              set(i, old[i]);
            }
          }

          exports.sort = sort;

          function sortPromise(get, set, length, // eslint-disable-next-line @typescript-eslint/no-explicit-any
          compare, // eslint-disable-next-line @typescript-eslint/no-explicit-any
          getField) {
            if (typeof Promise !== "undefined") {
              return createArrayPromise(get, getField, length).then(function (array) {
                array.sort(function (r1, r2) {
                  return compare(r1.f, r2.f);
                });

                for (var i = 0; i < length; i++) {
                  set(i, array[i].v);
                }
              });
            } else {
              sort(get, set, length, compare, getField);
              var dummyPromise = {
                then: function then(fn) {
                  fn();
                  return dummyPromise;
                },
                catch: function _catch() {
                  return dummyPromise;
                } // eslint-disable-next-line @typescript-eslint/no-explicit-any

              };
              return dummyPromise;
            }
          }

          exports.sortPromise = sortPromise;
          /***/
        },

        /***/
        "./internal/style.js":
        /*!***************************!*\
          !*** ./internal/style.js ***!
          \***************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function internalStyleJs(module, exports, __nested_webpack_require_969309__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.getScrollBarSize = exports.initDocument = void 0;

          function getScrollBarWidth() {
            var wrapper = document.createElement("div");
            var inner = document.createElement("div");
            var wrapperStyle = wrapper.style;
            wrapperStyle.position = "fixed";
            wrapperStyle.height = "50px";
            wrapperStyle.width = "50px";
            wrapperStyle.overflow = "scroll";
            wrapperStyle.opacity = "0";
            wrapperStyle.pointerEvents = "none";
            var style = inner.style;
            style.height = "100%";
            style.width = "100%";
            inner.textContent = "x";
            wrapper.appendChild(inner);
            document.body.appendChild(wrapper);
            var wrapperWidth = wrapper.getBoundingClientRect().width;
            var innerWidth = inner.getBoundingClientRect().width;
            document.body.removeChild(wrapper);
            return Math.ceil(wrapperWidth - innerWidth);
          }

          var SCROLLBAR_SIZE;

          function initDocumentInternal() {
            __nested_webpack_require_969309__(
            /*! @/internal/style.css */
            "../src/js/internal/style.css");

            SCROLLBAR_SIZE = getScrollBarWidth() || 10;
            var style = document.createElement("style");
            style.setAttribute("type", "text/css");
            style.setAttribute("data-name", "cheetah-grid");
            style.innerHTML = "\n.cheetah-grid .grid-scroll-end-point {\n\twidth: ".concat(SCROLLBAR_SIZE, "px;\n\theight: ").concat(SCROLLBAR_SIZE, "px;\n}\n.cheetah-grid > canvas {\n\twidth: -webkit-calc(100% - ").concat(SCROLLBAR_SIZE, "px);\n\twidth: calc(100% - ").concat(SCROLLBAR_SIZE, "px);\n\theight: -webkit-calc(100% - ").concat(SCROLLBAR_SIZE, "px);\n\theight: calc(100% - ").concat(SCROLLBAR_SIZE, "px);\n}\n\t\t");
            document.head.appendChild(style);
          }

          var initDocumentVar = initDocumentInternal;

          function initDocument() {
            initDocumentVar();
            initDocumentVar = Function.prototype;
          }

          exports.initDocument = initDocument;

          function getScrollBarSize() {
            return SCROLLBAR_SIZE;
          }

          exports.getScrollBarSize = getScrollBarSize;
          /***/
        },

        /***/
        "./internal/symbolManager.js":
        /*!***********************************!*\
          !*** ./internal/symbolManager.js ***!
          \***********************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function internalSymbolManagerJs(module, exports, __nested_webpack_require_972172__) {
          "use strict";
          /* WEBPACK VAR INJECTION */

          (function (global) {
            Object.defineProperty(exports, "__esModule", {
              value: true
            });
            exports.getCheckHeaderStateId = exports.getInlineMenuEditorStateId = exports.getInlineInputEditorStateId = exports.getSmallDialogInputEditorStateId = exports.getTreeColumnStateId = exports.getBranchGraphColumnStateId = exports.getColumnFadeinStateId = exports.getButtonColumnStateId = exports.getRadioColumnStateId = exports.getCheckColumnStateId = exports.getProtectedSymbol = exports.get = void 0;
            /* eslint-disable @typescript-eslint/no-explicit-any */

            var utils_1 = __nested_webpack_require_972172__(
            /*! ./utils */
            "./internal/utils.js");

            var _Symbol = utils_1.isNode ? global.Symbol : window.Symbol ? window.Symbol : function () {
              function random() {
                var c = "abcdefghijklmnopqrstuvwxyz0123456789";
                var cl = c.length;
                var r = "";

                for (var i = 0; i < 10; i++) {
                  r += c[Math.floor(Math.random() * cl)];
                }

                return r;
              }

              return function (name) {
                if (name) {
                  return "#".concat(name, "_").concat(random());
                } else {
                  return "#_".concat(random());
                }
              };
            }();

            var mem = {};

            function get(name) {
              if (name) {
                return mem[name] ? mem[name] : mem[name] = _Symbol(name);
              } else {
                return _Symbol();
              }
            }

            exports.get = get;

            function getProtectedSymbol() {
              return get("protected");
            }

            exports.getProtectedSymbol = getProtectedSymbol;

            function getCheckColumnStateId() {
              return get("chkcol.stateID");
            }

            exports.getCheckColumnStateId = getCheckColumnStateId;

            function getRadioColumnStateId() {
              return get("rdcol.stateID");
            }

            exports.getRadioColumnStateId = getRadioColumnStateId;

            function getButtonColumnStateId() {
              return get("btncol.stateID");
            }

            exports.getButtonColumnStateId = getButtonColumnStateId;

            function getColumnFadeinStateId() {
              return get("col.fadein_stateID");
            }

            exports.getColumnFadeinStateId = getColumnFadeinStateId;

            function getBranchGraphColumnStateId() {
              return get("branch_graph_col.stateID");
            }

            exports.getBranchGraphColumnStateId = getBranchGraphColumnStateId;

            function getTreeColumnStateId() {
              return get("tree_col.stateID");
            }

            exports.getTreeColumnStateId = getTreeColumnStateId;

            function getSmallDialogInputEditorStateId() {
              return get("small_dialog_input_editor.stateID");
            }

            exports.getSmallDialogInputEditorStateId = getSmallDialogInputEditorStateId;

            function getInlineInputEditorStateId() {
              return get("inline_input_editor.stateID");
            }

            exports.getInlineInputEditorStateId = getInlineInputEditorStateId;

            function getInlineMenuEditorStateId() {
              return get("inline_menu_editor.stateID");
            }

            exports.getInlineMenuEditorStateId = getInlineMenuEditorStateId;

            function getCheckHeaderStateId() {
              return get("check_header.stateID");
            }

            exports.getCheckHeaderStateId = getCheckHeaderStateId;
            /* WEBPACK VAR INJECTION */
          }).call(this, __nested_webpack_require_972172__(
          /*! ./../../node_modules/webpack/buildin/global.js */
          "../node_modules/webpack/buildin/global.js"));
          /***/
        },

        /***/
        "./internal/utils.js":
        /*!***************************!*\
          !*** ./internal/utils.js ***!
          \***************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function internalUtilsJs(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.emptyFn = exports.style = exports.event = exports.str = exports.obj = exports.browser = exports.cellInRange = exports.cellEquals = exports.array = exports.then = exports.getIgnoreCase = exports.getOrApply = exports.applyChainSafe = exports.getChainSafe = exports.isDescendantElement = exports.isNode = exports.isPromise = exports.extend = exports.defaults = exports.omit = exports.each = void 0;
          var isNode = typeof window === "undefined" || typeof window.window === "undefined";
          exports.isNode = isNode;
          var arrayFind;
          var arrayFindIndex;
          var array = {
            get find() {
              if (arrayFind) {
                return arrayFind;
              }

              if (Array.prototype.find) {
                arrayFind = function arrayFind(arr, predicate) {
                  return Array.prototype.find.call(arr, predicate);
                };
              } else {
                arrayFind = function arrayFind(arr, predicate) {
                  var index = array.findIndex(arr, predicate);
                  return index >= 0 ? arr[index] : undefined;
                };
              }

              return arrayFind;
            },

            get findIndex() {
              if (arrayFindIndex) {
                return arrayFindIndex;
              }

              if (Array.prototype.findIndex) {
                arrayFindIndex = function arrayFindIndex(arr, predicate) {
                  return Array.prototype.findIndex.call(arr, predicate);
                };
              } else {
                arrayFindIndex = function arrayFindIndex(arr, predicate) {
                  var length = arr.length;

                  for (var i = 0; i < length; i++) {
                    var value = arr[i];

                    if (predicate(value, i, arr)) {
                      return i;
                    }
                  }

                  return -1;
                };
              }

              return arrayFindIndex;
            }

          };
          exports.array = array;

          function analyzeUserAgent() {
            if (isNode) {
              return {
                IE: false,
                Edge: false,
                Chrome: false,
                Firefox: false,
                Safari: false
              };
            } else {
              var ua = window.navigator.userAgent.toLowerCase();
              return {
                IE: !!/(msie|trident)/.exec(ua),
                Edge: ua.indexOf("edge") > -1,
                Chrome: ua.indexOf("chrome") > -1 && ua.indexOf("edge") === -1,
                Firefox: ua.indexOf("firefox") > -1,
                Safari: ua.indexOf("safari") > -1 && ua.indexOf("edge") === -1
              };
            }
          }

          var _analyzeUserAgent = analyzeUserAgent(),
              IE = _analyzeUserAgent.IE,
              Chrome = _analyzeUserAgent.Chrome,
              Firefox = _analyzeUserAgent.Firefox,
              Edge = _analyzeUserAgent.Edge,
              Safari = _analyzeUserAgent.Safari;

          function setReadonly(obj, name, value) {
            Object.defineProperty(obj, name, {
              enumerable: false,
              configurable: true,
              value: value
            });
          } // eslint-disable-next-line @typescript-eslint/no-explicit-any


          function each(obj, fn) {
            for (var key in obj) {
              fn(obj[key], key, obj);
            }
          }

          exports.each = each; // eslint-disable-next-line @typescript-eslint/no-explicit-any

          function isObject(obj) {
            return obj === Object(obj);
          }

          function omit(source, omits) {
            var result = {};

            var _loop9 = function _loop9(key) {
              if (omits.indexOf(key) >= 0) {
                return "continue";
              }

              Object.defineProperty(result, key, {
                get: function get() {
                  return source[key];
                },
                set: function set(val) {
                  source[key] = val;
                },
                configurable: true,
                enumerable: true
              });
            };

            for (var key in source) {
              var _ret2 = _loop9(key);

              if (_ret2 === "continue") continue;
            }

            return result;
          }

          exports.omit = omit;

          function defaults(source, defs) {
            var keys = [];
            var result = {};

            var _loop10 = function _loop10(key) {
              keys.push(key);
              Object.defineProperty(result, key, {
                get: function get() {
                  var val = source[key];
                  return val === undefined ? defs[key] : val;
                },
                set: function set(val) {
                  source[key] = val;
                },
                configurable: true,
                enumerable: true
              });
            };

            for (var key in source) {
              _loop10(key);
            }

            var _loop11 = function _loop11(_key23) {
              if (keys.indexOf(_key23) >= 0) {
                return "continue";
              }

              Object.defineProperty(result, _key23, {
                get: function get() {
                  var val = source[_key23];
                  return val === undefined ? defs[_key23] : val;
                },
                set: function set(val) {
                  source[_key23] = val;
                },
                configurable: true,
                enumerable: true
              });
            };

            for (var _key23 in defs) {
              var _ret3 = _loop11(_key23);

              if (_ret3 === "continue") continue;
            }

            return result;
          }

          exports.defaults = defaults;

          function extend() {
            var result = {};

            for (var _len23 = arguments.length, args = new Array(_len23), _key24 = 0; _key24 < _len23; _key24++) {
              args[_key24] = arguments[_key24];
            }

            args.forEach(function (source) {
              var _loop12 = function _loop12(key) {
                Object.defineProperty(result, key, {
                  get: function get() {
                    return source[key];
                  },
                  set: function set(val) {
                    source[key] = val;
                  },
                  configurable: true,
                  enumerable: true
                });
              };

              for (var key in source) {
                _loop12(key);
              }
            });
            return result;
          }

          exports.extend = extend;

          function isDescendantElement(root, target) {
            while (target.parentElement) {
              var p = target.parentElement;

              if (root === p) {
                return true;
              }

              target = p;
            }

            return false;
          }

          exports.isDescendantElement = isDescendantElement;
          /* eslint-disable @typescript-eslint/no-explicit-any */

          function applyChainSafe(obj, fn) {
            var value = obj;

            for (var i = 0; i < (arguments.length <= 2 ? 0 : arguments.length - 2) && value != null; i++) {
              value = fn(value, i + 2 < 2 || arguments.length <= i + 2 ? undefined : arguments[i + 2]);
            }

            return value;
          }

          exports.applyChainSafe = applyChainSafe;

          function getChainSafe(obj) {
            for (var _len24 = arguments.length, names = new Array(_len24 > 1 ? _len24 - 1 : 0), _key25 = 1; _key25 < _len24; _key25++) {
              names[_key25 - 1] = arguments[_key25];
            }

            return applyChainSafe.apply(void 0, [obj, function (val, name) {
              return val[name];
            }].concat(names));
          }

          exports.getChainSafe = getChainSafe;

          function getOrApply(value) {
            if (typeof value === "function") {
              for (var _len25 = arguments.length, args = new Array(_len25 > 1 ? _len25 - 1 : 0), _key26 = 1; _key26 < _len25; _key26++) {
                args[_key26 - 1] = arguments[_key26];
              }

              return value.apply(void 0, args);
            } else {
              return value;
            }
          }

          exports.getOrApply = getOrApply;
          /* eslint-enable @typescript-eslint/no-explicit-any */

          function endsWith(str, searchString, position) {
            var subjectString = str.toString();

            if (typeof position !== "number" || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {
              position = subjectString.length;
            }

            position -= searchString.length;
            var lastIndex = subjectString.lastIndexOf(searchString, position);
            return lastIndex !== -1 && lastIndex === position;
          }

          function genChars(s) {
            // Surrogate Code Point
            // [\uD800-\uDBFF]
            // Variation Selectors
            // FVS [\u180B-\u180D]
            // VS1VS16 [\uFE00-\uFE0F]
            // VS17VS256 \uDB40[\uDD00-\uDDEF]
            var re = /([\uD800-\uDBFF][\uDC00-\uDFFF]|\r\n|[^\uD800-\uDFFF])([\u180B-\u180D]|[\uFE00-\uFE0F]|\uDB40[\uDD00-\uDDEF])?/g;
            return {
              next: function next() {
                var res = re.exec(s);
                return res !== null ? res[0] : null;
              }
            };
          }

          function genWords(s) {
            var re = /[!-~]+|[^!-~\s]+|\s+/g;
            return {
              next: function next() {
                var res = re.exec(s);
                return res !== null ? res[0] : null;
              }
            };
          }

          function isPromise(data) {
            return Boolean(data && typeof data.then === "function");
          }

          exports.isPromise = isPromise;

          function then(result, callback) {
            return isPromise(result) ? result.then(function (r) {
              return callback(r);
            }) : callback(result);
          }

          exports.then = then;

          function getMouseButtons(e) {
            if (e.buttons != null) {
              return e.buttons;
            }
            /*for legacy*/


            if (e.which != null) {
              if (e.which === 3) {
                //right?
                return 4;
              }

              if (e.which === 2) {
                //middle?
                return 4;
              }

              return e.which; //left or no
            }

            if (e.button === 0 || e.button === 1) {
              return 1; //candidate left
            }

            if (e.button === 2) {
              return 2; // right
            }

            return 0; //no or middle?
          }

          function getKeyCode(e) {
            return e.keyCode || e.which;
          }

          function isTouchEvent(e) {
            return !!e.changedTouches;
          } // eslint-disable-next-line @typescript-eslint/no-explicit-any


          function getIgnoreCase(obj, name) {
            if (obj[name]) {
              return obj[name];
            }

            var l = name.toLowerCase();

            if (obj[l]) {
              return obj[l];
            }

            var u = name.toLowerCase();

            if (obj[u]) {
              return obj[u];
            }

            for (var k in obj) {
              if (k.toLowerCase() === l) {
                return obj[k];
              }
            }

            return undefined;
          }

          exports.getIgnoreCase = getIgnoreCase;

          function cancel(e) {
            e.preventDefault();
            e.stopPropagation();
          }

          function toBoxArray(obj) {
            if (!Array.isArray(obj)) {
              return [obj
              /*top*/
              , obj
              /*right*/
              , obj
              /*bottom*/
              , obj
              /*left*/
              ];
            }

            if (obj.length === 3) {
              return [obj[0]
              /*top*/
              , obj[1]
              /*right*/
              , obj[2]
              /*bottom*/
              , obj[1]
              /*left*/
              ];
            }

            if (obj.length === 2) {
              return [obj[0]
              /*top*/
              , obj[1]
              /*right*/
              , obj[0]
              /*bottom*/
              , obj[1]
              /*left*/
              ];
            }

            if (obj.length === 1) {
              return [obj[0]
              /*top*/
              , obj[0]
              /*right*/
              , obj[0]
              /*bottom*/
              , obj[0]
              /*left*/
              ];
            }

            return obj;
          }

          function cellEquals(a, b) {
            return a.col === b.col && a.row === b.row;
          }

          exports.cellEquals = cellEquals;

          function cellInRange(range, col, row) {
            return range.start.col <= col && col <= range.end.col && range.start.row <= row && row <= range.end.row;
          }

          exports.cellInRange = cellInRange;
          exports.browser = {
            IE: IE,
            Edge: Edge,
            Chrome: Chrome,
            Firefox: Firefox,
            Safari: Safari,
            // Chrome 16777216 (onl Chrome 33554431)
            // FireFox 17895588
            // IE 10737433
            heightLimit: Chrome ? 16777216 : Firefox ? 17895588 : 10737433 // default IE limit

          };
          exports.obj = {
            setReadonly: setReadonly,
            isObject: isObject
          };
          exports.str = {
            endsWith: endsWith,
            genChars: genChars,
            genWords: genWords
          };
          exports.event = {
            getMouseButtons: getMouseButtons,
            getKeyCode: getKeyCode,
            isTouchEvent: isTouchEvent,
            cancel: cancel
          };
          exports.style = {
            toBoxArray: toBoxArray
          };
          exports.emptyFn = Function.prototype;
          /***/
        },

        /***/
        "./list-grid/LG_EVENT_TYPE.js":
        /*!************************************!*\
          !*** ./list-grid/LG_EVENT_TYPE.js ***!
          \************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function listGridLG_EVENT_TYPEJs(module, exports, __nested_webpack_require_991574__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.LG_EVENT_TYPE = void 0;

          var DG_EVENT_TYPE_1 = __nested_webpack_require_991574__(
          /*! ../core/DG_EVENT_TYPE */
          "./core/DG_EVENT_TYPE.js");

          var utils_1 = __nested_webpack_require_991574__(
          /*! ../internal/utils */
          "./internal/utils.js");

          exports.LG_EVENT_TYPE = (0, utils_1.extend)(DG_EVENT_TYPE_1.DG_EVENT_TYPE, {
            BEFORE_CHANGE_VALUE: "before_change_value",
            CHANGED_VALUE: "changed_value",
            CHANGED_HEADER_VALUE: "changed_header_value",
            REJECTED_PASTE_VALUES: "rejected_paste_values"
          });
          /***/
        },

        /***/
        "./list-grid/layout-map/index.js":
        /*!***************************************!*\
          !*** ./list-grid/layout-map/index.js ***!
          \***************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function listGridLayoutMapIndexJs(module, exports, __nested_webpack_require_992761__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.MultiLayoutMap = exports.SimpleHeaderLayoutMap = void 0;

          var simple_header_layout_1 = __nested_webpack_require_992761__(
          /*! ./internal/simple-header-layout */
          "./list-grid/layout-map/internal/simple-header-layout.js");

          Object.defineProperty(exports, "SimpleHeaderLayoutMap", {
            enumerable: true,
            get: function get() {
              return simple_header_layout_1.SimpleHeaderLayoutMap;
            }
          });

          var multi_layout_1 = __nested_webpack_require_992761__(
          /*! ./internal/multi-layout */
          "./list-grid/layout-map/internal/multi-layout.js");

          Object.defineProperty(exports, "MultiLayoutMap", {
            enumerable: true,
            get: function get() {
              return multi_layout_1.MultiLayoutMap;
            }
          });
          /***/
        },

        /***/
        "./list-grid/layout-map/internal/multi-layout.js":
        /*!*******************************************************!*\
          !*** ./list-grid/layout-map/internal/multi-layout.js ***!
          \*******************************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function listGridLayoutMapInternalMultiLayoutJs(module, exports, __nested_webpack_require_994264__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.MultiLayoutMap = void 0;

          var columns = __importStar(__nested_webpack_require_994264__(
          /*! ../../../columns */
          "./columns.js"));

          var headerAction = __importStar(__nested_webpack_require_994264__(
          /*! ../../../header/action */
          "./header/action.js"));

          var headerType = __importStar(__nested_webpack_require_994264__(
          /*! ../../../header/type */
          "./header/type.js"));

          var utils_1 = __nested_webpack_require_994264__(
          /*! ./utils */
          "./list-grid/layout-map/internal/utils.js");

          function normalizeLayout(layout) {
            if (Array.isArray(layout)) {
              return {
                header: layout,
                body: layout
              };
            }

            return layout;
          }

          var seqId = 0;

          var LayoutObjectGrid = /*#__PURE__*/function () {
            function LayoutObjectGrid(layout, transform) {
              var _this108 = this;

              _classCallCheck(this, LayoutObjectGrid);

              this.objects = [];
              this.objectGrid = [];
              this.objectMap = {};
              this.columnCount = 0;
              this.columnWidths = [];
              layout.forEach(function (rowLayout, row) {
                var col = 0;
                rowLayout.forEach(function (cell) {
                  var _a, _b;

                  var id = seqId++;
                  var obj = transform(cell, id);

                  _this108.objects.push(obj);

                  _this108.objectMap[id] = obj;
                  col = _this108._findStartCell(col, row);
                  var rowSpan = Number((_a = cell.rowSpan) !== null && _a !== void 0 ? _a : 1);
                  var colSpan = Number((_b = cell.colSpan) !== null && _b !== void 0 ? _b : 1);
                  var endRow = row + rowSpan;
                  var endCol = col + colSpan;

                  for (var rowIndex = row; rowIndex < endRow; rowIndex++) {
                    var objectGridRow = _this108._getObjectGridRow(rowIndex);

                    for (var colIndex = col; colIndex < endCol; colIndex++) {
                      objectGridRow[colIndex] = obj;
                    }
                  }

                  if (colSpan === 1) {
                    _this108._setWidthDataIfAbsent(col, cell);
                  }

                  _this108._useColumnIndex(endCol - 1);

                  col = endCol;
                });
              });
            }

            _createClass(LayoutObjectGrid, [{
              key: "rowCount",
              get: function get() {
                return this.objectGrid.length;
              }
            }, {
              key: "_findStartCell",
              value: function _findStartCell(col, row) {
                var objectGridRow = this._getObjectGridRow(row);

                for (var index = col; index < objectGridRow.length; index++) {
                  if (!objectGridRow[index]) {
                    return index;
                  }
                }

                return objectGridRow.length;
              }
            }, {
              key: "_getObjectGridRow",
              value: function _getObjectGridRow(row) {
                return this.objectGrid[row] || (this.objectGrid[row] = []);
              }
            }, {
              key: "_useColumnIndex",
              value: function _useColumnIndex(col) {
                if (this.columnCount > col) {
                  return;
                }

                this.columnCount = col + 1;
              }
            }, {
              key: "_setWidthDataIfAbsent",
              value: function _setWidthDataIfAbsent(col, cell) {
                if (!this.columnWidths[col]) {
                  if (cell.width != null || cell.maxWidth != null || cell.minWidth != null) {
                    this.columnWidths[col] = {
                      width: cell.width,
                      maxWidth: cell.maxWidth,
                      minWidth: cell.minWidth
                    };
                  }
                }
              }
            }]);

            return LayoutObjectGrid;
          }();

          var MultiLayoutMap = /*#__PURE__*/function () {
            function MultiLayoutMap(layout) {
              _classCallCheck(this, MultiLayoutMap);

              this._columnWidths = [];
              this._emptyDataCache = new utils_1.EmptyDataCache();
              var hbLayouut = normalizeLayout(layout);
              var header = this._header = new LayoutObjectGrid(hbLayouut.header, function (hd, id) {
                return {
                  id: id,
                  caption: hd.caption,
                  field: hd.headerField || hd.field,
                  headerIcon: hd.headerIcon,
                  style: hd.headerStyle,
                  headerType: headerType.ofCell(hd),
                  action: headerAction.ofCell(hd),
                  define: hd
                };
              });
              var body = this._body = new LayoutObjectGrid(hbLayouut.body, function (colDef, id) {
                return {
                  id: id,
                  field: colDef.field,
                  width: colDef.width,
                  minWidth: colDef.minWidth,
                  maxWidth: colDef.maxWidth,
                  icon: colDef.icon,
                  message: colDef.message,
                  columnType: columns.type.of(colDef.columnType),
                  action: columns.action.of(colDef.action),
                  style: colDef.style,
                  define: colDef
                };
              });
              var columnCount = this._columnCount = Math.max(header.columnCount, body.columnCount);

              for (var col = 0; col < columnCount; col++) {
                var widthDef = header.columnWidths[col] || body.columnWidths[col] || {};
                this._columnWidths[col] = widthDef;
              }
            }

            _createClass(MultiLayoutMap, [{
              key: "columnWidths",
              get: function get() {
                return this._columnWidths;
              }
            }, {
              key: "headerRowCount",
              get: function get() {
                return this._header.rowCount;
              }
            }, {
              key: "bodyRowCount",
              get: function get() {
                return this._body.rowCount;
              }
            }, {
              key: "colCount",
              get: function get() {
                return this._columnCount;
              }
            }, {
              key: "headerObjects",
              get: function get() {
                return this._header.objects;
              }
            }, {
              key: "columnObjects",
              get: function get() {
                return this._body.objects;
              }
            }, {
              key: "getCellId",
              value: function getCellId(col, row) {
                var _a, _b, _c, _d;

                if (this.headerRowCount <= row) {
                  var bodyRow = row - this.headerRowCount;
                  var bodyLayoutRow = bodyRow % this.bodyRowCount;
                  return (_b = (_a = this._body.objectGrid[bodyLayoutRow]) === null || _a === void 0 ? void 0 : _a[col]) === null || _b === void 0 ? void 0 : _b.id;
                } //in header


                return (_d = (_c = this._header.objectGrid[row]) === null || _c === void 0 ? void 0 : _c[col]) === null || _d === void 0 ? void 0 : _d.id;
              }
            }, {
              key: "getHeader",
              value: function getHeader(col, row) {
                var id = this.getCellId(col, row);
                return this._header.objectMap[id] || this._emptyDataCache.getHeader(col, row);
              }
            }, {
              key: "getBody",
              value: function getBody(col, row) {
                var id = this.getCellId(col, row);
                return this._body.objectMap[id] || this._emptyDataCache.getBody(col, row);
              }
            }, {
              key: "getBodyLayoutRangeById",
              value: function getBodyLayoutRangeById(id) {
                var _a;

                for (var row = 0; row < this.bodyRowCount; row++) {
                  var objectGridRow = this._body.objectGrid[row];

                  if (!objectGridRow) {
                    continue;
                  }

                  for (var col = 0; col < this.colCount; col++) {
                    if (id === ((_a = objectGridRow[col]) === null || _a === void 0 ? void 0 : _a.id)) {
                      return this._getCellRange(this._body, col, row, 0);
                    }
                  }
                }

                throw new Error("can not found body layout @id=".concat(id));
              }
            }, {
              key: "getCellRange",
              value: function getCellRange(col, row) {
                if (this.headerRowCount <= row) {
                  var recordIndex = this.getRecordIndexByRow(row);
                  var startRow = this.getRecordStartRowByRecordIndex(recordIndex);
                  var bodyRow = row - this.headerRowCount;
                  var bodyLayoutRow = bodyRow % this.bodyRowCount;
                  return this._getCellRange(this._body, col, bodyLayoutRow, startRow);
                } //in header


                return this._getCellRange(this._header, col, row, 0);
              }
            }, {
              key: "getRecordIndexByRow",
              value: function getRecordIndexByRow(row) {
                if (row < this.headerRowCount) {
                  return -1;
                } else {
                  var bodyRow = row - this.headerRowCount;
                  return Math.floor(bodyRow / this.bodyRowCount);
                }
              }
            }, {
              key: "getRecordStartRowByRecordIndex",
              value: function getRecordStartRowByRecordIndex(index) {
                return this.headerRowCount + index * this.bodyRowCount;
              }
            }, {
              key: "_getCellRange",
              value: function _getCellRange( // eslint-disable-next-line @typescript-eslint/no-explicit-any
              layout, col, layoutRow, offsetRow) {
                var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;

                var result = {
                  start: {
                    col: col,
                    row: layoutRow + offsetRow
                  },
                  end: {
                    col: col,
                    row: layoutRow + offsetRow
                  }
                };
                var objectGrid = layout.objectGrid;
                var id = (_b = (_a = objectGrid[layoutRow]) === null || _a === void 0 ? void 0 : _a[col]) === null || _b === void 0 ? void 0 : _b.id;

                if (id == null) {
                  return result;
                }

                for (var c = col - 1; c >= 0; c--) {
                  if (id !== ((_d = (_c = objectGrid[layoutRow]) === null || _c === void 0 ? void 0 : _c[c]) === null || _d === void 0 ? void 0 : _d.id)) {
                    break;
                  }

                  result.start.col = c;
                }

                for (var _c6 = col + 1; _c6 < layout.columnCount; _c6++) {
                  if (id !== ((_f = (_e = objectGrid[layoutRow]) === null || _e === void 0 ? void 0 : _e[_c6]) === null || _f === void 0 ? void 0 : _f.id)) {
                    break;
                  }

                  result.end.col = _c6;
                }

                for (var r = layoutRow - 1; r >= 0; r--) {
                  if (id !== ((_h = (_g = objectGrid[r]) === null || _g === void 0 ? void 0 : _g[col]) === null || _h === void 0 ? void 0 : _h.id)) {
                    break;
                  }

                  result.start.row = r + offsetRow;
                }

                for (var _r2 = layoutRow + 1; _r2 < layout.rowCount; _r2++) {
                  if (id !== ((_k = (_j = objectGrid[_r2]) === null || _j === void 0 ? void 0 : _j[col]) === null || _k === void 0 ? void 0 : _k.id)) {
                    break;
                  }

                  result.end.row = _r2 + offsetRow;
                }

                return result;
              }
            }]);

            return MultiLayoutMap;
          }();

          exports.MultiLayoutMap = MultiLayoutMap;
          /***/
        },

        /***/
        "./list-grid/layout-map/internal/simple-header-layout.js":
        /*!***************************************************************!*\
          !*** ./list-grid/layout-map/internal/simple-header-layout.js ***!
          \***************************************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function listGridLayoutMapInternalSimpleHeaderLayoutJs(module, exports, __nested_webpack_require_1008793__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.SimpleHeaderLayoutMap = void 0;

          var columns = __importStar(__nested_webpack_require_1008793__(
          /*! ../../../columns */
          "./columns.js"));

          var headerAction = __importStar(__nested_webpack_require_1008793__(
          /*! ../../../header/action */
          "./header/action.js"));

          var headerType = __importStar(__nested_webpack_require_1008793__(
          /*! ../../../header/type */
          "./header/type.js"));

          var utils_1 = __nested_webpack_require_1008793__(
          /*! ./utils */
          "./list-grid/layout-map/internal/utils.js");

          var seqId = 0;

          var SimpleHeaderLayoutMap = /*#__PURE__*/function () {
            function SimpleHeaderLayoutMap(header) {
              _classCallCheck(this, SimpleHeaderLayoutMap);

              this.bodyRowCount = 1;
              this._emptyDataCache = new utils_1.EmptyDataCache();
              this._columns = [];
              this._headerCellIds = [];
              this._headerObjects = this._addHeaders(0, header, []);
              this._headerObjectMap = this._headerObjects.reduce(function (o, e) {
                o[e.id] = e;
                return o;
              }, {});
            }

            _createClass(SimpleHeaderLayoutMap, [{
              key: "columnWidths",
              get: function get() {
                return this._columns;
              }
            }, {
              key: "headerRowCount",
              get: function get() {
                return this._headerCellIds.length;
              }
            }, {
              key: "colCount",
              get: function get() {
                return this._columns.length;
              }
            }, {
              key: "headerObjects",
              get: function get() {
                return this._headerObjects;
              }
            }, {
              key: "columnObjects",
              get: function get() {
                return this._columns;
              }
            }, {
              key: "getCellId",
              value: function getCellId(col, row) {
                if (this.headerRowCount <= row) {
                  return this._columns[col].id;
                } //in header


                return this._headerCellIds[row][col];
              }
            }, {
              key: "getHeader",
              value: function getHeader(col, row) {
                var id = this.getCellId(col, row);
                return this._headerObjectMap[id] || this._emptyDataCache.getHeader(col, row);
              }
            }, {
              key: "getBody",
              value: function getBody(col, _row) {
                return this._columns[col] || this._emptyDataCache.getBody(col, 0);
              }
            }, {
              key: "getBodyLayoutRangeById",
              value: function getBodyLayoutRangeById(id) {
                for (var col = 0; col < this.colCount; col++) {
                  if (id === this._columns[col].id) {
                    return {
                      start: {
                        col: col,
                        row: 0
                      },
                      end: {
                        col: col,
                        row: 0
                      }
                    };
                  }
                }

                throw new Error("can not found body layout @id=".concat(id));
              }
            }, {
              key: "getCellRange",
              value: function getCellRange(col, row) {
                var result = {
                  start: {
                    col: col,
                    row: row
                  },
                  end: {
                    col: col,
                    row: row
                  }
                };

                if (this.headerRowCount <= row) {
                  return result;
                } //in header


                var id = this.getCellId(col, row);

                for (var c = col - 1; c >= 0; c--) {
                  if (id !== this.getCellId(c, row)) {
                    break;
                  }

                  result.start.col = c;
                }

                for (var _c7 = col + 1; _c7 < this.colCount; _c7++) {
                  if (id !== this.getCellId(_c7, row)) {
                    break;
                  }

                  result.end.col = _c7;
                }

                for (var r = row - 1; r >= 0; r--) {
                  if (id !== this.getCellId(col, r)) {
                    break;
                  }

                  result.start.row = r;
                }

                for (var _r3 = row + 1; _r3 < this.headerRowCount; _r3++) {
                  if (id !== this.getCellId(col, _r3)) {
                    break;
                  }

                  result.end.row = _r3;
                }

                return result;
              }
            }, {
              key: "getRecordIndexByRow",
              value: function getRecordIndexByRow(row) {
                if (row < this.headerRowCount) {
                  return -1;
                } else {
                  return row - this.headerRowCount;
                }
              }
            }, {
              key: "getRecordStartRowByRecordIndex",
              value: function getRecordStartRowByRecordIndex(index) {
                return this.headerRowCount + index;
              }
            }, {
              key: "_addHeaders",
              value: function _addHeaders(row, header, roots) {
                var _this109 = this;

                var results = [];

                var rowCells = this._headerCellIds[row] || this._newRow(row);

                header.forEach(function (hd) {
                  var col = _this109._columns.length;
                  var id = seqId++;
                  var cell = {
                    id: id,
                    caption: hd.caption,
                    field: hd.headerField || hd.field,
                    headerIcon: hd.headerIcon,
                    style: hd.headerStyle,
                    headerType: headerType.ofCell(hd),
                    action: headerAction.ofCell(hd),
                    define: hd
                  };
                  results[id] = cell;
                  rowCells[col] = id;

                  for (var r = row - 1; r >= 0; r--) {
                    _this109._headerCellIds[r][col] = roots[r];
                  }

                  if (hd.columns) {
                    _this109._addHeaders(row + 1, hd.columns, [].concat(_toConsumableArray(roots), [id])).forEach(function (c) {
                      return results.push(c);
                    });
                  } else {
                    var colDef = hd;

                    _this109._columns.push({
                      id: seqId++,
                      field: colDef.field,
                      width: colDef.width,
                      minWidth: colDef.minWidth,
                      maxWidth: colDef.maxWidth,
                      icon: colDef.icon,
                      message: colDef.message,
                      columnType: columns.type.of(colDef.columnType),
                      action: columns.action.of(colDef.action),
                      style: colDef.style,
                      define: colDef
                    });

                    for (var _r4 = row + 1; _r4 < _this109._headerCellIds.length; _r4++) {
                      _this109._headerCellIds[_r4][col] = id;
                    }
                  }
                });
                return results;
              }
            }, {
              key: "_newRow",
              value: function _newRow(row) {
                var newRow = this._headerCellIds[row] = [];

                if (!this._columns.length) {
                  return newRow;
                }

                var prev = this._headerCellIds[row - 1];

                for (var col = 0; col < prev.length; col++) {
                  newRow[col] = prev[col];
                }

                return newRow;
              }
            }]);

            return SimpleHeaderLayoutMap;
          }();

          exports.SimpleHeaderLayoutMap = SimpleHeaderLayoutMap;
          /***/
        },

        /***/
        "./list-grid/layout-map/internal/utils.js":
        /*!************************************************!*\
          !*** ./list-grid/layout-map/internal/utils.js ***!
          \************************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function listGridLayoutMapInternalUtilsJs(module, exports, __nested_webpack_require_1018985__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.EmptyDataCache = exports.newEmptyColumnData = exports.newEmptyHeaderData = void 0;

          var columns = __importStar(__nested_webpack_require_1018985__(
          /*! ../../../columns */
          "./columns.js"));

          var headerType = __importStar(__nested_webpack_require_1018985__(
          /*! ../../../header/type */
          "./header/type.js"));

          var seqId = -1; // eslint-disable-next-line @typescript-eslint/no-explicit-any

          function newEmptyHeaderData() {
            return {
              id: seqId--,
              define: {},
              headerType: headerType.of(null) // default

            };
          }

          exports.newEmptyHeaderData = newEmptyHeaderData; // eslint-disable-next-line @typescript-eslint/no-explicit-any

          function newEmptyColumnData() {
            return {
              id: seqId--,
              define: {},
              columnType: columns.type.of(null),
              style: null
            };
          }

          exports.newEmptyColumnData = newEmptyColumnData;

          var EmptyDataCache = /*#__PURE__*/function () {
            function EmptyDataCache() {
              _classCallCheck(this, EmptyDataCache);

              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              this.headers = []; // eslint-disable-next-line @typescript-eslint/no-explicit-any

              this.columns = [];
            }

            _createClass(EmptyDataCache, [{
              key: "getHeader",
              value: function getHeader(col, row) {
                var rows = this.headers[row] || (this.headers[row] = []);
                return rows[col] || (rows[col] = newEmptyHeaderData());
              }
            }, {
              key: "getBody",
              value: function getBody(col, row) {
                var rows = this.columns[row] || (this.columns[row] = []);
                return rows[col] || (rows[col] = newEmptyColumnData());
              }
            }]);

            return EmptyDataCache;
          }();

          exports.EmptyDataCache = EmptyDataCache;
          /***/
        },

        /***/
        "./main.js":
        /*!*****************!*\
          !*** ./main.js ***!
          \*****************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function mainJs(module, exports, __nested_webpack_require_1022931__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.register = exports.getIcons = exports.GridCanvasHelper = exports.data = exports.themes = exports.headers = exports.columns = exports.ListGrid = exports.tools = exports.core = exports._getInternal = void 0;

          var columns = __importStar(__nested_webpack_require_1022931__(
          /*! ./columns */
          "./columns.js"));

          exports.columns = columns;

          var core = __importStar(__nested_webpack_require_1022931__(
          /*! ./core */
          "./core.js"));

          exports.core = core;

          var data = __importStar(__nested_webpack_require_1022931__(
          /*! ./data */
          "./data.js"));

          exports.data = data;

          var headers = __importStar(__nested_webpack_require_1022931__(
          /*! ./headers */
          "./headers.js"));

          exports.headers = headers;

          var icons = __importStar(__nested_webpack_require_1022931__(
          /*! ./icons */
          "./icons.js"));

          var register = __importStar(__nested_webpack_require_1022931__(
          /*! ./register */
          "./register.js"));

          exports.register = register;

          var themes = __importStar(__nested_webpack_require_1022931__(
          /*! ./themes */
          "./themes.js"));

          exports.themes = themes;

          var tools = __importStar(__nested_webpack_require_1022931__(
          /*! ./tools */
          "./tools.js"));

          exports.tools = tools;

          var ListGrid_1 = __nested_webpack_require_1022931__(
          /*! ./ListGrid */
          "./ListGrid.js");

          Object.defineProperty(exports, "ListGrid", {
            enumerable: true,
            get: function get() {
              return ListGrid_1.ListGrid;
            }
          });

          var GridCanvasHelper_1 = __nested_webpack_require_1022931__(
          /*! ./GridCanvasHelper */
          "./GridCanvasHelper.js");

          Object.defineProperty(exports, "GridCanvasHelper", {
            enumerable: true,
            get: function get() {
              return GridCanvasHelper_1.GridCanvasHelper;
            }
          });

          var get_internal_1 = __nested_webpack_require_1022931__(
          /*! ./get-internal */
          "./get-internal.js");

          Object.defineProperty(exports, "_getInternal", {
            enumerable: true,
            get: function get() {
              return get_internal_1.getInternal;
            }
          });
          /** @private */

          function getIcons() {
            return icons.get();
          }

          exports.getIcons = getIcons; // backward compatibility

          exports.default = {
            core: core,
            tools: tools,
            // impl Grids
            ListGrid: ListGrid_1.ListGrid,
            // objects
            columns: columns,
            headers: headers,
            themes: themes,
            data: data,
            // helper
            GridCanvasHelper: GridCanvasHelper_1.GridCanvasHelper,
            //plugin registers
            register: register,

            get icons() {
              return getIcons();
            }

          }; // eslint-disable-next-line @typescript-eslint/no-explicit-any

          Object.defineProperty(themes, "default", {
            enumerable: false,
            configurable: true,
            get: function get() {
              return themes.getDefault();
            },
            set: function set(defaultTheme) {
              themes.setDefault(defaultTheme);
            }
          }); // eslint-disable-next-line @typescript-eslint/no-explicit-any

          Object.defineProperty(themes, "choices", {
            enumerable: false,
            configurable: true,
            get: function get() {
              return themes.getChoices();
            }
          });
          /***/
        },

        /***/
        "./plugins/icons.js":
        /*!**************************!*\
          !*** ./plugins/icons.js ***!
          \**************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function pluginsIconsJs(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.icons = void 0;
          exports.icons = {};
          /***/
        },

        /***/
        "./plugins/themes.js":
        /*!***************************!*\
          !*** ./plugins/themes.js ***!
          \***************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function pluginsThemesJs(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.themes = void 0;
          exports.themes = {};
          /***/
        },

        /***/
        "./register.js":
        /*!*********************!*\
          !*** ./register.js ***!
          \*********************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function registerJs(module, exports, __nested_webpack_require_1029658__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.icons = exports.icon = exports.theme = void 0;

          var icons_1 = __nested_webpack_require_1029658__(
          /*! ./plugins/icons */
          "./plugins/icons.js");

          var themes_1 = __nested_webpack_require_1029658__(
          /*! ./plugins/themes */
          "./plugins/themes.js");

          function register(obj, name, value) {
            var old = obj[name];
            obj[name] = value;
            return old;
          }

          function registers(obj, values) {
            for (var k in values) {
              obj[k] = values[k];
            }
          }

          function theme(name, theme) {
            if (theme != null) {
              return register(themes_1.themes, name, theme);
            } else {
              return themes_1.themes[name];
            }
          }

          exports.theme = theme;

          function icon(name, icon) {
            if (icon != null) {
              return register(icons_1.icons, name, icon);
            } else {
              return icons_1.icons[name];
            }
          }

          exports.icon = icon;

          function icons(icons) {
            return registers(icons_1.icons, icons);
          }

          exports.icons = icons;
          /***/
        },

        /***/
        "./themes.js":
        /*!*******************!*\
          !*** ./themes.js ***!
          \*******************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function themesJs(module, exports, __nested_webpack_require_1031367__) {
          "use strict";

          var __importDefault = this && this.__importDefault || function (mod) {
            return mod && mod.__esModule ? mod : {
              "default": mod
            };
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.getChoices = exports.setDefault = exports.getDefault = exports.of = exports.theme = exports.MATERIAL_DESIGN = exports.BASIC = void 0;

          var utils_1 = __nested_webpack_require_1031367__(
          /*! ./internal/utils */
          "./internal/utils.js");

          var theme_1 = __nested_webpack_require_1031367__(
          /*! ./themes/theme */
          "./themes/theme.js");

          var BASIC_1 = __importDefault(__nested_webpack_require_1031367__(
          /*! ./themes/BASIC */
          "./themes/BASIC.js"));

          var MATERIAL_DESIGN_1 = __importDefault(__nested_webpack_require_1031367__(
          /*! ./themes/MATERIAL_DESIGN */
          "./themes/MATERIAL_DESIGN.js"));

          var themes_1 = __nested_webpack_require_1031367__(
          /*! ./plugins/themes */
          "./plugins/themes.js");

          exports.BASIC = new theme_1.Theme(BASIC_1.default);
          exports.MATERIAL_DESIGN = new theme_1.Theme(MATERIAL_DESIGN_1.default);
          var builtin = {
            BASIC: exports.BASIC,
            MATERIAL_DESIGN: exports.MATERIAL_DESIGN
          };
          var defTheme = exports.MATERIAL_DESIGN;
          exports.theme = {
            Theme: theme_1.Theme
          };

          function of(value) {
            if (!value) {
              return null;
            }

            if (typeof value === "string") {
              var t = (0, utils_1.getIgnoreCase)(getChoices(), value);

              if (t) {
                return t;
              }

              return null;
            }

            if (value instanceof theme_1.Theme) {
              return value;
            }

            return new theme_1.Theme(value);
          }

          exports.of = of;

          function getDefault() {
            return defTheme;
          }

          exports.getDefault = getDefault;

          function setDefault(defaultTheme) {
            defTheme = of(defaultTheme) || defTheme;
          }

          exports.setDefault = setDefault;

          function getChoices() {
            return (0, utils_1.extend)(builtin, themes_1.themes);
          }

          exports.getChoices = getChoices;
          /***/
        },

        /***/
        "./themes/BASIC.js":
        /*!*************************!*\
          !*** ./themes/BASIC.js ***!
          \*************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function themesBASICJs(module, exports, __webpack_require__) {
          "use strict";
          /*eslint no-bitwise:0*/

          Object.defineProperty(exports, "__esModule", {
            value: true
          });

          function DEFAULT_BG_COLOR(args) {
            var row = args.row,
                grid = args.grid;

            if (row < grid.frozenRowCount) {
              return "#FFF";
            }

            var index = grid.getRecordIndexByRow(row);

            if (!(index & 1)) {
              return "#FFF";
            } else {
              return "#F6F6F6";
            }
          }

          var cacheLinearGradient = {};

          function getLinearGradient(context, left, top, right, bottom, colorStops) {
            var stop;
            var stopsKey = [];

            for (stop in colorStops) {
              stopsKey.push("".concat(stop, "@").concat(colorStops[stop]));
            }

            var key = "".concat(left, "/").concat(top, "/").concat(right, "/").concat(bottom, "/").concat(stopsKey.join(","));
            var ret = cacheLinearGradient[key];

            if (ret) {
              return ret;
            }

            var grad = context.createLinearGradient(left, top, left, bottom);

            for (stop in colorStops) {
              grad.addColorStop(Number(stop), colorStops[stop]);
            }

            return cacheLinearGradient[key] = grad;
          }

          function FROZEN_ROWS_BG_COLOR(args) {
            var col = args.col,
                grid = args.grid,
                frozenRowCount = args.grid.frozenRowCount,
                context = args.context;

            var _grid$getCellRelative = grid.getCellRelativeRect(col, 0),
                left = _grid$getCellRelative.left,
                top = _grid$getCellRelative.top;

            var _grid$getCellRelative2 = grid.getCellRelativeRect(col, frozenRowCount - 1),
                bottom = _grid$getCellRelative2.bottom;

            return getLinearGradient(context, left, top, left, bottom, {
              0: "#FFF",
              1: "#D3D3D3"
            });
          }
          /**
           * basic theme
           * @name BASIC
           * @memberof cheetahGrid.themes.choices
           */


          exports.default = {
            color: "#000",
            // frozenRowsColor: '#000',
            defaultBgColor: DEFAULT_BG_COLOR,
            frozenRowsBgColor: FROZEN_ROWS_BG_COLOR,
            selectionBgColor: "#CCE0FF",
            borderColor: "#000",
            // frozenRowsBorderColor: '#000',
            highlightBorderColor: "#5E9ED6",
            checkbox: {
              uncheckBgColor: "#FFF",
              checkBgColor: "rgb(76, 73, 72)",
              borderColor: "#000"
            },
            radioButton: {
              checkColor: "rgb(76, 73, 72)",
              checkBorderColor: "#000",
              uncheckBorderColor: "#000",
              uncheckBgColor: "#FFF",
              checkBgColor: "#FFF"
            },
            button: {
              color: "#FFF",
              bgColor: "#2196F3"
            },
            header: {
              sortArrowColor: "rgba(0, 0, 0, 0.38)"
            },
            indicators: {
              topLeftColor: "#000"
            },
            underlayBackgroundColor: "#F6F6F6"
          };
          /***/
        },

        /***/
        "./themes/MATERIAL_DESIGN.js":
        /*!***********************************!*\
          !*** ./themes/MATERIAL_DESIGN.js ***!
          \***********************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function themesMATERIAL_DESIGNJs(module, exports, __webpack_require__) {
          "use strict";
          /*eslint no-bitwise:0*/

          Object.defineProperty(exports, "__esModule", {
            value: true
          });

          function FROZEN_ROWS_BORDER_COLOR(args) {
            var row = args.row,
                frozenRowCount = args.grid.frozenRowCount;

            if (frozenRowCount - 1 === row) {
              return ["#f2f2f2", "#f2f2f2", "#ccc7c7", "#f2f2f2"];
            } else {
              return ["#f2f2f2"];
            }
          }

          function BORDER_COLOR(args) {
            var col = args.col,
                row = args.row,
                grid = args.grid;
            var colCount = grid.colCount,
                frozenColCount = grid.frozenColCount,
                recordRowCount = grid.recordRowCount;
            var top = "#ccc7c7";
            var bottom = "#ccc7c7";

            if (recordRowCount > 1) {
              var startRow = grid.getRecordStartRowByRecordIndex(grid.getRecordIndexByRow(row));
              var endRow = startRow + recordRowCount - 1;

              if (startRow !== row) {
                top = null;
              }

              if (endRow !== row) {
                bottom = null;
              }
            }

            if (frozenColCount - 1 === col) {
              return [top, "#f2f2f2", bottom, null];
            }

            if (colCount - 1 === col) {
              return [top, "#f2f2f2", bottom, null];
            }

            return [top, null, bottom, null];
          }
          /**
           * material design theme
           * @name MATERIAL_DESIGN
           * @memberof cheetahGrid.themes.choices
           */


          exports.default = {
            color: "rgba(0, 0, 0, 0.87)",
            frozenRowsColor: "rgba(0, 0, 0, 0.54)",
            defaultBgColor: "#FFF",
            // frozenRowsBgColor: '#FFF',
            selectionBgColor: "#CCE0FF",
            borderColor: BORDER_COLOR,
            frozenRowsBorderColor: FROZEN_ROWS_BORDER_COLOR,
            highlightBorderColor: "#5E9ED6",
            checkbox: {
              // uncheckBgColor: '#FFF',
              checkBgColor: "rgb(76, 73, 72)",
              borderColor: "rgba(0, 0, 0, 0.26)"
            },
            radioButton: {
              checkColor: "rgb(76, 73, 72)",
              checkBorderColor: "rgb(76, 73, 72)",
              uncheckBorderColor: "rgb(189, 189, 189)" // uncheckBgColor: "#FFF",
              // checkBgColor: "#FFF",

            },
            button: {
              color: "#FFF",
              bgColor: "#2196F3"
            },
            header: {
              sortArrowColor: "rgba(0, 0, 0, 0.38)"
            },
            indicators: {
              topLeftColor: "#ccc7c7"
            },
            underlayBackgroundColor: "#FFF"
          };
          /***/
        },

        /***/
        "./themes/theme.js":
        /*!*************************!*\
          !*** ./themes/theme.js ***!
          \*************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function themesThemeJs(module, exports, __nested_webpack_require_1041089__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.Theme = void 0;

          var utils_1 = __nested_webpack_require_1041089__(
          /*! ../internal/utils */
          "./internal/utils.js");

          var symbolManager_1 = __nested_webpack_require_1041089__(
          /*! ../internal/symbolManager */
          "./internal/symbolManager.js");

          var TreeColumn_1 = __nested_webpack_require_1041089__(
          /*! ../columns/type/TreeColumn */
          "./columns/type/TreeColumn.js"); //private symbol


          var _ = (0, symbolManager_1.get)();

          function getProp(obj, superObj, names, defNames, convertForSuper, defaultValue) {
            var value = (0, utils_1.getChainSafe).apply(void 0, [obj].concat(_toConsumableArray(names))) || (0, utils_1.getChainSafe).apply(void 0, [superObj].concat(_toConsumableArray(names)));

            if (value) {
              return value;
            }

            if (!defNames) {
              return value || defaultValue;
            }

            var getChainSafeWithConvert = convertForSuper ? function (obj) {
              for (var _len26 = arguments.length, names = new Array(_len26 > 1 ? _len26 - 1 : 0), _key27 = 1; _key27 < _len26; _key27++) {
                names[_key27 - 1] = arguments[_key27];
              }

              var value = (0, utils_1.getChainSafe).apply(void 0, [obj].concat(names));

              if (!value) {
                return value;
              }

              return convertForSuper(value);
            } : utils_1.getChainSafe;
            return getChainSafeWithConvert.apply(void 0, [obj].concat(_toConsumableArray(defNames))) || getChainSafeWithConvert.apply(void 0, [superObj].concat(_toConsumableArray(defNames))) || defaultValue;
          }

          var Theme = /*#__PURE__*/function () {
            function Theme(obj, superTheme) {
              _classCallCheck(this, Theme);

              this._checkbox = null;
              this._radioButton = null;
              this._button = null;
              this._tree = null;
              this._header = null;
              this._messages = null;
              this._indicators = null;
              this[_] = {
                obj: obj,
                superTheme: superTheme
              };
            }

            _createClass(Theme, [{
              key: "font",
              get: function get() {
                var _this$_3 = this[_],
                    obj = _this$_3.obj,
                    superTheme = _this$_3.superTheme;
                return getProp(obj, superTheme, ["font"]);
              }
            }, {
              key: "underlayBackgroundColor",
              get: function get() {
                var _this$_4 = this[_],
                    obj = _this$_4.obj,
                    superTheme = _this$_4.superTheme;
                return getProp(obj, superTheme, ["underlayBackgroundColor"]);
              } // color

            }, {
              key: "color",
              get: function get() {
                var _this$_5 = this[_],
                    obj = _this$_5.obj,
                    superTheme = _this$_5.superTheme;
                return getProp(obj, superTheme, ["color"]);
              }
            }, {
              key: "frozenRowsColor",
              get: function get() {
                var _this$_6 = this[_],
                    obj = _this$_6.obj,
                    superTheme = _this$_6.superTheme;
                return getProp(obj, superTheme, ["frozenRowsColor"], ["color"]);
              } // background

            }, {
              key: "defaultBgColor",
              get: function get() {
                var _this$_7 = this[_],
                    obj = _this$_7.obj,
                    superTheme = _this$_7.superTheme;
                return getProp(obj, superTheme, ["defaultBgColor"]);
              }
            }, {
              key: "frozenRowsBgColor",
              get: function get() {
                var _this$_8 = this[_],
                    obj = _this$_8.obj,
                    superTheme = _this$_8.superTheme;
                return getProp(obj, superTheme, ["frozenRowsBgColor"], ["defaultBgColor"]);
              }
            }, {
              key: "selectionBgColor",
              get: function get() {
                var _this$_9 = this[_],
                    obj = _this$_9.obj,
                    superTheme = _this$_9.superTheme;
                return getProp(obj, superTheme, ["selectionBgColor"], ["defaultBgColor"]);
              }
            }, {
              key: "highlightBgColor",
              get: function get() {
                var _this110 = this;

                if (this.hasProperty(["highlightBgColor"])) {
                  var _this$_10 = this[_],
                      obj = _this$_10.obj,
                      superTheme = _this$_10.superTheme;
                  return getProp(obj, superTheme, ["highlightBgColor"]);
                } // eslint-disable-next-line @typescript-eslint/no-explicit-any


                return function (args) {
                  var color = args.row < args.grid.frozenRowCount ? _this110.frozenRowsBgColor : _this110.defaultBgColor;

                  if (typeof color === "function") {
                    return color(args);
                  }

                  return color;
                };
              } // border

            }, {
              key: "borderColor",
              get: function get() {
                var _this$_11 = this[_],
                    obj = _this$_11.obj,
                    superTheme = _this$_11.superTheme;
                return getProp(obj, superTheme, ["borderColor"]);
              }
            }, {
              key: "frozenRowsBorderColor",
              get: function get() {
                var _this$_12 = this[_],
                    obj = _this$_12.obj,
                    superTheme = _this$_12.superTheme;
                return getProp(obj, superTheme, ["frozenRowsBorderColor"], ["borderColor"]);
              }
            }, {
              key: "highlightBorderColor",
              get: function get() {
                var _this$_13 = this[_],
                    obj = _this$_13.obj,
                    superTheme = _this$_13.superTheme;
                return getProp(obj, superTheme, ["highlightBorderColor"], ["borderColor"]);
              }
            }, {
              key: "checkbox",
              get: function get() {
                var _this$_14 = this[_],
                    obj = _this$_14.obj,
                    superTheme = _this$_14.superTheme;
                return this._checkbox || (this._checkbox = {
                  get uncheckBgColor() {
                    return getCheckboxProp("uncheckBgColor", ["defaultBgColor"]);
                  },

                  get checkBgColor() {
                    return getCheckboxProp("checkBgColor", ["borderColor"], colorsToColor, "#000");
                  },

                  get borderColor() {
                    return getCheckboxProp("borderColor", ["borderColor"], colorsToColor, "#000");
                  }

                });

                function getCheckboxProp(prop, defNames, convertForSuper, defaultValue) {
                  return getProp(obj, superTheme, ["checkbox", prop], defNames, convertForSuper, defaultValue);
                }
              }
            }, {
              key: "radioButton",
              get: function get() {
                var _this$_15 = this[_],
                    obj = _this$_15.obj,
                    superTheme = _this$_15.superTheme;
                return this._radioButton || (this._radioButton = {
                  get checkColor() {
                    return getRadioButtonProp("checkColor", ["color"]);
                  },

                  get uncheckBorderColor() {
                    return getRadioButtonProp("uncheckBorderColor", ["borderColor"], colorsToColor, "#000");
                  },

                  get checkBorderColor() {
                    return getRadioButtonProp("checkBorderColor", ["borderColor"], colorsToColor, "#000");
                  },

                  get uncheckBgColor() {
                    return getRadioButtonProp("uncheckBgColor", ["defaultBgColor"]);
                  },

                  get checkBgColor() {
                    return getRadioButtonProp("checkBgColor", ["defaultBgColor"]);
                  }

                });

                function getRadioButtonProp(prop, defNames, convertForSuper, defaultValue) {
                  return getProp(obj, superTheme, ["radioButton", prop], defNames, convertForSuper, defaultValue);
                }
              }
            }, {
              key: "button",
              get: function get() {
                var _this$_16 = this[_],
                    obj = _this$_16.obj,
                    superTheme = _this$_16.superTheme;
                return this._button || (this._button = {
                  get color() {
                    return getButtonProp("color", ["color"]);
                  },

                  get bgColor() {
                    return getButtonProp("bgColor", ["defaultBgColor"]);
                  }

                });

                function getButtonProp(prop, defNames) {
                  return getProp(obj, superTheme, ["button", prop], defNames);
                }
              }
            }, {
              key: "tree",
              get: function get() {
                var _this$_17 = this[_],
                    obj = _this$_17.obj,
                    superTheme = _this$_17.superTheme;
                return this._tree || (this._tree = {
                  get lineStyle() {
                    return getTreeProp("lineStyle", undefined, undefined, "solid");
                  },

                  get lineColor() {
                    return getTreeProp("lineColor", ["borderColor"], colorsToColor, "#0000");
                  },

                  get lineWidth() {
                    return getTreeProp("lineWidth", undefined, undefined, 1);
                  },

                  get treeIcon() {
                    return getTreeProp("treeIcon", undefined, undefined, function (args) {
                      var _ref85 = (0, TreeColumn_1.getTreeNodeInfoAt)(args),
                          hasChildren = _ref85.hasChildren,
                          nodeType = _ref85.nodeType;

                      if (hasChildren) {
                        return "expand_more";
                      }

                      return nodeType === "branch" ? "chevron_right" : "none";
                    });
                  }

                });

                function getTreeProp(prop, defNames, convertForSuper, defaultValue) {
                  return getProp(obj, superTheme, ["tree", prop], defNames, convertForSuper, defaultValue);
                }
              }
            }, {
              key: "header",
              get: function get() {
                var _this$_18 = this[_],
                    obj = _this$_18.obj,
                    superTheme = _this$_18.superTheme;
                return this._header || (this._header = {
                  get sortArrowColor() {
                    return getProp(obj, superTheme, ["header", "sortArrowColor"], ["color"]);
                  }

                });
              }
            }, {
              key: "messages",
              get: function get() {
                var _this$_19 = this[_],
                    obj = _this$_19.obj,
                    superTheme = _this$_19.superTheme;
                return this._messages || (this._messages = {
                  get infoBgColor() {
                    return getMessageProp("infoBgColor");
                  },

                  get errorBgColor() {
                    return getMessageProp("errorBgColor");
                  },

                  get warnBgColor() {
                    return getMessageProp("warnBgColor");
                  },

                  get boxWidth() {
                    return getMessageProp("boxWidth");
                  },

                  get markHeight() {
                    return getMessageProp("markHeight");
                  }

                });

                function getMessageProp(prop) {
                  return getProp(obj, superTheme, ["messages", prop]);
                }
              }
            }, {
              key: "indicators",
              get: function get() {
                var _this$_20 = this[_],
                    obj = _this$_20.obj,
                    superTheme = _this$_20.superTheme;
                return this._indicators || (this._indicators = {
                  get topLeftColor() {
                    return getIndicatorsProp("topLeftColor", ["borderColor"], colorsToColor, "#000");
                  },

                  get topLeftSize() {
                    return getIndicatorsProp("topLeftSize");
                  },

                  get topRightColor() {
                    return getIndicatorsProp("topRightColor", ["borderColor"], colorsToColor, "#000");
                  },

                  get topRightSize() {
                    return getIndicatorsProp("topRightSize");
                  },

                  get bottomRightColor() {
                    return getIndicatorsProp("bottomRightColor", ["borderColor"], colorsToColor, "#000");
                  },

                  get bottomRightSize() {
                    return getIndicatorsProp("bottomRightSize");
                  },

                  get bottomLeftColor() {
                    return getIndicatorsProp("bottomLeftColor", ["borderColor"], colorsToColor, "#000");
                  },

                  get bottomLeftSize() {
                    return getIndicatorsProp("bottomLeftSize");
                  }

                });

                function getIndicatorsProp(prop, defNames, convertForSuper, defaultValue) {
                  return getProp(obj, superTheme, ["indicators", prop], defNames, convertForSuper, defaultValue);
                }
              }
            }, {
              key: "hasProperty",
              value: function hasProperty(names) {
                var _this$_21 = this[_],
                    obj = _this$_21.obj,
                    superTheme = _this$_21.superTheme;
                return hasThemeProperty(obj, names) || hasThemeProperty(superTheme, names);
              }
            }, {
              key: "extends",
              value: function _extends(obj) {
                return new Theme(obj, this);
              }
            }]);

            return Theme;
          }();

          exports.Theme = Theme;

          function hasThemeProperty(obj, names) {
            if (obj instanceof Theme) {
              return obj.hasProperty(names);
            } else {
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              var o = obj;

              if (!o) {
                return false;
              }

              for (var index = 0; index < names.length; index++) {
                var name = names[index];
                o = o[name];

                if (!o) {
                  return false;
                }
              }

              return !!o;
            }
          }

          function colorsToColor(colors) {
            if (typeof colors === "function") {
              return function (arg) {
                var val = colors(arg);
                return val ? colorsArrayToColor(val) : val;
              };
            }

            return colorsArrayToColor(colors);

            function colorsArrayToColor( // eslint-disable-next-line @typescript-eslint/ban-types
            colors) {
              if (!Array.isArray(colors)) {
                return colors;
              }

              return colors.find(Boolean) || undefined;
            }
          }
          /***/

        },

        /***/
        "./tools.js":
        /*!******************!*\
          !*** ./tools.js ***!
          \******************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function toolsJs(module, exports, __nested_webpack_require_1057444__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.canvashelper = void 0;

          var canvashelper = __importStar(__nested_webpack_require_1057444__(
          /*! ./tools/canvashelper */
          "./tools/canvashelper.js"));

          exports.canvashelper = canvashelper;
          /***/
        },

        /***/
        "./tools/canvashelper.js":
        /*!*******************************!*\
          !*** ./tools/canvashelper.js ***!
          \*******************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function toolsCanvashelperJs(module, exports, __nested_webpack_require_1059597__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.drawButton = exports.drawRadioButton = exports.drawCheckbox = exports.measureRadioButton = exports.measureCheckbox = exports.drawInlineImageRect = exports.fillTextRect = exports.strokeCircle = exports.fillCircle = exports.strokeRoundRect = exports.fillRoundRect = exports.roundRect = exports.strokeColorsRect = void 0;

          var canvases_1 = __nested_webpack_require_1059597__(
          /*! ../internal/canvases */
          "./internal/canvases.js");

          var ceil = Math.ceil,
              PI = Math.PI;

          function strokeColorsRect(ctx, borderColors, left, top, width, height) {
            function strokeRectLines(positions) {
              for (var i = 0; i < borderColors.length; i++) {
                var color = borderColors[i];
                var _preColor = borderColors[i - 1];

                if (color) {
                  if (_preColor !== color) {
                    if (_preColor) {
                      ctx.strokeStyle = _preColor;
                      ctx.stroke();
                    }

                    var pos1 = positions[i];
                    ctx.beginPath();
                    ctx.moveTo(pos1.x, pos1.y);
                  }

                  var pos2 = positions[i + 1];
                  ctx.lineTo(pos2.x, pos2.y);
                } else {
                  if (_preColor) {
                    ctx.strokeStyle = _preColor;
                    ctx.stroke();
                  }
                }
              }

              var preColor = borderColors[borderColors.length - 1];

              if (preColor) {
                ctx.strokeStyle = preColor;
                ctx.stroke();
              }
            }

            if (borderColors[0] === borderColors[1] && borderColors[0] === borderColors[2] && borderColors[0] === borderColors[3]) {
              if (borderColors[0]) {
                ctx.strokeStyle = borderColors[0];
                ctx.strokeRect(left, top, width, height);
              }
            } else {
              strokeRectLines([{
                x: left,
                y: top
              }, {
                x: left + width,
                y: top
              }, {
                x: left + width,
                y: top + height
              }, {
                x: left,
                y: top + height
              }, {
                x: left,
                y: top
              }]);
            }
          }

          exports.strokeColorsRect = strokeColorsRect;

          function roundRect(ctx, left, top, width, height, radius) {
            ctx.beginPath();
            ctx.arc(left + radius, top + radius, radius, -PI, -0.5 * PI, false);
            ctx.arc(left + width - radius, top + radius, radius, -0.5 * PI, 0, false);
            ctx.arc(left + width - radius, top + height - radius, radius, 0, 0.5 * PI, false);
            ctx.arc(left + radius, top + height - radius, radius, 0.5 * PI, PI, false);
            ctx.closePath();
          }

          exports.roundRect = roundRect;

          function fillRoundRect(ctx, left, top, width, height, radius) {
            roundRect(ctx, left, top, width, height, radius);
            ctx.fill();
          }

          exports.fillRoundRect = fillRoundRect;

          function strokeRoundRect(ctx, left, top, width, height, radius) {
            roundRect(ctx, left, top, width, height, radius);
            ctx.stroke();
          }

          exports.strokeRoundRect = strokeRoundRect;

          function fillCircle(ctx, left, top, width, height) {
            var min = Math.min(width, height) / 2;
            ctx.beginPath();
            ctx.arc(left + min, top + min, min, 0, 2 * Math.PI);
            ctx.closePath();
            ctx.fill();
          }

          exports.fillCircle = fillCircle;

          function strokeCircle(ctx, left, top, width, height) {
            var min = Math.min(width, height) / 2;
            ctx.beginPath();
            ctx.arc(left + min, top + min, min, 0, 2 * Math.PI);
            ctx.closePath();
            ctx.stroke();
          }

          exports.strokeCircle = strokeCircle;

          function fillTextRect(ctx, text, left, top, width, height) {
            var _ref86 = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {},
                _ref86$offset = _ref86.offset,
                offset = _ref86$offset === void 0 ? 2 : _ref86$offset,
                padding = _ref86.padding;

            var rect = {
              left: left,
              top: top,
              width: width,
              height: height,
              right: left + width,
              bottom: top + height
            };
            ctx.save();

            try {
              ctx.beginPath();
              ctx.rect(rect.left, rect.top, rect.width, rect.height); //clip

              ctx.clip(); //

              var pos = (0, canvases_1.calcBasePosition)(ctx, rect, {
                offset: offset,
                padding: padding
              });
              ctx.fillText(text, pos.x, pos.y);
            } finally {
              ctx.restore();
            }
          }

          exports.fillTextRect = fillTextRect;

          function drawInlineImageRect(ctx, image, srcLeft, srcTop, srcWidth, srcHeight, destWidth, destHeight, left, top, width, height) {
            var _ref87 = arguments.length > 12 && arguments[12] !== undefined ? arguments[12] : {},
                _ref87$offset = _ref87.offset,
                offset = _ref87$offset === void 0 ? 2 : _ref87$offset,
                padding = _ref87.padding;

            var rect = {
              left: left,
              top: top,
              width: width,
              height: height,
              right: left + width,
              bottom: top + height
            };
            ctx.save();

            try {
              ctx.beginPath();
              ctx.rect(rect.left, rect.top, rect.width, rect.height); //clip

              ctx.clip(); //

              var pos = (0, canvases_1.calcStartPosition)(ctx, rect, destWidth, destHeight, {
                offset: offset,
                padding: padding
              });
              ctx.drawImage(image, srcLeft, srcTop, srcWidth, srcHeight, pos.x, pos.y, destWidth, destHeight);
            } finally {
              ctx.restore();
            }
          }

          exports.drawInlineImageRect = drawInlineImageRect;
          /**
           * Returns an object containing the width of the checkbox.
           * @param  {CanvasRenderingContext2D} ctx canvas context
           * @return {Object} Object containing the width of the checkbox
           * @memberof cheetahGrid.tools.canvashelper
           */

          function measureCheckbox(ctx) {
            return {
              width: (0, canvases_1.getFontSize)(ctx, null).width
            };
          }

          exports.measureCheckbox = measureCheckbox;
          /**
           * Returns an object containing the width of the radio button.
           * @param  {CanvasRenderingContext2D} ctx canvas context
           * @return {Object} Object containing the width of the radio button
           * @memberof cheetahGrid.tools.canvashelper
           */

          function measureRadioButton(ctx) {
            return {
              width: (0, canvases_1.getFontSize)(ctx, null).width
            };
          }

          exports.measureRadioButton = measureRadioButton;
          /**
           * draw Checkbox
           * @param  {CanvasRenderingContext2D} ctx canvas context
           * @param  {number} x The x coordinate where to start drawing the checkbox (relative to the canvas)
           * @param  {number} y The y coordinate where to start drawing the checkbox (relative to the canvas)
           * @param  {boolean|number} check checkbox check status
           * @param  {object} option option
           * @return {void}
           * @memberof cheetahGrid.tools.canvashelper
           */

          function drawCheckbox(ctx, x, y, check) {
            var _ref88 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {},
                _ref88$uncheckBgColor = _ref88.uncheckBgColor,
                uncheckBgColor = _ref88$uncheckBgColor === void 0 ? "#FFF" : _ref88$uncheckBgColor,
                _ref88$checkBgColor = _ref88.checkBgColor,
                checkBgColor = _ref88$checkBgColor === void 0 ? "rgb(76, 73, 72)" : _ref88$checkBgColor,
                _ref88$borderColor = _ref88.borderColor,
                borderColor = _ref88$borderColor === void 0 ? "#000" : _ref88$borderColor,
                _ref88$boxSize = _ref88.boxSize,
                boxSize = _ref88$boxSize === void 0 ? measureCheckbox(ctx).width : _ref88$boxSize;

            var checkPoint = typeof check === "number" ? check > 1 ? 1 : check : 1;
            ctx.save();

            try {
              ctx.fillStyle = check ? checkBgColor : uncheckBgColor;
              var leftX = ceil(x);
              var topY = ceil(y);
              var size = ceil(boxSize);
              fillRoundRect(ctx, leftX - 1, topY - 1, size + 1, size + 1, boxSize / 5);
              ctx.lineWidth = 1;
              ctx.strokeStyle = borderColor;
              strokeRoundRect(ctx, leftX - 0.5, topY - 0.5, size, size, boxSize / 5);

              if (check) {
                ctx.lineWidth = ceil(boxSize / 10);
                ctx.strokeStyle = uncheckBgColor;
                var leftWidth = boxSize / 4;
                var rightWidth = boxSize / 2 * 0.9;
                var leftLeftPos = x + boxSize * 0.2;
                var leftTopPos = y + boxSize / 2;

                if (checkPoint < 0.5) {
                  leftWidth *= checkPoint * 2;
                }

                ctx.beginPath();
                ctx.moveTo(leftLeftPos, leftTopPos);
                ctx.lineTo(leftLeftPos + leftWidth, leftTopPos + leftWidth);

                if (checkPoint > 0.5) {
                  if (checkPoint < 1) {
                    rightWidth *= (checkPoint - 0.5) * 2;
                  }

                  ctx.lineTo(leftLeftPos + leftWidth + rightWidth, leftTopPos + leftWidth - rightWidth);
                }

                ctx.stroke();
              }
            } finally {
              ctx.restore();
            }
          }

          exports.drawCheckbox = drawCheckbox;
          /**
           * draw Radio button
           * @param  {CanvasRenderingContext2D} ctx canvas context
           * @param  {number} x The x coordinate where to start drawing the radio button (relative to the canvas)
           * @param  {number} y The y coordinate where to start drawing the radio button (relative to the canvas)
           * @param  {boolean|number} check radio button check status
           * @param  {object} option option
           * @return {void}
           * @memberof cheetahGrid.tools.canvashelper
           */

          function drawRadioButton(ctx, x, y, check) {
            var _ref89 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {},
                _ref89$checkColor = _ref89.checkColor,
                checkColor = _ref89$checkColor === void 0 ? "rgb(76, 73, 72)" : _ref89$checkColor,
                _ref89$borderColor = _ref89.borderColor,
                borderColor = _ref89$borderColor === void 0 ? "#000" : _ref89$borderColor,
                _ref89$bgColor = _ref89.bgColor,
                bgColor = _ref89$bgColor === void 0 ? "#FFF" : _ref89$bgColor,
                _ref89$boxSize = _ref89.boxSize,
                boxSize = _ref89$boxSize === void 0 ? measureRadioButton(ctx).width : _ref89$boxSize;

            var ratio = typeof check === "number" ? check > 1 ? 1 : check : 1;
            ctx.save();

            try {
              ctx.fillStyle = bgColor;
              var leftX = ceil(x);
              var topY = ceil(y);
              var size = ceil(boxSize);
              fillCircle(ctx, leftX - 1, topY - 1, size + 1, size + 1);
              ctx.lineWidth = 1;
              ctx.strokeStyle = borderColor;
              strokeCircle(ctx, leftX - 0.5, topY - 0.5, size, size);

              if (check) {
                var checkSize = size * ratio / 2;
                var padding = (size - checkSize) / 2;
                ctx.fillStyle = checkColor;
                fillCircle(ctx, ceil((leftX - 0.5 + padding) * 100) / 100, ceil((topY - 0.5 + padding) * 100) / 100, ceil(checkSize * 100) / 100, ceil(checkSize * 100) / 100);
              }
            } finally {
              ctx.restore();
            }
          }

          exports.drawRadioButton = drawRadioButton;
          /**
           * draw Button
           */

          function drawButton(ctx, left, top, width, height) {
            var option = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};
            var _option$backgroundCol = option.backgroundColor,
                backgroundColor = _option$backgroundCol === void 0 ? "#FFF" : _option$backgroundCol,
                _option$bgColor = option.bgColor,
                bgColor = _option$bgColor === void 0 ? backgroundColor : _option$bgColor,
                _option$radius = option.radius,
                radius = _option$radius === void 0 ? 4 : _option$radius,
                _option$shadow = option.shadow,
                shadow = _option$shadow === void 0 ? {} : _option$shadow;
            ctx.save();

            try {
              ctx.fillStyle = bgColor;

              if (shadow) {
                var _shadow$color = shadow.color,
                    color = _shadow$color === void 0 ? "rgba(0, 0, 0, 0.24)" : _shadow$color,
                    _shadow$blur = shadow.blur,
                    blur = _shadow$blur === void 0 ? 1 : _shadow$blur,
                    _shadow$offsetX = shadow.offsetX,
                    offsetX = _shadow$offsetX === void 0 ? 0 : _shadow$offsetX,
                    _shadow$offsetY = shadow.offsetY,
                    offsetY = _shadow$offsetY === void 0 ? 2 : _shadow$offsetY,
                    _shadow$offset = shadow.offset;
                _shadow$offset = _shadow$offset === void 0 ? {} : _shadow$offset;
                var _shadow$offset$x = _shadow$offset.x,
                    ox = _shadow$offset$x === void 0 ? offsetX : _shadow$offset$x,
                    _shadow$offset$y = _shadow$offset.y,
                    oy = _shadow$offset$y === void 0 ? offsetY : _shadow$offset$y;
                ctx.shadowColor = color;
                ctx.shadowBlur = blur; //

                ctx.shadowOffsetX = ox;
                ctx.shadowOffsetY = oy;
              }

              fillRoundRect(ctx, ceil(left), ceil(top), ceil(width), ceil(height), radius);
            } finally {
              ctx.restore();
            }
          }

          exports.drawButton = drawButton;
          /***/
        },

        /***/
        "./tooltip/BaseTooltip.js":
        /*!********************************!*\
          !*** ./tooltip/BaseTooltip.js ***!
          \********************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function tooltipBaseTooltipJs(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.BaseTooltip = void 0;

          var BaseTooltip = /*#__PURE__*/function () {
            function BaseTooltip(grid) {
              _classCallCheck(this, BaseTooltip);

              this._grid = grid;
            }

            _createClass(BaseTooltip, [{
              key: "dispose",
              value: function dispose() {
                this.detachTooltipElement();

                if (this._tooltipElement) {
                  this._tooltipElement.dispose();
                }

                this._tooltipElement = undefined;
              }
            }, {
              key: "_getTooltipElement",
              value: function _getTooltipElement() {
                if (this._tooltipElement) {
                  return this._tooltipElement;
                }

                return this._tooltipElement = this.createTooltipElementInternal();
              }
            }, {
              key: "attachTooltipElement",
              value: function attachTooltipElement(col, row, content) {
                var tooltipElement = this._getTooltipElement();

                tooltipElement.attach(this._grid, col, row, content);
              }
            }, {
              key: "moveTooltipElement",
              value: function moveTooltipElement(col, row) {
                var tooltipElement = this._getTooltipElement();

                tooltipElement.move(this._grid, col, row);
              }
            }, {
              key: "detachTooltipElement",
              value: function detachTooltipElement() {
                var tooltipElement = this._getTooltipElement();

                tooltipElement._detach();
              }
            }]);

            return BaseTooltip;
          }();

          exports.BaseTooltip = BaseTooltip;
          /***/
        },

        /***/
        "./tooltip/Tooltip.js":
        /*!****************************!*\
          !*** ./tooltip/Tooltip.js ***!
          \****************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function tooltipTooltipJs(module, exports, __nested_webpack_require_1077309__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.Tooltip = void 0;

          var BaseTooltip_1 = __nested_webpack_require_1077309__(
          /*! ./BaseTooltip */
          "./tooltip/BaseTooltip.js");

          var TooltipElement_1 = __nested_webpack_require_1077309__(
          /*! ./internal/TooltipElement */
          "./tooltip/internal/TooltipElement.js");

          var Tooltip = /*#__PURE__*/function (_BaseTooltip_1$BaseTo) {
            _inherits(Tooltip, _BaseTooltip_1$BaseTo);

            var _super75 = _createSuper(Tooltip);

            function Tooltip() {
              _classCallCheck(this, Tooltip);

              return _super75.apply(this, arguments);
            }

            _createClass(Tooltip, [{
              key: "createTooltipElementInternal",
              value: function createTooltipElementInternal() {
                return new TooltipElement_1.TooltipElement();
              }
            }]);

            return Tooltip;
          }(BaseTooltip_1.BaseTooltip);

          exports.Tooltip = Tooltip;
          /***/
        },

        /***/
        "./tooltip/TooltipHandler.js":
        /*!***********************************!*\
          !*** ./tooltip/TooltipHandler.js ***!
          \***********************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function tooltipTooltipHandlerJs(module, exports, __nested_webpack_require_1078861__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.TooltipHandler = void 0;

          var LG_EVENT_TYPE_1 = __nested_webpack_require_1078861__(
          /*! ../list-grid/LG_EVENT_TYPE */
          "./list-grid/LG_EVENT_TYPE.js");

          var Tooltip_1 = __nested_webpack_require_1078861__(
          /*! ./Tooltip */
          "./tooltip/Tooltip.js");

          var utils_1 = __nested_webpack_require_1078861__(
          /*! ../internal/utils */
          "./internal/utils.js");

          var TOOLTIP_INSTANCE_FACTORY = {
            "overflow-text": function overflowText(grid) {
              return new Tooltip_1.Tooltip(grid);
            }
          };

          function getTooltipInstanceInfo( // eslint-disable-next-line @typescript-eslint/no-explicit-any
          grid, col, row) {
            //
            // overflow text tooltip
            var overflowText = grid.getCellOverflowText(col, row);

            if (overflowText) {
              return {
                type: "overflow-text",
                content: overflowText
              };
            }

            return null;
          }

          var TooltipHandler = /*#__PURE__*/function () {
            function TooltipHandler(grid) {
              _classCallCheck(this, TooltipHandler);

              this._grid = grid;
              this._tooltipInstances = {};

              this._bindGridEvent(grid);
            }

            _createClass(TooltipHandler, [{
              key: "dispose",
              value: function dispose() {
                var tooltipInstances = this._tooltipInstances;

                for (var k in tooltipInstances) {
                  tooltipInstances[k].dispose();
                } // @ts-expect-error -- ignore


                delete this._tooltipInstances;
                this._attachInfo = null;
              }
            }, {
              key: "_attach",
              value: function _attach(col, row) {
                var info = this._attachInfo;

                var instanceInfo = this._getTooltipInstanceInfo(col, row);

                if (info && (!instanceInfo || info.instance !== instanceInfo.instance)) {
                  info.instance.detachTooltipElement();
                  this._attachInfo = null;
                }

                if (!instanceInfo) {
                  return;
                }

                var instance = instanceInfo.instance;
                instance.attachTooltipElement(col, row, instanceInfo.content);

                var range = this._grid.getCellRange(col, row);

                this._attachInfo = {
                  range: range,
                  instance: instance
                };
              }
            }, {
              key: "_move",
              value: function _move(col, row) {
                var info = this._attachInfo;

                if (!info || !(0, utils_1.cellInRange)(info.range, col, row)) {
                  return;
                }

                var instance = info.instance;
                instance.moveTooltipElement(col, row);
              }
            }, {
              key: "_detach",
              value: function _detach() {
                var info = this._attachInfo;

                if (!info) {
                  return;
                }

                var instance = info.instance;
                instance.detachTooltipElement();
                this._attachInfo = null;
              }
            }, {
              key: "_isAttachCell",
              value: function _isAttachCell(col, row) {
                var info = this._attachInfo;

                if (!info) {
                  return false;
                }

                return (0, utils_1.cellInRange)(info.range, col, row);
              }
            }, {
              key: "_bindGridEvent",
              value: function _bindGridEvent(grid) {
                var _this111 = this;

                grid.listen(LG_EVENT_TYPE_1.LG_EVENT_TYPE.MOUSEOVER_CELL, function (e) {
                  if (e.related) {
                    if (_this111._isAttachCell(e.col, e.row)) {
                      return;
                    }
                  }

                  _this111._attach(e.col, e.row);
                });
                grid.listen(LG_EVENT_TYPE_1.LG_EVENT_TYPE.MOUSEOUT_CELL, function (e) {
                  if (e.related) {
                    if (_this111._isAttachCell(e.related.col, e.related.row)) {
                      return;
                    }
                  }

                  _this111._detach();
                });
                grid.listen(LG_EVENT_TYPE_1.LG_EVENT_TYPE.SELECTED_CELL, function (e) {
                  if (_this111._isAttachCell(e.col, e.row)) {
                    _this111._detach();
                  }
                });
                grid.listen(LG_EVENT_TYPE_1.LG_EVENT_TYPE.SCROLL, function () {
                  var info = _this111._attachInfo;

                  if (!info) {
                    return;
                  }

                  _this111._move(info.range.start.col, info.range.start.row);
                });
                grid.listen(LG_EVENT_TYPE_1.LG_EVENT_TYPE.CHANGED_VALUE, function (e) {
                  if (_this111._isAttachCell(e.col, e.row)) {
                    _this111._detach();

                    _this111._attach(e.col, e.row);
                  }
                });
              }
            }, {
              key: "_getTooltipInstanceInfo",
              value: function _getTooltipInstanceInfo(col, row) {
                var grid = this._grid;
                var tooltipInstances = this._tooltipInstances;
                var info = getTooltipInstanceInfo(grid, col, row);

                if (!info) {
                  return null;
                }

                var type = info.type;
                var instance = tooltipInstances[type] || (tooltipInstances[type] = TOOLTIP_INSTANCE_FACTORY[type](grid));
                return {
                  instance: instance,
                  type: type,
                  content: info.content
                };
              }
            }]);

            return TooltipHandler;
          }();

          exports.TooltipHandler = TooltipHandler;
          /***/
        },

        /***/
        "./tooltip/internal/TooltipElement.js":
        /*!********************************************!*\
          !*** ./tooltip/internal/TooltipElement.js ***!
          \********************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function tooltipInternalTooltipElementJs(module, exports, __nested_webpack_require_1085623__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.TooltipElement = void 0;

          var EventHandler_1 = __nested_webpack_require_1085623__(
          /*! ../../internal/EventHandler */
          "./internal/EventHandler.js");

          var dom_1 = __nested_webpack_require_1085623__(
          /*! ../../internal/dom */
          "./internal/dom.js");

          var CLASSNAME = "cheetah-grid__tooltip-element";
          var CONTENT_CLASSNAME = "".concat(CLASSNAME, "__content");
          var HIDDEN_CLASSNAME = "".concat(CLASSNAME, "--hidden");
          var SHOWN_CLASSNAME = "".concat(CLASSNAME, "--shown");

          function createTooltipDomElement() {
            __nested_webpack_require_1085623__(
            /*! @/tooltip/internal/TooltipElement.css */
            "../src/js/tooltip/internal/TooltipElement.css");

            var rootElement = (0, dom_1.createElement)("div", {
              classList: [CLASSNAME, HIDDEN_CLASSNAME]
            });
            var messageElement = (0, dom_1.createElement)("pre", {
              classList: [CONTENT_CLASSNAME]
            });
            rootElement.appendChild(messageElement);
            return rootElement;
          }

          var TooltipElement = /*#__PURE__*/function () {
            function TooltipElement() {
              _classCallCheck(this, TooltipElement);

              this._handler = new EventHandler_1.EventHandler();
              var rootElement = this._rootElement = createTooltipDomElement();
              this._messageElement = rootElement.querySelector(".".concat(CONTENT_CLASSNAME));
            }

            _createClass(TooltipElement, [{
              key: "dispose",
              value: function dispose() {
                this.detach();
                var rootElement = this._rootElement;

                if (rootElement.parentElement) {
                  rootElement.parentElement.removeChild(rootElement);
                }

                this._handler.dispose(); // @ts-expect-error -- ignore


                delete this._rootElement; // @ts-expect-error -- ignore

                delete this._messageElement;
              }
            }, {
              key: "attach",
              value: function attach(grid, col, row, content) {
                var rootElement = this._rootElement;
                var messageElement = this._messageElement;
                rootElement.classList.remove(SHOWN_CLASSNAME);
                rootElement.classList.add(HIDDEN_CLASSNAME);

                if (this._attachCell(grid, col, row)) {
                  rootElement.classList.add(SHOWN_CLASSNAME);
                  rootElement.classList.remove(HIDDEN_CLASSNAME);
                  messageElement.textContent = content;
                } else {
                  this._detach();
                }
              }
            }, {
              key: "move",
              value: function move(grid, col, row) {
                var rootElement = this._rootElement;

                if (this._attachCell(grid, col, row)) {
                  rootElement.classList.add(SHOWN_CLASSNAME);
                  rootElement.classList.remove(HIDDEN_CLASSNAME);
                } else {
                  this._detach();
                }
              }
            }, {
              key: "detach",
              value: function detach() {
                this._detach();
              }
            }, {
              key: "_detach",
              value: function _detach() {
                var rootElement = this._rootElement;

                if (rootElement.parentElement) {
                  // rootElement.parentElement.removeChild(rootElement);
                  rootElement.classList.remove(SHOWN_CLASSNAME);
                  rootElement.classList.add(HIDDEN_CLASSNAME);
                }
              }
            }, {
              key: "_attachCell",
              value: function _attachCell(grid, col, row) {
                var rootElement = this._rootElement;

                var _grid$getAttachCellsA8 = grid.getAttachCellsArea(grid.getCellRange(col, row)),
                    element = _grid$getAttachCellsA8.element,
                    rect = _grid$getAttachCellsA8.rect;

                var top = rect.bottom,
                    left = rect.left,
                    width = rect.width;
                var frozenRowCount = grid.frozenRowCount,
                    frozenColCount = grid.frozenColCount;

                if (row >= frozenRowCount && frozenRowCount > 0) {
                  var _grid$getAttachCellsA9 = grid.getAttachCellsArea(grid.getCellRange(col, frozenRowCount - 1)),
                      frozenRect = _grid$getAttachCellsA9.rect;

                  if (top < frozenRect.bottom) {
                    return false; //
                  }
                } else {
                  if (top < 0) {
                    return false; //
                  }
                }

                if (col >= frozenColCount && frozenColCount > 0) {
                  var _grid$getAttachCellsA10 = grid.getAttachCellsArea(grid.getCellRange(frozenColCount - 1, row)),
                      _frozenRect5 = _grid$getAttachCellsA10.rect;

                  if (left < _frozenRect5.right) {
                    return false; //
                  }
                } else {
                  if (left < 0) {
                    return false; //
                  }
                }

                var _element$getBoundingC = element.getBoundingClientRect(),
                    offsetHeight = _element$getBoundingC.height,
                    offsetWidth = _element$getBoundingC.width,
                    elementLeft = _element$getBoundingC.left,
                    elementRight = _element$getBoundingC.right;

                if (offsetHeight < top) {
                  return false; //
                }

                if (offsetWidth < left) {
                  return false; //
                }

                var cellCenter = left + width / 2;
                rootElement.style.top = "".concat(top.toFixed(), "px");
                rootElement.style.left = "".concat(cellCenter.toFixed(), "px");
                rootElement.style.minWidth = "".concat(width.toFixed(), "px");
                var maxWidthForLeft = (elementLeft + cellCenter) * 2;
                var winWidth = window.innerWidth;
                var maxWidthForRight = (offsetWidth - cellCenter + (winWidth - elementRight)) * 2;
                var maxWidth = Math.min(maxWidthForLeft, maxWidthForRight);
                rootElement.style.maxWidth = "".concat(maxWidth.toFixed(), "px");

                if (rootElement.parentElement !== element) {
                  element.appendChild(rootElement);
                }

                return true;
              }
            }]);

            return TooltipElement;
          }();

          exports.TooltipElement = TooltipElement;
          /***/
        }
        /******/

      })
    );
  });
}).call(typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : window, typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : window);
})();
//# sourceMappingURL=cheetahGrid.es5.js.map

/***/ }),

/***/ "./srcjs/modules/utils.js":
/*!********************************!*\
  !*** ./srcjs/modules/utils.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   combineColumnsAndGroups: () => (/* binding */ combineColumnsAndGroups)
/* harmony export */ });
function combineColumnsAndGroups(columnsList, colGroups) {
    // 1. Build a lookup by field
    const colsByField = {};
    columnsList.forEach(col => {
      colsByField[col.field] = col;
    });
  
    // 2. Find each group's first member and all members
    const groupFirst   = colGroups.map(g => g.columns[0]);
    const groupMembers = colGroups.reduce((acc, g) => acc.concat(g.columns), []);
  
    const result = [];
  
    // 3. Iterate in original order
    columnsList.forEach(col => {
      const f = col.field;
      const gi = groupFirst.indexOf(f);
  
      if (gi !== -1) {
        // this is the first field of group gi  emit the group
        const grp = colGroups[gi];
  
        // build nested column definitions
        const nested = grp.columns.map(fieldName => colsByField[fieldName]);
  
        // extract everything except `columns` from grp
        const { columns, ...grpMeta } = grp;
  
        result.push({ ...grpMeta, columns: nested });
  
      } else if (groupMembers.includes(f)) {
        // a member of some group but not its first  skip
  
      } else {
        // standalone column
        result.push(colsByField[f]);
      }
    });
  
    return result;
  }
  
  

/***/ }),

/***/ "widgets":
/*!******************************!*\
  !*** external "HTMLWidgets" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = HTMLWidgets;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
(() => {
"use strict";
/*!**********************************!*\
  !*** ./srcjs/widgets/cheetah.js ***!
  \**********************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var widgets__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! widgets */ "widgets");
/* harmony import */ var widgets__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(widgets__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _modules_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../modules/utils.js */ "./srcjs/modules/utils.js");
/* harmony import */ var cheetah_grid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheetah-grid */ "./node_modules/cheetah-grid/dist/cheetahGrid.es5.js");
/* harmony import */ var cheetah_grid__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(cheetah_grid__WEBPACK_IMPORTED_MODULE_2__);




HTMLWidgets.widget({

  name: 'cheetah',

  type: 'output',

  factory: function (el, width, height) {

    let id = el.id;

    return {

      renderValue: function (x, id = el.id) {
        let columns;
        const header = Object.keys(x.data[0])
        const defaultCol = header.map((key) => {
          return ({ field: key, caption: key, width: 'auto' });
        });

        if (x.columns !== null) {
          // Create a lookup map from user input
          const userMap = Object.fromEntries(x.columns.map(item => [item.field, item]));

          // Merge user input values into defaultCol
          columns = defaultCol.map(item => ({
            ...item,
            ...(userMap[item.field] || {})
          }));

          // Iterate over the list and process the `action` property if it is not null or undefined
          columns.forEach((obj) => {
            if (obj.action != null) {  // Checks for both null and undefined
              if (obj.action.type === "inline_menu") {
                obj.columnType = new cheetah_grid__WEBPACK_IMPORTED_MODULE_2__.columns.type.MenuColumn({
                  options: obj.action.options,
                });

                obj.action = new cheetah_grid__WEBPACK_IMPORTED_MODULE_2__.columns.action.InlineMenuEditor({
                  options: obj.action.options,
                });
              }
            }
          });

        } else {
          columns = defaultCol;
        }

        if (x.colGroup !== null) {
          columns = (0,_modules_utils_js__WEBPACK_IMPORTED_MODULE_1__.combineColumnsAndGroups)(columns, x.colGroup);
        }

        const grid = new cheetah_grid__WEBPACK_IMPORTED_MODULE_2__.ListGrid({
          parentElement: document.getElementById(id),
          header: columns,
          // Column fixed position
          // frozenColCount: 1,
        });

        // Search feature
        if (x.search !== 'disabled') {
          const filterDataSource = new cheetah_grid__WEBPACK_IMPORTED_MODULE_2__.data
            .FilterDataSource(
              cheetah_grid__WEBPACK_IMPORTED_MODULE_2__.data.DataSource.ofArray(x.data)
            );
          grid.dataSource = filterDataSource;

          const widget = document.getElementById(el.id);
          const label = document.createElement('label');
          label.textContent = 'Filter:';
          // Create input
          const input = document.createElement('input');
          input.id = `${el.id}-filter-input`;
          input.style.margin = '10px';
          widget.prepend(label, input);

          const filterInput = document.getElementById(`${el.id}-filter-input`);
          filterInput.addEventListener('input', (e) => {
            const filterValue = document.getElementById(e.currentTarget.id).value;
            filterDataSource.filter = filterValue
              ? (record) => {
                // filtering method
                for (const k in record) {
                  let testCond;
                  switch (x.search) {
                    case 'contains':
                      testCond = `${record[k]}`.indexOf(filterValue) >= 0;;
                      break;
                    case 'exact':
                      let r = new RegExp(`^${filterValue}$`);
                      testCond = r.test(`${record[k]}`);
                      break;
                    default:
                      console.log(`${x.search} value not implemented yet.`);
                  }
                  if (testCond) {
                    return true;
                  }
                }
                return false;
              }
              : null;
            grid.invalidate();
          })
        } else {
          // Array data to be displayed on the grid
          grid.records = x.data;
        }

        // Only is Shiny exists
        if (HTMLWidgets.shinyMode) {
          const {
            CLICK_CELL,
            CHANGED_VALUE,
          } = cheetah_grid__WEBPACK_IMPORTED_MODULE_2__.ListGrid.EVENT_TYPE;

          grid.listen(
            CLICK_CELL, (...args) => {
              Shiny.setInputValue(`${id}_click_cell`, args);
            }
          );

          grid.listen(
            CHANGED_VALUE, (...args) => {
              Shiny.setInputValue(`${id}_changed_value`, args);
            }
          );
        }
      },

      resize: function (width, height) {

        // TODO: code to re-render the widget with a new size

      }

    };
  }
});

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGtHQUFrRztBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBLGtHQUFrRztBQUNsRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxrR0FBa0c7QUFDbEc7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQSxtR0FBbUc7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsZ0JBQWdCOztBQUVoQixhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdEQUFnRDs7QUFFaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQSxtR0FBbUc7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBLG1HQUFtRztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQSxtR0FBbUc7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsNkNBQTZDLGlDQUFtQjtBQUNoRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUEsbUNBQW1DLGlDQUFtQjtBQUN0RDtBQUNBOztBQUVBLG9DQUFvQyxpQ0FBbUI7QUFDdkQ7QUFDQTs7QUFFQSx1QkFBdUIsaUNBQW1CO0FBQzFDO0FBQ0E7O0FBRUEsNkJBQTZCLGlDQUFtQjtBQUNoRDtBQUNBOztBQUVBLGlDQUFpQyxpQ0FBbUI7QUFDcEQ7QUFDQTs7QUFFQSx3QkFBd0IsaUNBQW1CO0FBQzNDO0FBQ0E7O0FBRUEsd0JBQXdCLGlDQUFtQjtBQUMzQztBQUNBOztBQUVBLDJCQUEyQixpQ0FBbUI7QUFDOUM7QUFDQTs7QUFFQSxtQ0FBbUMsaUNBQW1CO0FBQ3REO0FBQ0E7O0FBRUEsd0JBQXdCLGlDQUFtQjtBQUMzQztBQUNBOztBQUVBLGdDQUFnQyxpQ0FBbUI7QUFDbkQ7QUFDQTs7QUFFQSx1QkFBdUIsaUNBQW1CO0FBQzFDO0FBQ0E7O0FBRUEsaUNBQWlDLGlDQUFtQjtBQUNwRDtBQUNBLDBDQUEwQzs7O0FBRzFDLGdDQUFnQyxpQ0FBbUI7QUFDbkQ7QUFDQTs7QUFFQSw4QkFBOEIsaUNBQW1CO0FBQ2pEO0FBQ0E7QUFDQTs7O0FBR0EsNkRBQTZEOztBQUU3RDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0MsZUFBZTtBQUNuRDtBQUNBOztBQUVBLHNDQUFzQyxlQUFlO0FBQ3JEO0FBQ0E7O0FBRUEsb0NBQW9DLGVBQWU7QUFDbkQ7QUFDQTs7QUFFQSxxQ0FBcUMsY0FBYztBQUNuRDtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0NBQWtDLHdCQUF3QjtBQUMxRDs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0EsY0FBYzs7O0FBR2QsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUdBQWlHO0FBQ2pHOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUdBQWlHO0FBQ2pHOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYzs7O0FBR2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Qsb0NBQW9DOztBQUVwQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDOztBQUU5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViLDhCQUE4QixxQ0FBcUM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw4QkFBOEIsZ0NBQWdDO0FBQzlEOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtDQUFrQyxrQ0FBa0M7QUFDcEU7QUFDQTs7QUFFQSxzQ0FBc0MsMkJBQTJCO0FBQ2pFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0MsMkJBQTJCO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxxQkFBcUI7QUFDckIsbUJBQW1CO0FBQ25COztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVDQUF1Qyw0QkFBNEI7QUFDbkU7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDLGtDQUFrQztBQUNwRTtBQUNBOztBQUVBLHNDQUFzQyw0QkFBNEI7QUFDbEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0MsNEJBQTRCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixxQkFBcUI7QUFDckIsbUJBQW1CO0FBQ25CO0FBQ0E7O0FBRUEsd0NBQXdDLDhCQUE4QjtBQUN0RTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7OztBQUdsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFFBQVE7QUFDbEMsMEJBQTBCLFFBQVE7QUFDbEMsMEJBQTBCLEdBQUc7QUFDN0I7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixRQUFRO0FBQ2xDLDBCQUEwQixRQUFRO0FBQ2xDLDBCQUEwQixHQUFHO0FBQzdCOztBQUVBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsUUFBUTtBQUNsQywwQkFBMEIsUUFBUTtBQUNsQywwQkFBMEIsR0FBRztBQUM3QjtBQUNBOztBQUVBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsUUFBUTtBQUNsQywwQkFBMEIsUUFBUTtBQUNsQywwQkFBMEIsR0FB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QUFDbkI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjs7QUFFaEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7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O0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyR0FBMkc7O0FBRTNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBLFdB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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsNkRBQTZELGlDQUFtQjtBQUNoRjs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBLDRCQUE0QixpQ0FBbUI7QUFDL0M7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Es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QUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEOztBQUV0RDtB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QUF3QjtBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYixxQ0FBcUMsZUFBZTtBQUNwRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTs7QUFFaEU7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLGtCQUFrQjs7O0FBR2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esa0JBQWtCOzs7QUFHbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Qsb0NBQW9DOztBQUVwQztBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkLG9DQUFvQzs7QUFFcEM7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZCxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Qsb0NBQW9DOztBQUVwQztBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Qsb0NBQW9DOztBQUVwQztBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Qsa0RBQWtEOztBQUVsRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Qsa0RBQWtEOztBQUVsRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Qsa0RBQWtEOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtB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QUNBLDBCQUEwQixRQUFRO0FBQ2xDOztBQUVBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMEJBQTBCO0FBQ3BEOztBQUVBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE1BQU07QUFDaEM7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE1BQU07QUFDaEM7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0M7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCOztBQUVBOztBQUVBO0FBQ0EsK0pBQStKOztBQUUvSjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjs7QUFFQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0EsV0FBVztBQUNYOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpSEFBaUg7O0FBRWpIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsYUFBYTtBQUN0Qzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCOztBQUVBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsZ0VBQWdFOztBQUVoRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7O0FBRUEs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QUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsNERBQTRELGlDQUFtQjtBQUMvRTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBLDRCQUE0QixpQ0FBbUI7QUFDL0M7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EseUVBQXlFLGlDQUFtQjtBQUM1Rjs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBLG1DQUFtQyxpQ0FBbUI7QUFDdEQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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VDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsMENBQTBDLGlDQUFtQjtBQUM3RDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUEsd0JBQXdCLGlDQUFtQjtBQUMzQztBQUNBOztBQUVBLHdCQUF3QixpQ0FBbUI7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFD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QTtBQUNBLGFBQWE7O0FBRWI7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLHVEQUF1RCxpQ0FBbUI7QUFDMUU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBLG1DQUFtQyxpQ0FBbUI7QUFDdEQ7QUFDQTs7QUFFQSwrQkFBK0IsaUNBQW1CO0FBQ2xEO0FBQ0E7O0FBRUEsd0JBQXdCLGlDQUFtQjtBQUMzQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG1FQUFtRSxtR0FBbUc7QUFDdEs7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7O0FBRWxCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyRkFBMkY7QUFDM0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLG9EQUFvRCxpQ0FBbUI7QUFDdkU7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQSx3QkFBd0IsaUNBQW1CO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsUUFBUTtBQUM3QixxQkFBcUIsVUFBVTtBQUMvQixxQkFBcUIsaUJBQWlCO0FBQ3RDLHVCQUF1QixRQUFRO0FBQy9COzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGNBQWM7QUFDZCxrREFBa0QsZ0JBQWdCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxpREFBaUQsaUNBQW1CO0FBQ3BFOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUEsd0JBQXdCLGlDQUFtQjtBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsUUFBUTtBQUM3Qix1QkFBdUIsT0FBTztBQUM5QjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0MsYUFBYTtBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsZ0JBQWdCO0FBQ2hCO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsZ0JBQWdCLDRCQUE0QjtBQUM1QyxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHFCQUFxQixhQUFhO0FBQ2xDOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQkFBcUIsYUFBYTtBQUNsQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsK0ZBQStGO0FBQy9GO0FBQ0E7QUFDQTs7QUFFQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7O0FBRUE7QUFDQSwrRkFBK0Y7QUFDL0Y7QUFDQTtBQUNBOztBQUVBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4QjtBQUM5Qjs7QUFFQTtBQUNBLHdCQUF3QjtBQUN4Qjs7QUFFQTtBQUNBLHdCQUF3QjtBQUN4Qjs7QUFFQSxzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZOzs7QUFHWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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OztBQUVBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtB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QUNBLGNBQWMsOENBQWdCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixNQUFNO0FBQzlCO0FBQ0E7O0FBRUEseURBQXlELE1BQU07QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFVBQVU7QUFDOUM7QUFDQTtBQUNBLDZDQUE2QyxZQUFZO0FBQ3pELDJDQUEyQyxVQUFVO0FBQ3JEO0FBQ0E7QUFDQSxxQ0FBcUMsVUFBVTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxFQUFFLGtEQUFvQjs7QUFFbEM7QUFDQTtBQUNBLHFDQUFxQyxHQUFHO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQyxHQUFHO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaGVldGFoci8uL25vZGVfbW9kdWxlcy9jaGVldGFoLWdyaWQvZGlzdC9jaGVldGFoR3JpZC5lczUuanMiLCJ3ZWJwYWNrOi8vY2hlZXRhaHIvLi9zcmNqcy9tb2R1bGVzL3V0aWxzLmpzIiwid2VicGFjazovL2NoZWV0YWhyL2V4dGVybmFsIHZhciBcIkhUTUxXaWRnZXRzXCIiLCJ3ZWJwYWNrOi8vY2hlZXRhaHIvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vY2hlZXRhaHIvd2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQiLCJ3ZWJwYWNrOi8vY2hlZXRhaHIvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL2NoZWV0YWhyL3dlYnBhY2svcnVudGltZS9nbG9iYWwiLCJ3ZWJwYWNrOi8vY2hlZXRhaHIvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly9jaGVldGFoci93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL2NoZWV0YWhyL3dlYnBhY2svcnVudGltZS9ub2RlIG1vZHVsZSBkZWNvcmF0b3IiLCJ3ZWJwYWNrOi8vY2hlZXRhaHIvLi9zcmNqcy93aWRnZXRzL2NoZWV0YWguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIENoZWV0YWggR3JpZCB2MS4xNi4wIHwgbGljZW5zZSBNSVQgKi9cbihmdW5jdGlvbigpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIHNldCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3Quc2V0KSB7IHNldCA9IFJlZmxlY3Quc2V0OyB9IGVsc2UgeyBzZXQgPSBmdW5jdGlvbiBzZXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIHJlY2VpdmVyKSB7IHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7IHZhciBkZXNjOyBpZiAoYmFzZSkgeyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7IGlmIChkZXNjLnNldCkgeyBkZXNjLnNldC5jYWxsKHJlY2VpdmVyLCB2YWx1ZSk7IHJldHVybiB0cnVlOyB9IGVsc2UgaWYgKCFkZXNjLndyaXRhYmxlKSB7IHJldHVybiBmYWxzZTsgfSB9IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHJlY2VpdmVyLCBwcm9wZXJ0eSk7IGlmIChkZXNjKSB7IGlmICghZGVzYy53cml0YWJsZSkgeyByZXR1cm4gZmFsc2U7IH0gZGVzYy52YWx1ZSA9IHZhbHVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVjZWl2ZXIsIHByb3BlcnR5LCBkZXNjKTsgfSBlbHNlIHsgX2RlZmluZVByb3BlcnR5KHJlY2VpdmVyLCBwcm9wZXJ0eSwgdmFsdWUpOyB9IHJldHVybiB0cnVlOyB9OyB9IHJldHVybiBzZXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIHJlY2VpdmVyKTsgfVxuXG5mdW5jdGlvbiBfc2V0KHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCByZWNlaXZlciwgaXNTdHJpY3QpIHsgdmFyIHMgPSBzZXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIHJlY2VpdmVyIHx8IHRhcmdldCk7IGlmICghcyAmJiBpc1N0cmljdCkgeyB0aHJvdyBuZXcgRXJyb3IoJ2ZhaWxlZCB0byBzZXQgcHJvcGVydHknKTsgfSByZXR1cm4gdmFsdWU7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHsgX2dldCA9IFJlZmxlY3QuZ2V0OyB9IGVsc2UgeyBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOyBpZiAoIWJhc2UpIHJldHVybjsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTsgaWYgKGRlc2MuZ2V0KSB7IHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTsgfSByZXR1cm4gZGVzYy52YWx1ZTsgfTsgfSByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpOyB9XG5cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHsgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHsgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrOyB9IHJldHVybiBvYmplY3Q7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7IGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KGFycik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuKGZ1bmN0aW9uICh3aW5kb3cpIHtcbiAgKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcbiAgICBpZiAoKHR5cGVvZiBleHBvcnRzID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoZXhwb3J0cykpID09PSAnb2JqZWN0JyAmJiAodHlwZW9mIG1vZHVsZSA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKG1vZHVsZSkpID09PSAnb2JqZWN0JykgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSBkZWZpbmUoW10sIGZhY3RvcnkpO2Vsc2UgaWYgKCh0eXBlb2YgZXhwb3J0cyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKGV4cG9ydHMpKSA9PT0gJ29iamVjdCcpIGV4cG9ydHNbXCJjaGVldGFoR3JpZFwiXSA9IGZhY3RvcnkoKTtlbHNlIHJvb3RbXCJjaGVldGFoR3JpZFwiXSA9IGZhY3RvcnkoKTtcbiAgfSkod2luZG93LCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIC8qKioqKiovXG4gICAgICBmdW5jdGlvbiAobW9kdWxlcykge1xuICAgICAgICAvLyB3ZWJwYWNrQm9vdHN0cmFwXG5cbiAgICAgICAgLyoqKioqKi9cbiAgICAgICAgLy8gVGhlIG1vZHVsZSBjYWNoZVxuXG4gICAgICAgIC8qKioqKiovXG4gICAgICAgIHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4gICAgICAgIC8qKioqKiovXG5cbiAgICAgICAgLyoqKioqKi9cbiAgICAgICAgLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cblxuICAgICAgICAvKioqKioqL1xuXG4gICAgICAgIGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbiAgICAgICAgICAvKioqKioqL1xuXG4gICAgICAgICAgLyoqKioqKi9cbiAgICAgICAgICAvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblxuICAgICAgICAgIC8qKioqKiovXG4gICAgICAgICAgaWYgKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gICAgICAgICAgICAvKioqKioqL1xuICAgICAgICAgICAgcmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gICAgICAgICAgICAvKioqKioqL1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKioqKioqL1xuICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cbiAgICAgICAgICAvKioqKioqL1xuXG5cbiAgICAgICAgICB2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gICAgICAgICAgICAvKioqKioqL1xuICAgICAgICAgICAgaTogbW9kdWxlSWQsXG5cbiAgICAgICAgICAgIC8qKioqKiovXG4gICAgICAgICAgICBsOiBmYWxzZSxcblxuICAgICAgICAgICAgLyoqKioqKi9cbiAgICAgICAgICAgIGV4cG9ydHM6IHt9XG4gICAgICAgICAgICAvKioqKioqL1xuXG4gICAgICAgICAgfTtcbiAgICAgICAgICAvKioqKioqL1xuXG4gICAgICAgICAgLyoqKioqKi9cbiAgICAgICAgICAvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblxuICAgICAgICAgIC8qKioqKiovXG5cbiAgICAgICAgICBtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbiAgICAgICAgICAvKioqKioqL1xuXG4gICAgICAgICAgLyoqKioqKi9cbiAgICAgICAgICAvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG5cbiAgICAgICAgICAvKioqKioqL1xuXG4gICAgICAgICAgbW9kdWxlLmwgPSB0cnVlO1xuICAgICAgICAgIC8qKioqKiovXG5cbiAgICAgICAgICAvKioqKioqL1xuICAgICAgICAgIC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cbiAgICAgICAgICAvKioqKioqL1xuXG4gICAgICAgICAgcmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuICAgICAgICAgIC8qKioqKiovXG4gICAgICAgIH1cbiAgICAgICAgLyoqKioqKi9cblxuICAgICAgICAvKioqKioqL1xuXG4gICAgICAgIC8qKioqKiovXG4gICAgICAgIC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG5cbiAgICAgICAgLyoqKioqKi9cblxuXG4gICAgICAgIF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4gICAgICAgIC8qKioqKiovXG5cbiAgICAgICAgLyoqKioqKi9cbiAgICAgICAgLy8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcblxuICAgICAgICAvKioqKioqL1xuXG4gICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4gICAgICAgIC8qKioqKiovXG5cbiAgICAgICAgLyoqKioqKi9cbiAgICAgICAgLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG5cbiAgICAgICAgLyoqKioqKi9cblxuICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbiAoZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gICAgICAgICAgLyoqKioqKi9cbiAgICAgICAgICBpZiAoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuICAgICAgICAgICAgLyoqKioqKi9cbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgIGdldDogZ2V0dGVyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8qKioqKiovXG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKioqKiovXG5cbiAgICAgICAgfTtcbiAgICAgICAgLyoqKioqKi9cblxuICAgICAgICAvKioqKioqL1xuICAgICAgICAvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5cbiAgICAgICAgLyoqKioqKi9cblxuXG4gICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uIChleHBvcnRzKSB7XG4gICAgICAgICAgLyoqKioqKi9cbiAgICAgICAgICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gICAgICAgICAgICAvKioqKioqL1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywge1xuICAgICAgICAgICAgICB2YWx1ZTogJ01vZHVsZSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLyoqKioqKi9cbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqKioqKi9cblxuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICAvKioqKioqL1xuICAgICAgICB9O1xuICAgICAgICAvKioqKioqL1xuXG4gICAgICAgIC8qKioqKiovXG4gICAgICAgIC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuXG4gICAgICAgIC8qKioqKiovXG4gICAgICAgIC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuXG4gICAgICAgIC8qKioqKiovXG4gICAgICAgIC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuXG4gICAgICAgIC8qKioqKiovXG4gICAgICAgIC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuXG4gICAgICAgIC8qKioqKiovXG4gICAgICAgIC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcblxuICAgICAgICAvKioqKioqL1xuXG5cbiAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24gKHZhbHVlLCBtb2RlKSB7XG4gICAgICAgICAgLyoqKioqKi9cbiAgICAgICAgICBpZiAobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gICAgICAgICAgLyoqKioqKi9cblxuICAgICAgICAgIGlmIChtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIC8qKioqKiovXG5cbiAgICAgICAgICBpZiAobW9kZSAmIDQgJiYgX3R5cGVvZih2YWx1ZSkgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAvKioqKioqL1xuXG4gICAgICAgICAgdmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAvKioqKioqL1xuXG4gICAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiAgICAgICAgICAvKioqKioqL1xuXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0Jywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIC8qKioqKiovXG5cbiAgICAgICAgICBpZiAobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZVtrZXldO1xuICAgICAgICAgICAgfS5iaW5kKG51bGwsIGtleSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKioqKioqL1xuXG4gICAgICAgICAgcmV0dXJuIG5zO1xuICAgICAgICAgIC8qKioqKiovXG4gICAgICAgIH07XG4gICAgICAgIC8qKioqKiovXG5cbiAgICAgICAgLyoqKioqKi9cbiAgICAgICAgLy8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcblxuICAgICAgICAvKioqKioqL1xuXG5cbiAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24gKG1vZHVsZSkge1xuICAgICAgICAgIC8qKioqKiovXG4gICAgICAgICAgdmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gICAgICAgICAgLyoqKioqKi9cbiAgICAgICAgICBmdW5jdGlvbiBnZXREZWZhdWx0KCkge1xuICAgICAgICAgICAgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddO1xuICAgICAgICAgIH0gOlxuICAgICAgICAgIC8qKioqKiovXG4gICAgICAgICAgZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHtcbiAgICAgICAgICAgIHJldHVybiBtb2R1bGU7XG4gICAgICAgICAgfTtcbiAgICAgICAgICAvKioqKioqL1xuXG4gICAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuICAgICAgICAgIC8qKioqKiovXG5cblxuICAgICAgICAgIHJldHVybiBnZXR0ZXI7XG4gICAgICAgICAgLyoqKioqKi9cbiAgICAgICAgfTtcbiAgICAgICAgLyoqKioqKi9cblxuICAgICAgICAvKioqKioqL1xuICAgICAgICAvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcblxuICAgICAgICAvKioqKioqL1xuXG5cbiAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24gKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpO1xuICAgICAgICB9O1xuICAgICAgICAvKioqKioqL1xuXG4gICAgICAgIC8qKioqKiovXG4gICAgICAgIC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG5cbiAgICAgICAgLyoqKioqKi9cblxuXG4gICAgICAgIF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4gICAgICAgIC8qKioqKiovXG5cbiAgICAgICAgLyoqKioqKi9cblxuICAgICAgICAvKioqKioqL1xuICAgICAgICAvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcblxuICAgICAgICAvKioqKioqL1xuXG4gICAgICAgIHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9tYWluLmpzXCIpO1xuICAgICAgICAvKioqKioqL1xuICAgICAgfShcbiAgICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgIC8qKioqKiovXG4gICAgICB7XG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/IS4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/IS4uL3NyYy9qcy9jb2x1bW5zL2FjdGlvbi9pbnRlcm5hbC9JbmxpbmVJbnB1dEVsZW1lbnQuY3NzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tNS0xIS4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmM/P3JlZi0tNS0yIS4uL3NyYy9qcy9jb2x1bW5zL2FjdGlvbi9pbnRlcm5hbC9JbmxpbmVJbnB1dEVsZW1lbnQuY3NzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIHVzZXMgbW9kdWxlLmlkICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ3NzTG9hZGVyRGlzdENqc0pzTm9kZV9tb2R1bGVzUG9zdGNzc0xvYWRlclNyY0luZGV4SnNTcmNKc0NvbHVtbnNBY3Rpb25JbnRlcm5hbElubGluZUlucHV0RWxlbWVudENzcyhtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbiAgICAgICAgICAvKiBoYXJtb255IGltcG9ydCAqL1xuXG5cbiAgICAgICAgICB2YXIgX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfcnVudGltZV9hcGlfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanMgKi9cbiAgICAgICAgICBcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIik7XG4gICAgICAgICAgLyogaGFybW9ueSBpbXBvcnQgKi9cblxuXG4gICAgICAgICAgdmFyIF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X3J1bnRpbWVfYXBpX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfcnVudGltZV9hcGlfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7IC8vIEltcG9ydHNcblxuXG4gICAgICAgICAgdmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfcnVudGltZV9hcGlfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoZmFsc2UpOyAvLyBNb2R1bGVcblxuXG4gICAgICAgICAgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmksIFwiLmNoZWV0YWgtZ3JpZF9faW5saW5lLWlucHV0OjotbXMtY2xlYXJ7dmlzaWJpbGl0eTpoaWRkZW59LmNoZWV0YWgtZ3JpZF9faW5saW5lLWlucHV0e3Bvc2l0aW9uOmFic29sdXRlOy13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveH1cIiwgXCJcIl0pOyAvLyBFeHBvcnRzXG5cbiAgICAgICAgICAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovXG5cblxuICAgICAgICAgIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPyEuLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPyEuLi9zcmMvanMvY29sdW1ucy9hY3Rpb24vaW50ZXJuYWwvSW5saW5lTWVudUVsZW1lbnQuY3NzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS01LTEhLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYz8/cmVmLS01LTIhLi4vc3JjL2pzL2NvbHVtbnMvYWN0aW9uL2ludGVybmFsL0lubGluZU1lbnVFbGVtZW50LmNzcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIHVzZXMgbW9kdWxlLmlkICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ3NzTG9hZGVyRGlzdENqc0pzTm9kZV9tb2R1bGVzUG9zdGNzc0xvYWRlclNyY0luZGV4SnNTcmNKc0NvbHVtbnNBY3Rpb25JbnRlcm5hbElubGluZU1lbnVFbGVtZW50Q3NzKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuICAgICAgICAgIC8qIGhhcm1vbnkgaW1wb3J0ICovXG5cblxuICAgICAgICAgIHZhciBfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9ydW50aW1lX2FwaV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qcyAqL1xuICAgICAgICAgIFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiKTtcbiAgICAgICAgICAvKiBoYXJtb255IGltcG9ydCAqL1xuXG5cbiAgICAgICAgICB2YXIgX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfcnVudGltZV9hcGlfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9ydW50aW1lX2FwaV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTsgLy8gSW1wb3J0c1xuXG5cbiAgICAgICAgICB2YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9ydW50aW1lX2FwaV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShmYWxzZSk7IC8vIE1vZHVsZVxuXG5cbiAgICAgICAgICBfX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaSwgXCIuY2hlZXRhaC1ncmlkX19pbmxpbmUtbWVudXtwb3NpdGlvbjphYnNvbHV0ZTtjb2xvcjpyZ2JhKDAsMCwwLC44Nyk7LXdlYmtpdC1ib3gtc2l6aW5nOmNvbnRlbnQtYm94O2JveC1zaXppbmc6Y29udGVudC1ib3g7bWFyZ2luOi0xcHggYXV0byBhdXRvIC0xcHg7cGFkZGluZzo4cHggMDtiYWNrZ3JvdW5kLWNvbG9yOiNmYWZhZmE7bGlzdC1zdHlsZS10eXBlOm5vbmU7Ym9yZGVyLXJhZGl1czoycHg7bWF4LWhlaWdodDpjYWxjKDEwMHZoIC0gNDBweCk7b3ZlcmZsb3cteTphdXRvfS5jaGVldGFoLWdyaWRfX2lubGluZS1tZW51LS1oaWRkZW57LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUoLjkpO3RyYW5zZm9ybTpzY2FsZSguOSk7LXdlYmtpdC1ib3gtc2hhZG93Om5vbmU7Ym94LXNoYWRvdzpub25lO29wYWNpdHk6MDtwb2ludGVyLWV2ZW50czpub25lOy13ZWJraXQtdHJhbnNpdGlvbjphbGwgNTBtcyBlYXNlLW91dDt0cmFuc2l0aW9uOmFsbCA1MG1zIGVhc2Utb3V0fS5jaGVldGFoLWdyaWRfX2lubGluZS1tZW51LS1oaWRkZW4gKntwb2ludGVyLWV2ZW50czpub25lfS5jaGVldGFoLWdyaWRfX2lubGluZS1tZW51LS1zaG93bnstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKC03cHgpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKC03cHgpOy13ZWJraXQtYm94LXNoYWRvdzowIDNweCAxcHggLTJweCByZ2JhKDAsMCwwLC4yKSwwIDJweCAycHggMCByZ2JhKDAsMCwwLC4xNCksMCAxcHggNXB4IDAgcmdiYSgwLDAsMCwuMTIpO2JveC1zaGFkb3c6MCAzcHggMXB4IC0ycHggcmdiYSgwLDAsMCwuMiksMCAycHggMnB4IDAgcmdiYSgwLDAsMCwuMTQpLDAgMXB4IDVweCAwIHJnYmEoMCwwLDAsLjEyKTtvcGFjaXR5OjE7LXdlYmtpdC10cmFuc2l0aW9uOmFsbCAuMTVzIGVhc2Utb3V0O3RyYW5zaXRpb246YWxsIC4xNXMgZWFzZS1vdXR9LmNoZWV0YWgtZ3JpZF9faW5saW5lLW1lbnVfX21lbnUtaXRlbXtoZWlnaHQ6MTAwJTstd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDtib3gtc2l6aW5nOmJvcmRlci1ib3g7ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDstd2Via2l0LWJveC1hbGlnbjpjZW50ZXI7LW1zLWZsZXgtYWxpZ246Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjstd2Via2l0LWJveC1wYWNrOnN0YXJ0Oy1tcy1mbGV4LXBhY2s6c3RhcnQ7anVzdGlmeS1jb250ZW50OmZsZXgtc3RhcnQ7b3V0bGluZTpub25lO2N1cnNvcjpwb2ludGVyO3Bvc2l0aW9uOnJlbGF0aXZlO292ZXJmbG93OmhpZGRlbjtwYWRkaW5nOjAgMTZweH0uY2hlZXRhaC1ncmlkX19pbmxpbmUtbWVudV9fbWVudS1pdGVtLS1lbXB0eXtjb2xvcjpyZ2JhKDAsMCwwLC4zOCl9LmNoZWV0YWgtZ3JpZF9faW5saW5lLW1lbnVfX21lbnUtaXRlbTpiZWZvcmV7Y29udGVudDpcXFwiXFxcIjtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6LTUwJTtsZWZ0Oi01MCU7d2lkdGg6MjAwJTtoZWlnaHQ6MjAwJTtiYWNrZ3JvdW5kLWNvbG9yOiMwMDA7b3BhY2l0eTowO3BvaW50ZXItZXZlbnRzOm5vbmU7LXdlYmtpdC10cmFuc2l0aW9uOm9wYWNpdHkgMTVtcyBsaW5lYXI7dHJhbnNpdGlvbjpvcGFjaXR5IDE1bXMgbGluZWFyfS5jaGVldGFoLWdyaWRfX2lubGluZS1tZW51X19tZW51LWl0ZW06aG92ZXI6YmVmb3JlLC5jaGVldGFoLWdyaWRfX2lubGluZS1tZW51X19tZW51LWl0ZW1bZGF0YS1zZWxlY3RdOmJlZm9yZXtvcGFjaXR5Oi4wNH0uY2hlZXRhaC1ncmlkX19pbmxpbmUtbWVudV9fbWVudS1pdGVtOmZvY3VzOmJlZm9yZXtvcGFjaXR5Oi4xMn1cIiwgXCJcIl0pOyAvLyBFeHBvcnRzXG5cbiAgICAgICAgICAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovXG5cblxuICAgICAgICAgIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPyEuLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPyEuLi9zcmMvanMvY29sdW1ucy9hY3Rpb24vaW50ZXJuYWwvU21hbGxEaWFsb2dJbnB1dEVsZW1lbnQuY3NzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS01LTEhLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYz8/cmVmLS01LTIhLi4vc3JjL2pzL2NvbHVtbnMvYWN0aW9uL2ludGVybmFsL1NtYWxsRGlhbG9nSW5wdXRFbGVtZW50LmNzcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIHVzZXMgbW9kdWxlLmlkICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ3NzTG9hZGVyRGlzdENqc0pzTm9kZV9tb2R1bGVzUG9zdGNzc0xvYWRlclNyY0luZGV4SnNTcmNKc0NvbHVtbnNBY3Rpb25JbnRlcm5hbFNtYWxsRGlhbG9nSW5wdXRFbGVtZW50Q3NzKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuICAgICAgICAgIC8qIGhhcm1vbnkgaW1wb3J0ICovXG5cblxuICAgICAgICAgIHZhciBfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9ydW50aW1lX2FwaV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qcyAqL1xuICAgICAgICAgIFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiKTtcbiAgICAgICAgICAvKiBoYXJtb255IGltcG9ydCAqL1xuXG5cbiAgICAgICAgICB2YXIgX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfcnVudGltZV9hcGlfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9ydW50aW1lX2FwaV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTsgLy8gSW1wb3J0c1xuXG5cbiAgICAgICAgICB2YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9ydW50aW1lX2FwaV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShmYWxzZSk7IC8vIE1vZHVsZVxuXG5cbiAgICAgICAgICBfX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaSwgXCIuY2hlZXRhaC1ncmlkX19zbWFsbC1kaWFsb2ctaW5wdXRfX2lucHV0OjotbXMtY2xlYXJ7dmlzaWJpbGl0eTpoaWRkZW59QC13ZWJraXQta2V5ZnJhbWVzIGNoZWV0YWgtZ3JpZF9fc21hbGwtZGlhbG9nLWlucHV0LS1oaWRkZW4tYW5pbWF0aW9uezAle29wYWNpdHk6MX05OSV7b3BhY2l0eToxfXRve29wYWNpdHk6MH19QGtleWZyYW1lcyBjaGVldGFoLWdyaWRfX3NtYWxsLWRpYWxvZy1pbnB1dC0taGlkZGVuLWFuaW1hdGlvbnswJXtvcGFjaXR5OjF9OTkle29wYWNpdHk6MX10b3tvcGFjaXR5OjB9fS5jaGVldGFoLWdyaWRfX3NtYWxsLWRpYWxvZy1pbnB1dHtwb3NpdGlvbjphYnNvbHV0ZTstd2Via2l0LWJveC1zaXppbmc6Y29udGVudC1ib3g7Ym94LXNpemluZzpjb250ZW50LWJveDttYXJnaW46LTFweCBhdXRvIGF1dG8gLTFweDtib3JkZXItcmFkaXVzOjNweDtiYWNrZ3JvdW5kLWNvbG9yOiNmYWZhZmE7LXdlYmtpdC10cmFuc2l0aW9uOnBhZGRpbmcgLjE1cyBlYXNlLW91dCwtd2Via2l0LWJveC1zaGFkb3cgLjE1cyBlYXNlLW91dDt0cmFuc2l0aW9uOnBhZGRpbmcgLjE1cyBlYXNlLW91dCwtd2Via2l0LWJveC1zaGFkb3cgLjE1cyBlYXNlLW91dDt0cmFuc2l0aW9uOnBhZGRpbmcgLjE1cyBlYXNlLW91dCxib3gtc2hhZG93IC4xNXMgZWFzZS1vdXQ7dHJhbnNpdGlvbjpwYWRkaW5nIC4xNXMgZWFzZS1vdXQsYm94LXNoYWRvdyAuMTVzIGVhc2Utb3V0LC13ZWJraXQtYm94LXNoYWRvdyAuMTVzIGVhc2Utb3V0fS5jaGVldGFoLWdyaWRfX3NtYWxsLWRpYWxvZy1pbnB1dC0taGlkZGVuey13ZWJraXQtYm94LXNoYWRvdzpub25lO2JveC1zaGFkb3c6bm9uZTtwYWRkaW5nOjA7cG9pbnRlci1ldmVudHM6bm9uZTstd2Via2l0LWFuaW1hdGlvbjpjaGVldGFoLWdyaWRfX3NtYWxsLWRpYWxvZy1pbnB1dC0taGlkZGVuLWFuaW1hdGlvbiAuMTVzIGVhc2Utb3V0O2FuaW1hdGlvbjpjaGVldGFoLWdyaWRfX3NtYWxsLWRpYWxvZy1pbnB1dC0taGlkZGVuLWFuaW1hdGlvbiAuMTVzIGVhc2Utb3V0O29wYWNpdHk6MH0uY2hlZXRhaC1ncmlkX19zbWFsbC1kaWFsb2ctaW5wdXQtLXNob3duey13ZWJraXQtYm94LXNoYWRvdzowIDNweCAxcHggLTJweCByZ2JhKDAsMCwwLC4yKSwwIDJweCAycHggMCByZ2JhKDAsMCwwLC4xNCksMCAxcHggNXB4IDAgcmdiYSgwLDAsMCwuMTIpO2JveC1zaGFkb3c6MCAzcHggMXB4IC0ycHggcmdiYSgwLDAsMCwuMiksMCAycHggMnB4IDAgcmdiYSgwLDAsMCwuMTQpLDAgMXB4IDVweCAwIHJnYmEoMCwwLDAsLjEyKTtwYWRkaW5nOjhweCAyNHB4fS5jaGVldGFoLWdyaWRfX3NtYWxsLWRpYWxvZy1pbnB1dF9faW5wdXR7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTstd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDtib3gtc2l6aW5nOmJvcmRlci1ib3g7cGFkZGluZzozcHggMnB4IDAgNHB4O2JvcmRlcjpub25lO2JvcmRlci1ib3R0b206MXB4IHNvbGlkIHJnYmEoMCwwLDAsLjg3KTtvdXRsaW5lOm5vbmU7YmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudDstd2Via2l0LXRyYW5zaXRpb246YWxsIC4zcyBlYXNlLW91dDt0cmFuc2l0aW9uOmFsbCAuM3MgZWFzZS1vdXR9LmNoZWV0YWgtZ3JpZF9fc21hbGwtZGlhbG9nLWlucHV0X19pbnB1dDpmb2N1c3tib3JkZXItYm90dG9tOjFweCBzb2xpZCAjMjE5NmYzOy13ZWJraXQtYm94LXNoYWRvdzowIDFweCAwIDAgIzIxOTZmMztib3gtc2hhZG93OjAgMXB4IDAgMCAjMjE5NmYzfS5jaGVldGFoLWdyaWRfX3NtYWxsLWRpYWxvZy1pbnB1dDphZnRlcntjb250ZW50OlxcXCJcXFwiO2ZvbnQtZmFtaWx5OlJvYm90bztmb250LXNpemU6MTJweDtmb250LXNpemU6Ljc1cmVtO21pbi1oZWlnaHQ6MWVtO2xpbmUtaGVpZ2h0OjE7ZGlzcGxheTpibG9jazt3aWR0aDoxMDAlO3BhZGRpbmctdG9wOjhweH0uY2hlZXRhaC1ncmlkX19zbWFsbC1kaWFsb2ctaW5wdXQuaGVscGVyLXRleHQtLXJpZ2h0LWp1c3RpZmllZDphZnRlcnt0ZXh0LWFsaWduOnJpZ2h0fS5jaGVldGFoLWdyaWRfX3NtYWxsLWRpYWxvZy1pbnB1dFtkYXRhLWhlbHBlci10ZXh0XTphZnRlcntjb250ZW50OmF0dHIoZGF0YS1oZWxwZXItdGV4dCk7Y29sb3I6cmdiYSgwLDAsMCwuODcpfS5jaGVldGFoLWdyaWRfX3NtYWxsLWRpYWxvZy1pbnB1dFtkYXRhLWVycm9yLW1lc3NhZ2VdIGlucHV0e2JvcmRlci1ib3R0b206MXB4IHNvbGlkICNmZjE3NDQ7LXdlYmtpdC1ib3gtc2hhZG93OjAgMXB4IDAgMCAjZmYxNzQ0O2JveC1zaGFkb3c6MCAxcHggMCAwICNmZjE3NDR9LmNoZWV0YWgtZ3JpZF9fc21hbGwtZGlhbG9nLWlucHV0W2RhdGEtZXJyb3ItbWVzc2FnZV06YWZ0ZXJ7Y29udGVudDphdHRyKGRhdGEtZXJyb3ItbWVzc2FnZSk7Y29sb3I6I2ZmMTc0NDt0ZXh0LWFsaWduOmxlZnR9XCIsIFwiXCJdKTsgLy8gRXhwb3J0c1xuXG4gICAgICAgICAgLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqL1xuXG5cbiAgICAgICAgICBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8hLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8hLi4vc3JjL2pzL2NvbHVtbnMvbWVzc2FnZS9pbnRlcm5hbC9FcnJvck1lc3NhZ2VFbGVtZW50LmNzc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tNS0xIS4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmM/P3JlZi0tNS0yIS4uL3NyYy9qcy9jb2x1bW5zL21lc3NhZ2UvaW50ZXJuYWwvRXJyb3JNZXNzYWdlRWxlbWVudC5jc3MgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSB1c2VzIG1vZHVsZS5pZCAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0Nzc0xvYWRlckRpc3RDanNKc05vZGVfbW9kdWxlc1Bvc3Rjc3NMb2FkZXJTcmNJbmRleEpzU3JjSnNDb2x1bW5zTWVzc2FnZUludGVybmFsRXJyb3JNZXNzYWdlRWxlbWVudENzcyhtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbiAgICAgICAgICAvKiBoYXJtb255IGltcG9ydCAqL1xuXG5cbiAgICAgICAgICB2YXIgX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfcnVudGltZV9hcGlfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanMgKi9cbiAgICAgICAgICBcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIik7XG4gICAgICAgICAgLyogaGFybW9ueSBpbXBvcnQgKi9cblxuXG4gICAgICAgICAgdmFyIF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X3J1bnRpbWVfYXBpX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfcnVudGltZV9hcGlfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7IC8vIEltcG9ydHNcblxuXG4gICAgICAgICAgdmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfcnVudGltZV9hcGlfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoZmFsc2UpOyAvLyBNb2R1bGVcblxuXG4gICAgICAgICAgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmksIFwiLmNoZWV0YWgtZ3JpZF9fZXJyb3ItbWVzc2FnZS1lbGVtZW50e2JvcmRlci10b3A6MXB4IHNvbGlkICNmZjE3NDQ7Y29sb3I6I2ZmMTc0NH1cIiwgXCJcIl0pOyAvLyBFeHBvcnRzXG5cbiAgICAgICAgICAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovXG5cblxuICAgICAgICAgIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPyEuLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPyEuLi9zcmMvanMvY29sdW1ucy9tZXNzYWdlL2ludGVybmFsL01lc3NhZ2VFbGVtZW50LmNzc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTUtMSEuLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvc3JjPz9yZWYtLTUtMiEuLi9zcmMvanMvY29sdW1ucy9tZXNzYWdlL2ludGVybmFsL01lc3NhZ2VFbGVtZW50LmNzcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSB1c2VzIG1vZHVsZS5pZCAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0Nzc0xvYWRlckRpc3RDanNKc05vZGVfbW9kdWxlc1Bvc3Rjc3NMb2FkZXJTcmNJbmRleEpzU3JjSnNDb2x1bW5zTWVzc2FnZUludGVybmFsTWVzc2FnZUVsZW1lbnRDc3MobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4gICAgICAgICAgLyogaGFybW9ueSBpbXBvcnQgKi9cblxuXG4gICAgICAgICAgdmFyIF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X3J1bnRpbWVfYXBpX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzICovXG4gICAgICAgICAgXCIuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCIpO1xuICAgICAgICAgIC8qIGhhcm1vbnkgaW1wb3J0ICovXG5cblxuICAgICAgICAgIHZhciBfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9ydW50aW1lX2FwaV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X3J1bnRpbWVfYXBpX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pOyAvLyBJbXBvcnRzXG5cblxuICAgICAgICAgIHZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X3J1bnRpbWVfYXBpX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKGZhbHNlKTsgLy8gTW9kdWxlXG5cblxuICAgICAgICAgIF9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pLCBcIi5jaGVldGFoLWdyaWRfX21lc3NhZ2UtZWxlbWVudHtwb3NpdGlvbjphYnNvbHV0ZTttYXJnaW4tdG9wOi0ycHg7LXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7Ym94LXNpemluZzpib3JkZXItYm94O2JvcmRlci1yYWRpdXM6MCAwIDNweCAzcHg7YmFja2dyb3VuZC1jb2xvcjpoc2xhKDAsMCUsOTglLC44NSk7cGFkZGluZzo4cHggMnB4O3BvaW50ZXItZXZlbnRzOm5vbmU7LXdlYmtpdC11c2VyLXNlbGVjdDpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTstbXMtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lO2JvcmRlci10b3A6MXB4IHNvbGlkIHJnYmEoMCwwLDAsLjg3KTtjb2xvcjpyZ2JhKDAsMCwwLC44Nyl9LmNoZWV0YWgtZ3JpZF9fbWVzc2FnZS1lbGVtZW50LS1oaWRkZW57ZGlzcGxheTpub25lfS5jaGVldGFoLWdyaWRfX21lc3NhZ2UtZWxlbWVudC0tc2hvd257ZGlzcGxheTpibG9ja30uY2hlZXRhaC1ncmlkX19tZXNzYWdlLWVsZW1lbnRfX21lc3NhZ2V7Zm9udC1mYW1pbHk6Um9ib3RvO2ZvbnQtc2l6ZToxMnB4O2ZvbnQtc2l6ZTouNzVyZW07bWluLWhlaWdodDoxZW07bGluZS1oZWlnaHQ6MTtkaXNwbGF5OmJsb2NrO3dpZHRoOjEwMCV9XCIsIFwiXCJdKTsgLy8gRXhwb3J0c1xuXG4gICAgICAgICAgLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqL1xuXG5cbiAgICAgICAgICBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8hLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8hLi4vc3JjL2pzL2NvbHVtbnMvbWVzc2FnZS9pbnRlcm5hbC9XYXJuaW5nTWVzc2FnZUVsZW1lbnQuY3NzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTUtMSEuLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvc3JjPz9yZWYtLTUtMiEuLi9zcmMvanMvY29sdW1ucy9tZXNzYWdlL2ludGVybmFsL1dhcm5pbmdNZXNzYWdlRWxlbWVudC5jc3MgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIHVzZXMgbW9kdWxlLmlkICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ3NzTG9hZGVyRGlzdENqc0pzTm9kZV9tb2R1bGVzUG9zdGNzc0xvYWRlclNyY0luZGV4SnNTcmNKc0NvbHVtbnNNZXNzYWdlSW50ZXJuYWxXYXJuaW5nTWVzc2FnZUVsZW1lbnRDc3MobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4gICAgICAgICAgLyogaGFybW9ueSBpbXBvcnQgKi9cblxuXG4gICAgICAgICAgdmFyIF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X3J1bnRpbWVfYXBpX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzICovXG4gICAgICAgICAgXCIuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCIpO1xuICAgICAgICAgIC8qIGhhcm1vbnkgaW1wb3J0ICovXG5cblxuICAgICAgICAgIHZhciBfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9ydW50aW1lX2FwaV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X3J1bnRpbWVfYXBpX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pOyAvLyBJbXBvcnRzXG5cblxuICAgICAgICAgIHZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X3J1bnRpbWVfYXBpX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKGZhbHNlKTsgLy8gTW9kdWxlXG5cblxuICAgICAgICAgIF9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pLCBcIi5jaGVldGFoLWdyaWRfX3dhcm5pbmctbWVzc2FnZS1lbGVtZW50e2JvcmRlci10b3A6MXB4IHNvbGlkICNkZDJjMDA7Y29sb3I6I2RkMmMwMH1cIiwgXCJcIl0pOyAvLyBFeHBvcnRzXG5cbiAgICAgICAgICAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovXG5cblxuICAgICAgICAgIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPyEuLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPyEuLi9zcmMvanMvaW50ZXJuYWwvc3R5bGUuY3NzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS01LTEhLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYz8/cmVmLS01LTIhLi4vc3JjL2pzL2ludGVybmFsL3N0eWxlLmNzcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIHVzZXMgbW9kdWxlLmlkICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ3NzTG9hZGVyRGlzdENqc0pzTm9kZV9tb2R1bGVzUG9zdGNzc0xvYWRlclNyY0luZGV4SnNTcmNKc0ludGVybmFsU3R5bGVDc3MobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4gICAgICAgICAgLyogaGFybW9ueSBpbXBvcnQgKi9cblxuXG4gICAgICAgICAgdmFyIF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X3J1bnRpbWVfYXBpX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzICovXG4gICAgICAgICAgXCIuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCIpO1xuICAgICAgICAgIC8qIGhhcm1vbnkgaW1wb3J0ICovXG5cblxuICAgICAgICAgIHZhciBfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9ydW50aW1lX2FwaV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X3J1bnRpbWVfYXBpX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pOyAvLyBJbXBvcnRzXG5cblxuICAgICAgICAgIHZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X3J1bnRpbWVfYXBpX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKGZhbHNlKTsgLy8gTW9kdWxlXG5cblxuICAgICAgICAgIF9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pLCBcIi5jaGVldGFoLWdyaWQgLmdyaWQtc2Nyb2xsYWJsZXtoZWlnaHQ6MTAwJTt3aWR0aDoxMDAlO3Bvc2l0aW9uOmFic29sdXRlO292ZXJmbG93OnNjcm9sbH0uY2hlZXRhaC1ncmlkIC5ncmlkLXNjcm9sbC1lbmQtcG9pbnR7b3BhY2l0eTowO3Bvc2l0aW9uOnJlbGF0aXZlfS5jaGVldGFoLWdyaWR7cG9zaXRpb246cmVsYXRpdmU7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJX0uY2hlZXRhaC1ncmlkPmNhbnZhc3twb3NpdGlvbjphYnNvbHV0ZTt3aWR0aDowO2hlaWdodDowfS5jaGVldGFoLWdyaWQgLmdyaWQtZm9jdXMtY29udHJvbHtwb3NpdGlvbjpyZWxhdGl2ZSFpbXBvcnRhbnQ7d2lkdGg6MXB4O2hlaWdodDoxcHg7b3BhY2l0eTowO3BhZGRpbmc6MDttYXJnaW46MDstd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDtib3gtc2l6aW5nOmJvcmRlci1ib3g7cG9pbnRlci1ldmVudHM6bm9uZTttYXgtd2lkdGg6MDttYXgtaGVpZ2h0OjA7ZmxvYXQ6bm9uZSFpbXBvcnRhbnR9LmNoZWV0YWgtZ3JpZCBpbnB1dC5ncmlkLWZvY3VzLWNvbnRyb2w6Oi1tcy1jbGVhcnt2aXNpYmlsaXR5OmhpZGRlbn0uY2hlZXRhaC1ncmlkIGlucHV0LmdyaWQtZm9jdXMtY29udHJvbC5jb21wb3NpdGlvbntvcGFjaXR5OjE7bWF4LXdpZHRoOm5vbmU7bWF4LWhlaWdodDpub25lfVwiLCBcIlwiXSk7IC8vIEV4cG9ydHNcblxuICAgICAgICAgIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi9cblxuXG4gICAgICAgICAgX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/IS4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/IS4uL3NyYy9qcy90b29sdGlwL2ludGVybmFsL1Rvb2x0aXBFbGVtZW50LmNzc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS01LTEhLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYz8/cmVmLS01LTIhLi4vc3JjL2pzL3Rvb2x0aXAvaW50ZXJuYWwvVG9vbHRpcEVsZW1lbnQuY3NzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSB1c2VzIG1vZHVsZS5pZCAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0Nzc0xvYWRlckRpc3RDanNKc05vZGVfbW9kdWxlc1Bvc3Rjc3NMb2FkZXJTcmNJbmRleEpzU3JjSnNUb29sdGlwSW50ZXJuYWxUb29sdGlwRWxlbWVudENzcyhtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbiAgICAgICAgICAvKiBoYXJtb255IGltcG9ydCAqL1xuXG5cbiAgICAgICAgICB2YXIgX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfcnVudGltZV9hcGlfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanMgKi9cbiAgICAgICAgICBcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIik7XG4gICAgICAgICAgLyogaGFybW9ueSBpbXBvcnQgKi9cblxuXG4gICAgICAgICAgdmFyIF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X3J1bnRpbWVfYXBpX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfcnVudGltZV9hcGlfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7IC8vIEltcG9ydHNcblxuXG4gICAgICAgICAgdmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfcnVudGltZV9hcGlfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoZmFsc2UpOyAvLyBNb2R1bGVcblxuXG4gICAgICAgICAgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmksIFwiQC13ZWJraXQta2V5ZnJhbWVzIGNoZWV0YWgtZ3JpZF9fdG9vbHRpcC1lbGVtZW50LS1zaG93bi1hbmltYXRpb257MCV7b3BhY2l0eTowOy13ZWJraXQtdHJhbnNmb3JtOnNjYWxlKC44KSB0cmFuc2xhdGVYKC02MCUpO3RyYW5zZm9ybTpzY2FsZSguOCkgdHJhbnNsYXRlWCgtNjAlKX10b3tvcGFjaXR5OjE7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUoMSkgdHJhbnNsYXRlWCgtNTAlKTt0cmFuc2Zvcm06c2NhbGUoMSkgdHJhbnNsYXRlWCgtNTAlKX19QGtleWZyYW1lcyBjaGVldGFoLWdyaWRfX3Rvb2x0aXAtZWxlbWVudC0tc2hvd24tYW5pbWF0aW9uezAle29wYWNpdHk6MDstd2Via2l0LXRyYW5zZm9ybTpzY2FsZSguOCkgdHJhbnNsYXRlWCgtNjAlKTt0cmFuc2Zvcm06c2NhbGUoLjgpIHRyYW5zbGF0ZVgoLTYwJSl9dG97b3BhY2l0eToxOy13ZWJraXQtdHJhbnNmb3JtOnNjYWxlKDEpIHRyYW5zbGF0ZVgoLTUwJSk7dHJhbnNmb3JtOnNjYWxlKDEpIHRyYW5zbGF0ZVgoLTUwJSl9fS5jaGVldGFoLWdyaWRfX3Rvb2x0aXAtZWxlbWVudHtwb3NpdGlvbjphYnNvbHV0ZTstd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDtib3gtc2l6aW5nOmJvcmRlci1ib3g7Ym9yZGVyLXJhZGl1czozcHg7YmFja2dyb3VuZC1jb2xvcjojMjMyZjM0O3BhZGRpbmc6OHB4O3BvaW50ZXItZXZlbnRzOm5vbmU7LXdlYmtpdC11c2VyLXNlbGVjdDpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTstbXMtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lO2NvbG9yOiNmZmZ9LmNoZWV0YWgtZ3JpZF9fdG9vbHRpcC1lbGVtZW50LS1oaWRkZW57b3BhY2l0eTowOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTUwJSk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTUwJSk7LXdlYmtpdC10cmFuc2l0aW9uOm9wYWNpdHkgNzVtcyBsaW5lYXI7dHJhbnNpdGlvbjpvcGFjaXR5IDc1bXMgbGluZWFyfS5jaGVldGFoLWdyaWRfX3Rvb2x0aXAtZWxlbWVudC0tc2hvd257b3BhY2l0eToxOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTUwJSk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTUwJSk7LXdlYmtpdC1hbmltYXRpb246Y2hlZXRhaC1ncmlkX190b29sdGlwLWVsZW1lbnQtLXNob3duLWFuaW1hdGlvbiAuMTVzIGVhc2Utb3V0O2FuaW1hdGlvbjpjaGVldGFoLWdyaWRfX3Rvb2x0aXAtZWxlbWVudC0tc2hvd24tYW5pbWF0aW9uIC4xNXMgZWFzZS1vdXR9LmNoZWV0YWgtZ3JpZF9fdG9vbHRpcC1lbGVtZW50X19jb250ZW50e2ZvbnQtZmFtaWx5OlJvYm90bztmb250LXNpemU6MTJweDtmb250LXNpemU6Ljc1cmVtO21pbi1oZWlnaHQ6MWVtO2xpbmUtaGVpZ2h0OjE7d2lkdGg6MTAwJTtkaXNwbGF5OmJsb2NrO3doaXRlLXNwYWNlOnByZS13cmFwO21hcmdpbjowOy13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveH1cIiwgXCJcIl0pOyAvLyBFeHBvcnRzXG5cbiAgICAgICAgICAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovXG5cblxuICAgICAgICAgIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0Nzc0xvYWRlckRpc3RSdW50aW1lQXBpSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgLypcbiAgICAgICAgICAgIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gICAgICAgICAgICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4gICAgICAgICAgKi9cbiAgICAgICAgICAvLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5cbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh1c2VTb3VyY2VNYXApIHtcbiAgICAgICAgICAgIHZhciBsaXN0ID0gW107IC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblxuICAgICAgICAgICAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblxuICAgICAgICAgICAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwiIHtcIikuY29uY2F0KGNvbnRlbnQsIFwifVwiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgICAgICAgICAgfSkuam9pbignJyk7XG4gICAgICAgICAgICB9OyAvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcblxuXG4gICAgICAgICAgICBsaXN0LmkgPSBmdW5jdGlvbiAobW9kdWxlcywgbWVkaWFRdWVyeSwgZGVkdXBlKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgbW9kdWxlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgICAgICBtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCAnJ11dO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblxuICAgICAgICAgICAgICBpZiAoZGVkdXBlKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICAgICAgICAgICAgICAgIHZhciBpZCA9IHRoaXNbaV1bMF07XG5cbiAgICAgICAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbW9kdWxlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IFtdLmNvbmNhdChtb2R1bGVzW19pXSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZGVkdXBlICYmIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcbiAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG1lZGlhUXVlcnkpIHtcbiAgICAgICAgICAgICAgICAgIGlmICghaXRlbVsyXSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtWzJdID0gbWVkaWFRdWVyeTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1bMl0gPSBcIlwiLmNvbmNhdChtZWRpYVF1ZXJ5LCBcIiBhbmQgXCIpLmNvbmNhdChpdGVtWzJdKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsaXN0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiBsaXN0O1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBmdW5jdGlvbiBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCkge1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcblxuICAgICAgICAgICAgdmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXG4gICAgICAgICAgICBpZiAoIWNzc01hcHBpbmcpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh1c2VTb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgdmFyIHNvdXJjZU1hcHBpbmcgPSB0b0NvbW1lbnQoY3NzTWFwcGluZyk7XG4gICAgICAgICAgICAgIHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiLyojIHNvdXJjZVVSTD1cIi5jb25jYXQoY3NzTWFwcGluZy5zb3VyY2VSb290IHx8ICcnKS5jb25jYXQoc291cmNlLCBcIiAqL1wiKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oJ1xcbicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xuICAgICAgICAgIH0gLy8gQWRhcHRlZCBmcm9tIGNvbnZlcnQtc291cmNlLW1hcCAoTUlUKVxuXG5cbiAgICAgICAgICBmdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICAgICAgICAgIHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBcInNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LFwiLmNvbmNhdChiYXNlNjQpO1xuICAgICAgICAgICAgcmV0dXJuIFwiLyojIFwiLmNvbmNhdChkYXRhLCBcIiAqL1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqKi9cblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBub2RlX21vZHVsZXNTdHlsZUxvYWRlckRpc3RSdW50aW1lSW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICB2YXIgaXNPbGRJRSA9IGZ1bmN0aW9uIGlzT2xkSUUoKSB7XG4gICAgICAgICAgICB2YXIgbWVtbztcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBtZW1vcml6ZSgpIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZW1vID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG4gICAgICAgICAgICAgICAgLy8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxuICAgICAgICAgICAgICAgIC8vIFRlc3RzIGZvciBleGlzdGVuY2Ugb2Ygc3RhbmRhcmQgZ2xvYmFscyBpcyB0byBhbGxvdyBzdHlsZS1sb2FkZXJcbiAgICAgICAgICAgICAgICAvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcbiAgICAgICAgICAgICAgICAvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcbiAgICAgICAgICAgICAgICBtZW1vID0gQm9vbGVhbih3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYik7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gbWVtbztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSgpO1xuXG4gICAgICAgICAgdmFyIGdldFRhcmdldCA9IGZ1bmN0aW9uIGdldFRhcmdldCgpIHtcbiAgICAgICAgICAgIHZhciBtZW1vID0ge307XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gbWVtb3JpemUodGFyZ2V0KSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHZhciBzdHlsZVRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTsgLy8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcblxuICAgICAgICAgICAgICAgIGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYWNjZXNzIHRvIGlmcmFtZSBpcyBibG9ja2VkXG4gICAgICAgICAgICAgICAgICAgIC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtZW1vW3RhcmdldF0gPSBzdHlsZVRhcmdldDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBtZW1vW3RhcmdldF07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0oKTtcblxuICAgICAgICAgIHZhciBzdHlsZXNJbkRvbSA9IFtdO1xuXG4gICAgICAgICAgZnVuY3Rpb24gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcikge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IC0xO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlc0luRG9tLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGlmIChzdHlsZXNJbkRvbVtpXS5pZGVudGlmaWVyID09PSBpZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gaTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgaWRDb3VudE1hcCA9IHt9O1xuICAgICAgICAgICAgdmFyIGlkZW50aWZpZXJzID0gW107XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgaXRlbSA9IGxpc3RbaV07XG4gICAgICAgICAgICAgIHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuICAgICAgICAgICAgICB2YXIgY291bnQgPSBpZENvdW50TWFwW2lkXSB8fCAwO1xuICAgICAgICAgICAgICB2YXIgaWRlbnRpZmllciA9IFwiXCIuY29uY2F0KGlkLCBcIiBcIikuY29uY2F0KGNvdW50KTtcbiAgICAgICAgICAgICAgaWRDb3VudE1hcFtpZF0gPSBjb3VudCArIDE7XG4gICAgICAgICAgICAgIHZhciBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgICAgICAgICAgICB2YXIgb2JqID0ge1xuICAgICAgICAgICAgICAgIGNzczogaXRlbVsxXSxcbiAgICAgICAgICAgICAgICBtZWRpYTogaXRlbVsyXSxcbiAgICAgICAgICAgICAgICBzb3VyY2VNYXA6IGl0ZW1bM11cbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMrKztcbiAgICAgICAgICAgICAgICBzdHlsZXNJbkRvbVtpbmRleF0udXBkYXRlcihvYmopO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0eWxlc0luRG9tLnB1c2goe1xuICAgICAgICAgICAgICAgICAgaWRlbnRpZmllcjogaWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICAgIHVwZGF0ZXI6IGFkZFN0eWxlKG9iaiwgb3B0aW9ucyksXG4gICAgICAgICAgICAgICAgICByZWZlcmVuY2VzOiAxXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZGVudGlmaWVycy5wdXNoKGlkZW50aWZpZXIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaWRlbnRpZmllcnM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlcyA9IG9wdGlvbnMuYXR0cmlidXRlcyB8fCB7fTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBhdHRyaWJ1dGVzLm5vbmNlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICB2YXIgbm9uY2UgPSB0cnVlID8gX193ZWJwYWNrX3JlcXVpcmVfXy5uYyA6IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgICBpZiAobm9uY2UpIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLm5vbmNlID0gbm9uY2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgIHN0eWxlLnNldEF0dHJpYnV0ZShrZXksIGF0dHJpYnV0ZXNba2V5XSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmluc2VydCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBvcHRpb25zLmluc2VydChzdHlsZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZ2V0VGFyZ2V0KG9wdGlvbnMuaW5zZXJ0IHx8ICdoZWFkJyk7XG5cbiAgICAgICAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydCcgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSkge1xuICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIGlmXG4gICAgICAgICAgICBpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cblxuXG4gICAgICAgICAgdmFyIHJlcGxhY2VUZXh0ID0gZnVuY3Rpb24gcmVwbGFjZVRleHQoKSB7XG4gICAgICAgICAgICB2YXIgdGV4dFN0b3JlID0gW107XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gcmVwbGFjZShpbmRleCwgcmVwbGFjZW1lbnQpIHtcbiAgICAgICAgICAgICAgdGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xuICAgICAgICAgICAgICByZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSgpO1xuXG4gICAgICAgICAgZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyhzdHlsZSwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG4gICAgICAgICAgICB2YXIgY3NzID0gcmVtb3ZlID8gJycgOiBvYmoubWVkaWEgPyBcIkBtZWRpYSBcIi5jb25jYXQob2JqLm1lZGlhLCBcIiB7XCIpLmNvbmNhdChvYmouY3NzLCBcIn1cIikgOiBvYmouY3NzOyAvLyBGb3Igb2xkIElFXG5cbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cblxuICAgICAgICAgICAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICAgICAgICAgICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XG4gICAgICAgICAgICAgIHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuICAgICAgICAgICAgICBpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHtcbiAgICAgICAgICAgICAgICBzdHlsZS5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBzdHlsZS5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gYXBwbHlUb1RhZyhzdHlsZSwgb3B0aW9ucywgb2JqKSB7XG4gICAgICAgICAgICB2YXIgY3NzID0gb2JqLmNzcztcbiAgICAgICAgICAgIHZhciBtZWRpYSA9IG9iai5tZWRpYTtcbiAgICAgICAgICAgIHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xuXG4gICAgICAgICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgICAgICAgc3R5bGUuc2V0QXR0cmlidXRlKCdtZWRpYScsIG1lZGlhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0eWxlLnJlbW92ZUF0dHJpYnV0ZSgnbWVkaWEnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgY3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIi5jb25jYXQoYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSwgXCIgKi9cIik7XG4gICAgICAgICAgICB9IC8vIEZvciBvbGQgSUVcblxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqL1xuXG5cbiAgICAgICAgICAgIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgICAgICAgICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdoaWxlIChzdHlsZS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgc2luZ2xldG9uID0gbnVsbDtcbiAgICAgICAgICB2YXIgc2luZ2xldG9uQ291bnRlciA9IDA7XG5cbiAgICAgICAgICBmdW5jdGlvbiBhZGRTdHlsZShvYmosIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZTtcbiAgICAgICAgICAgIHZhciB1cGRhdGU7XG4gICAgICAgICAgICB2YXIgcmVtb3ZlO1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcbiAgICAgICAgICAgICAgdmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XG4gICAgICAgICAgICAgIHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuICAgICAgICAgICAgICB1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcbiAgICAgICAgICAgICAgcmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0eWxlID0gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuICAgICAgICAgICAgICB1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGUsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgIHJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB1cGRhdGUob2JqKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZShuZXdPYmopIHtcbiAgICAgICAgICAgICAgaWYgKG5ld09iaikge1xuICAgICAgICAgICAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB1cGRhdGUob2JqID0gbmV3T2JqKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZW1vdmUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChsaXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsgLy8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG4gICAgICAgICAgICAvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5cbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5zaW5nbGV0b24gJiYgdHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxpc3QgPSBsaXN0IHx8IFtdO1xuICAgICAgICAgICAgdmFyIGxhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xuICAgICAgICAgICAgICBuZXdMaXN0ID0gbmV3TGlzdCB8fCBbXTtcblxuICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ld0xpc3QpICE9PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICAgICAgICAgICAgICBzdHlsZXNJbkRvbVtpbmRleF0ucmVmZXJlbmNlcy0tO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIG5ld0xhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShuZXdMaXN0LCBvcHRpb25zKTtcblxuICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBfaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tfaV07XG5cbiAgICAgICAgICAgICAgICB2YXIgX2luZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoX2lkZW50aWZpZXIpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlc0luRG9tW19pbmRleF0ucmVmZXJlbmNlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgc3R5bGVzSW5Eb21bX2luZGV4XS51cGRhdGVyKCk7XG5cbiAgICAgICAgICAgICAgICAgIHN0eWxlc0luRG9tLnNwbGljZShfaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGxhc3RJZGVudGlmaWVycyA9IG5ld0xhc3RJZGVudGlmaWVycztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgICAvKioqL1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2dsb2JhbC5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9nbG9iYWwuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzV2VicGFja0J1aWxkaW5HbG9iYWxKcyhtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICAgICB2YXIgZzsgLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcblxuICAgICAgICAgIGcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9KCk7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG4gICAgICAgICAgICBnID0gZyB8fCBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG4gICAgICAgICAgICBpZiAoX3R5cGVvZih3aW5kb3cpID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xuICAgICAgICAgIH0gLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuICAgICAgICAgIC8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXG4gICAgICAgICAgLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5cbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGc7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4uL3NyYy9qcy9jb2x1bW5zL2FjdGlvbi9pbnRlcm5hbC9JbmxpbmVJbnB1dEVsZW1lbnQuY3NzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuLi9zcmMvanMvY29sdW1ucy9hY3Rpb24vaW50ZXJuYWwvSW5saW5lSW5wdXRFbGVtZW50LmNzcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBzcmNKc0NvbHVtbnNBY3Rpb25JbnRlcm5hbElubGluZUlucHV0RWxlbWVudENzcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICB2YXIgYXBpID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzICovXG4gICAgICAgICAgXCIuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIik7XG5cbiAgICAgICAgICB2YXIgY29udGVudCA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohICEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS01LTEhLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYz8/cmVmLS01LTIhLi9JbmxpbmVJbnB1dEVsZW1lbnQuY3NzICovXG4gICAgICAgICAgXCIuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8hLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8hLi4vc3JjL2pzL2NvbHVtbnMvYWN0aW9uL2ludGVybmFsL0lubGluZUlucHV0RWxlbWVudC5jc3NcIik7XG5cbiAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBvcHRpb25zID0ge307XG4gICAgICAgICAgb3B0aW9ucy5pbnNlcnQgPSBcImhlYWRcIjtcbiAgICAgICAgICBvcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuICAgICAgICAgIHZhciB1cGRhdGUgPSBhcGkoY29udGVudCwgb3B0aW9ucyk7XG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscyB8fCB7fTtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi4vc3JjL2pzL2NvbHVtbnMvYWN0aW9uL2ludGVybmFsL0lubGluZU1lbnVFbGVtZW50LmNzc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuLi9zcmMvanMvY29sdW1ucy9hY3Rpb24vaW50ZXJuYWwvSW5saW5lTWVudUVsZW1lbnQuY3NzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gc3JjSnNDb2x1bW5zQWN0aW9uSW50ZXJuYWxJbmxpbmVNZW51RWxlbWVudENzcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICB2YXIgYXBpID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzICovXG4gICAgICAgICAgXCIuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIik7XG5cbiAgICAgICAgICB2YXIgY29udGVudCA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohICEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS01LTEhLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYz8/cmVmLS01LTIhLi9JbmxpbmVNZW51RWxlbWVudC5jc3MgKi9cbiAgICAgICAgICBcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPyEuLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPyEuLi9zcmMvanMvY29sdW1ucy9hY3Rpb24vaW50ZXJuYWwvSW5saW5lTWVudUVsZW1lbnQuY3NzXCIpO1xuXG4gICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaSwgY29udGVudCwgJyddXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgIG9wdGlvbnMuaW5zZXJ0ID0gXCJoZWFkXCI7XG4gICAgICAgICAgb3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcbiAgICAgICAgICB2YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHMgfHwge307XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4uL3NyYy9qcy9jb2x1bW5zL2FjdGlvbi9pbnRlcm5hbC9TbWFsbERpYWxvZ0lucHV0RWxlbWVudC5jc3NcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi4vc3JjL2pzL2NvbHVtbnMvYWN0aW9uL2ludGVybmFsL1NtYWxsRGlhbG9nSW5wdXRFbGVtZW50LmNzcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIHNyY0pzQ29sdW1uc0FjdGlvbkludGVybmFsU21hbGxEaWFsb2dJbnB1dEVsZW1lbnRDc3MobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgdmFyIGFwaSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcyAqL1xuICAgICAgICAgIFwiLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIGNvbnRlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAhLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tNS0xIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmM/P3JlZi0tNS0yIS4vU21hbGxEaWFsb2dJbnB1dEVsZW1lbnQuY3NzICovXG4gICAgICAgICAgXCIuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8hLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8hLi4vc3JjL2pzL2NvbHVtbnMvYWN0aW9uL2ludGVybmFsL1NtYWxsRGlhbG9nSW5wdXRFbGVtZW50LmNzc1wiKTtcblxuICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmksIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICBvcHRpb25zLmluc2VydCA9IFwiaGVhZFwiO1xuICAgICAgICAgIG9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG4gICAgICAgICAgdmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzIHx8IHt9O1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuLi9zcmMvanMvY29sdW1ucy9tZXNzYWdlL2ludGVybmFsL0Vycm9yTWVzc2FnZUVsZW1lbnQuY3NzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4uL3NyYy9qcy9jb2x1bW5zL21lc3NhZ2UvaW50ZXJuYWwvRXJyb3JNZXNzYWdlRWxlbWVudC5jc3MgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBzcmNKc0NvbHVtbnNNZXNzYWdlSW50ZXJuYWxFcnJvck1lc3NhZ2VFbGVtZW50Q3NzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIHZhciBhcGkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanMgKi9cbiAgICAgICAgICBcIi4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKTtcblxuICAgICAgICAgIHZhciBjb250ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTUtMSEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvc3JjPz9yZWYtLTUtMiEuL0Vycm9yTWVzc2FnZUVsZW1lbnQuY3NzICovXG4gICAgICAgICAgXCIuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8hLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8hLi4vc3JjL2pzL2NvbHVtbnMvbWVzc2FnZS9pbnRlcm5hbC9FcnJvck1lc3NhZ2VFbGVtZW50LmNzc1wiKTtcblxuICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmksIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICBvcHRpb25zLmluc2VydCA9IFwiaGVhZFwiO1xuICAgICAgICAgIG9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG4gICAgICAgICAgdmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzIHx8IHt9O1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuLi9zcmMvanMvY29sdW1ucy9tZXNzYWdlL2ludGVybmFsL01lc3NhZ2VFbGVtZW50LmNzc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi4vc3JjL2pzL2NvbHVtbnMvbWVzc2FnZS9pbnRlcm5hbC9NZXNzYWdlRWxlbWVudC5jc3MgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gc3JjSnNDb2x1bW5zTWVzc2FnZUludGVybmFsTWVzc2FnZUVsZW1lbnRDc3MobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgdmFyIGFwaSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcyAqL1xuICAgICAgICAgIFwiLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIGNvbnRlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAhLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tNS0xIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmM/P3JlZi0tNS0yIS4vTWVzc2FnZUVsZW1lbnQuY3NzICovXG4gICAgICAgICAgXCIuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8hLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8hLi4vc3JjL2pzL2NvbHVtbnMvbWVzc2FnZS9pbnRlcm5hbC9NZXNzYWdlRWxlbWVudC5jc3NcIik7XG5cbiAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBvcHRpb25zID0ge307XG4gICAgICAgICAgb3B0aW9ucy5pbnNlcnQgPSBcImhlYWRcIjtcbiAgICAgICAgICBvcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuICAgICAgICAgIHZhciB1cGRhdGUgPSBhcGkoY29udGVudCwgb3B0aW9ucyk7XG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscyB8fCB7fTtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi4vc3JjL2pzL2NvbHVtbnMvbWVzc2FnZS9pbnRlcm5hbC9XYXJuaW5nTWVzc2FnZUVsZW1lbnQuY3NzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi4vc3JjL2pzL2NvbHVtbnMvbWVzc2FnZS9pbnRlcm5hbC9XYXJuaW5nTWVzc2FnZUVsZW1lbnQuY3NzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBzcmNKc0NvbHVtbnNNZXNzYWdlSW50ZXJuYWxXYXJuaW5nTWVzc2FnZUVsZW1lbnRDc3MobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgdmFyIGFwaSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcyAqL1xuICAgICAgICAgIFwiLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIGNvbnRlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAhLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tNS0xIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmM/P3JlZi0tNS0yIS4vV2FybmluZ01lc3NhZ2VFbGVtZW50LmNzcyAqL1xuICAgICAgICAgIFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/IS4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/IS4uL3NyYy9qcy9jb2x1bW5zL21lc3NhZ2UvaW50ZXJuYWwvV2FybmluZ01lc3NhZ2VFbGVtZW50LmNzc1wiKTtcblxuICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmksIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICBvcHRpb25zLmluc2VydCA9IFwiaGVhZFwiO1xuICAgICAgICAgIG9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG4gICAgICAgICAgdmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzIHx8IHt9O1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuLi9zcmMvanMvaW50ZXJuYWwvc3R5bGUuY3NzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4uL3NyYy9qcy9pbnRlcm5hbC9zdHlsZS5jc3MgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBzcmNKc0ludGVybmFsU3R5bGVDc3MobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgdmFyIGFwaSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcyAqL1xuICAgICAgICAgIFwiLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIGNvbnRlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tNS0xIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmM/P3JlZi0tNS0yIS4vc3R5bGUuY3NzICovXG4gICAgICAgICAgXCIuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8hLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8hLi4vc3JjL2pzL2ludGVybmFsL3N0eWxlLmNzc1wiKTtcblxuICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmksIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICBvcHRpb25zLmluc2VydCA9IFwiaGVhZFwiO1xuICAgICAgICAgIG9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG4gICAgICAgICAgdmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzIHx8IHt9O1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuLi9zcmMvanMvdG9vbHRpcC9pbnRlcm5hbC9Ub29sdGlwRWxlbWVudC5jc3NcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuLi9zcmMvanMvdG9vbHRpcC9pbnRlcm5hbC9Ub29sdGlwRWxlbWVudC5jc3MgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIHNyY0pzVG9vbHRpcEludGVybmFsVG9vbHRpcEVsZW1lbnRDc3MobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgdmFyIGFwaSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcyAqL1xuICAgICAgICAgIFwiLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIGNvbnRlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tNS0xIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmM/P3JlZi0tNS0yIS4vVG9vbHRpcEVsZW1lbnQuY3NzICovXG4gICAgICAgICAgXCIuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8hLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8hLi4vc3JjL2pzL3Rvb2x0aXAvaW50ZXJuYWwvVG9vbHRpcEVsZW1lbnQuY3NzXCIpO1xuXG4gICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaSwgY29udGVudCwgJyddXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgIG9wdGlvbnMuaW5zZXJ0ID0gXCJoZWFkXCI7XG4gICAgICAgICAgb3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcbiAgICAgICAgICB2YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHMgfHwge307XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vR3JpZENhbnZhc0hlbHBlci5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vR3JpZENhbnZhc0hlbHBlci5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gR3JpZENhbnZhc0hlbHBlckpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgdmFyIF9fY3JlYXRlQmluZGluZyA9IHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcgfHwgKE9iamVjdC5jcmVhdGUgPyBmdW5jdGlvbiAobywgbSwgaywgazIpIHtcbiAgICAgICAgICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG5cbiAgICAgICAgICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICAgICAgICAgIGRlc2MgPSB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBtW2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbiAgICAgICAgICB9IDogZnVuY3Rpb24gKG8sIG0sIGssIGsyKSB7XG4gICAgICAgICAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgICAgICAgICAgb1trMl0gPSBtW2tdO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQgfHwgKE9iamVjdC5jcmVhdGUgPyBmdW5jdGlvbiAobywgdikge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7XG4gICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgIHZhbHVlOiB2XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IDogZnVuY3Rpb24gKG8sIHYpIHtcbiAgICAgICAgICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBfX2ltcG9ydFN0YXIgPSB0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgICAgICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgICAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSB7XG4gICAgICAgICAgICAgIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuR3JpZENhbnZhc0hlbHBlciA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBjYWxjID0gX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vaW50ZXJuYWwvY2FsYyAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC9jYWxjLmpzXCIpKTtcblxuICAgICAgICAgIHZhciBjYW52YXNoZWxwZXIgPSBfX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi90b29scy9jYW52YXNoZWxwZXIgKi9cbiAgICAgICAgICBcIi4vdG9vbHMvY2FudmFzaGVscGVyLmpzXCIpKTtcblxuICAgICAgICAgIHZhciBmb250cyA9IF9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL2ludGVybmFsL2ZvbnRzICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL2ZvbnRzLmpzXCIpKTtcblxuICAgICAgICAgIHZhciBpbmxpbmVVdGlscyA9IF9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL2VsZW1lbnQvaW5saW5lcyAqL1xuICAgICAgICAgIFwiLi9lbGVtZW50L2lubGluZXMuanNcIikpO1xuXG4gICAgICAgICAgdmFyIHRoZW1lcyA9IF9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL3RoZW1lcyAqL1xuICAgICAgICAgIFwiLi90aGVtZXMuanNcIikpO1xuXG4gICAgICAgICAgdmFyIGNhbnZhc2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL2ludGVybmFsL2NhbnZhc2VzICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL2NhbnZhc2VzLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIHV0aWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL2ludGVybmFsL3V0aWxzICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL3V0aWxzLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIElubGluZURyYXdlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9lbGVtZW50L0lubGluZURyYXdlciAqL1xuICAgICAgICAgIFwiLi9lbGVtZW50L0lubGluZURyYXdlci5qc1wiKTtcblxuICAgICAgICAgIHZhciBSZWN0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL2ludGVybmFsL1JlY3QgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvUmVjdC5qc1wiKTtcblxuICAgICAgICAgIHZhciBjb2xvcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9pbnRlcm5hbC9jb2xvciAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC9jb2xvci5qc1wiKTtcblxuICAgICAgICAgIHZhciBfdG9Cb3hBcnJheSA9IHV0aWxzXzEuc3R5bGUudG9Cb3hBcnJheTtcbiAgICAgICAgICB2YXIgSU5MSU5FX0VMTElQU0lTID0gaW5saW5lVXRpbHMub2YoXCJcXHUyMDI2XCIpO1xuICAgICAgICAgIHZhciBURVhUX09GRlNFVCA9IDI7XG4gICAgICAgICAgdmFyIENIRUNLQk9YX09GRlNFVCA9IFRFWFRfT0ZGU0VUICsgMTtcblxuICAgICAgICAgIGZ1bmN0aW9uIGludmFsaWRhdGVDZWxsKGNvbnRleHQsIGdyaWQpIHtcbiAgICAgICAgICAgIHZhciBjb2wgPSBjb250ZXh0LmNvbCxcbiAgICAgICAgICAgICAgICByb3cgPSBjb250ZXh0LnJvdztcbiAgICAgICAgICAgIGdyaWQuaW52YWxpZGF0ZUNlbGwoY29sLCByb3cpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIF9nZXRTdHlsZVByb3BlcnR5KGNvbG9yLCBjb2wsIHJvdywgZ3JpZCwgY29udGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLmdldE9yQXBwbHkpKGNvbG9yLCB7XG4gICAgICAgICAgICAgIGNvbDogY29sLFxuICAgICAgICAgICAgICByb3c6IHJvdyxcbiAgICAgICAgICAgICAgZ3JpZDogZ3JpZCxcbiAgICAgICAgICAgICAgY29udGV4dDogY29udGV4dFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gZ2V0Rm9udChmb250LCBjb2wsIHJvdywgZ3JpZCwgY29udGV4dCkge1xuICAgICAgICAgICAgaWYgKGZvbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEuZ2V0T3JBcHBseSkoZm9udCwge1xuICAgICAgICAgICAgICBjb2w6IGNvbCxcbiAgICAgICAgICAgICAgcm93OiByb3csXG4gICAgICAgICAgICAgIGdyaWQ6IGdyaWQsXG4gICAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIF9nZXRUaGVtZVZhbHVlKGdyaWQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBuYW1lcyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgICAgIG5hbWVzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGdyaWRUaGVtZVZhbHVlID0gKDAsIHV0aWxzXzEuZ2V0Q2hhaW5TYWZlKS5hcHBseSh2b2lkIDAsIFtncmlkLnRoZW1lXS5jb25jYXQobmFtZXMpKTtcblxuICAgICAgICAgICAgaWYgKGdyaWRUaGVtZVZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gdXNlIGRlZmF1bHQgdGhlbWVcbiAgICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLmdldENoYWluU2FmZSkuYXBwbHkodm9pZCAwLCBbdGhlbWVzLmdldERlZmF1bHQoKV0uY29uY2F0KG5hbWVzKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZ3JpZFRoZW1lVmFsdWUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICByZXR1cm4gZ3JpZFRoZW1lVmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkZWZhdWx0VGhlbWVWYWx1ZTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcblxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGdyaWRUaGVtZVZhbHVlKGFyZ3MpO1xuXG4gICAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gdXNlIGdyaWQgdGhlbWVcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgIH0gLy8gdXNlIGRlZmF1bHQgdGhlbWVcblxuXG4gICAgICAgICAgICAgIGRlZmF1bHRUaGVtZVZhbHVlID0gZGVmYXVsdFRoZW1lVmFsdWUgfHwgKDAsIHV0aWxzXzEuZ2V0Q2hhaW5TYWZlKS5hcHBseSh2b2lkIDAsIFt0aGVtZXMuZ2V0RGVmYXVsdCgpXS5jb25jYXQobmFtZXMpKTtcbiAgICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLmdldE9yQXBwbHkpKGRlZmF1bHRUaGVtZVZhbHVlLCBhcmdzKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gX3Rlc3RGb250TG9hZChmb250LCB2YWx1ZSwgY29udGV4dCwgZ3JpZCkge1xuICAgICAgICAgICAgaWYgKGZvbnQpIHtcbiAgICAgICAgICAgICAgaWYgKCFmb250cy5jaGVjayhmb250LCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBmb250cy5sb2FkKGZvbnQsIHZhbHVlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gaW52YWxpZGF0ZUNlbGwoY29udGV4dCwgZ3JpZCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGRyYXdJbmxpbmVzKGN0eCwgaW5saW5lcywgcmVjdCwgb2Zmc2V0LCBvZmZzZXRUb3AsIG9mZnNldEJvdHRvbSwgY29sLCByb3csIGdyaWQpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGRyYXdJbmxpbmUoaW5saW5lLCBvZmZzZXRMZWZ0LCBvZmZzZXRSaWdodCkge1xuICAgICAgICAgICAgICBpZiAoaW5saW5lLmNhbkRyYXcoKSkge1xuICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IF9nZXRTdHlsZVByb3BlcnR5KGlubGluZS5jb2xvcigpIHx8IGN0eC5maWxsU3R5bGUsIGNvbCwgcm93LCBncmlkLCBjdHgpO1xuICAgICAgICAgICAgICAgICAgY3R4LmZvbnQgPSBpbmxpbmUuZm9udCgpIHx8IGN0eC5mb250O1xuICAgICAgICAgICAgICAgICAgaW5saW5lLmRyYXcoe1xuICAgICAgICAgICAgICAgICAgICBjdHg6IGN0eCxcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzaGVscGVyOiBjYW52YXNoZWxwZXIsXG4gICAgICAgICAgICAgICAgICAgIHJlY3Q6IHJlY3QsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXRMZWZ0OiBvZmZzZXRMZWZ0LFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXRSaWdodDogb2Zmc2V0UmlnaHQsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFRvcDogb2Zmc2V0VG9wLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXRCb3R0b206IG9mZnNldEJvdHRvbVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlubGluZS5vblJlYWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBncmlkLmludmFsaWRhdGVDZWxsKGNvbCwgcm93KTtcbiAgICAgICAgICAgICAgICB9KTsgLy9ub29wXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlubGluZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgIC8vMeS7tuOBruWgtOWQiOOBr+W5heioiOeul+OBjOS4jeimgeOBquOBn+OCgeWIhuWykFxuICAgICAgICAgICAgICB2YXIgaW5saW5lID0gaW5saW5lc1swXTtcbiAgICAgICAgICAgICAgZHJhd0lubGluZShpbmxpbmUsIDAsIDApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIGlubGluZVdpZHRocyA9IGlubGluZXMubWFwKGZ1bmN0aW9uIChpbmxpbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGlubGluZS53aWR0aCh7XG4gICAgICAgICAgICAgICAgICBjdHg6IGN0eFxuICAgICAgICAgICAgICAgIH0pIHx8IDApIC0gMDtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHZhciBvZmZzZXRSaWdodCA9IGlubGluZVdpZHRocy5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYSArIGI7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB2YXIgb2Zmc2V0TGVmdCA9IDA7XG4gICAgICAgICAgICAgIGlubGluZXMuZm9yRWFjaChmdW5jdGlvbiAoaW5saW5lLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBpbmxpbmVXaWR0aCA9IGlubGluZVdpZHRoc1tpbmRleF07XG4gICAgICAgICAgICAgICAgb2Zmc2V0UmlnaHQgLT0gaW5saW5lV2lkdGg7XG4gICAgICAgICAgICAgICAgZHJhd0lubGluZShpbmxpbmUsIG9mZnNldExlZnQsIG9mZnNldFJpZ2h0KTtcbiAgICAgICAgICAgICAgICBvZmZzZXRMZWZ0ICs9IGlubGluZVdpZHRoO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBidWlsZElubGluZXMoaWNvbnMsIGlubGluZSkge1xuICAgICAgICAgICAgcmV0dXJuIGlubGluZVV0aWxzLmJ1aWxkSW5saW5lcyhpY29ucywgaW5saW5lIHx8IFwiXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGlubGluZVRvU3RyaW5nKGlubGluZSkge1xuICAgICAgICAgICAgcmV0dXJuIGlubGluZVV0aWxzLnN0cmluZyhpbmxpbmUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGdldE92ZXJmbG93SW5saW5lKHRleHRPdmVyZmxvdykge1xuICAgICAgICAgICAgaWYgKCFpc0FsbG93T3ZlcmZsb3codGV4dE92ZXJmbG93KSB8fCB0ZXh0T3ZlcmZsb3cgPT09IFwiZWxsaXBzaXNcIikge1xuICAgICAgICAgICAgICByZXR1cm4gSU5MSU5FX0VMTElQU0lTO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0ZXh0T3ZlcmZsb3cgPSB0ZXh0T3ZlcmZsb3cudHJpbSgpO1xuXG4gICAgICAgICAgICBpZiAodGV4dE92ZXJmbG93Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICByZXR1cm4gaW5saW5lVXRpbHMub2YodGV4dE92ZXJmbG93WzBdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIElOTElORV9FTExJUFNJUztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBpc0FsbG93T3ZlcmZsb3codGV4dE92ZXJmbG93KSB7XG4gICAgICAgICAgICByZXR1cm4gQm9vbGVhbih0ZXh0T3ZlcmZsb3cgJiYgdGV4dE92ZXJmbG93ICE9PSBcImNsaXBcIiAmJiB0eXBlb2YgdGV4dE92ZXJmbG93ID09PSBcInN0cmluZ1wiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBnZXRPdmVyZmxvd0lubGluZXNJbmRleChjdHgsIGlubGluZXMsIHdpZHRoKSB7XG4gICAgICAgICAgICB2YXIgbWF4V2lkdGggPSB3aWR0aCAtIDM7XG4gICAgICAgICAgICAvKmJ1ZmZlciovXG5cbiAgICAgICAgICAgIHZhciBsaW5lV2lkdGggPSAwO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlubGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIGlubGluZSA9IGlubGluZXNbaV07XG4gICAgICAgICAgICAgIHZhciBpbmxpbmVXaWR0aCA9IChpbmxpbmUud2lkdGgoe1xuICAgICAgICAgICAgICAgIGN0eDogY3R4XG4gICAgICAgICAgICAgIH0pIHx8IDApIC0gMDtcblxuICAgICAgICAgICAgICBpZiAobGluZVdpZHRoICsgaW5saW5lV2lkdGggPiBtYXhXaWR0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogbGluZVdpZHRoLFxuICAgICAgICAgICAgICAgICAgcmVtV2lkdGg6IG1heFdpZHRoIC0gbGluZVdpZHRoXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGxpbmVXaWR0aCArPSBpbmxpbmVXaWR0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gaXNPdmVyZmxvd0lubGluZXMoY3R4LCBpbmxpbmVzLCB3aWR0aCkge1xuICAgICAgICAgICAgcmV0dXJuICEhZ2V0T3ZlcmZsb3dJbmxpbmVzSW5kZXgoY3R4LCBpbmxpbmVzLCB3aWR0aCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gYnJlYWtXaWR0aElubGluZXMoY3R4LCBpbmxpbmVzLCB3aWR0aCkge1xuICAgICAgICAgICAgdmFyIGluZGV4RGF0YSA9IGdldE92ZXJmbG93SW5saW5lc0luZGV4KGN0eCwgaW5saW5lcywgd2lkdGgpO1xuXG4gICAgICAgICAgICBpZiAoIWluZGV4RGF0YSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJlZm9yZUlubGluZXM6IGlubGluZXMsXG4gICAgICAgICAgICAgICAgb3ZlcmZsb3c6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGFmdGVySW5saW5lczogW11cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGluZGV4ID0gaW5kZXhEYXRhLmluZGV4LFxuICAgICAgICAgICAgICAgIHJlbVdpZHRoID0gaW5kZXhEYXRhLnJlbVdpZHRoO1xuICAgICAgICAgICAgdmFyIGlubGluZSA9IGlubGluZXNbaW5kZXhdO1xuICAgICAgICAgICAgdmFyIGJlZm9yZUlubGluZXMgPSBpbmxpbmVzLnNsaWNlKDAsIGluZGV4KTtcbiAgICAgICAgICAgIHZhciBhZnRlcklubGluZXMgPSBbXTtcblxuICAgICAgICAgICAgaWYgKGlubGluZS5jYW5CcmVhaygpKSB7XG4gICAgICAgICAgICAgIHZhciBfaW5saW5lJGJyZWFrV29yZCA9IGlubGluZS5icmVha1dvcmQoY3R4LCByZW1XaWR0aCksXG4gICAgICAgICAgICAgICAgICBiZWZvcmUgPSBfaW5saW5lJGJyZWFrV29yZC5iZWZvcmUsXG4gICAgICAgICAgICAgICAgICBhZnRlciA9IF9pbmxpbmUkYnJlYWtXb3JkLmFmdGVyO1xuXG4gICAgICAgICAgICAgIGlmICghYmVmb3JlICYmICFiZWZvcmVJbmxpbmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBfaW5saW5lJGJyZWFrQWxsID0gaW5saW5lLmJyZWFrQWxsKGN0eCwgcmVtV2lkdGgpO1xuXG4gICAgICAgICAgICAgICAgYmVmb3JlID0gX2lubGluZSRicmVha0FsbC5iZWZvcmU7XG4gICAgICAgICAgICAgICAgYWZ0ZXIgPSBfaW5saW5lJGJyZWFrQWxsLmFmdGVyO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCFiZWZvcmUgJiYgIWJlZm9yZUlubGluZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gQWx3YXlzIHJldHVybiBvbmUgY2hhclxuICAgICAgICAgICAgICAgIHZhciBfaW5saW5lJHNwbGl0SW5kZXggPSBpbmxpbmUuc3BsaXRJbmRleCgxKTtcblxuICAgICAgICAgICAgICAgIGJlZm9yZSA9IF9pbmxpbmUkc3BsaXRJbmRleC5iZWZvcmU7XG4gICAgICAgICAgICAgICAgYWZ0ZXIgPSBfaW5saW5lJHNwbGl0SW5kZXguYWZ0ZXI7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgYmVmb3JlSW5saW5lcy5wdXNoKGJlZm9yZSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoYWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICBhZnRlcklubGluZXMucHVzaChhZnRlcik7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBhZnRlcklubGluZXMucHVzaC5hcHBseShhZnRlcklubGluZXMsIF90b0NvbnN1bWFibGVBcnJheShpbmxpbmVzLnNsaWNlKGluZGV4ICsgMSkpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICghYmVmb3JlSW5saW5lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBBbHdheXMgcmV0dXJuIG9uZSBjaGFyXG4gICAgICAgICAgICAgICAgYmVmb3JlSW5saW5lcy5wdXNoKGlubGluZSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBhZnRlcklubGluZXMucHVzaC5hcHBseShhZnRlcklubGluZXMsIF90b0NvbnN1bWFibGVBcnJheShpbmxpbmVzLnNsaWNlKGJlZm9yZUlubGluZXMubGVuZ3RoKSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBiZWZvcmVJbmxpbmVzOiBiZWZvcmVJbmxpbmVzLFxuICAgICAgICAgICAgICBvdmVyZmxvdzogdHJ1ZSxcbiAgICAgICAgICAgICAgYWZ0ZXJJbmxpbmVzOiBhZnRlcklubGluZXNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gdHJ1bmNhdGVJbmxpbmVzKGN0eCwgaW5saW5lcywgd2lkdGgsIG9wdGlvbikge1xuICAgICAgICAgICAgdmFyIGluZGV4RGF0YSA9IGdldE92ZXJmbG93SW5saW5lc0luZGV4KGN0eCwgaW5saW5lcywgd2lkdGgpO1xuXG4gICAgICAgICAgICBpZiAoIWluZGV4RGF0YSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlubGluZXM6IGlubGluZXMsXG4gICAgICAgICAgICAgICAgb3ZlcmZsb3c6IGZhbHNlXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpbmRleCA9IGluZGV4RGF0YS5pbmRleCxcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGggPSBpbmRleERhdGEubGluZVdpZHRoO1xuICAgICAgICAgICAgdmFyIGlubGluZSA9IGlubGluZXNbaW5kZXhdO1xuICAgICAgICAgICAgdmFyIG92ZXJmbG93SW5saW5lID0gZ2V0T3ZlcmZsb3dJbmxpbmUob3B0aW9uKTtcbiAgICAgICAgICAgIHZhciBlbGxpcHNpc1dpZHRoID0gb3ZlcmZsb3dJbmxpbmUud2lkdGgoe1xuICAgICAgICAgICAgICBjdHg6IGN0eFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgcmVtV2lkdGggPSB3aWR0aCAtIGxpbmVXaWR0aCAtIGVsbGlwc2lzV2lkdGg7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gaW5saW5lcy5zbGljZSgwLCBpbmRleCk7XG5cbiAgICAgICAgICAgIGlmIChpbmxpbmUuY2FuQnJlYWsoKSkge1xuICAgICAgICAgICAgICB2YXIgX2lubGluZSRicmVha0FsbDIgPSBpbmxpbmUuYnJlYWtBbGwoY3R4LCByZW1XaWR0aCksXG4gICAgICAgICAgICAgICAgICBiZWZvcmUgPSBfaW5saW5lJGJyZWFrQWxsMi5iZWZvcmU7XG5cbiAgICAgICAgICAgICAgaWYgKGJlZm9yZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJlZm9yZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0LnB1c2gob3ZlcmZsb3dJbmxpbmUpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgaW5saW5lczogcmVzdWx0LFxuICAgICAgICAgICAgICBvdmVyZmxvdzogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBfaW5saW5lUmVjdChncmlkLCBjdHgsIGlubGluZSwgZHJhd1JlY3QsIGNvbCwgcm93LCBfcmVmKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gX3JlZi5vZmZzZXQsXG4gICAgICAgICAgICAgICAgY29sb3IgPSBfcmVmLmNvbG9yLFxuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9IF9yZWYudGV4dEFsaWduLFxuICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZSA9IF9yZWYudGV4dEJhc2VsaW5lLFxuICAgICAgICAgICAgICAgIGZvbnQgPSBfcmVmLmZvbnQsXG4gICAgICAgICAgICAgICAgdGV4dE92ZXJmbG93ID0gX3JlZi50ZXh0T3ZlcmZsb3csXG4gICAgICAgICAgICAgICAgaWNvbnMgPSBfcmVmLmljb25zLFxuICAgICAgICAgICAgICAgIHRyYWlsaW5nSWNvbiA9IF9yZWYudHJhaWxpbmdJY29uO1xuICAgICAgICAgICAgLy/mloflrZdzdHlsZVxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IF9nZXRTdHlsZVByb3BlcnR5KGNvbG9yIHx8IGN0eC5maWxsU3R5bGUsIGNvbCwgcm93LCBncmlkLCBjdHgpO1xuICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9IHRleHRBbGlnbjtcbiAgICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSB0ZXh0QmFzZWxpbmU7XG4gICAgICAgICAgICBjdHguZm9udCA9IGZvbnQgfHwgY3R4LmZvbnQ7XG4gICAgICAgICAgICB2YXIgaW5saW5lcyA9IGJ1aWxkSW5saW5lcyhpY29ucywgaW5saW5lKTtcbiAgICAgICAgICAgIHZhciB0cmFpbGluZ0ljb25JbmxpbmUgPSB0cmFpbGluZ0ljb24gPyBpbmxpbmVVdGlscy5pY29uT2YodHJhaWxpbmdJY29uKSA6IG51bGw7XG4gICAgICAgICAgICB2YXIgaW5saW5lRHJhd1JlY3QgPSBkcmF3UmVjdDtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IGRyYXdSZWN0LndpZHRoO1xuICAgICAgICAgICAgdmFyIHRyYWlsaW5nSWNvbldpZHRoID0gMDtcblxuICAgICAgICAgICAgaWYgKHRyYWlsaW5nSWNvbklubGluZSkge1xuICAgICAgICAgICAgICB0cmFpbGluZ0ljb25XaWR0aCA9IHRyYWlsaW5nSWNvbklubGluZS53aWR0aCh7XG4gICAgICAgICAgICAgICAgY3R4OiBjdHhcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHdpZHRoIC09IHRyYWlsaW5nSWNvbldpZHRoO1xuICAgICAgICAgICAgICBpbmxpbmVEcmF3UmVjdCA9IG5ldyBSZWN0XzEuUmVjdChkcmF3UmVjdC5sZWZ0LCBkcmF3UmVjdC50b3AsIHdpZHRoLCBkcmF3UmVjdC5oZWlnaHQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNBbGxvd092ZXJmbG93KHRleHRPdmVyZmxvdykgJiYgaXNPdmVyZmxvd0lubGluZXMoY3R4LCBpbmxpbmVzLCB3aWR0aCkpIHtcbiAgICAgICAgICAgICAgdmFyIF90cnVuY2F0ZUlubGluZXMgPSB0cnVuY2F0ZUlubGluZXMoY3R4LCBpbmxpbmVzLCB3aWR0aCwgdGV4dE92ZXJmbG93KSxcbiAgICAgICAgICAgICAgICAgIHRydW5jSW5saW5lcyA9IF90cnVuY2F0ZUlubGluZXMuaW5saW5lcyxcbiAgICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gX3RydW5jYXRlSW5saW5lcy5vdmVyZmxvdztcblxuICAgICAgICAgICAgICBpbmxpbmVzID0gdHJ1bmNJbmxpbmVzO1xuICAgICAgICAgICAgICBncmlkLnNldENlbGxPdmVyZmxvd1RleHQoY29sLCByb3csIG92ZXJmbG93ICYmIGlubGluZVRvU3RyaW5nKGlubGluZSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZ3JpZC5zZXRDZWxsT3ZlcmZsb3dUZXh0KGNvbCwgcm93LCBmYWxzZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRyYXdJbmxpbmVzKGN0eCwgaW5saW5lcywgaW5saW5lRHJhd1JlY3QsIG9mZnNldCwgMCwgMCwgY29sLCByb3csIGdyaWQpO1xuXG4gICAgICAgICAgICBpZiAodHJhaWxpbmdJY29uSW5saW5lKSB7XG4gICAgICAgICAgICAgIC8vIERyYXcgdHJhaWxpbmcgaWNvblxuICAgICAgICAgICAgICB2YXIgc3VtV2lkdGggPSAwO1xuICAgICAgICAgICAgICBpbmxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGlubGluZSkge1xuICAgICAgICAgICAgICAgIHN1bVdpZHRoICs9IGlubGluZS53aWR0aCh7XG4gICAgICAgICAgICAgICAgICBjdHg6IGN0eFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgdmFyIGJhc2VSZWN0ID0gbmV3IFJlY3RfMS5SZWN0KGRyYXdSZWN0LmxlZnQsIGRyYXdSZWN0LnRvcCwgZHJhd1JlY3Qud2lkdGgsIGRyYXdSZWN0LmhlaWdodCk7XG4gICAgICAgICAgICAgIHZhciB0cmFpbGluZ0ljb25SZWN0ID0gYmFzZVJlY3QuY29weSgpO1xuXG4gICAgICAgICAgICAgIGlmICh3aWR0aCA8IHN1bVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgdHJhaWxpbmdJY29uUmVjdC5sZWZ0ID0gdHJhaWxpbmdJY29uUmVjdC5yaWdodCAtIHRyYWlsaW5nSWNvbldpZHRoIC0gb2Zmc2V0O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyYWlsaW5nSWNvblJlY3QubGVmdCArPSBzdW1XaWR0aDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRyYWlsaW5nSWNvblJlY3QucmlnaHQgPSBiYXNlUmVjdC5yaWdodDtcbiAgICAgICAgICAgICAgZHJhd0lubGluZXMoY3R4LCBbdHJhaWxpbmdJY29uSW5saW5lXSwgdHJhaWxpbmdJY29uUmVjdCwgb2Zmc2V0LCAwLCAwLCBjb2wsIHJvdywgZ3JpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuXG5cbiAgICAgICAgICBmdW5jdGlvbiBfbXVsdGlJbmxpbmVSZWN0KGdyaWQsIGN0eCwgbXVsdGlJbmxpbmVzLCBkcmF3UmVjdCwgY29sLCByb3csIF9yZWYyKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gX3JlZjIub2Zmc2V0LFxuICAgICAgICAgICAgICAgIGNvbG9yID0gX3JlZjIuY29sb3IsXG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gX3JlZjIudGV4dEFsaWduLFxuICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZSA9IF9yZWYyLnRleHRCYXNlbGluZSxcbiAgICAgICAgICAgICAgICBmb250ID0gX3JlZjIuZm9udCxcbiAgICAgICAgICAgICAgICBsaW5lSGVpZ2h0ID0gX3JlZjIubGluZUhlaWdodCxcbiAgICAgICAgICAgICAgICBhdXRvV3JhcFRleHQgPSBfcmVmMi5hdXRvV3JhcFRleHQsXG4gICAgICAgICAgICAgICAgbGluZUNsYW1wID0gX3JlZjIubGluZUNsYW1wLFxuICAgICAgICAgICAgICAgIHRleHRPdmVyZmxvdyA9IF9yZWYyLnRleHRPdmVyZmxvdyxcbiAgICAgICAgICAgICAgICBpY29ucyA9IF9yZWYyLmljb25zLFxuICAgICAgICAgICAgICAgIHRyYWlsaW5nSWNvbiA9IF9yZWYyLnRyYWlsaW5nSWNvbjtcbiAgICAgICAgICAgIC8v5paH5a2Xc3R5bGVcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBfZ2V0U3R5bGVQcm9wZXJ0eShjb2xvciB8fCBjdHguZmlsbFN0eWxlLCBjb2wsIHJvdywgZ3JpZCwgY3R4KTtcbiAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSB0ZXh0QWxpZ247XG4gICAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gdGV4dEJhc2VsaW5lO1xuICAgICAgICAgICAgY3R4LmZvbnQgPSBmb250IHx8IGN0eC5mb250O1xuXG4gICAgICAgICAgICBpZiAobGluZUNsYW1wID09PSBcImF1dG9cIikge1xuICAgICAgICAgICAgICB2YXIgcmVjdEhlaWdodCA9IGRyYXdSZWN0LmhlaWdodCAtIG9mZnNldCAqIDIgLSAyO1xuICAgICAgICAgICAgICAvKm9mZnNldCBhZGRlZCBieSBJbmxpbmUjZHJhdyovXG5cbiAgICAgICAgICAgICAgbGluZUNsYW1wID0gTWF0aC5tYXgoTWF0aC5mbG9vcihyZWN0SGVpZ2h0IC8gbGluZUhlaWdodCksIDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdHJhaWxpbmdJY29uSW5saW5lID0gdHJhaWxpbmdJY29uID8gaW5saW5lVXRpbHMuaWNvbk9mKHRyYWlsaW5nSWNvbikgOiBudWxsO1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gZHJhd1JlY3Qud2lkdGg7XG4gICAgICAgICAgICB2YXIgdHJhaWxpbmdJY29uV2lkdGggPSAwO1xuXG4gICAgICAgICAgICBpZiAodHJhaWxpbmdJY29uSW5saW5lKSB7XG4gICAgICAgICAgICAgIHRyYWlsaW5nSWNvbldpZHRoID0gdHJhaWxpbmdJY29uSW5saW5lLndpZHRoKHtcbiAgICAgICAgICAgICAgICBjdHg6IGN0eFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgd2lkdGggLT0gdHJhaWxpbmdJY29uV2lkdGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBidWlsZGVkTXVsdGlJbmxpbmVzO1xuXG4gICAgICAgICAgICBpZiAoYXV0b1dyYXBUZXh0IHx8IGxpbmVDbGFtcCA+IDAgfHwgaXNBbGxvd092ZXJmbG93KHRleHRPdmVyZmxvdykpIHtcbiAgICAgICAgICAgICAgYnVpbGRlZE11bHRpSW5saW5lcyA9IFtdO1xuICAgICAgICAgICAgICB2YXIgcHJvY0xpbmVDbGFtcCA9IGxpbmVDbGFtcCA+IDAgPyBmdW5jdGlvbiAoaW5saW5lcywgaGFzTmV4dCkge1xuICAgICAgICAgICAgICAgIGlmIChidWlsZGVkTXVsdGlJbmxpbmVzLmxlbmd0aCArIDEgPj0gbGluZUNsYW1wKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaW5saW5lcy5sZW5ndGggPT09IDAgJiYgaGFzTmV4dCkge1xuICAgICAgICAgICAgICAgICAgICBidWlsZGVkTXVsdGlJbmxpbmVzLnB1c2goW2dldE92ZXJmbG93SW5saW5lKHRleHRPdmVyZmxvdyldKTtcbiAgICAgICAgICAgICAgICAgICAgZ3JpZC5zZXRDZWxsT3ZlcmZsb3dUZXh0KGNvbCwgcm93LCBtdWx0aUlubGluZXMubWFwKGlubGluZVRvU3RyaW5nKS5qb2luKFwiXFxuXCIpKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdHJ1bmNhdGVJbmxpbmVzMiA9IHRydW5jYXRlSW5saW5lcyhjdHgsIGlubGluZXMsIHdpZHRoLCB0ZXh0T3ZlcmZsb3cpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ1bmNJbmxpbmVzID0gX3RydW5jYXRlSW5saW5lczIuaW5saW5lcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gX3RydW5jYXRlSW5saW5lczIub3ZlcmZsb3c7XG5cbiAgICAgICAgICAgICAgICAgICAgYnVpbGRlZE11bHRpSW5saW5lcy5wdXNoKGhhc05leHQgJiYgIW92ZXJmbG93ID8gdHJ1bmNJbmxpbmVzLmNvbmNhdChbZ2V0T3ZlcmZsb3dJbmxpbmUodGV4dE92ZXJmbG93KV0pIDogdHJ1bmNJbmxpbmVzKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAob3ZlcmZsb3cgfHwgaGFzTmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgIGdyaWQuc2V0Q2VsbE92ZXJmbG93VGV4dChjb2wsIHJvdywgbXVsdGlJbmxpbmVzLm1hcChpbmxpbmVUb1N0cmluZykuam9pbihcIlxcblwiKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9IDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB2YXIgcHJvY0xpbmUgPSBhdXRvV3JhcFRleHQgPyBmdW5jdGlvbiAoaW5saW5lcywgaGFzTmV4dCkge1xuICAgICAgICAgICAgICAgIGlmICghcHJvY0xpbmVDbGFtcChpbmxpbmVzLCBoYXNOZXh0KSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHdoaWxlIChpbmxpbmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgaWYgKCFwcm9jTGluZUNsYW1wKGlubGluZXMsIGhhc05leHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgdmFyIF9icmVha1dpZHRoSW5saW5lcyA9IGJyZWFrV2lkdGhJbmxpbmVzKGN0eCwgaW5saW5lcywgd2lkdGgpLFxuICAgICAgICAgICAgICAgICAgICAgIGJlZm9yZUlubGluZXMgPSBfYnJlYWtXaWR0aElubGluZXMuYmVmb3JlSW5saW5lcyxcbiAgICAgICAgICAgICAgICAgICAgICBhZnRlcklubGluZXMgPSBfYnJlYWtXaWR0aElubGluZXMuYWZ0ZXJJbmxpbmVzO1xuXG4gICAgICAgICAgICAgICAgICBidWlsZGVkTXVsdGlJbmxpbmVzLnB1c2goYmVmb3JlSW5saW5lcyk7XG4gICAgICAgICAgICAgICAgICBpbmxpbmVzID0gYWZ0ZXJJbmxpbmVzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9IDogaXNBbGxvd092ZXJmbG93KHRleHRPdmVyZmxvdykgPyBmdW5jdGlvbiAoaW5saW5lcywgaGFzTmV4dCkge1xuICAgICAgICAgICAgICAgIGlmICghcHJvY0xpbmVDbGFtcChpbmxpbmVzLCBoYXNOZXh0KSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBfdHJ1bmNhdGVJbmxpbmVzMyA9IHRydW5jYXRlSW5saW5lcyhjdHgsIGlubGluZXMsIHdpZHRoLCB0ZXh0T3ZlcmZsb3cpLFxuICAgICAgICAgICAgICAgICAgICB0cnVuY0lubGluZXMgPSBfdHJ1bmNhdGVJbmxpbmVzMy5pbmxpbmVzLFxuICAgICAgICAgICAgICAgICAgICBvdmVyZmxvdyA9IF90cnVuY2F0ZUlubGluZXMzLm92ZXJmbG93O1xuXG4gICAgICAgICAgICAgICAgYnVpbGRlZE11bHRpSW5saW5lcy5wdXNoKHRydW5jSW5saW5lcyk7XG5cbiAgICAgICAgICAgICAgICBpZiAob3ZlcmZsb3cpIHtcbiAgICAgICAgICAgICAgICAgIGdyaWQuc2V0Q2VsbE92ZXJmbG93VGV4dChjb2wsIHJvdywgbXVsdGlJbmxpbmVzLm1hcChpbmxpbmVUb1N0cmluZykuam9pbihcIlxcblwiKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH0gOiBmdW5jdGlvbiAoaW5saW5lcywgaGFzTmV4dCkge1xuICAgICAgICAgICAgICAgIGlmICghcHJvY0xpbmVDbGFtcChpbmxpbmVzLCBoYXNOZXh0KSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJ1aWxkZWRNdWx0aUlubGluZXMucHVzaChpbmxpbmVzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgZ3JpZC5zZXRDZWxsT3ZlcmZsb3dUZXh0KGNvbCwgcm93LCBmYWxzZSk7XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgbGluZVJvdyA9IDA7IGxpbmVSb3cgPCBtdWx0aUlubGluZXMubGVuZ3RoOyBsaW5lUm93KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5saW5lID0gbXVsdGlJbmxpbmVzW2xpbmVSb3ddO1xuICAgICAgICAgICAgICAgIHZhciBidWlsZGVkSW5saW5lID0gYnVpbGRJbmxpbmVzKGxpbmVSb3cgPT09IDAgPyBpY29ucyA6IHVuZGVmaW5lZCwgaW5saW5lKTtcblxuICAgICAgICAgICAgICAgIGlmICghcHJvY0xpbmUoYnVpbGRlZElubGluZSwgbGluZVJvdyArIDEgPCBtdWx0aUlubGluZXMubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBncmlkLnNldENlbGxPdmVyZmxvd1RleHQoY29sLCByb3csIGZhbHNlKTtcbiAgICAgICAgICAgICAgYnVpbGRlZE11bHRpSW5saW5lcyA9IG11bHRpSW5saW5lcy5tYXAoZnVuY3Rpb24gKGlubGluZSwgbGluZVJvdykge1xuICAgICAgICAgICAgICAgIHJldHVybiBidWlsZElubGluZXMobGluZVJvdyA9PT0gMCA/IGljb25zIDogdW5kZWZpbmVkLCBpbmxpbmUpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHBhZGRpbmdUb3AgPSAwO1xuICAgICAgICAgICAgdmFyIHBhZGRpbmdCb3R0b20gPSBsaW5lSGVpZ2h0ICogKGJ1aWxkZWRNdWx0aUlubGluZXMubGVuZ3RoIC0gMSk7XG5cbiAgICAgICAgICAgIGlmIChjdHgudGV4dEJhc2VsaW5lID09PSBcInRvcFwiIHx8IGN0eC50ZXh0QmFzZWxpbmUgPT09IFwiaGFuZ2luZ1wiKSB7XG4gICAgICAgICAgICAgIHZhciBlbSA9ICgwLCBjYW52YXNlc18xLmdldEZvbnRTaXplKShjdHgsIGN0eC5mb250KS5oZWlnaHQ7XG4gICAgICAgICAgICAgIHZhciBwYWQgPSAobGluZUhlaWdodCAtIGVtKSAvIDI7XG4gICAgICAgICAgICAgIHBhZGRpbmdUb3AgKz0gcGFkO1xuICAgICAgICAgICAgICBwYWRkaW5nQm90dG9tIC09IHBhZDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3R4LnRleHRCYXNlbGluZSA9PT0gXCJib3R0b21cIiB8fCBjdHgudGV4dEJhc2VsaW5lID09PSBcImFscGhhYmV0aWNcIiB8fCBjdHgudGV4dEJhc2VsaW5lID09PSBcImlkZW9ncmFwaGljXCIpIHtcbiAgICAgICAgICAgICAgdmFyIF9lbSA9ICgwLCBjYW52YXNlc18xLmdldEZvbnRTaXplKShjdHgsIGN0eC5mb250KS5oZWlnaHQ7XG5cbiAgICAgICAgICAgICAgdmFyIF9wYWQgPSAobGluZUhlaWdodCAtIF9lbSkgLyAyO1xuXG4gICAgICAgICAgICAgIHBhZGRpbmdUb3AgLT0gX3BhZDtcbiAgICAgICAgICAgICAgcGFkZGluZ0JvdHRvbSArPSBfcGFkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBidWlsZGVkTXVsdGlJbmxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGJ1aWxkZWRJbmxpbmUpIHtcbiAgICAgICAgICAgICAgZHJhd0lubGluZXMoY3R4LCBidWlsZGVkSW5saW5lLCBkcmF3UmVjdCwgb2Zmc2V0LCBwYWRkaW5nVG9wLCBwYWRkaW5nQm90dG9tLCBjb2wsIHJvdywgZ3JpZCk7XG4gICAgICAgICAgICAgIHBhZGRpbmdUb3AgKz0gbGluZUhlaWdodDtcbiAgICAgICAgICAgICAgcGFkZGluZ0JvdHRvbSAtPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICh0cmFpbGluZ0ljb25JbmxpbmUpIHtcbiAgICAgICAgICAgICAgLy8gRHJhdyB0cmFpbGluZyBpY29uXG4gICAgICAgICAgICAgIHZhciBtYXhXaWR0aCA9IDA7XG4gICAgICAgICAgICAgIGJ1aWxkZWRNdWx0aUlubGluZXMuZm9yRWFjaChmdW5jdGlvbiAoYnVpbGRlZElubGluZSkge1xuICAgICAgICAgICAgICAgIHZhciBzdW1XaWR0aCA9IDA7XG4gICAgICAgICAgICAgICAgYnVpbGRlZElubGluZS5mb3JFYWNoKGZ1bmN0aW9uIChpbmxpbmUpIHtcbiAgICAgICAgICAgICAgICAgIHN1bVdpZHRoICs9IGlubGluZS53aWR0aCh7XG4gICAgICAgICAgICAgICAgICAgIGN0eDogY3R4XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBtYXhXaWR0aCA9IE1hdGgubWF4KG1heFdpZHRoLCBzdW1XaWR0aCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB2YXIgYmFzZVJlY3QgPSBuZXcgUmVjdF8xLlJlY3QoZHJhd1JlY3QubGVmdCwgZHJhd1JlY3QudG9wLCBkcmF3UmVjdC53aWR0aCwgZHJhd1JlY3QuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgdmFyIHRyYWlsaW5nSWNvblJlY3QgPSBiYXNlUmVjdC5jb3B5KCk7XG5cbiAgICAgICAgICAgICAgaWYgKHdpZHRoIDwgbWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgICB0cmFpbGluZ0ljb25SZWN0LmxlZnQgPSB0cmFpbGluZ0ljb25SZWN0LnJpZ2h0IC0gdHJhaWxpbmdJY29uV2lkdGggLSBvZmZzZXQ7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJhaWxpbmdJY29uUmVjdC5sZWZ0ICs9IG1heFdpZHRoO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdHJhaWxpbmdJY29uUmVjdC5yaWdodCA9IGJhc2VSZWN0LnJpZ2h0O1xuICAgICAgICAgICAgICBkcmF3SW5saW5lcyhjdHgsIFt0cmFpbGluZ0ljb25JbmxpbmVdLCB0cmFpbGluZ0ljb25SZWN0LCBvZmZzZXQsIDAsIDAsIGNvbCwgcm93LCBncmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBjYWxjRWxhcHNlZENvbG9yKHN0YXJ0Q29sb3IsIGVuZENvbG9yLCBlbGFwc2VkVGltZSkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0Q29sb3JSR0IgPSAoMCwgY29sb3JfMS5jb2xvclRvUkdCKShzdGFydENvbG9yKTtcbiAgICAgICAgICAgIHZhciBlbmRDb2xvclJHQiA9ICgwLCBjb2xvcl8xLmNvbG9yVG9SR0IpKGVuZENvbG9yKTtcblxuICAgICAgICAgICAgdmFyIGdldFJHQiA9IGZ1bmN0aW9uIGdldFJHQihjb2xvck5hbWUpIHtcbiAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gc3RhcnRDb2xvclJHQltjb2xvck5hbWVdO1xuICAgICAgICAgICAgICB2YXIgZW5kID0gZW5kQ29sb3JSR0JbY29sb3JOYW1lXTtcblxuICAgICAgICAgICAgICBpZiAoZWxhcHNlZFRpbWUgPj0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmQ7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoZWxhcHNlZFRpbWUgPD0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGFydDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBkaWZmID0gc3RhcnQgLSBlbmQ7XG4gICAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwoc3RhcnQgLSBkaWZmICogZWxhcHNlZFRpbWUpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIFwicmdiKFwiLmNvbmNhdChnZXRSR0IoXCJyXCIpLCBcIiwgXCIpLmNvbmNhdChnZXRSR0IoXCJnXCIpLCBcIiwgXCIpLmNvbmNhdChnZXRSR0IoXCJiXCIpLCBcIilcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gZHJhd0NoZWNrYm94KGN0eCwgcmVjdCwgY29sLCByb3csIGNoZWNrLCBoZWxwZXIsIF9yZWYzKSB7XG4gICAgICAgICAgICB2YXIgX3JlZjMkYW5pbUVsYXBzZWRUaW1lID0gX3JlZjMuYW5pbUVsYXBzZWRUaW1lLFxuICAgICAgICAgICAgICAgIGFuaW1FbGFwc2VkVGltZSA9IF9yZWYzJGFuaW1FbGFwc2VkVGltZSA9PT0gdm9pZCAwID8gMSA6IF9yZWYzJGFuaW1FbGFwc2VkVGltZSxcbiAgICAgICAgICAgICAgICBfcmVmMyR1bmNoZWNrQmdDb2xvciA9IF9yZWYzLnVuY2hlY2tCZ0NvbG9yLFxuICAgICAgICAgICAgICAgIHVuY2hlY2tCZ0NvbG9yID0gX3JlZjMkdW5jaGVja0JnQ29sb3IgPT09IHZvaWQgMCA/IGhlbHBlci50aGVtZS5jaGVja2JveC51bmNoZWNrQmdDb2xvciA6IF9yZWYzJHVuY2hlY2tCZ0NvbG9yLFxuICAgICAgICAgICAgICAgIF9yZWYzJGNoZWNrQmdDb2xvciA9IF9yZWYzLmNoZWNrQmdDb2xvcixcbiAgICAgICAgICAgICAgICBjaGVja0JnQ29sb3IgPSBfcmVmMyRjaGVja0JnQ29sb3IgPT09IHZvaWQgMCA/IGhlbHBlci50aGVtZS5jaGVja2JveC5jaGVja0JnQ29sb3IgOiBfcmVmMyRjaGVja0JnQ29sb3IsXG4gICAgICAgICAgICAgICAgX3JlZjMkYm9yZGVyQ29sb3IgPSBfcmVmMy5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgICBib3JkZXJDb2xvciA9IF9yZWYzJGJvcmRlckNvbG9yID09PSB2b2lkIDAgPyBoZWxwZXIudGhlbWUuY2hlY2tib3guYm9yZGVyQ29sb3IgOiBfcmVmMyRib3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgICBfcmVmMyR0ZXh0QWxpZ24gPSBfcmVmMy50ZXh0QWxpZ24sXG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gX3JlZjMkdGV4dEFsaWduID09PSB2b2lkIDAgPyBcImNlbnRlclwiIDogX3JlZjMkdGV4dEFsaWduLFxuICAgICAgICAgICAgICAgIF9yZWYzJHRleHRCYXNlbGluZSA9IF9yZWYzLnRleHRCYXNlbGluZSxcbiAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmUgPSBfcmVmMyR0ZXh0QmFzZWxpbmUgPT09IHZvaWQgMCA/IFwibWlkZGxlXCIgOiBfcmVmMyR0ZXh0QmFzZWxpbmU7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb25PcHQgPSBhcmd1bWVudHMubGVuZ3RoID4gNyAmJiBhcmd1bWVudHNbN10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s3XSA6IHt9O1xuICAgICAgICAgICAgdmFyIGJveFdpZHRoID0gY2FudmFzaGVscGVyLm1lYXN1cmVDaGVja2JveChjdHgpLndpZHRoO1xuICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9IHRleHRBbGlnbjtcbiAgICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSB0ZXh0QmFzZWxpbmU7XG4gICAgICAgICAgICB2YXIgcG9zID0gKDAsIGNhbnZhc2VzXzEuY2FsY1N0YXJ0UG9zaXRpb24pKGN0eCwgcmVjdCwgYm94V2lkdGggKyAxXG4gICAgICAgICAgICAvKue9q+e3muWIhisxKi9cbiAgICAgICAgICAgICwgYm94V2lkdGggKyAxXG4gICAgICAgICAgICAvKue9q+e3muWIhisxKi9cbiAgICAgICAgICAgICwgcG9zaXRpb25PcHQpO1xuICAgICAgICAgICAgdW5jaGVja0JnQ29sb3IgPSBoZWxwZXIuZ2V0Q29sb3IodW5jaGVja0JnQ29sb3IsIGNvbCwgcm93LCBjdHgpO1xuICAgICAgICAgICAgY2hlY2tCZ0NvbG9yID0gaGVscGVyLmdldENvbG9yKGNoZWNrQmdDb2xvciwgY29sLCByb3csIGN0eCk7XG4gICAgICAgICAgICBib3JkZXJDb2xvciA9IGhlbHBlci5nZXRDb2xvcihib3JkZXJDb2xvciwgY29sLCByb3csIGN0eCk7XG5cbiAgICAgICAgICAgIGlmICgwIDwgYW5pbUVsYXBzZWRUaW1lICYmIGFuaW1FbGFwc2VkVGltZSA8IDEpIHtcbiAgICAgICAgICAgICAgdW5jaGVja0JnQ29sb3IgPSBjaGVjayA/IHVuY2hlY2tCZ0NvbG9yIDogY2FsY0VsYXBzZWRDb2xvcihjaGVja0JnQ29sb3IsIHVuY2hlY2tCZ0NvbG9yLCBhbmltRWxhcHNlZFRpbWUpO1xuICAgICAgICAgICAgICBjaGVja0JnQ29sb3IgPSBjaGVjayA/IGNhbGNFbGFwc2VkQ29sb3IodW5jaGVja0JnQ29sb3IsIGNoZWNrQmdDb2xvciwgYW5pbUVsYXBzZWRUaW1lKSA6IGNoZWNrQmdDb2xvcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FudmFzaGVscGVyLmRyYXdDaGVja2JveChjdHgsIHBvcy54LCBwb3MueSwgY2hlY2sgPyBhbmltRWxhcHNlZFRpbWUgOiBmYWxzZSwge1xuICAgICAgICAgICAgICB1bmNoZWNrQmdDb2xvcjogdW5jaGVja0JnQ29sb3IsXG4gICAgICAgICAgICAgIGNoZWNrQmdDb2xvcjogY2hlY2tCZ0NvbG9yLFxuICAgICAgICAgICAgICBib3JkZXJDb2xvcjogYm9yZGVyQ29sb3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGRyYXdSYWRpb0J1dHRvbihjdHgsIHJlY3QsIGNvbCwgcm93LCBjaGVjaywgaGVscGVyLCBfcmVmNCkge1xuICAgICAgICAgICAgdmFyIF9yZWY0JGFuaW1FbGFwc2VkVGltZSA9IF9yZWY0LmFuaW1FbGFwc2VkVGltZSxcbiAgICAgICAgICAgICAgICBhbmltRWxhcHNlZFRpbWUgPSBfcmVmNCRhbmltRWxhcHNlZFRpbWUgPT09IHZvaWQgMCA/IDEgOiBfcmVmNCRhbmltRWxhcHNlZFRpbWUsXG4gICAgICAgICAgICAgICAgX3JlZjQkY2hlY2tDb2xvciA9IF9yZWY0LmNoZWNrQ29sb3IsXG4gICAgICAgICAgICAgICAgY2hlY2tDb2xvciA9IF9yZWY0JGNoZWNrQ29sb3IgPT09IHZvaWQgMCA/IGhlbHBlci50aGVtZS5yYWRpb0J1dHRvbi5jaGVja0NvbG9yIDogX3JlZjQkY2hlY2tDb2xvcixcbiAgICAgICAgICAgICAgICBfcmVmNCR1bmNoZWNrQm9yZGVyQ28gPSBfcmVmNC51bmNoZWNrQm9yZGVyQ29sb3IsXG4gICAgICAgICAgICAgICAgdW5jaGVja0JvcmRlckNvbG9yID0gX3JlZjQkdW5jaGVja0JvcmRlckNvID09PSB2b2lkIDAgPyBoZWxwZXIudGhlbWUucmFkaW9CdXR0b24udW5jaGVja0JvcmRlckNvbG9yIDogX3JlZjQkdW5jaGVja0JvcmRlckNvLFxuICAgICAgICAgICAgICAgIF9yZWY0JGNoZWNrQm9yZGVyQ29sbyA9IF9yZWY0LmNoZWNrQm9yZGVyQ29sb3IsXG4gICAgICAgICAgICAgICAgY2hlY2tCb3JkZXJDb2xvciA9IF9yZWY0JGNoZWNrQm9yZGVyQ29sbyA9PT0gdm9pZCAwID8gaGVscGVyLnRoZW1lLnJhZGlvQnV0dG9uLmNoZWNrQm9yZGVyQ29sb3IgOiBfcmVmNCRjaGVja0JvcmRlckNvbG8sXG4gICAgICAgICAgICAgICAgX3JlZjQkdW5jaGVja0JnQ29sb3IgPSBfcmVmNC51bmNoZWNrQmdDb2xvcixcbiAgICAgICAgICAgICAgICB1bmNoZWNrQmdDb2xvciA9IF9yZWY0JHVuY2hlY2tCZ0NvbG9yID09PSB2b2lkIDAgPyBoZWxwZXIudGhlbWUucmFkaW9CdXR0b24udW5jaGVja0JnQ29sb3IgOiBfcmVmNCR1bmNoZWNrQmdDb2xvcixcbiAgICAgICAgICAgICAgICBfcmVmNCRjaGVja0JnQ29sb3IgPSBfcmVmNC5jaGVja0JnQ29sb3IsXG4gICAgICAgICAgICAgICAgY2hlY2tCZ0NvbG9yID0gX3JlZjQkY2hlY2tCZ0NvbG9yID09PSB2b2lkIDAgPyBoZWxwZXIudGhlbWUucmFkaW9CdXR0b24uY2hlY2tCZ0NvbG9yIDogX3JlZjQkY2hlY2tCZ0NvbG9yLFxuICAgICAgICAgICAgICAgIF9yZWY0JHRleHRBbGlnbiA9IF9yZWY0LnRleHRBbGlnbixcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSBfcmVmNCR0ZXh0QWxpZ24gPT09IHZvaWQgMCA/IFwiY2VudGVyXCIgOiBfcmVmNCR0ZXh0QWxpZ24sXG4gICAgICAgICAgICAgICAgX3JlZjQkdGV4dEJhc2VsaW5lID0gX3JlZjQudGV4dEJhc2VsaW5lLFxuICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZSA9IF9yZWY0JHRleHRCYXNlbGluZSA9PT0gdm9pZCAwID8gXCJtaWRkbGVcIiA6IF9yZWY0JHRleHRCYXNlbGluZTtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbk9wdCA9IGFyZ3VtZW50cy5sZW5ndGggPiA3ICYmIGFyZ3VtZW50c1s3XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzddIDoge307XG4gICAgICAgICAgICB2YXIgYm94V2lkdGggPSBjYW52YXNoZWxwZXIubWVhc3VyZVJhZGlvQnV0dG9uKGN0eCkud2lkdGg7XG4gICAgICAgICAgICBjdHgudGV4dEFsaWduID0gdGV4dEFsaWduO1xuICAgICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9IHRleHRCYXNlbGluZTtcbiAgICAgICAgICAgIHZhciBwb3MgPSAoMCwgY2FudmFzZXNfMS5jYWxjU3RhcnRQb3NpdGlvbikoY3R4LCByZWN0LCBib3hXaWR0aCArIDFcbiAgICAgICAgICAgIC8q572r57ea5YiGKzEqL1xuICAgICAgICAgICAgLCBib3hXaWR0aCArIDFcbiAgICAgICAgICAgIC8q572r57ea5YiGKzEqL1xuICAgICAgICAgICAgLCBwb3NpdGlvbk9wdCk7XG4gICAgICAgICAgICBjaGVja0NvbG9yID0gaGVscGVyLmdldENvbG9yKGNoZWNrQ29sb3IsIGNvbCwgcm93LCBjdHgpO1xuICAgICAgICAgICAgdW5jaGVja0JvcmRlckNvbG9yID0gaGVscGVyLmdldENvbG9yKHVuY2hlY2tCb3JkZXJDb2xvciwgY29sLCByb3csIGN0eCk7XG4gICAgICAgICAgICBjaGVja0JvcmRlckNvbG9yID0gaGVscGVyLmdldENvbG9yKGNoZWNrQm9yZGVyQ29sb3IsIGNvbCwgcm93LCBjdHgpO1xuICAgICAgICAgICAgdW5jaGVja0JnQ29sb3IgPSBoZWxwZXIuZ2V0Q29sb3IodW5jaGVja0JnQ29sb3IsIGNvbCwgcm93LCBjdHgpO1xuICAgICAgICAgICAgY2hlY2tCZ0NvbG9yID0gaGVscGVyLmdldENvbG9yKGNoZWNrQmdDb2xvciwgY29sLCByb3csIGN0eCk7XG4gICAgICAgICAgICB2YXIgYm9yZGVyQ29sb3IgPSBjaGVjayA/IGNoZWNrQm9yZGVyQ29sb3IgOiB1bmNoZWNrQm9yZGVyQ29sb3I7XG4gICAgICAgICAgICB2YXIgYmdDb2xvciA9IGNoZWNrID8gY2hlY2tCZ0NvbG9yIDogdW5jaGVja0JnQ29sb3I7XG5cbiAgICAgICAgICAgIGlmICgwIDwgYW5pbUVsYXBzZWRUaW1lICYmIGFuaW1FbGFwc2VkVGltZSA8IDEpIHtcbiAgICAgICAgICAgICAgYm9yZGVyQ29sb3IgPSBjaGVjayA/IGNhbGNFbGFwc2VkQ29sb3IodW5jaGVja0JvcmRlckNvbG9yLCBjaGVja0JvcmRlckNvbG9yLCBhbmltRWxhcHNlZFRpbWUpIDogY2FsY0VsYXBzZWRDb2xvcihjaGVja0JvcmRlckNvbG9yLCB1bmNoZWNrQm9yZGVyQ29sb3IsIGFuaW1FbGFwc2VkVGltZSk7XG4gICAgICAgICAgICAgIGJnQ29sb3IgPSBjaGVjayA/IGNhbGNFbGFwc2VkQ29sb3IodW5jaGVja0JnQ29sb3IsIGNoZWNrQmdDb2xvciwgYW5pbUVsYXBzZWRUaW1lKSA6IGNhbGNFbGFwc2VkQ29sb3IoY2hlY2tCZ0NvbG9yLCB1bmNoZWNrQmdDb2xvciwgYW5pbUVsYXBzZWRUaW1lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FudmFzaGVscGVyLmRyYXdSYWRpb0J1dHRvbihjdHgsIHBvcy54LCBwb3MueSwgY2hlY2sgPyBhbmltRWxhcHNlZFRpbWUgOiAxIC0gYW5pbUVsYXBzZWRUaW1lLCB7XG4gICAgICAgICAgICAgIGNoZWNrQ29sb3I6IGNoZWNrQ29sb3IsXG4gICAgICAgICAgICAgIGJvcmRlckNvbG9yOiBib3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgYmdDb2xvcjogYmdDb2xvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIFRoZW1lUmVzb2x2ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gVGhlbWVSZXNvbHZlcihncmlkKSB7XG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUaGVtZVJlc29sdmVyKTtcblxuICAgICAgICAgICAgICB0aGlzLl9jaGVja2JveCA9IG51bGw7XG4gICAgICAgICAgICAgIHRoaXMuX3JhZGlvQnV0dG9uID0gbnVsbDtcbiAgICAgICAgICAgICAgdGhpcy5fYnV0dG9uID0gbnVsbDtcbiAgICAgICAgICAgICAgdGhpcy5fdHJlZSA9IG51bGw7XG4gICAgICAgICAgICAgIHRoaXMuX2hlYWRlciA9IG51bGw7XG4gICAgICAgICAgICAgIHRoaXMuX21lc3NhZ2VzID0gbnVsbDtcbiAgICAgICAgICAgICAgdGhpcy5faW5kaWNhdG9ycyA9IG51bGw7XG4gICAgICAgICAgICAgIHRoaXMuX2dyaWQgPSBncmlkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoVGhlbWVSZXNvbHZlciwgW3tcbiAgICAgICAgICAgICAga2V5OiBcImdldFRoZW1lVmFsdWVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRoZW1lVmFsdWUoKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBuYW1lID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgICAgICAgICAgICBuYW1lW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9nZXRUaGVtZVZhbHVlLmFwcGx5KHZvaWQgMCwgW3RoaXMuX2dyaWRdLmNvbmNhdChuYW1lKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImZvbnRcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9nZXRUaGVtZVZhbHVlKHRoaXMuX2dyaWQsIFwiZm9udFwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwidW5kZXJsYXlCYWNrZ3JvdW5kQ29sb3JcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9nZXRUaGVtZVZhbHVlKHRoaXMuX2dyaWQsIFwidW5kZXJsYXlCYWNrZ3JvdW5kQ29sb3JcIik7XG4gICAgICAgICAgICAgIH0gLy8gY29sb3JcblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY29sb3JcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9nZXRUaGVtZVZhbHVlKHRoaXMuX2dyaWQsIFwiY29sb3JcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImZyb3plblJvd3NDb2xvclwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2dldFRoZW1lVmFsdWUodGhpcy5fZ3JpZCwgXCJmcm96ZW5Sb3dzQ29sb3JcIik7XG4gICAgICAgICAgICAgIH0gLy8gYmFja2dyb3VuZFxuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJkZWZhdWx0QmdDb2xvclwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2dldFRoZW1lVmFsdWUodGhpcy5fZ3JpZCwgXCJkZWZhdWx0QmdDb2xvclwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZnJvemVuUm93c0JnQ29sb3JcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9nZXRUaGVtZVZhbHVlKHRoaXMuX2dyaWQsIFwiZnJvemVuUm93c0JnQ29sb3JcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInNlbGVjdGlvbkJnQ29sb3JcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9nZXRUaGVtZVZhbHVlKHRoaXMuX2dyaWQsIFwic2VsZWN0aW9uQmdDb2xvclwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiaGlnaGxpZ2h0QmdDb2xvclwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2dldFRoZW1lVmFsdWUodGhpcy5fZ3JpZCwgXCJoaWdobGlnaHRCZ0NvbG9yXCIpO1xuICAgICAgICAgICAgICB9IC8vIGJvcmRlclxuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJib3JkZXJDb2xvclwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2dldFRoZW1lVmFsdWUodGhpcy5fZ3JpZCwgXCJib3JkZXJDb2xvclwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZnJvemVuUm93c0JvcmRlckNvbG9yXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZ2V0VGhlbWVWYWx1ZSh0aGlzLl9ncmlkLCBcImZyb3plblJvd3NCb3JkZXJDb2xvclwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiaGlnaGxpZ2h0Qm9yZGVyQ29sb3JcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9nZXRUaGVtZVZhbHVlKHRoaXMuX2dyaWQsIFwiaGlnaGxpZ2h0Qm9yZGVyQ29sb3JcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNoZWNrYm94XCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHZhciBncmlkID0gdGhpcy5fZ3JpZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tib3ggfHwgKHRoaXMuX2NoZWNrYm94ID0ge1xuICAgICAgICAgICAgICAgICAgZ2V0IHVuY2hlY2tCZ0NvbG9yKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Q2hlY2tib3hQcm9wKFwidW5jaGVja0JnQ29sb3JcIik7XG4gICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICBnZXQgY2hlY2tCZ0NvbG9yKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Q2hlY2tib3hQcm9wKFwiY2hlY2tCZ0NvbG9yXCIpO1xuICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgZ2V0IGJvcmRlckNvbG9yKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Q2hlY2tib3hQcm9wKFwiYm9yZGVyQ29sb3JcIik7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdldENoZWNrYm94UHJvcChwcm9wKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2dldFRoZW1lVmFsdWUoZ3JpZCwgXCJjaGVja2JveFwiLCBwcm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInJhZGlvQnV0dG9uXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHZhciBncmlkID0gdGhpcy5fZ3JpZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmFkaW9CdXR0b24gfHwgKHRoaXMuX3JhZGlvQnV0dG9uID0ge1xuICAgICAgICAgICAgICAgICAgZ2V0IGNoZWNrQ29sb3IoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRSYWRpb0J1dHRvblByb3AoXCJjaGVja0NvbG9yXCIpO1xuICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgZ2V0IHVuY2hlY2tCb3JkZXJDb2xvcigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldFJhZGlvQnV0dG9uUHJvcChcInVuY2hlY2tCb3JkZXJDb2xvclwiKTtcbiAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgIGdldCBjaGVja0JvcmRlckNvbG9yKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0UmFkaW9CdXR0b25Qcm9wKFwiY2hlY2tCb3JkZXJDb2xvclwiKTtcbiAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgIGdldCB1bmNoZWNrQmdDb2xvcigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldFJhZGlvQnV0dG9uUHJvcChcInVuY2hlY2tCZ0NvbG9yXCIpO1xuICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgZ2V0IGNoZWNrQmdDb2xvcigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldFJhZGlvQnV0dG9uUHJvcChcImNoZWNrQmdDb2xvclwiKTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2V0UmFkaW9CdXR0b25Qcm9wKHByb3ApIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfZ2V0VGhlbWVWYWx1ZShncmlkLCBcInJhZGlvQnV0dG9uXCIsIHByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiYnV0dG9uXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHZhciBncmlkID0gdGhpcy5fZ3JpZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYnV0dG9uIHx8ICh0aGlzLl9idXR0b24gPSB7XG4gICAgICAgICAgICAgICAgICBnZXQgY29sb3IoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRCdXR0b25Qcm9wKFwiY29sb3JcIik7XG4gICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICBnZXQgYmdDb2xvcigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEJ1dHRvblByb3AoXCJiZ0NvbG9yXCIpO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXRCdXR0b25Qcm9wKHByb3ApIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfZ2V0VGhlbWVWYWx1ZShncmlkLCBcImJ1dHRvblwiLCBwcm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInRyZWVcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGdyaWQgPSB0aGlzLl9ncmlkO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90cmVlIHx8ICh0aGlzLl90cmVlID0ge1xuICAgICAgICAgICAgICAgICAgZ2V0IGxpbmVTdHlsZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldFRyZWVQcm9wKFwibGluZVN0eWxlXCIpO1xuICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgZ2V0IGxpbmVDb2xvcigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldFRyZWVQcm9wKFwibGluZUNvbG9yXCIpO1xuICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgZ2V0IGxpbmVXaWR0aCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldFRyZWVQcm9wKFwibGluZVdpZHRoXCIpO1xuICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgZ2V0IHRyZWVJY29uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0VHJlZVByb3AoXCJ0cmVlSWNvblwiKTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2V0VHJlZVByb3AocHJvcCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9nZXRUaGVtZVZhbHVlKGdyaWQsIFwidHJlZVwiLCBwcm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImhlYWRlclwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZ3JpZCA9IHRoaXMuX2dyaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hlYWRlciB8fCAodGhpcy5faGVhZGVyID0ge1xuICAgICAgICAgICAgICAgICAgZ2V0IHNvcnRBcnJvd0NvbG9yKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2dldFRoZW1lVmFsdWUoZ3JpZCwgXCJoZWFkZXJcIiwgXCJzb3J0QXJyb3dDb2xvclwiKTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJtZXNzYWdlc1wiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZ3JpZCA9IHRoaXMuX2dyaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21lc3NhZ2VzIHx8ICh0aGlzLl9tZXNzYWdlcyA9IHtcbiAgICAgICAgICAgICAgICAgIGdldCBpbmZvQmdDb2xvcigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldE1lc3NhZ2VQcm9wKFwiaW5mb0JnQ29sb3JcIik7XG4gICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICBnZXQgZXJyb3JCZ0NvbG9yKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0TWVzc2FnZVByb3AoXCJlcnJvckJnQ29sb3JcIik7XG4gICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICBnZXQgd2FybkJnQ29sb3IoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRNZXNzYWdlUHJvcChcIndhcm5CZ0NvbG9yXCIpO1xuICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgZ2V0IGJveFdpZHRoKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0TWVzc2FnZVByb3AoXCJib3hXaWR0aFwiKTtcbiAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgIGdldCBtYXJrSGVpZ2h0KCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0TWVzc2FnZVByb3AoXCJtYXJrSGVpZ2h0XCIpO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXRNZXNzYWdlUHJvcChwcm9wKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2dldFRoZW1lVmFsdWUoZ3JpZCwgXCJtZXNzYWdlc1wiLCBwcm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImluZGljYXRvcnNcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGdyaWQgPSB0aGlzLl9ncmlkO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbmRpY2F0b3JzIHx8ICh0aGlzLl9pbmRpY2F0b3JzID0ge1xuICAgICAgICAgICAgICAgICAgZ2V0IHRvcExlZnRDb2xvcigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEluZGljYXRvcnNQcm9wKFwidG9wTGVmdENvbG9yXCIpO1xuICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgZ2V0IHRvcExlZnRTaXplKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0SW5kaWNhdG9yc1Byb3AoXCJ0b3BMZWZ0U2l6ZVwiKTtcbiAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgIGdldCB0b3BSaWdodENvbG9yKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0SW5kaWNhdG9yc1Byb3AoXCJ0b3BSaWdodENvbG9yXCIpO1xuICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgZ2V0IHRvcFJpZ2h0U2l6ZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEluZGljYXRvcnNQcm9wKFwidG9wUmlnaHRTaXplXCIpO1xuICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgZ2V0IGJvdHRvbVJpZ2h0Q29sb3IoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRJbmRpY2F0b3JzUHJvcChcImJvdHRvbVJpZ2h0Q29sb3JcIik7XG4gICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICBnZXQgYm90dG9tUmlnaHRTaXplKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0SW5kaWNhdG9yc1Byb3AoXCJib3R0b21SaWdodFNpemVcIik7XG4gICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICBnZXQgYm90dG9tTGVmdENvbG9yKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0SW5kaWNhdG9yc1Byb3AoXCJib3R0b21MZWZ0Q29sb3JcIik7XG4gICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICBnZXQgYm90dG9tTGVmdFNpemUoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRJbmRpY2F0b3JzUHJvcChcImJvdHRvbUxlZnRTaXplXCIpO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXRJbmRpY2F0b3JzUHJvcChwcm9wKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2dldFRoZW1lVmFsdWUoZ3JpZCwgXCJpbmRpY2F0b3JzXCIsIHByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gVGhlbWVSZXNvbHZlcjtcbiAgICAgICAgICB9KCk7XG5cbiAgICAgICAgICBmdW5jdGlvbiBzdHJva2VSZWN0KGN0eCwgY29sb3IsIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGNvbG9yKSkge1xuICAgICAgICAgICAgICBpZiAoY29sb3IpIHtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlUmVjdChsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgYm9yZGVyQ29sb3JzID0gX3RvQm94QXJyYXkoY29sb3IpO1xuXG4gICAgICAgICAgICAgIGNhbnZhc2hlbHBlci5zdHJva2VDb2xvcnNSZWN0KGN0eCwgYm9yZGVyQ29sb3JzLCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGdldFBhZGRlZFJlY3QocmVjdCwgcGFkZGluZywgZm9udCwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICBoZWxwZXIsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGlmICghcGFkZGluZykge1xuICAgICAgICAgICAgICByZXR1cm4gcmVjdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIF9oZWxwZXIkdG9Cb3hQaXhlbEFyciA9IGhlbHBlci50b0JveFBpeGVsQXJyYXkocGFkZGluZywgY29udGV4dCwgZm9udCksXG4gICAgICAgICAgICAgICAgcFRvcCA9IF9oZWxwZXIkdG9Cb3hQaXhlbEFyclswXSxcbiAgICAgICAgICAgICAgICBwUmlnaHQgPSBfaGVscGVyJHRvQm94UGl4ZWxBcnJbMV0sXG4gICAgICAgICAgICAgICAgcEJvdHRvbSA9IF9oZWxwZXIkdG9Cb3hQaXhlbEFyclsyXSxcbiAgICAgICAgICAgICAgICBwTGVmdCA9IF9oZWxwZXIkdG9Cb3hQaXhlbEFyclszXTtcblxuICAgICAgICAgICAgdmFyIGxlZnQgPSByZWN0LmxlZnQgKyBwTGVmdDtcbiAgICAgICAgICAgIHZhciB0b3AgPSByZWN0LnRvcCArIHBUb3A7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSByZWN0LndpZHRoIC0gcFJpZ2h0IC0gcExlZnQ7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gcmVjdC5oZWlnaHQgLSBwVG9wIC0gcEJvdHRvbTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVjdF8xLlJlY3QobGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgR3JpZENhbnZhc0hlbHBlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBHcmlkQ2FudmFzSGVscGVyKGdyaWQpIHtcbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEdyaWRDYW52YXNIZWxwZXIpO1xuXG4gICAgICAgICAgICAgIHRoaXMuX2dyaWQgPSBncmlkO1xuICAgICAgICAgICAgICB0aGlzLl90aGVtZSA9IG5ldyBUaGVtZVJlc29sdmVyKGdyaWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoR3JpZENhbnZhc0hlbHBlciwgW3tcbiAgICAgICAgICAgICAga2V5OiBcImNyZWF0ZUNhbGN1bGF0b3JcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUNhbGN1bGF0b3IoY29udGV4dCwgZm9udCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICBjYWxjV2lkdGg6IGZ1bmN0aW9uIGNhbGNXaWR0aCh3aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsYy50b1B4KHdpZHRoLCB7XG4gICAgICAgICAgICAgICAgICAgICAgZ2V0IGZ1bGwoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IGNvbnRleHQuZ2V0UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlY3Qud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICAgIGdldCBlbSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgY2FudmFzZXNfMS5nZXRGb250U2l6ZSkoY29udGV4dC5nZXRDb250ZXh0KCksIGZvbnQpLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBjYWxjSGVpZ2h0OiBmdW5jdGlvbiBjYWxjSGVpZ2h0KGhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsYy50b1B4KGhlaWdodCwge1xuICAgICAgICAgICAgICAgICAgICAgIGdldCBmdWxsKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlY3QgPSBjb250ZXh0LmdldFJlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWN0LmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgICAgZ2V0IGVtKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBjYW52YXNlc18xLmdldEZvbnRTaXplKShjb250ZXh0LmdldENvbnRleHQoKSwgZm9udCkuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJnZXRDb2xvclwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29sb3IoY29sb3IsIGNvbCwgcm93LCBjdHgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2dldFN0eWxlUHJvcGVydHkoY29sb3IsIGNvbCwgcm93LCB0aGlzLl9ncmlkLCBjdHgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJnZXRTdHlsZVByb3BlcnR5XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTdHlsZVByb3BlcnR5KHN0eWxlLCBjb2wsIHJvdywgY3R4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9nZXRTdHlsZVByb3BlcnR5KHN0eWxlLCBjb2wsIHJvdywgdGhpcy5fZ3JpZCwgY3R4KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwidG9Cb3hBcnJheVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9Cb3hBcnJheShvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RvQm94QXJyYXkob2JqKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwidG9Cb3hQaXhlbEFycmF5XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b0JveFBpeGVsQXJyYXkodmFsdWUsIGNvbnRleHQsIGZvbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY2FsY3VsYXRvciA9IHRoaXMuY3JlYXRlQ2FsY3VsYXRvcihjb250ZXh0LCBmb250KTtcblxuICAgICAgICAgICAgICAgICAgdmFyIGJveCA9IF90b0JveEFycmF5KHZhbHVlKTtcblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIFtjYWxjdWxhdG9yLmNhbGNIZWlnaHQoYm94WzBdKSwgY2FsY3VsYXRvci5jYWxjV2lkdGgoYm94WzFdKSwgY2FsY3VsYXRvci5jYWxjSGVpZ2h0KGJveFsyXSksIGNhbGN1bGF0b3IuY2FsY1dpZHRoKGJveFszXSldO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBfdG9Cb3hBcnJheSh2YWx1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInRoZW1lXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90aGVtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZHJhd1dpdGhDbGlwXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3V2l0aENsaXAoY29udGV4dCwgZHJhdykge1xuICAgICAgICAgICAgICAgIHZhciBkcmF3UmVjdCA9IGNvbnRleHQuZ2V0RHJhd1JlY3QoKTtcblxuICAgICAgICAgICAgICAgIGlmICghZHJhd1JlY3QpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgY3R4ID0gY29udGV4dC5nZXRDb250ZXh0KCk7XG4gICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICBjdHgucmVjdChkcmF3UmVjdC5sZWZ0LCBkcmF3UmVjdC50b3AsIGRyYXdSZWN0LndpZHRoLCBkcmF3UmVjdC5oZWlnaHQpOyAvL2NsaXBcblxuICAgICAgICAgICAgICAgICAgY3R4LmNsaXAoKTtcbiAgICAgICAgICAgICAgICAgIGRyYXcoY3R4KTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImRyYXdCb3JkZXJXaXRoQ2xpcFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0JvcmRlcldpdGhDbGlwKGNvbnRleHQsIGRyYXcpIHtcbiAgICAgICAgICAgICAgICB2YXIgZHJhd1JlY3QgPSBjb250ZXh0LmdldERyYXdSZWN0KCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWRyYXdSZWN0KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHJlY3QgPSBjb250ZXh0LmdldFJlY3QoKTtcbiAgICAgICAgICAgICAgICB2YXIgY3R4ID0gY29udGV4dC5nZXRDb250ZXh0KCk7XG4gICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAvL+e9q+e3mueUqGNsaXBcbiAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgIHZhciBjbGlwTGVmdCA9IGRyYXdSZWN0LmxlZnQ7XG4gICAgICAgICAgICAgICAgICB2YXIgY2xpcFdpZHRoID0gZHJhd1JlY3Qud2lkdGg7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChkcmF3UmVjdC5sZWZ0ID09PSByZWN0LmxlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xpcExlZnQgKz0gLTE7XG4gICAgICAgICAgICAgICAgICAgIGNsaXBXaWR0aCArPSAxO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICB2YXIgY2xpcFRvcCA9IGRyYXdSZWN0LnRvcDtcbiAgICAgICAgICAgICAgICAgIHZhciBjbGlwSGVpZ2h0ID0gZHJhd1JlY3QuaGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgICBpZiAoZHJhd1JlY3QudG9wID09PSByZWN0LnRvcCkge1xuICAgICAgICAgICAgICAgICAgICBjbGlwVG9wICs9IC0xO1xuICAgICAgICAgICAgICAgICAgICBjbGlwSGVpZ2h0ICs9IDE7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGN0eC5yZWN0KGNsaXBMZWZ0LCBjbGlwVG9wLCBjbGlwV2lkdGgsIGNsaXBIZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgY3R4LmNsaXAoKTtcbiAgICAgICAgICAgICAgICAgIGRyYXcoY3R4KTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInRleHRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRleHQoX3RleHQsIGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9yZWY1ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZyA9IF9yZWY1LnBhZGRpbmcsXG4gICAgICAgICAgICAgICAgICAgIF9yZWY1JG9mZnNldCA9IF9yZWY1Lm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gX3JlZjUkb2Zmc2V0ID09PSB2b2lkIDAgPyBURVhUX09GRlNFVCA6IF9yZWY1JG9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBfcmVmNS5jb2xvcixcbiAgICAgICAgICAgICAgICAgICAgX3JlZjUkdGV4dEFsaWduID0gX3JlZjUudGV4dEFsaWduLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSBfcmVmNSR0ZXh0QWxpZ24gPT09IHZvaWQgMCA/IFwibGVmdFwiIDogX3JlZjUkdGV4dEFsaWduLFxuICAgICAgICAgICAgICAgICAgICBfcmVmNSR0ZXh0QmFzZWxpbmUgPSBfcmVmNS50ZXh0QmFzZWxpbmUsXG4gICAgICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZSA9IF9yZWY1JHRleHRCYXNlbGluZSA9PT0gdm9pZCAwID8gXCJtaWRkbGVcIiA6IF9yZWY1JHRleHRCYXNlbGluZSxcbiAgICAgICAgICAgICAgICAgICAgZm9udCA9IF9yZWY1LmZvbnQsXG4gICAgICAgICAgICAgICAgICAgIF9yZWY1JHRleHRPdmVyZmxvdyA9IF9yZWY1LnRleHRPdmVyZmxvdyxcbiAgICAgICAgICAgICAgICAgICAgdGV4dE92ZXJmbG93ID0gX3JlZjUkdGV4dE92ZXJmbG93ID09PSB2b2lkIDAgPyBcImNsaXBcIiA6IF9yZWY1JHRleHRPdmVyZmxvdyxcbiAgICAgICAgICAgICAgICAgICAgaWNvbnMgPSBfcmVmNS5pY29ucyxcbiAgICAgICAgICAgICAgICAgICAgdHJhaWxpbmdJY29uID0gX3JlZjUudHJhaWxpbmdJY29uO1xuXG4gICAgICAgICAgICAgICAgdmFyIGNvbCA9IGNvbnRleHQuY29sLFxuICAgICAgICAgICAgICAgICAgICByb3cgPSBjb250ZXh0LnJvdztcblxuICAgICAgICAgICAgICAgIGlmICghY29sb3IpIHtcbiAgICAgICAgICAgICAgICAgIGNvbG9yID0gdGhpcy50aGVtZS5jb2xvcjtcblxuICAgICAgICAgICAgICAgICAgLy8gaGVhZGVyIGNvbG9yXG4gICAgICAgICAgICAgICAgICB2YXIgaXNGcm96ZW5DZWxsID0gdGhpcy5fZ3JpZC5pc0Zyb3plbkNlbGwoY29sLCByb3cpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoaXNGcm96ZW5DZWxsICYmIGlzRnJvemVuQ2VsbC5yb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3IgPSB0aGlzLnRoZW1lLmZyb3plblJvd3NDb2xvcjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdXaXRoQ2xpcChjb250ZXh0LCBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICAgICAgICBmb250ID0gZ2V0Rm9udChmb250LCBjb250ZXh0LmNvbCwgY29udGV4dC5yb3csIF90aGlzLl9ncmlkLCBjdHgpO1xuICAgICAgICAgICAgICAgICAgdmFyIHJlY3QgPSBnZXRQYWRkZWRSZWN0KGNvbnRleHQuZ2V0UmVjdCgpLCBwYWRkaW5nLCBmb250LCBfdGhpcywgY29udGV4dCk7XG5cbiAgICAgICAgICAgICAgICAgIF9pbmxpbmVSZWN0KF90aGlzLl9ncmlkLCBjdHgsIF90ZXh0LCByZWN0LCBjb2wsIHJvdywge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ246IHRleHRBbGlnbixcbiAgICAgICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lOiB0ZXh0QmFzZWxpbmUsXG4gICAgICAgICAgICAgICAgICAgIGZvbnQ6IGZvbnQsXG4gICAgICAgICAgICAgICAgICAgIHRleHRPdmVyZmxvdzogdGV4dE92ZXJmbG93LFxuICAgICAgICAgICAgICAgICAgICBpY29uczogaWNvbnMsXG4gICAgICAgICAgICAgICAgICAgIHRyYWlsaW5nSWNvbjogdHJhaWxpbmdJY29uXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwibXVsdGlsaW5lVGV4dFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbXVsdGlsaW5lVGV4dChsaW5lcywgY29udGV4dCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9yZWY2ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZyA9IF9yZWY2LnBhZGRpbmcsXG4gICAgICAgICAgICAgICAgICAgIF9yZWY2JG9mZnNldCA9IF9yZWY2Lm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gX3JlZjYkb2Zmc2V0ID09PSB2b2lkIDAgPyBURVhUX09GRlNFVCA6IF9yZWY2JG9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBfcmVmNi5jb2xvcixcbiAgICAgICAgICAgICAgICAgICAgX3JlZjYkdGV4dEFsaWduID0gX3JlZjYudGV4dEFsaWduLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSBfcmVmNiR0ZXh0QWxpZ24gPT09IHZvaWQgMCA/IFwibGVmdFwiIDogX3JlZjYkdGV4dEFsaWduLFxuICAgICAgICAgICAgICAgICAgICBfcmVmNiR0ZXh0QmFzZWxpbmUgPSBfcmVmNi50ZXh0QmFzZWxpbmUsXG4gICAgICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZSA9IF9yZWY2JHRleHRCYXNlbGluZSA9PT0gdm9pZCAwID8gXCJtaWRkbGVcIiA6IF9yZWY2JHRleHRCYXNlbGluZSxcbiAgICAgICAgICAgICAgICAgICAgZm9udCA9IF9yZWY2LmZvbnQsXG4gICAgICAgICAgICAgICAgICAgIF9yZWY2JGxpbmVIZWlnaHQgPSBfcmVmNi5saW5lSGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBsaW5lSGVpZ2h0ID0gX3JlZjYkbGluZUhlaWdodCA9PT0gdm9pZCAwID8gXCIxZW1cIiA6IF9yZWY2JGxpbmVIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIF9yZWY2JGF1dG9XcmFwVGV4dCA9IF9yZWY2LmF1dG9XcmFwVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgYXV0b1dyYXBUZXh0ID0gX3JlZjYkYXV0b1dyYXBUZXh0ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWY2JGF1dG9XcmFwVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgX3JlZjYkbGluZUNsYW1wID0gX3JlZjYubGluZUNsYW1wLFxuICAgICAgICAgICAgICAgICAgICBsaW5lQ2xhbXAgPSBfcmVmNiRsaW5lQ2xhbXAgPT09IHZvaWQgMCA/IDAgOiBfcmVmNiRsaW5lQ2xhbXAsXG4gICAgICAgICAgICAgICAgICAgIF9yZWY2JHRleHRPdmVyZmxvdyA9IF9yZWY2LnRleHRPdmVyZmxvdyxcbiAgICAgICAgICAgICAgICAgICAgdGV4dE92ZXJmbG93ID0gX3JlZjYkdGV4dE92ZXJmbG93ID09PSB2b2lkIDAgPyBcImNsaXBcIiA6IF9yZWY2JHRleHRPdmVyZmxvdyxcbiAgICAgICAgICAgICAgICAgICAgaWNvbnMgPSBfcmVmNi5pY29ucyxcbiAgICAgICAgICAgICAgICAgICAgdHJhaWxpbmdJY29uID0gX3JlZjYudHJhaWxpbmdJY29uO1xuXG4gICAgICAgICAgICAgICAgdmFyIGNvbCA9IGNvbnRleHQuY29sLFxuICAgICAgICAgICAgICAgICAgICByb3cgPSBjb250ZXh0LnJvdztcblxuICAgICAgICAgICAgICAgIGlmICghY29sb3IpIHtcbiAgICAgICAgICAgICAgICAgIGNvbG9yID0gdGhpcy50aGVtZS5jb2xvcjtcblxuICAgICAgICAgICAgICAgICAgLy8gaGVhZGVyIGNvbG9yXG4gICAgICAgICAgICAgICAgICB2YXIgaXNGcm96ZW5DZWxsID0gdGhpcy5fZ3JpZC5pc0Zyb3plbkNlbGwoY29sLCByb3cpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoaXNGcm96ZW5DZWxsICYmIGlzRnJvemVuQ2VsbC5yb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3IgPSB0aGlzLnRoZW1lLmZyb3plblJvd3NDb2xvcjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdXaXRoQ2xpcChjb250ZXh0LCBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICAgICAgICBmb250ID0gZ2V0Rm9udChmb250LCBjb250ZXh0LmNvbCwgY29udGV4dC5yb3csIF90aGlzMi5fZ3JpZCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgIHZhciByZWN0ID0gZ2V0UGFkZGVkUmVjdChjb250ZXh0LmdldFJlY3QoKSwgcGFkZGluZywgZm9udCwgX3RoaXMyLCBjb250ZXh0KTtcblxuICAgICAgICAgICAgICAgICAgdmFyIGNhbGN1bGF0b3IgPSBfdGhpczIuY3JlYXRlQ2FsY3VsYXRvcihjb250ZXh0LCBmb250KTtcblxuICAgICAgICAgICAgICAgICAgbGluZUhlaWdodCA9IGNhbGN1bGF0b3IuY2FsY0hlaWdodChsaW5lSGVpZ2h0KTtcblxuICAgICAgICAgICAgICAgICAgX211bHRpSW5saW5lUmVjdChfdGhpczIuX2dyaWQsIGN0eCwgbGluZXMsIHJlY3QsIGNvbCwgcm93LCB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbjogdGV4dEFsaWduLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmU6IHRleHRCYXNlbGluZSxcbiAgICAgICAgICAgICAgICAgICAgZm9udDogZm9udCxcbiAgICAgICAgICAgICAgICAgICAgbGluZUhlaWdodDogbGluZUhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgYXV0b1dyYXBUZXh0OiBhdXRvV3JhcFRleHQsXG4gICAgICAgICAgICAgICAgICAgIGxpbmVDbGFtcDogbGluZUNsYW1wLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0T3ZlcmZsb3c6IHRleHRPdmVyZmxvdyxcbiAgICAgICAgICAgICAgICAgICAgaWNvbnM6IGljb25zLFxuICAgICAgICAgICAgICAgICAgICB0cmFpbGluZ0ljb246IHRyYWlsaW5nSWNvblxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImZpbGxUZXh0XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmaWxsVGV4dCh0ZXh0LCB4LCB5LCBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9yZWY3ID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBfcmVmNy5jb2xvcixcbiAgICAgICAgICAgICAgICAgICAgX3JlZjckdGV4dEFsaWduID0gX3JlZjcudGV4dEFsaWduLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSBfcmVmNyR0ZXh0QWxpZ24gPT09IHZvaWQgMCA/IFwibGVmdFwiIDogX3JlZjckdGV4dEFsaWduLFxuICAgICAgICAgICAgICAgICAgICBfcmVmNyR0ZXh0QmFzZWxpbmUgPSBfcmVmNy50ZXh0QmFzZWxpbmUsXG4gICAgICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZSA9IF9yZWY3JHRleHRCYXNlbGluZSA9PT0gdm9pZCAwID8gXCJ0b3BcIiA6IF9yZWY3JHRleHRCYXNlbGluZSxcbiAgICAgICAgICAgICAgICAgICAgZm9udCA9IF9yZWY3LmZvbnQ7XG5cbiAgICAgICAgICAgICAgICB2YXIgY29sID0gY29udGV4dC5jb2wsXG4gICAgICAgICAgICAgICAgICAgIHJvdyA9IGNvbnRleHQucm93O1xuXG4gICAgICAgICAgICAgICAgaWYgKCFjb2xvcikge1xuICAgICAgICAgICAgICAgICAgY29sb3IgPSB0aGlzLnRoZW1lLmNvbG9yO1xuXG4gICAgICAgICAgICAgICAgICAvLyBoZWFkZXIgY29sb3JcbiAgICAgICAgICAgICAgICAgIHZhciBpc0Zyb3plbkNlbGwgPSB0aGlzLl9ncmlkLmlzRnJvemVuQ2VsbChjb2wsIHJvdyk7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChpc0Zyb3plbkNlbGwgJiYgaXNGcm96ZW5DZWxsLnJvdykge1xuICAgICAgICAgICAgICAgICAgICBjb2xvciA9IHRoaXMudGhlbWUuZnJvemVuUm93c0NvbG9yO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBjdHggPSBjb250ZXh0LmdldENvbnRleHQoKTtcbiAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGZvbnQgPSBnZXRGb250KGZvbnQsIGNvbnRleHQuY29sLCBjb250ZXh0LnJvdywgdGhpcy5fZ3JpZCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBfZ2V0U3R5bGVQcm9wZXJ0eShjb2xvciwgY29sLCByb3csIHRoaXMuX2dyaWQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICBjdHgudGV4dEFsaWduID0gdGV4dEFsaWduO1xuICAgICAgICAgICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9IHRleHRCYXNlbGluZTtcbiAgICAgICAgICAgICAgICAgIGN0eC5mb250ID0gZm9udCB8fCBjdHguZm9udDtcbiAgICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dCh0ZXh0LCB4LCB5KTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImZpbGxDZWxsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmaWxsQ2VsbChjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICB2YXIgX3JlZjggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9LFxuICAgICAgICAgICAgICAgICAgICBfcmVmOCRmaWxsQ29sb3IgPSBfcmVmOC5maWxsQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGZpbGxDb2xvciA9IF9yZWY4JGZpbGxDb2xvciA9PT0gdm9pZCAwID8gdGhpcy50aGVtZS5kZWZhdWx0QmdDb2xvciA6IF9yZWY4JGZpbGxDb2xvcjtcblxuICAgICAgICAgICAgICAgIHZhciByZWN0ID0gY29udGV4dC5nZXRSZWN0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3V2l0aENsaXAoY29udGV4dCwgZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAgICAgICAgICAgdmFyIGNvbCA9IGNvbnRleHQuY29sLFxuICAgICAgICAgICAgICAgICAgICAgIHJvdyA9IGNvbnRleHQucm93O1xuICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IF9nZXRTdHlsZVByb3BlcnR5KGZpbGxDb2xvciwgY29sLCByb3csIF90aGlzMy5fZ3JpZCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgIGN0eC5yZWN0KHJlY3QubGVmdCwgcmVjdC50b3AsIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImZpbGxDZWxsV2l0aFN0YXRlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmaWxsQ2VsbFdpdGhTdGF0ZShjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICAgICAgICAgICAgb3B0aW9uLmZpbGxDb2xvciA9IHRoaXMuZ2V0RmlsbENvbG9yU3RhdGUoY29udGV4dCwgb3B0aW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbGxDZWxsKGNvbnRleHQsIG9wdGlvbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImZpbGxSZWN0XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmaWxsUmVjdChyZWN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9yZWY5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgX3JlZjkkZmlsbENvbG9yID0gX3JlZjkuZmlsbENvbG9yLFxuICAgICAgICAgICAgICAgICAgICBmaWxsQ29sb3IgPSBfcmVmOSRmaWxsQ29sb3IgPT09IHZvaWQgMCA/IHRoaXMudGhlbWUuZGVmYXVsdEJnQ29sb3IgOiBfcmVmOSRmaWxsQ29sb3I7XG5cbiAgICAgICAgICAgICAgICB2YXIgY3R4ID0gY29udGV4dC5nZXRDb250ZXh0KCk7XG4gICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY29sID0gY29udGV4dC5jb2wsXG4gICAgICAgICAgICAgICAgICAgICAgcm93ID0gY29udGV4dC5yb3c7XG4gICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gX2dldFN0eWxlUHJvcGVydHkoZmlsbENvbG9yLCBjb2wsIHJvdywgdGhpcy5fZ3JpZCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgIGN0eC5yZWN0KHJlY3QubGVmdCwgcmVjdC50b3AsIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJmaWxsUmVjdFdpdGhTdGF0ZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZmlsbFJlY3RXaXRoU3RhdGUocmVjdCwgY29udGV4dCkge1xuICAgICAgICAgICAgICAgIHZhciBvcHRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgICAgICAgICAgICAgIG9wdGlvbi5maWxsQ29sb3IgPSB0aGlzLmdldEZpbGxDb2xvclN0YXRlKGNvbnRleHQsIG9wdGlvbik7XG4gICAgICAgICAgICAgICAgdGhpcy5maWxsUmVjdChyZWN0LCBjb250ZXh0LCBvcHRpb24pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJnZXRGaWxsQ29sb3JTdGF0ZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RmlsbENvbG9yU3RhdGUoY29udGV4dCkge1xuICAgICAgICAgICAgICAgIHZhciBvcHRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgICAgICAgICAgIHZhciBzZWwgPSBjb250ZXh0LmdldFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgICAgIHZhciBjb2wgPSBjb250ZXh0LmNvbCxcbiAgICAgICAgICAgICAgICAgICAgcm93ID0gY29udGV4dC5yb3c7XG5cbiAgICAgICAgICAgICAgICBpZiAoISgwLCB1dGlsc18xLmNlbGxFcXVhbHMpKHNlbC5zZWxlY3QsIGNvbnRleHQpICYmICgwLCB1dGlsc18xLmNlbGxJblJhbmdlKShzZWwucmFuZ2UsIGNvbCwgcm93KSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGhlbWUuc2VsZWN0aW9uQmdDb2xvcjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9uLmZpbGxDb2xvcikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbi5maWxsQ29sb3I7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCgwLCB1dGlsc18xLmNlbGxFcXVhbHMpKHNlbC5zZWxlY3QsIGNvbnRleHQpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50aGVtZS5oaWdobGlnaHRCZ0NvbG9yO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBpc0Zyb3plbkNlbGwgPSB0aGlzLl9ncmlkLmlzRnJvemVuQ2VsbChjb2wsIHJvdyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNGcm96ZW5DZWxsICYmIGlzRnJvemVuQ2VsbC5yb3cpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRoZW1lLmZyb3plblJvd3NCZ0NvbG9yO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRoZW1lLmRlZmF1bHRCZ0NvbG9yO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJib3JkZXJcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGJvcmRlcihjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICB2YXIgX3JlZjEwID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgX3JlZjEwJGJvcmRlckNvbG9yID0gX3JlZjEwLmJvcmRlckNvbG9yLFxuICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvciA9IF9yZWYxMCRib3JkZXJDb2xvciA9PT0gdm9pZCAwID8gdGhpcy50aGVtZS5ib3JkZXJDb2xvciA6IF9yZWYxMCRib3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgX3JlZjEwJGxpbmVXaWR0aCA9IF9yZWYxMC5saW5lV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGxpbmVXaWR0aCA9IF9yZWYxMCRsaW5lV2lkdGggPT09IHZvaWQgMCA/IDEgOiBfcmVmMTAkbGluZVdpZHRoO1xuXG4gICAgICAgICAgICAgICAgdmFyIHJlY3QgPSBjb250ZXh0LmdldFJlY3QoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdCb3JkZXJXaXRoQ2xpcChjb250ZXh0LCBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY29sID0gY29udGV4dC5jb2wsXG4gICAgICAgICAgICAgICAgICAgICAgcm93ID0gY29udGV4dC5yb3c7XG5cbiAgICAgICAgICAgICAgICAgIHZhciBib3JkZXJDb2xvcnMgPSBfZ2V0U3R5bGVQcm9wZXJ0eShib3JkZXJDb2xvciwgY29sLCByb3csIF90aGlzNC5fZ3JpZCwgY3R4KTtcblxuICAgICAgICAgICAgICAgICAgaWYgKGxpbmVXaWR0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gMTtcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlUmVjdChjdHgsIGJvcmRlckNvbG9ycywgcmVjdC5sZWZ0IC0gMC41LCByZWN0LnRvcCAtIDAuNSwgcmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsaW5lV2lkdGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDI7XG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZVJlY3QoY3R4LCBib3JkZXJDb2xvcnMsIHJlY3QubGVmdCwgcmVjdC50b3AsIHJlY3Qud2lkdGggLSAxLCByZWN0LmhlaWdodCAtIDEpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0T2Zmc2V0ID0gbGluZVdpZHRoIC8gMiAtIDE7XG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZVJlY3QoY3R4LCBib3JkZXJDb2xvcnMsIHJlY3QubGVmdCArIHN0YXJ0T2Zmc2V0LCByZWN0LnRvcCArIHN0YXJ0T2Zmc2V0LCByZWN0LndpZHRoIC0gbGluZVdpZHRoICsgMSwgcmVjdC5oZWlnaHQgLSBsaW5lV2lkdGggKyAxKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSAvLyBVbnVzZWQgaW4gbWFpblxuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJib3JkZXJXaXRoU3RhdGVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGJvcmRlcldpdGhTdGF0ZShjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IGNvbnRleHQuZ2V0UmVjdCgpO1xuICAgICAgICAgICAgICAgIHZhciBzZWwgPSBjb250ZXh0LmdldFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgICAgIHZhciBjb2wgPSBjb250ZXh0LmNvbCxcbiAgICAgICAgICAgICAgICAgICAgcm93ID0gY29udGV4dC5yb3c7IC8v572r57eaXG5cbiAgICAgICAgICAgICAgICBpZiAoKDAsIHV0aWxzXzEuY2VsbEVxdWFscykoc2VsLnNlbGVjdCwgY29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgIG9wdGlvbi5ib3JkZXJDb2xvciA9IHRoaXMudGhlbWUuaGlnaGxpZ2h0Qm9yZGVyQ29sb3I7XG4gICAgICAgICAgICAgICAgICBvcHRpb24ubGluZVdpZHRoID0gMjtcbiAgICAgICAgICAgICAgICAgIHRoaXMuYm9yZGVyKGNvbnRleHQsIG9wdGlvbik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIGhlYWRlciBjb2xvclxuICAgICAgICAgICAgICAgICAgdmFyIGlzRnJvemVuQ2VsbCA9IHRoaXMuX2dyaWQuaXNGcm96ZW5DZWxsKGNvbCwgcm93KTtcblxuICAgICAgICAgICAgICAgICAgaWYgKGlzRnJvemVuQ2VsbCA9PT0gbnVsbCB8fCBpc0Zyb3plbkNlbGwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGlzRnJvemVuQ2VsbC5yb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uLmJvcmRlckNvbG9yID0gdGhpcy50aGVtZS5mcm96ZW5Sb3dzQm9yZGVyQ29sb3I7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIG9wdGlvbi5saW5lV2lkdGggPSAxO1xuICAgICAgICAgICAgICAgICAgdGhpcy5ib3JkZXIoY29udGV4dCwgb3B0aW9uKTsgLy/ov73liqDlh6bnkIZcblxuICAgICAgICAgICAgICAgICAgdmFyIF9zZWwgPSB0aGlzLl9ncmlkLnNlbGVjdGlvbi5zZWxlY3Q7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChfc2VsLmNvbCArIDEgPT09IGNvbCAmJiBfc2VsLnJvdyA9PT0gcm93KSB7XG4gICAgICAgICAgICAgICAgICAgIC8v5Y+z44GM6YG45oqe44GV44KM44Gm44GE44KLXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd0JvcmRlcldpdGhDbGlwKGNvbnRleHQsIGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgYm9yZGVyQ29sb3JzID0gX3RvQm94QXJyYXkoX2dldFN0eWxlUHJvcGVydHkoX3RoaXM1LnRoZW1lLmhpZ2hsaWdodEJvcmRlckNvbG9yLCBfc2VsLmNvbCwgX3NlbC5yb3csIF90aGlzNS5fZ3JpZCwgY3R4KSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBib3JkZXJDb2xvcnNbMV0gfHwgY3R4LnN0cm9rZVN0eWxlO1xuICAgICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHJlY3QubGVmdCAtIDAuNSwgcmVjdC50b3ApO1xuICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8ocmVjdC5sZWZ0IC0gMC41LCByZWN0LmJvdHRvbSk7XG4gICAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoX3NlbC5jb2wgPT09IGNvbCAmJiBfc2VsLnJvdyArIDEgPT09IHJvdykge1xuICAgICAgICAgICAgICAgICAgICAvL+S4iuOBjOmBuOaKnuOBleOCjOOBpuOBhOOCi1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdCb3JkZXJXaXRoQ2xpcChjb250ZXh0LCBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGJvcmRlckNvbG9ycyA9IF90b0JveEFycmF5KF9nZXRTdHlsZVByb3BlcnR5KF90aGlzNS50aGVtZS5oaWdobGlnaHRCb3JkZXJDb2xvciwgX3NlbC5jb2wsIF9zZWwucm93LCBfdGhpczUuX2dyaWQsIGN0eCkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gYm9yZGVyQ29sb3JzWzBdIHx8IGN0eC5zdHJva2VTdHlsZTtcbiAgICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhyZWN0LmxlZnQsIHJlY3QudG9wIC0gMC41KTtcbiAgICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHJlY3QucmlnaHQsIHJlY3QudG9wIC0gMC41KTtcbiAgICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiYnVpbGRDaGVja0JveElubGluZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYnVpbGRDaGVja0JveElubGluZShjaGVjaywgY29udGV4dCkge1xuICAgICAgICAgICAgICAgIHZhciBvcHRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhc1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgY3R4ID0gY29udGV4dC5nZXRDb250ZXh0KCk7XG4gICAgICAgICAgICAgICAgdmFyIGJveFdpZHRoID0gY2FudmFzaGVscGVyLm1lYXN1cmVDaGVja2JveChjdHgpLndpZHRoO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSW5saW5lRHJhd2VyXzEuSW5saW5lRHJhd2VyKHtcbiAgICAgICAgICAgICAgICAgIGRyYXc6IGRyYXcsXG4gICAgICAgICAgICAgICAgICB3aWR0aDogYm94V2lkdGggKyAzLFxuICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBib3hXaWR0aCArIDEsXG4gICAgICAgICAgICAgICAgICBjb2xvcjogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBkcmF3KF9yZWYxMSkge1xuICAgICAgICAgICAgICAgICAgdmFyIGN0eCA9IF9yZWYxMS5jdHgsXG4gICAgICAgICAgICAgICAgICAgICAgcmVjdCA9IF9yZWYxMS5yZWN0LFxuICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IF9yZWYxMS5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0TGVmdCA9IF9yZWYxMS5vZmZzZXRMZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgIG9mZnNldFJpZ2h0ID0gX3JlZjExLm9mZnNldFJpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgIG9mZnNldFRvcCA9IF9yZWYxMS5vZmZzZXRUb3AsXG4gICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0Qm90dG9tID0gX3JlZjExLm9mZnNldEJvdHRvbTtcbiAgICAgICAgICAgICAgICAgIHZhciBjb2wgPSBjb250ZXh0LmNvbCxcbiAgICAgICAgICAgICAgICAgICAgICByb3cgPSBjb250ZXh0LnJvdztcbiAgICAgICAgICAgICAgICAgIGRyYXdDaGVja2JveChjdHgsIHJlY3QsIGNvbCwgcm93LCBjaGVjaywgc2VsZiwgb3B0aW9uLCB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0ICsgKENIRUNLQk9YX09GRlNFVCAtIFRFWFRfT0ZGU0VUKSxcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZzoge1xuICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IG9mZnNldExlZnQgKyAoQ0hFQ0tCT1hfT0ZGU0VUIC0gVEVYVF9PRkZTRVQpLFxuICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBvZmZzZXRSaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICB0b3A6IG9mZnNldFRvcCxcbiAgICAgICAgICAgICAgICAgICAgICBib3R0b206IG9mZnNldEJvdHRvbVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNoZWNrYm94XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja2JveChjaGVjaywgY29udGV4dCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9yZWYxMiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge30sXG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmcgPSBfcmVmMTIucGFkZGluZyxcbiAgICAgICAgICAgICAgICAgICAgYW5pbUVsYXBzZWRUaW1lID0gX3JlZjEyLmFuaW1FbGFwc2VkVGltZSxcbiAgICAgICAgICAgICAgICAgICAgX3JlZjEyJG9mZnNldCA9IF9yZWYxMi5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IF9yZWYxMiRvZmZzZXQgPT09IHZvaWQgMCA/IENIRUNLQk9YX09GRlNFVCA6IF9yZWYxMiRvZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIHVuY2hlY2tCZ0NvbG9yID0gX3JlZjEyLnVuY2hlY2tCZ0NvbG9yLFxuICAgICAgICAgICAgICAgICAgICBjaGVja0JnQ29sb3IgPSBfcmVmMTIuY2hlY2tCZ0NvbG9yLFxuICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvciA9IF9yZWYxMi5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgdGV4dEFsaWduID0gX3JlZjEyLnRleHRBbGlnbixcbiAgICAgICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lID0gX3JlZjEyLnRleHRCYXNlbGluZTtcblxuICAgICAgICAgICAgICAgIHRoaXMuZHJhd1dpdGhDbGlwKGNvbnRleHQsIGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBjb2wgPSBjb250ZXh0LmNvbCxcbiAgICAgICAgICAgICAgICAgICAgICByb3cgPSBjb250ZXh0LnJvdztcbiAgICAgICAgICAgICAgICAgIGRyYXdDaGVja2JveChjdHgsIGdldFBhZGRlZFJlY3QoY29udGV4dC5nZXRSZWN0KCksIHBhZGRpbmcsIHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgLyogZm9udCAqL1xuICAgICAgICAgICAgICAgICAgLCBfdGhpczYsIGNvbnRleHQpLCBjb2wsIHJvdywgY2hlY2ssIF90aGlzNiwge1xuICAgICAgICAgICAgICAgICAgICBhbmltRWxhcHNlZFRpbWU6IGFuaW1FbGFwc2VkVGltZSxcbiAgICAgICAgICAgICAgICAgICAgdW5jaGVja0JnQ29sb3I6IHVuY2hlY2tCZ0NvbG9yLFxuICAgICAgICAgICAgICAgICAgICBjaGVja0JnQ29sb3I6IGNoZWNrQmdDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IGJvcmRlckNvbG9yLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ246IHRleHRBbGlnbixcbiAgICAgICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lOiB0ZXh0QmFzZWxpbmVcbiAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IHtcbiAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBDSEVDS0JPWF9PRkZTRVQgLSBURVhUX09GRlNFVFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwicmFkaW9CdXR0b25cIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJhZGlvQnV0dG9uKGNoZWNrLCBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzNyA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICB2YXIgX3JlZjEzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZyA9IF9yZWYxMy5wYWRkaW5nLFxuICAgICAgICAgICAgICAgICAgICBhbmltRWxhcHNlZFRpbWUgPSBfcmVmMTMuYW5pbUVsYXBzZWRUaW1lLFxuICAgICAgICAgICAgICAgICAgICBfcmVmMTMkb2Zmc2V0ID0gX3JlZjEzLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gX3JlZjEzJG9mZnNldCA9PT0gdm9pZCAwID8gQ0hFQ0tCT1hfT0ZGU0VUIDogX3JlZjEzJG9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tDb2xvciA9IF9yZWYxMy5jaGVja0NvbG9yLFxuICAgICAgICAgICAgICAgICAgICB1bmNoZWNrQm9yZGVyQ29sb3IgPSBfcmVmMTMudW5jaGVja0JvcmRlckNvbG9yLFxuICAgICAgICAgICAgICAgICAgICBjaGVja0JvcmRlckNvbG9yID0gX3JlZjEzLmNoZWNrQm9yZGVyQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIHVuY2hlY2tCZ0NvbG9yID0gX3JlZjEzLnVuY2hlY2tCZ0NvbG9yLFxuICAgICAgICAgICAgICAgICAgICBjaGVja0JnQ29sb3IgPSBfcmVmMTMuY2hlY2tCZ0NvbG9yLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSBfcmVmMTMudGV4dEFsaWduLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmUgPSBfcmVmMTMudGV4dEJhc2VsaW5lO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3V2l0aENsaXAoY29udGV4dCwgZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAgICAgICAgICAgdmFyIGNvbCA9IGNvbnRleHQuY29sLFxuICAgICAgICAgICAgICAgICAgICAgIHJvdyA9IGNvbnRleHQucm93O1xuICAgICAgICAgICAgICAgICAgZHJhd1JhZGlvQnV0dG9uKGN0eCwgZ2V0UGFkZGVkUmVjdChjb250ZXh0LmdldFJlY3QoKSwgcGFkZGluZywgdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAvKiBmb250ICovXG4gICAgICAgICAgICAgICAgICAsIF90aGlzNywgY29udGV4dCksIGNvbCwgcm93LCBjaGVjaywgX3RoaXM3LCB7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1FbGFwc2VkVGltZTogYW5pbUVsYXBzZWRUaW1lLFxuICAgICAgICAgICAgICAgICAgICBjaGVja0NvbG9yOiBjaGVja0NvbG9yLFxuICAgICAgICAgICAgICAgICAgICB1bmNoZWNrQm9yZGVyQ29sb3I6IHVuY2hlY2tCb3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tCb3JkZXJDb2xvcjogY2hlY2tCb3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgdW5jaGVja0JnQ29sb3I6IHVuY2hlY2tCZ0NvbG9yLFxuICAgICAgICAgICAgICAgICAgICBjaGVja0JnQ29sb3I6IGNoZWNrQmdDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24sXG4gICAgICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZTogdGV4dEJhc2VsaW5lXG4gICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiB7XG4gICAgICAgICAgICAgICAgICAgICAgbGVmdDogQ0hFQ0tCT1hfT0ZGU0VUIC0gVEVYVF9PRkZTRVRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImJ1dHRvblwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYnV0dG9uKGNhcHRpb24sIGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXM4ID0gdGhpcztcblxuICAgICAgICAgICAgICAgIHZhciBfcmVmMTQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9LFxuICAgICAgICAgICAgICAgICAgICBfcmVmMTQkYmdDb2xvciA9IF9yZWYxNC5iZ0NvbG9yLFxuICAgICAgICAgICAgICAgICAgICBiZ0NvbG9yID0gX3JlZjE0JGJnQ29sb3IgPT09IHZvaWQgMCA/IHRoaXMudGhlbWUuYnV0dG9uLmJnQ29sb3IgOiBfcmVmMTQkYmdDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZyA9IF9yZWYxNC5wYWRkaW5nLFxuICAgICAgICAgICAgICAgICAgICBfcmVmMTQkb2Zmc2V0ID0gX3JlZjE0Lm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gX3JlZjE0JG9mZnNldCA9PT0gdm9pZCAwID8gVEVYVF9PRkZTRVQgOiBfcmVmMTQkb2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBfcmVmMTQkY29sb3IgPSBfcmVmMTQuY29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yID0gX3JlZjE0JGNvbG9yID09PSB2b2lkIDAgPyB0aGlzLnRoZW1lLmJ1dHRvbi5jb2xvciA6IF9yZWYxNCRjb2xvcixcbiAgICAgICAgICAgICAgICAgICAgX3JlZjE0JHRleHRBbGlnbiA9IF9yZWYxNC50ZXh0QWxpZ24sXG4gICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9IF9yZWYxNCR0ZXh0QWxpZ24gPT09IHZvaWQgMCA/IFwiY2VudGVyXCIgOiBfcmVmMTQkdGV4dEFsaWduLFxuICAgICAgICAgICAgICAgICAgICBfcmVmMTQkdGV4dEJhc2VsaW5lID0gX3JlZjE0LnRleHRCYXNlbGluZSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lID0gX3JlZjE0JHRleHRCYXNlbGluZSA9PT0gdm9pZCAwID8gXCJtaWRkbGVcIiA6IF9yZWYxNCR0ZXh0QmFzZWxpbmUsXG4gICAgICAgICAgICAgICAgICAgIHNoYWRvdyA9IF9yZWYxNC5zaGFkb3csXG4gICAgICAgICAgICAgICAgICAgIGZvbnQgPSBfcmVmMTQuZm9udCxcbiAgICAgICAgICAgICAgICAgICAgX3JlZjE0JHRleHRPdmVyZmxvdyA9IF9yZWYxNC50ZXh0T3ZlcmZsb3csXG4gICAgICAgICAgICAgICAgICAgIHRleHRPdmVyZmxvdyA9IF9yZWYxNCR0ZXh0T3ZlcmZsb3cgPT09IHZvaWQgMCA/IFwiY2xpcFwiIDogX3JlZjE0JHRleHRPdmVyZmxvdyxcbiAgICAgICAgICAgICAgICAgICAgaWNvbnMgPSBfcmVmMTQuaWNvbnM7XG5cbiAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IGNvbnRleHQuZ2V0UmVjdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhd1dpdGhDbGlwKGNvbnRleHQsIGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICAgICAgICAgIGZvbnQgPSBnZXRGb250KGZvbnQsIGNvbnRleHQuY29sLCBjb250ZXh0LnJvdywgX3RoaXM4Ll9ncmlkLCBjdHgpO1xuICAgICAgICAgICAgICAgICAgdmFyIGNvbCA9IGNvbnRleHQuY29sLFxuICAgICAgICAgICAgICAgICAgICAgIHJvdyA9IGNvbnRleHQucm93O1xuXG4gICAgICAgICAgICAgICAgICB2YXIgX2dldFBhZGRlZFJlY3QgPSBnZXRQYWRkZWRSZWN0KHJlY3QsIHBhZGRpbmcgfHwgcmVjdC5oZWlnaHQgLyA4LCBmb250LCBfdGhpczgsIGNvbnRleHQpLFxuICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBfZ2V0UGFkZGVkUmVjdC5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgIHRvcCA9IF9nZXRQYWRkZWRSZWN0LnRvcCxcbiAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IF9nZXRQYWRkZWRSZWN0LndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IF9nZXRQYWRkZWRSZWN0LmhlaWdodDtcblxuICAgICAgICAgICAgICAgICAgYmdDb2xvciA9IF9nZXRTdHlsZVByb3BlcnR5KGJnQ29sb3IsIGNvbnRleHQuY29sLCBjb250ZXh0LnJvdywgX3RoaXM4Ll9ncmlkLCBjdHgpO1xuICAgICAgICAgICAgICAgICAgY2FudmFzaGVscGVyLmRyYXdCdXR0b24oY3R4LCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQsIHtcbiAgICAgICAgICAgICAgICAgICAgYmdDb2xvcjogYmdDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgcmFkaXVzOiByZWN0LmhlaWdodCAvIDgsXG4gICAgICAgICAgICAgICAgICAgIC8vIG9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgc2hhZG93OiBzaGFkb3dcbiAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICBfaW5saW5lUmVjdChfdGhpczguX2dyaWQsIGN0eCwgY2FwdGlvbiwgbmV3IFJlY3RfMS5SZWN0KGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCksIGNvbCwgcm93LCB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbjogdGV4dEFsaWduLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmU6IHRleHRCYXNlbGluZSxcbiAgICAgICAgICAgICAgICAgICAgZm9udDogZm9udCxcbiAgICAgICAgICAgICAgICAgICAgdGV4dE92ZXJmbG93OiB0ZXh0T3ZlcmZsb3csXG4gICAgICAgICAgICAgICAgICAgIGljb25zOiBpY29uc1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInRlc3RGb250TG9hZFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdGVzdEZvbnRMb2FkKGZvbnQsIHZhbHVlLCBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90ZXN0Rm9udExvYWQoZm9udCwgdmFsdWUsIGNvbnRleHQsIHRoaXMuX2dyaWQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBHcmlkQ2FudmFzSGVscGVyO1xuICAgICAgICAgIH0oKTtcblxuICAgICAgICAgIGV4cG9ydHMuR3JpZENhbnZhc0hlbHBlciA9IEdyaWRDYW52YXNIZWxwZXI7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vTGlzdEdyaWQuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9MaXN0R3JpZC5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIExpc3RHcmlkSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICB2YXIgX19jcmVhdGVCaW5kaW5nID0gdGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZyB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICAgICAgICAgICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcblxuICAgICAgICAgICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgICAgICAgICAgZGVzYyA9IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ba107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xuICAgICAgICAgIH0gOiBmdW5jdGlvbiAobywgbSwgaywgazIpIHtcbiAgICAgICAgICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgICAgICAgICBvW2syXSA9IG1ba107XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gdGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCB2KSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHtcbiAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gOiBmdW5jdGlvbiAobywgdikge1xuICAgICAgICAgICAgb1tcImRlZmF1bHRcIl0gPSB2O1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIF9faW1wb3J0U3RhciA9IHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgICAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIHtcbiAgICAgICAgICAgICAgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICB2YXIgX2E7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5MaXN0R3JpZCA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBpY29ucyA9IF9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL2ludGVybmFsL2ljb25zICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL2ljb25zLmpzXCIpKTtcblxuICAgICAgICAgIHZhciB0aGVtZXMgPSBfX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi90aGVtZXMgKi9cbiAgICAgICAgICBcIi4vdGhlbWVzLmpzXCIpKTtcblxuICAgICAgICAgIHZhciBkYXRhXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL2RhdGEgKi9cbiAgICAgICAgICBcIi4vZGF0YS5qc1wiKTtcblxuICAgICAgICAgIHZhciBsYXlvdXRfbWFwXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL2xpc3QtZ3JpZC9sYXlvdXQtbWFwICovXG4gICAgICAgICAgXCIuL2xpc3QtZ3JpZC9sYXlvdXQtbWFwL2luZGV4LmpzXCIpO1xuXG4gICAgICAgICAgdmFyIE1lc3NhZ2VIYW5kbGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL2NvbHVtbnMvbWVzc2FnZS9NZXNzYWdlSGFuZGxlciAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL21lc3NhZ2UvTWVzc2FnZUhhbmRsZXIuanNcIik7XG5cbiAgICAgICAgICB2YXIgdXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vaW50ZXJuYWwvdXRpbHMgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvdXRpbHMuanNcIik7XG5cbiAgICAgICAgICB2YXIgc3R5bGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vY29sdW1ucy9zdHlsZSAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3N0eWxlLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIERyYXdHcmlkXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL2NvcmUvRHJhd0dyaWQgKi9cbiAgICAgICAgICBcIi4vY29yZS9EcmF3R3JpZC5qc1wiKTtcblxuICAgICAgICAgIHZhciBHcmlkQ2FudmFzSGVscGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL0dyaWRDYW52YXNIZWxwZXIgKi9cbiAgICAgICAgICBcIi4vR3JpZENhbnZhc0hlbHBlci5qc1wiKTtcblxuICAgICAgICAgIHZhciBzdHlsZV8yID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9oZWFkZXIvc3R5bGUgKi9cbiAgICAgICAgICBcIi4vaGVhZGVyL3N0eWxlLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIExHX0VWRU5UX1RZUEVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vbGlzdC1ncmlkL0xHX0VWRU5UX1RZUEUgKi9cbiAgICAgICAgICBcIi4vbGlzdC1ncmlkL0xHX0VWRU5UX1RZUEUuanNcIik7XG5cbiAgICAgICAgICB2YXIgUmVjdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9pbnRlcm5hbC9SZWN0ICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL1JlY3QuanNcIik7XG5cbiAgICAgICAgICB2YXIgVG9vbHRpcEhhbmRsZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vdG9vbHRpcC9Ub29sdGlwSGFuZGxlciAqL1xuICAgICAgICAgIFwiLi90b29sdGlwL1Rvb2x0aXBIYW5kbGVyLmpzXCIpOyAvL3Byb3RlY3RlZCBzeW1ib2xcblxuXG4gICAgICAgICAgdmFyIHN5bWJvbE1hbmFnZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vaW50ZXJuYWwvc3ltYm9sTWFuYWdlciAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC9zeW1ib2xNYW5hZ2VyLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIHBhc3RlX3V0aWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL2ludGVybmFsL3Bhc3RlLXV0aWxzICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL3Bhc3RlLXV0aWxzLmpzXCIpO1xuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgICAgICAgICB2YXIgXyA9ICgwLCBzeW1ib2xNYW5hZ2VyXzEuZ2V0UHJvdGVjdGVkU3ltYm9sKSgpOyAvL3ByaXZhdGUgbWV0aG9kc1xuXG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cblxuICAgICAgICAgIGZ1bmN0aW9uIF9nZXRDZWxsUmFuZ2UoZ3JpZCwgY29sLCByb3cpIHtcbiAgICAgICAgICAgIHJldHVybiBncmlkW19dLmxheW91dE1hcC5nZXRDZWxsUmFuZ2UoY29sLCByb3cpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKiogQHByaXZhdGUgKi9cblxuXG4gICAgICAgICAgZnVuY3Rpb24gX3VwZGF0ZVJlY3QoZ3JpZCwgY29sLCByb3csIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGNvbnRleHQuc2V0UmVjdEZpbHRlcihmdW5jdGlvbiAocmVjdCkge1xuICAgICAgICAgICAgICB2YXIgbGVmdCA9IHJlY3QubGVmdCxcbiAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmVjdC5yaWdodCxcbiAgICAgICAgICAgICAgICAgIHRvcCA9IHJlY3QudG9wLFxuICAgICAgICAgICAgICAgICAgYm90dG9tID0gcmVjdC5ib3R0b207XG5cbiAgICAgICAgICAgICAgdmFyIF9nZXRDZWxsUmFuZ2UyID0gX2dldENlbGxSYW5nZShncmlkLCBjb2wsIHJvdyksXG4gICAgICAgICAgICAgICAgICBfZ2V0Q2VsbFJhbmdlMiRzdGFydCA9IF9nZXRDZWxsUmFuZ2UyLnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgc3RhcnRDb2wgPSBfZ2V0Q2VsbFJhbmdlMiRzdGFydC5jb2wsXG4gICAgICAgICAgICAgICAgICBzdGFydFJvdyA9IF9nZXRDZWxsUmFuZ2UyJHN0YXJ0LnJvdyxcbiAgICAgICAgICAgICAgICAgIF9nZXRDZWxsUmFuZ2UyJGVuZCA9IF9nZXRDZWxsUmFuZ2UyLmVuZCxcbiAgICAgICAgICAgICAgICAgIGVuZENvbCA9IF9nZXRDZWxsUmFuZ2UyJGVuZC5jb2wsXG4gICAgICAgICAgICAgICAgICBlbmRSb3cgPSBfZ2V0Q2VsbFJhbmdlMiRlbmQucm93O1xuXG4gICAgICAgICAgICAgIGZvciAodmFyIGMgPSBjb2wgLSAxOyBjID49IHN0YXJ0Q29sOyBjLS0pIHtcbiAgICAgICAgICAgICAgICBsZWZ0IC09IGdyaWQuZ2V0Q29sV2lkdGgoYyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBmb3IgKHZhciBfYzIgPSBjb2wgKyAxOyBfYzIgPD0gZW5kQ29sOyBfYzIrKykge1xuICAgICAgICAgICAgICAgIHJpZ2h0ICs9IGdyaWQuZ2V0Q29sV2lkdGgoX2MyKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGZvciAodmFyIHIgPSByb3cgLSAxOyByID49IHN0YXJ0Um93OyByLS0pIHtcbiAgICAgICAgICAgICAgICB0b3AgLT0gZ3JpZC5nZXRSb3dIZWlnaHQocik7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBmb3IgKHZhciBfciA9IHJvdyArIDE7IF9yIDw9IGVuZFJvdzsgX3IrKykge1xuICAgICAgICAgICAgICAgIGJvdHRvbSArPSBncmlkLmdldFJvd0hlaWdodChfcik7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gUmVjdF8xLlJlY3QuYm91bmRzKGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cblxuICAgICAgICAgIGZ1bmN0aW9uIF9nZXRDZWxsVmFsdWUoZ3JpZCwgY29sLCByb3cpIHtcbiAgICAgICAgICAgIGlmIChyb3cgPCBncmlkW19dLmxheW91dE1hcC5oZWFkZXJSb3dDb3VudCkge1xuICAgICAgICAgICAgICB2YXIgX2dyaWQkXyRsYXlvdXRNYXAkZ2V0ID0gZ3JpZFtfXS5sYXlvdXRNYXAuZ2V0SGVhZGVyKGNvbCwgcm93KSxcbiAgICAgICAgICAgICAgICAgIGNhcHRpb24gPSBfZ3JpZCRfJGxheW91dE1hcCRnZXQuY2FwdGlvbjtcblxuICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIGNhcHRpb24gPT09IFwiZnVuY3Rpb25cIiA/IGNhcHRpb24oKSA6IGNhcHRpb247XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgX2dyaWQkXyRsYXlvdXRNYXAkZ2V0MiA9IGdyaWRbX10ubGF5b3V0TWFwLmdldEJvZHkoY29sLCByb3cpLFxuICAgICAgICAgICAgICAgICAgZmllbGQgPSBfZ3JpZCRfJGxheW91dE1hcCRnZXQyLmZpZWxkO1xuXG4gICAgICAgICAgICAgIHJldHVybiBfZ2V0RmllbGQoZ3JpZCwgZmllbGQsIHJvdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgICAgICAgICBmdW5jdGlvbiBfc2V0Q2VsbFZhbHVlKGdyaWQsIGNvbCwgcm93LCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAocm93IDwgZ3JpZFtfXS5sYXlvdXRNYXAuaGVhZGVyUm93Q291bnQpIHtcbiAgICAgICAgICAgICAgLy8gbm9wXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBfZ3JpZCRfJGxheW91dE1hcCRnZXQzID0gZ3JpZFtfXS5sYXlvdXRNYXAuZ2V0Qm9keShjb2wsIHJvdyksXG4gICAgICAgICAgICAgICAgICBmaWVsZCA9IF9ncmlkJF8kbGF5b3V0TWFwJGdldDMuZmllbGQ7XG5cbiAgICAgICAgICAgICAgaWYgKGZpZWxkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgaW5kZXggPSBfZ2V0UmVjb3JkSW5kZXhCeVJvdyhncmlkLCByb3cpO1xuXG4gICAgICAgICAgICAgIHJldHVybiBncmlkW19dLmRhdGFTb3VyY2Uuc2V0RmllbGQoaW5kZXgsIGZpZWxkLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgICAgICAgICBmdW5jdGlvbiBfZ2V0Q2VsbE1lc3NhZ2UoZ3JpZCwgY29sLCByb3cpIHtcbiAgICAgICAgICAgIGlmIChyb3cgPCBncmlkW19dLmxheW91dE1hcC5oZWFkZXJSb3dDb3VudCkge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBfZ3JpZCRfJGxheW91dE1hcCRnZXQ0ID0gZ3JpZFtfXS5sYXlvdXRNYXAuZ2V0Qm9keShjb2wsIHJvdyksXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlID0gX2dyaWQkXyRsYXlvdXRNYXAkZ2V0NC5tZXNzYWdlO1xuXG4gICAgICAgICAgICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9nZXRGaWVsZChncmlkLCBtZXNzYWdlLCByb3cpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIHByb21pc2VzID0gW107XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IG1lc3NhZ2UubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1zZyA9IF9nZXRGaWVsZChncmlkLCBtZXNzYWdlW2luZGV4XSwgcm93KTtcblxuICAgICAgICAgICAgICAgIGlmICgoMCwgdXRpbHNfMS5pc1Byb21pc2UpKG1zZykpIHtcbiAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2gobXNnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCgwLCBNZXNzYWdlSGFuZGxlcl8xLmhhc01lc3NhZ2UpKG1zZykpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBtc2c7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCFwcm9taXNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMuZm9yRWFjaChmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgICAgICAgcC50aGVuKGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCBNZXNzYWdlSGFuZGxlcl8xLmhhc01lc3NhZ2UpKG1zZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG1zZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIF9nZXRDZWxsSWNvbjAoZ3JpZCwgaWNvbiwgcm93KSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpY29uKSkge1xuICAgICAgICAgICAgICByZXR1cm4gaWNvbi5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2dldENlbGxJY29uMChncmlkLCBpLCByb3cpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF1dGlsc18xLm9iai5pc09iamVjdChpY29uKSB8fCB0eXBlb2YgaWNvbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfZ2V0RmllbGQoZ3JpZCwgaWNvbiwgcm93KTtcbiAgICAgICAgICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcblxuXG4gICAgICAgICAgICB2YXIgcmV0SWNvbiA9IHt9OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXG4gICAgICAgICAgICB2YXIgaWNvbk9wdCA9IGljb247XG4gICAgICAgICAgICBpY29ucy5pY29uUHJvcEtleXMuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgICBpZiAoaWNvbk9wdFtrXSkge1xuICAgICAgICAgICAgICAgIHZhciBmID0gX2dldEZpZWxkKGdyaWQsIGljb25PcHRba10sIHJvdyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICByZXRJY29uW2tdID0gZjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYgKCFfaGFzRmllbGQoZ3JpZCwgaWNvbk9wdFtrXSwgcm93KSkge1xuICAgICAgICAgICAgICAgICAgICByZXRJY29uW2tdID0gaWNvbk9wdFtrXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJldEljb247XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgICAgICAgICBmdW5jdGlvbiBfZ2V0Q2VsbEljb24oZ3JpZCwgY29sLCByb3cpIHtcbiAgICAgICAgICAgIGlmIChyb3cgPCBncmlkW19dLmxheW91dE1hcC5oZWFkZXJSb3dDb3VudCkge1xuICAgICAgICAgICAgICB2YXIgX2dyaWQkXyRsYXlvdXRNYXAkZ2V0NSA9IGdyaWRbX10ubGF5b3V0TWFwLmdldEhlYWRlcihjb2wsIHJvdyksXG4gICAgICAgICAgICAgICAgICBoZWFkZXJJY29uID0gX2dyaWQkXyRsYXlvdXRNYXAkZ2V0NS5oZWFkZXJJY29uO1xuXG4gICAgICAgICAgICAgIGlmIChoZWFkZXJJY29uID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBoZWFkZXJJY29uO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIF9ncmlkJF8kbGF5b3V0TWFwJGdldDYgPSBncmlkW19dLmxheW91dE1hcC5nZXRCb2R5KGNvbCwgcm93KSxcbiAgICAgICAgICAgICAgICAgIGljb24gPSBfZ3JpZCRfJGxheW91dE1hcCRnZXQ2Lmljb247XG5cbiAgICAgICAgICAgICAgaWYgKGljb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIF9nZXRDZWxsSWNvbjAoZ3JpZCwgaWNvbiwgcm93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cblxuICAgICAgICAgIGZ1bmN0aW9uIF9nZXRGaWVsZChncmlkLCBmaWVsZCwgcm93KSB7XG4gICAgICAgICAgICBpZiAoZmllbGQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJvdyA8IGdyaWRbX10ubGF5b3V0TWFwLmhlYWRlclJvd0NvdW50KSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIGluZGV4ID0gX2dldFJlY29yZEluZGV4QnlSb3coZ3JpZCwgcm93KTtcblxuICAgICAgICAgICAgICByZXR1cm4gZ3JpZFtfXS5kYXRhU291cmNlLmdldEZpZWxkKGluZGV4LCBmaWVsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgICAgICAgICBmdW5jdGlvbiBfaGFzRmllbGQoZ3JpZCwgZmllbGQsIHJvdykge1xuICAgICAgICAgICAgaWYgKGZpZWxkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocm93IDwgZ3JpZFtfXS5sYXlvdXRNYXAuaGVhZGVyUm93Q291bnQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIGluZGV4ID0gX2dldFJlY29yZEluZGV4QnlSb3coZ3JpZCwgcm93KTtcblxuICAgICAgICAgICAgICByZXR1cm4gZ3JpZFtfXS5kYXRhU291cmNlLmhhc0ZpZWxkKGluZGV4LCBmaWVsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgICAgICAgICBmdW5jdGlvbiBfb25EcmF3VmFsdWUoZ3JpZCwgY2VsbFZhbHVlLCBjb250ZXh0LCBfcmVmMTUsIHN0eWxlLCBkcmF3KSB7XG4gICAgICAgICAgICB2YXIgY29sID0gX3JlZjE1LmNvbCxcbiAgICAgICAgICAgICAgICByb3cgPSBfcmVmMTUucm93O1xuICAgICAgICAgICAgdmFyIGhlbHBlciA9IGdyaWRbX10uZ3JpZENhbnZhc0hlbHBlcjtcblxuICAgICAgICAgICAgdmFyIGRyYXdDZWxsQmcgPSBmdW5jdGlvbiBkcmF3Q2VsbEJnKCkge1xuICAgICAgICAgICAgICB2YXIgX3JlZjE2ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgICAgICAgICAgIGJnQ29sb3IgPSBfcmVmMTYuYmdDb2xvcjtcblxuICAgICAgICAgICAgICB2YXIgZmlsbE9wdCA9IHtcbiAgICAgICAgICAgICAgICBmaWxsQ29sb3I6IGJnQ29sb3JcbiAgICAgICAgICAgICAgfTsgLy9jZWxs5YWo5L2T44KS5o+P55S7XG5cbiAgICAgICAgICAgICAgaGVscGVyLmZpbGxDZWxsV2l0aFN0YXRlKGNvbnRleHQsIGZpbGxPcHQpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGRyYXdDZWxsQm9yZGVyID0gZnVuY3Rpb24gZHJhd0NlbGxCb3JkZXIoKSB7XG4gICAgICAgICAgICAgIGlmIChjb250ZXh0LmNvbCA9PT0gZ3JpZC5mcm96ZW5Db2xDb3VudCAtIDEpIHtcbiAgICAgICAgICAgICAgICAvL+WbuuWumuWIl+e9q+e3mlxuICAgICAgICAgICAgICAgIHZhciByZWN0ID0gY29udGV4dC5nZXRSZWN0KCk7XG4gICAgICAgICAgICAgICAgaGVscGVyLmRyYXdXaXRoQ2xpcChjb250ZXh0LCBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgYm9yZGVyQ29sb3IgPSBjb250ZXh0LnJvdyA+PSBncmlkLmZyb3plblJvd0NvdW50ID8gaGVscGVyLnRoZW1lLmJvcmRlckNvbG9yIDogaGVscGVyLnRoZW1lLmZyb3plblJvd3NCb3JkZXJDb2xvcjtcbiAgICAgICAgICAgICAgICAgIHZhciBib3JkZXJDb2xvcnMgPSBoZWxwZXIudG9Cb3hBcnJheShoZWxwZXIuZ2V0Q29sb3IoYm9yZGVyQ29sb3IsIGNvbnRleHQuY29sLCBjb250ZXh0LnJvdywgY3R4KSk7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChib3JkZXJDb2xvcnNbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGJvcmRlckNvbG9yc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHJlY3QucmlnaHQgLSAyLjUsIHJlY3QudG9wKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhyZWN0LnJpZ2h0IC0gMi41LCByZWN0LmJvdHRvbSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIF9ib3JkZXJXaXRoU3RhdGUoZ3JpZCwgaGVscGVyLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBkcmF3Q2VsbEJhc2UgPSBmdW5jdGlvbiBkcmF3Q2VsbEJhc2UoKSB7XG4gICAgICAgICAgICAgIHZhciBfcmVmMTcgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgICAgICAgICAgICAgYmdDb2xvciA9IF9yZWYxNy5iZ0NvbG9yO1xuXG4gICAgICAgICAgICAgIGRyYXdDZWxsQmcoe1xuICAgICAgICAgICAgICAgIGJnQ29sb3I6IGJnQ29sb3JcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGRyYXdDZWxsQm9yZGVyKCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgaW5mbyA9IHtcbiAgICAgICAgICAgICAgZ2V0UmVjb3JkOiBmdW5jdGlvbiBnZXRSZWNvcmQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdyaWQuZ2V0Um93UmVjb3JkKHJvdyk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGdldEljb246IGZ1bmN0aW9uIGdldEljb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9nZXRDZWxsSWNvbihncmlkLCBjb2wsIHJvdyk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGdldE1lc3NhZ2U6IGZ1bmN0aW9uIGdldE1lc3NhZ2UoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9nZXRDZWxsTWVzc2FnZShncmlkLCBjb2wsIHJvdyk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG1lc3NhZ2VIYW5kbGVyOiBncmlkW19dLm1lc3NhZ2VIYW5kbGVyLFxuICAgICAgICAgICAgICBzdHlsZTogc3R5bGUsXG4gICAgICAgICAgICAgIGRyYXdDZWxsQmFzZTogZHJhd0NlbGxCYXNlLFxuICAgICAgICAgICAgICBkcmF3Q2VsbEJnOiBkcmF3Q2VsbEJnLFxuICAgICAgICAgICAgICBkcmF3Q2VsbEJvcmRlcjogZHJhd0NlbGxCb3JkZXJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gZHJhdyhjZWxsVmFsdWUsIGluZm8sIGNvbnRleHQsIGdyaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKiogQHByaXZhdGUgKi9cblxuXG4gICAgICAgICAgZnVuY3Rpb24gX2JvcmRlcldpdGhTdGF0ZShncmlkLCBoZWxwZXIsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBjb2wgPSBjb250ZXh0LmNvbCxcbiAgICAgICAgICAgICAgICByb3cgPSBjb250ZXh0LnJvdztcbiAgICAgICAgICAgIHZhciBzZWwgPSBncmlkLnNlbGVjdGlvbi5zZWxlY3Q7XG4gICAgICAgICAgICB2YXIgbGF5b3V0TWFwID0gZ3JpZFtfXS5sYXlvdXRNYXA7XG4gICAgICAgICAgICB2YXIgcmVjdCA9IGNvbnRleHQuZ2V0UmVjdCgpO1xuICAgICAgICAgICAgdmFyIG9wdGlvbiA9IHt9O1xuICAgICAgICAgICAgdmFyIHNlbFJlY29yZEluZGV4ID0gbGF5b3V0TWFwLmdldFJlY29yZEluZGV4QnlSb3coc2VsLnJvdyk7XG4gICAgICAgICAgICB2YXIgc2VsSWQgPSBsYXlvdXRNYXAuZ2V0Q2VsbElkKHNlbC5jb2wsIHNlbC5yb3cpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBpc1NlbGVjdENlbGwoY29sLCByb3cpIHtcbiAgICAgICAgICAgICAgaWYgKGNvbCA9PT0gc2VsLmNvbCAmJiByb3cgPT09IHNlbC5yb3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBzZWxJZCAhPSBudWxsICYmIGxheW91dE1hcC5nZXRDZWxsSWQoY29sLCByb3cpID09PSBzZWxJZCAmJiBsYXlvdXRNYXAuZ2V0UmVjb3JkSW5kZXhCeVJvdyhyb3cpID09PSBzZWxSZWNvcmRJbmRleDtcbiAgICAgICAgICAgIH0gLy/nvavnt5pcblxuXG4gICAgICAgICAgICBpZiAoaXNTZWxlY3RDZWxsKGNvbCwgcm93KSkge1xuICAgICAgICAgICAgICBvcHRpb24uYm9yZGVyQ29sb3IgPSBoZWxwZXIudGhlbWUuaGlnaGxpZ2h0Qm9yZGVyQ29sb3I7XG4gICAgICAgICAgICAgIG9wdGlvbi5saW5lV2lkdGggPSAyO1xuICAgICAgICAgICAgICBoZWxwZXIuYm9yZGVyKGNvbnRleHQsIG9wdGlvbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvcHRpb24ubGluZVdpZHRoID0gMTsgLy8gaGVhZGVyIGNvbG9yXG5cbiAgICAgICAgICAgICAgdmFyIGlzRnJvemVuQ2VsbCA9IGdyaWQuaXNGcm96ZW5DZWxsKGNvbCwgcm93KTtcblxuICAgICAgICAgICAgICBpZiAoaXNGcm96ZW5DZWxsID09PSBudWxsIHx8IGlzRnJvemVuQ2VsbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaXNGcm96ZW5DZWxsLnJvdykge1xuICAgICAgICAgICAgICAgIG9wdGlvbi5ib3JkZXJDb2xvciA9IGhlbHBlci50aGVtZS5mcm96ZW5Sb3dzQm9yZGVyQ29sb3I7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBoZWxwZXIuYm9yZGVyKGNvbnRleHQsIG9wdGlvbik7IC8v6L+95Yqg5Yem55CGXG5cbiAgICAgICAgICAgICAgaWYgKGNvbCA+IDAgJiYgaXNTZWxlY3RDZWxsKGNvbCAtIDEsIHJvdykpIHtcbiAgICAgICAgICAgICAgICAvL+WPs+OBjOmBuOaKnuOBleOCjOOBpuOBhOOCi1xuICAgICAgICAgICAgICAgIGhlbHBlci5kcmF3Qm9yZGVyV2l0aENsaXAoY29udGV4dCwgZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAgICAgICAgICAgdmFyIGJvcmRlckNvbG9ycyA9IGhlbHBlci50b0JveEFycmF5KGhlbHBlci5nZXRDb2xvcihoZWxwZXIudGhlbWUuaGlnaGxpZ2h0Qm9yZGVyQ29sb3IsIHNlbC5jb2wsIHNlbC5yb3csIGN0eCkpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoYm9yZGVyQ29sb3JzWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAxO1xuICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBib3JkZXJDb2xvcnNbMV07XG4gICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhyZWN0LmxlZnQgLSAwLjUsIHJlY3QudG9wKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhyZWN0LmxlZnQgLSAwLjUsIHJlY3QuYm90dG9tKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJvdyA+IDAgJiYgaXNTZWxlY3RDZWxsKGNvbCwgcm93IC0gMSkpIHtcbiAgICAgICAgICAgICAgICAvL+S4iuOBjOmBuOaKnuOBleOCjOOBpuOBhOOCi1xuICAgICAgICAgICAgICAgIGhlbHBlci5kcmF3Qm9yZGVyV2l0aENsaXAoY29udGV4dCwgZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAgICAgICAgICAgdmFyIGJvcmRlckNvbG9ycyA9IGhlbHBlci50b0JveEFycmF5KGhlbHBlci5nZXRDb2xvcihoZWxwZXIudGhlbWUuaGlnaGxpZ2h0Qm9yZGVyQ29sb3IsIHNlbC5jb2wsIHNlbC5yb3csIGN0eCkpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoYm9yZGVyQ29sb3JzWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAxO1xuICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBib3JkZXJDb2xvcnNbMF07XG4gICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhyZWN0LmxlZnQsIHJlY3QudG9wIC0gMC41KTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhyZWN0LnJpZ2h0LCByZWN0LnRvcCAtIDAuNSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvKiogQHByaXZhdGUgKi9cblxuXG4gICAgICAgICAgZnVuY3Rpb24gX3JlZnJlc2hIZWFkZXIoZ3JpZCkge1xuICAgICAgICAgICAgdmFyIF9iO1xuXG4gICAgICAgICAgICB2YXIgcHJvdGVjdGVkU3BhY2UgPSBncmlkW19dO1xuXG4gICAgICAgICAgICBpZiAocHJvdGVjdGVkU3BhY2UuaGVhZGVyRXZlbnRzKSB7XG4gICAgICAgICAgICAgIHByb3RlY3RlZFNwYWNlLmhlYWRlckV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBncmlkLnVubGlzdGVuKGlkKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBoZWFkZXJFdmVudHMgPSBncmlkW19dLmhlYWRlckV2ZW50cyA9IFtdO1xuICAgICAgICAgICAgaGVhZGVyRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBncmlkLnVubGlzdGVuKGlkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGxheW91dE1hcDtcblxuICAgICAgICAgICAgaWYgKHByb3RlY3RlZFNwYWNlLmxheW91dCAmJiAoIUFycmF5LmlzQXJyYXkocHJvdGVjdGVkU3BhY2UubGF5b3V0KSB8fCBwcm90ZWN0ZWRTcGFjZS5sYXlvdXQubGVuZ3RoID4gMCkpIHtcbiAgICAgICAgICAgICAgbGF5b3V0TWFwID0gcHJvdGVjdGVkU3BhY2UubGF5b3V0TWFwID0gbmV3IGxheW91dF9tYXBfMS5NdWx0aUxheW91dE1hcChwcm90ZWN0ZWRTcGFjZS5sYXlvdXQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbGF5b3V0TWFwID0gcHJvdGVjdGVkU3BhY2UubGF5b3V0TWFwID0gbmV3IGxheW91dF9tYXBfMS5TaW1wbGVIZWFkZXJMYXlvdXRNYXAoKF9iID0gcHJvdGVjdGVkU3BhY2UuaGVhZGVyKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxheW91dE1hcC5oZWFkZXJPYmplY3RzLmZvckVhY2goZnVuY3Rpb24gKGNlbGwpIHtcbiAgICAgICAgICAgICAgdmFyIGlkcyA9IGNlbGwuaGVhZGVyVHlwZS5iaW5kR3JpZEV2ZW50KGdyaWQsIGNlbGwuaWQpO1xuICAgICAgICAgICAgICBoZWFkZXJFdmVudHMucHVzaC5hcHBseShoZWFkZXJFdmVudHMsIF90b0NvbnN1bWFibGVBcnJheShpZHMpKTtcblxuICAgICAgICAgICAgICBpZiAoY2VsbC5zdHlsZSkge1xuICAgICAgICAgICAgICAgIGlmIChjZWxsLnN0eWxlIGluc3RhbmNlb2Ygc3R5bGVfMi5CYXNlU3R5bGUpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBpZCA9IGNlbGwuc3R5bGUubGlzdGVuKHN0eWxlXzIuQmFzZVN0eWxlLkVWRU5UX1RZUEUuQ0hBTkdFX1NUWUxFLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyaWQuaW52YWxpZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBoZWFkZXJFdmVudHMucHVzaChpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGNlbGwuYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9pZHMgPSBjZWxsLmFjdGlvbi5iaW5kR3JpZEV2ZW50KGdyaWQsIGNlbGwuaWQpO1xuXG4gICAgICAgICAgICAgICAgaGVhZGVyRXZlbnRzLnB1c2guYXBwbHkoaGVhZGVyRXZlbnRzLCBfdG9Db25zdW1hYmxlQXJyYXkoX2lkcykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxheW91dE1hcC5jb2x1bW5PYmplY3RzLmZvckVhY2goZnVuY3Rpb24gKGNvbCkge1xuICAgICAgICAgICAgICBpZiAoY29sLmFjdGlvbikge1xuICAgICAgICAgICAgICAgIHZhciBpZHMgPSBjb2wuYWN0aW9uLmJpbmRHcmlkRXZlbnQoZ3JpZCwgY29sLmlkKTtcbiAgICAgICAgICAgICAgICBoZWFkZXJFdmVudHMucHVzaC5hcHBseShoZWFkZXJFdmVudHMsIF90b0NvbnN1bWFibGVBcnJheShpZHMpKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChjb2wuY29sdW1uVHlwZSkge1xuICAgICAgICAgICAgICAgIHZhciBfaWRzMiA9IGNvbC5jb2x1bW5UeXBlLmJpbmRHcmlkRXZlbnQoZ3JpZCwgY29sLmlkKTtcblxuICAgICAgICAgICAgICAgIGhlYWRlckV2ZW50cy5wdXNoLmFwcGx5KGhlYWRlckV2ZW50cywgX3RvQ29uc3VtYWJsZUFycmF5KF9pZHMyKSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoY29sLnN0eWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbC5zdHlsZSBpbnN0YW5jZW9mIHN0eWxlXzEuQmFzZVN0eWxlKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgaWQgPSBjb2wuc3R5bGUubGlzdGVuKHN0eWxlXzEuQmFzZVN0eWxlLkVWRU5UX1RZUEUuQ0hBTkdFX1NUWUxFLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyaWQuaW52YWxpZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBoZWFkZXJFdmVudHMucHVzaChpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgbGF5b3V0TWFwLmNvbHVtbldpZHRocy5sZW5ndGg7IGNvbCsrKSB7XG4gICAgICAgICAgICAgIHZhciBjb2x1bW4gPSBsYXlvdXRNYXAuY29sdW1uV2lkdGhzW2NvbF07XG4gICAgICAgICAgICAgIHZhciB3aWR0aCA9IGNvbHVtbi53aWR0aCxcbiAgICAgICAgICAgICAgICAgIG1pbldpZHRoID0gY29sdW1uLm1pbldpZHRoLFxuICAgICAgICAgICAgICAgICAgbWF4V2lkdGggPSBjb2x1bW4ubWF4V2lkdGg7XG5cbiAgICAgICAgICAgICAgaWYgKHdpZHRoICYmICh0eXBlb2Ygd2lkdGggPT09IFwic3RyaW5nXCIgfHwgd2lkdGggPiAwKSkge1xuICAgICAgICAgICAgICAgIGdyaWQuc2V0Q29sV2lkdGgoY29sLCB3aWR0aCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ3JpZC5zZXRDb2xXaWR0aChjb2wsIG51bGwpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKG1pbldpZHRoICYmICh0eXBlb2YgbWluV2lkdGggPT09IFwic3RyaW5nXCIgfHwgbWluV2lkdGggPiAwKSkge1xuICAgICAgICAgICAgICAgIGdyaWQuc2V0TWluQ29sV2lkdGgoY29sLCBtaW5XaWR0aCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ3JpZC5zZXRNaW5Db2xXaWR0aChjb2wsIG51bGwpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKG1heFdpZHRoICYmICh0eXBlb2YgbWF4V2lkdGggPT09IFwic3RyaW5nXCIgfHwgbWF4V2lkdGggPiAwKSkge1xuICAgICAgICAgICAgICAgIGdyaWQuc2V0TWF4Q29sV2lkdGgoY29sLCBtYXhXaWR0aCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ3JpZC5zZXRNYXhDb2xXaWR0aChjb2wsIG51bGwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBoZWFkZXJSb3dIZWlnaHQgPSBncmlkW19dLmhlYWRlclJvd0hlaWdodDtcblxuICAgICAgICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgbGF5b3V0TWFwLmhlYWRlclJvd0NvdW50OyByb3crKykge1xuICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gQXJyYXkuaXNBcnJheShoZWFkZXJSb3dIZWlnaHQpID8gaGVhZGVyUm93SGVpZ2h0W3Jvd10gOiBoZWFkZXJSb3dIZWlnaHQ7XG5cbiAgICAgICAgICAgICAgaWYgKGhlaWdodCAmJiBoZWlnaHQgPiAwKSB7XG4gICAgICAgICAgICAgICAgZ3JpZC5zZXRSb3dIZWlnaHQocm93LCBoZWlnaHQpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGdyaWQuc2V0Um93SGVpZ2h0KHJvdywgbnVsbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ3JpZC5jb2xDb3VudCA9IGxheW91dE1hcC5jb2xDb3VudDtcblxuICAgICAgICAgICAgX3JlZnJlc2hSb3dDb3VudChncmlkKTtcblxuICAgICAgICAgICAgZ3JpZC5mcm96ZW5Sb3dDb3VudCA9IGxheW91dE1hcC5oZWFkZXJSb3dDb3VudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cblxuICAgICAgICAgIGZ1bmN0aW9uIF9yZWZyZXNoUm93Q291bnQoZ3JpZCkge1xuICAgICAgICAgICAgdmFyIGxheW91dE1hcCA9IGdyaWRbX10ubGF5b3V0TWFwO1xuICAgICAgICAgICAgZ3JpZC5yb3dDb3VudCA9IGdyaWRbX10uZGF0YVNvdXJjZS5sZW5ndGggKiBsYXlvdXRNYXAuYm9keVJvd0NvdW50ICsgbGF5b3V0TWFwLmhlYWRlclJvd0NvdW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKiogQHByaXZhdGUgKi9cblxuXG4gICAgICAgICAgZnVuY3Rpb24gX3RyeVdpdGhVcGRhdGVEYXRhU291cmNlKGdyaWQsIGZuKSB7XG4gICAgICAgICAgICB2YXIgZGF0YVNvdXJjZUV2ZW50SWRzID0gZ3JpZFtfXS5kYXRhU291cmNlRXZlbnRJZHM7XG5cbiAgICAgICAgICAgIGlmIChkYXRhU291cmNlRXZlbnRJZHMpIHtcbiAgICAgICAgICAgICAgZGF0YVNvdXJjZUV2ZW50SWRzLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdyaWRbX10uaGFuZGxlci5vZmYoaWQpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm4oZ3JpZCk7XG4gICAgICAgICAgICBncmlkW19dLmRhdGFTb3VyY2VFdmVudElkcyA9IFtncmlkW19dLmhhbmRsZXIub24oZ3JpZFtfXS5kYXRhU291cmNlLCBkYXRhXzEuRGF0YVNvdXJjZS5FVkVOVF9UWVBFLlVQREFURURfTEVOR1RILCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF9yZWZyZXNoUm93Q291bnQoZ3JpZCk7XG5cbiAgICAgICAgICAgICAgZ3JpZC5pbnZhbGlkYXRlKCk7XG4gICAgICAgICAgICB9KSwgZ3JpZFtfXS5oYW5kbGVyLm9uKGdyaWRbX10uZGF0YVNvdXJjZSwgZGF0YV8xLkRhdGFTb3VyY2UuRVZFTlRfVFlQRS5VUERBVEVEX09SREVSLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGdyaWQuaW52YWxpZGF0ZSgpO1xuICAgICAgICAgICAgfSldO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKiogQHByaXZhdGUgKi9cblxuXG4gICAgICAgICAgZnVuY3Rpb24gX3NldFJlY29yZHMoZ3JpZCkge1xuICAgICAgICAgICAgdmFyIHJlY29yZHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdO1xuXG4gICAgICAgICAgICBfdHJ5V2l0aFVwZGF0ZURhdGFTb3VyY2UoZ3JpZCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBncmlkW19dLnJlY29yZHMgPSByZWNvcmRzO1xuICAgICAgICAgICAgICB2YXIgbmV3RGF0YVNvdXJjZSA9IGdyaWRbX10uZGF0YVNvdXJjZSA9IGRhdGFfMS5DYWNoZWREYXRhU291cmNlLm9mQXJyYXkocmVjb3Jkcyk7XG4gICAgICAgICAgICAgIGdyaWQuYWRkRGlzcG9zYWJsZShuZXdEYXRhU291cmNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKiogQHByaXZhdGUgKi9cblxuXG4gICAgICAgICAgZnVuY3Rpb24gX3NldERhdGFTb3VyY2UoZ3JpZCwgZGF0YVNvdXJjZSkge1xuICAgICAgICAgICAgX3RyeVdpdGhVcGRhdGVEYXRhU291cmNlKGdyaWQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgaWYgKGRhdGFTb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YVNvdXJjZSBpbnN0YW5jZW9mIGRhdGFfMS5EYXRhU291cmNlKSB7XG4gICAgICAgICAgICAgICAgICBncmlkW19dLmRhdGFTb3VyY2UgPSBkYXRhU291cmNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB2YXIgbmV3RGF0YVNvdXJjZSA9IGdyaWRbX10uZGF0YVNvdXJjZSA9IG5ldyBkYXRhXzEuQ2FjaGVkRGF0YVNvdXJjZShkYXRhU291cmNlKTtcbiAgICAgICAgICAgICAgICAgIGdyaWQuYWRkRGlzcG9zYWJsZShuZXdEYXRhU291cmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ3JpZFtfXS5kYXRhU291cmNlID0gZGF0YV8xLkRhdGFTb3VyY2UuRU1QVFk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBncmlkW19dLnJlY29yZHMgPSBudWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgICAgICAgICBmdW5jdGlvbiBfZ2V0UmVjb3JkSW5kZXhCeVJvdyhncmlkLCByb3cpIHtcbiAgICAgICAgICAgIHZhciBsYXlvdXRNYXAgPSBncmlkW19dLmxheW91dE1hcDtcbiAgICAgICAgICAgIHJldHVybiBsYXlvdXRNYXAuZ2V0UmVjb3JkSW5kZXhCeVJvdyhyb3cpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKiogQHByaXZhdGUgKi9cblxuXG4gICAgICAgICAgZnVuY3Rpb24gX29uUmFuZ2VQYXN0ZSh0ZXh0KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXM5ID0gdGhpcztcblxuICAgICAgICAgICAgdmFyIHRlc3QgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgX2I7XG5cbiAgICAgICAgICAgIHZhciBsYXlvdXRNYXAgPSB0aGlzW19dLmxheW91dE1hcDtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb25SYW5nZSA9IHRoaXMuc2VsZWN0aW9uLnJhbmdlO1xuXG4gICAgICAgICAgICB2YXIgX3RoaXMkZ2V0Q2VsbFJhbmdlID0gdGhpcy5nZXRDZWxsUmFuZ2Uoc2VsZWN0aW9uUmFuZ2Uuc3RhcnQuY29sLCBzZWxlY3Rpb25SYW5nZS5zdGFydC5yb3cpLFxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gX3RoaXMkZ2V0Q2VsbFJhbmdlLnN0YXJ0O1xuXG4gICAgICAgICAgICB2YXIgX3RoaXMkZ2V0Q2VsbFJhbmdlMiA9IHRoaXMuZ2V0Q2VsbFJhbmdlKHNlbGVjdGlvblJhbmdlLmVuZC5jb2wsIHNlbGVjdGlvblJhbmdlLmVuZC5yb3cpLFxuICAgICAgICAgICAgICAgIGVuZCA9IF90aGlzJGdldENlbGxSYW5nZTIuZW5kO1xuXG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gKDAsIHBhc3RlX3V0aWxzXzEucGFyc2VQYXN0ZVJhbmdlQm94VmFsdWVzKSh0ZXh0LCB7XG4gICAgICAgICAgICAgIHRyaW1PblBhc3RlOiB0aGlzLnRyaW1PblBhc3RlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBwYXN0ZVJvd0NvdW50ID0gTWF0aC5taW4oTWF0aC5tYXgoZW5kLnJvdyAtIHN0YXJ0LnJvdyArIDEsIHZhbHVlcy5yb3dDb3VudCksIHRoaXMucm93Q291bnQgLSBzdGFydC5yb3cpO1xuICAgICAgICAgICAgdmFyIHBhc3RlQ29sQ291bnQgPSBNYXRoLm1pbihNYXRoLm1heChlbmQuY29sIC0gc3RhcnQuY29sICsgMSwgdmFsdWVzLmNvbENvdW50KSwgdGhpcy5jb2xDb3VudCAtIHN0YXJ0LmNvbCk7XG4gICAgICAgICAgICB2YXIgaGFzRWRpdGFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBhY3Rpb25Db2x1bW5zQm94ID0gW107XG5cbiAgICAgICAgICAgIGZvciAodmFyIGJvZHlSb3cgPSAwOyBib2R5Um93IDwgbGF5b3V0TWFwLmJvZHlSb3dDb3VudDsgYm9keVJvdysrKSB7XG4gICAgICAgICAgICAgIHZhciBhY3Rpb25Db2x1bW5zUm93ID0gW107XG4gICAgICAgICAgICAgIGFjdGlvbkNvbHVtbnNCb3gucHVzaChhY3Rpb25Db2x1bW5zUm93KTtcblxuICAgICAgICAgICAgICBmb3IgKHZhciBvZmZzZXRDb2wgPSAwOyBvZmZzZXRDb2wgPCBwYXN0ZUNvbENvdW50OyBvZmZzZXRDb2wrKykge1xuICAgICAgICAgICAgICAgIHZhciBib2R5ID0gbGF5b3V0TWFwLmdldEJvZHkoc3RhcnQuY29sICsgb2Zmc2V0Q29sLCBib2R5Um93ICsgbGF5b3V0TWFwLmhlYWRlclJvd0NvdW50KTtcbiAgICAgICAgICAgICAgICBhY3Rpb25Db2x1bW5zUm93W29mZnNldENvbF0gPSBib2R5O1xuXG4gICAgICAgICAgICAgICAgaWYgKCFoYXNFZGl0YWJsZSAmJiAoKF9iID0gYm9keS5hY3Rpb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5lZGl0YWJsZSkpIHtcbiAgICAgICAgICAgICAgICAgIGhhc0VkaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFoYXNFZGl0YWJsZSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzdGFydFJvdyA9IGxheW91dE1hcC5nZXRSZWNvcmRTdGFydFJvd0J5UmVjb3JkSW5kZXgobGF5b3V0TWFwLmdldFJlY29yZEluZGV4QnlSb3coc3RhcnQucm93KSk7XG4gICAgICAgICAgICB2YXIgc3RhcnRSb3dPZmZzZXQgPSBzdGFydC5yb3cgLSBzdGFydFJvdztcbiAgICAgICAgICAgIHZhciByZWplY3RlZERldGFpbCA9IFtdO1xuXG4gICAgICAgICAgICB2YXIgYWRkUmVqZWN0ZWREZXRhaWwgPSBmdW5jdGlvbiBhZGRSZWplY3RlZERldGFpbChjZWxsLCByZWNvcmQsIGRlZmluZSwgcGFzdGVWYWx1ZSkge1xuICAgICAgICAgICAgICByZWplY3RlZERldGFpbC5wdXNoKHtcbiAgICAgICAgICAgICAgICBjb2w6IGNlbGwuY29sLFxuICAgICAgICAgICAgICAgIHJvdzogY2VsbC5yb3csXG4gICAgICAgICAgICAgICAgcmVjb3JkOiByZWNvcmQsXG4gICAgICAgICAgICAgICAgZGVmaW5lOiBkZWZpbmUsXG4gICAgICAgICAgICAgICAgcGFzdGVWYWx1ZTogcGFzdGVWYWx1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciB0aW1lb3V0ID0gbnVsbDtcblxuICAgICAgICAgICAgdmFyIHByb2Nlc3NSZWplY3RlZCA9IGZ1bmN0aW9uIHByb2Nlc3NSZWplY3RlZCgpIHtcbiAgICAgICAgICAgICAgaWYgKHRpbWVvdXQpIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChyZWplY3RlZERldGFpbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICBfdGhpczkuZmlyZUxpc3RlbmVycyhMR19FVkVOVF9UWVBFXzEuTEdfRVZFTlRfVFlQRS5SRUpFQ1RFRF9QQVNURV9WQUxVRVMsIHtcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsOiByZWplY3RlZERldGFpbFxuICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgIHJlamVjdGVkRGV0YWlsID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LCAxMDApO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIF9yZWplY3QgPSBhZGRSZWplY3RlZERldGFpbDtcbiAgICAgICAgICAgIHZhciBkdXBsaWNhdGUgPSB7fTtcbiAgICAgICAgICAgIHZhciBhY3Rpb25Sb3cgPSBzdGFydFJvd09mZnNldDtcbiAgICAgICAgICAgIHZhciB2YWx1ZXNSb3cgPSAwO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBvZmZzZXRSb3cgPSAwOyBvZmZzZXRSb3cgPCBwYXN0ZVJvd0NvdW50OyBvZmZzZXRSb3crKykge1xuICAgICAgICAgICAgICB2YXIgdmFsdWVzQ29sID0gMDtcblxuICAgICAgICAgICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChfb2Zmc2V0Q29sKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hY3Rpb25Db2x1bW5zQm94JGFjdCA9IGFjdGlvbkNvbHVtbnNCb3hbYWN0aW9uUm93XVtfb2Zmc2V0Q29sXSxcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uID0gX2FjdGlvbkNvbHVtbnNCb3gkYWN0LmFjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgaWQgPSBfYWN0aW9uQ29sdW1uc0JveCRhY3QuaWQsXG4gICAgICAgICAgICAgICAgICAgIGRlZmluZSA9IF9hY3Rpb25Db2x1bW5zQm94JGFjdC5kZWZpbmU7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWR1cGxpY2F0ZVtpZF0gJiYgKGFjdGlvbiA9PT0gbnVsbCB8fCBhY3Rpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFjdGlvbi5lZGl0YWJsZSkpIHtcbiAgICAgICAgICAgICAgICAgIGR1cGxpY2F0ZVtpZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgdmFyIGNvbCA9IHN0YXJ0LmNvbCArIF9vZmZzZXRDb2w7XG4gICAgICAgICAgICAgICAgICB2YXIgcm93ID0gc3RhcnQucm93ICsgb2Zmc2V0Um93O1xuICAgICAgICAgICAgICAgICAgdmFyIGNlbGxWYWx1ZSA9IHZhbHVlcy5nZXRDZWxsVmFsdWUodmFsdWVzQ29sLCB2YWx1ZXNSb3cpO1xuICAgICAgICAgICAgICAgICAgKDAsIHV0aWxzXzEudGhlbikoX3RoaXM5LmdldFJvd1JlY29yZChyb3cpLCBmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgICAgICgwLCB1dGlsc18xLnRoZW4pKF9nZXRDZWxsVmFsdWUoX3RoaXM5LCBjb2wsIHJvdyksIGZ1bmN0aW9uIChvbGRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyaWQ6IF90aGlzOSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZDogcmVjb3JkLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sOiBjb2wsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3c6IHJvdyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjZWxsVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZTogb2xkVmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uLm9uUGFzdGVDZWxsUmFuZ2VCb3goX3RoaXM5LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbDogY29sLFxuICAgICAgICAgICAgICAgICAgICAgICAgICByb3c6IHJvd1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgY2VsbFZhbHVlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdDogZnVuY3Rpb24gcmVqZWN0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZWplY3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sOiBjb2wsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3c6IHJvd1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHJlY29yZCwgZGVmaW5lLCBjZWxsVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFsdWVzQ29sKys7XG5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWVzQ29sID49IHZhbHVlcy5jb2xDb3VudCkge1xuICAgICAgICAgICAgICAgICAgdmFsdWVzQ29sID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgX29mZnNldENvbCA9IDA7IF9vZmZzZXRDb2wgPCBwYXN0ZUNvbENvdW50OyBfb2Zmc2V0Q29sKyspIHtcbiAgICAgICAgICAgICAgICBfbG9vcChfb2Zmc2V0Q29sKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGFjdGlvblJvdysrO1xuXG4gICAgICAgICAgICAgIGlmIChhY3Rpb25Sb3cgPj0gbGF5b3V0TWFwLmJvZHlSb3dDb3VudCkge1xuICAgICAgICAgICAgICAgIGFjdGlvblJvdyA9IDA7XG4gICAgICAgICAgICAgICAgZHVwbGljYXRlID0ge307XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YWx1ZXNSb3crKztcblxuICAgICAgICAgICAgICBpZiAodmFsdWVzUm93ID49IHZhbHVlcy5yb3dDb3VudCkge1xuICAgICAgICAgICAgICAgIHZhbHVlc1JvdyA9IDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG5ld0VuZCA9IHtcbiAgICAgICAgICAgICAgY29sOiBzdGFydC5jb2wgKyBwYXN0ZUNvbENvdW50IC0gMSxcbiAgICAgICAgICAgICAgcm93OiBzdGFydC5yb3cgKyBwYXN0ZVJvd0NvdW50IC0gMVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLnJhbmdlID0ge1xuICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgIGVuZDogbmV3RW5kXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5pbnZhbGlkYXRlQ2VsbFJhbmdlKHRoaXMuc2VsZWN0aW9uLnJhbmdlKTtcbiAgICAgICAgICAgIHByb2Nlc3NSZWplY3RlZCgpO1xuXG4gICAgICAgICAgICBfcmVqZWN0ID0gZnVuY3Rpb24gX3JlamVjdChjZWxsLCByZWNvcmQsIGRlZmluZSwgcGFzdGVWYWx1ZSkge1xuICAgICAgICAgICAgICBhZGRSZWplY3RlZERldGFpbChjZWxsLCByZWNvcmQsIGRlZmluZSwgcGFzdGVWYWx1ZSk7XG4gICAgICAgICAgICAgIHByb2Nlc3NSZWplY3RlZCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cblxuICAgICAgICAgIGZ1bmN0aW9uIF9vblJhbmdlRGVsZXRlKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzMTAgPSB0aGlzO1xuXG4gICAgICAgICAgICB2YXIgX2I7XG5cbiAgICAgICAgICAgIHZhciBsYXlvdXRNYXAgPSB0aGlzW19dLmxheW91dE1hcDtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb25SYW5nZSA9IHRoaXMuc2VsZWN0aW9uLnJhbmdlO1xuXG4gICAgICAgICAgICB2YXIgX3RoaXMkZ2V0Q2VsbFJhbmdlMyA9IHRoaXMuZ2V0Q2VsbFJhbmdlKHNlbGVjdGlvblJhbmdlLnN0YXJ0LmNvbCwgc2VsZWN0aW9uUmFuZ2Uuc3RhcnQucm93KSxcbiAgICAgICAgICAgICAgICBzdGFydCA9IF90aGlzJGdldENlbGxSYW5nZTMuc3RhcnQ7XG5cbiAgICAgICAgICAgIHZhciBfdGhpcyRnZXRDZWxsUmFuZ2U0ID0gdGhpcy5nZXRDZWxsUmFuZ2Uoc2VsZWN0aW9uUmFuZ2UuZW5kLmNvbCwgc2VsZWN0aW9uUmFuZ2UuZW5kLnJvdyksXG4gICAgICAgICAgICAgICAgZW5kID0gX3RoaXMkZ2V0Q2VsbFJhbmdlNC5lbmQ7XG5cbiAgICAgICAgICAgIHZhciBkZWxldGVSb3dDb3VudCA9IE1hdGgubWluKGVuZC5yb3cgLSBzdGFydC5yb3cgKyAxLCB0aGlzLnJvd0NvdW50IC0gc3RhcnQucm93KTtcbiAgICAgICAgICAgIHZhciBkZWxldGVDb2xDb3VudCA9IE1hdGgubWluKGVuZC5jb2wgLSBzdGFydC5jb2wgKyAxLCB0aGlzLmNvbENvdW50IC0gc3RhcnQuY29sKTtcbiAgICAgICAgICAgIHZhciBoYXNFZGl0YWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGFjdGlvbkNvbHVtbnNCb3ggPSBbXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgYm9keVJvdyA9IDA7IGJvZHlSb3cgPCBsYXlvdXRNYXAuYm9keVJvd0NvdW50OyBib2R5Um93KyspIHtcbiAgICAgICAgICAgICAgdmFyIGFjdGlvbkNvbHVtbnNSb3cgPSBbXTtcbiAgICAgICAgICAgICAgYWN0aW9uQ29sdW1uc0JveC5wdXNoKGFjdGlvbkNvbHVtbnNSb3cpO1xuXG4gICAgICAgICAgICAgIGZvciAodmFyIG9mZnNldENvbCA9IDA7IG9mZnNldENvbCA8IGRlbGV0ZUNvbENvdW50OyBvZmZzZXRDb2wrKykge1xuICAgICAgICAgICAgICAgIHZhciBib2R5ID0gbGF5b3V0TWFwLmdldEJvZHkoc3RhcnQuY29sICsgb2Zmc2V0Q29sLCBib2R5Um93ICsgbGF5b3V0TWFwLmhlYWRlclJvd0NvdW50KTtcbiAgICAgICAgICAgICAgICBhY3Rpb25Db2x1bW5zUm93W29mZnNldENvbF0gPSBib2R5O1xuXG4gICAgICAgICAgICAgICAgaWYgKCFoYXNFZGl0YWJsZSAmJiAoKF9iID0gYm9keS5hY3Rpb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5lZGl0YWJsZSkpIHtcbiAgICAgICAgICAgICAgICAgIGhhc0VkaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFoYXNFZGl0YWJsZSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzdGFydFJvdyA9IGxheW91dE1hcC5nZXRSZWNvcmRTdGFydFJvd0J5UmVjb3JkSW5kZXgobGF5b3V0TWFwLmdldFJlY29yZEluZGV4QnlSb3coc3RhcnQucm93KSk7XG4gICAgICAgICAgICB2YXIgc3RhcnRSb3dPZmZzZXQgPSBzdGFydC5yb3cgLSBzdGFydFJvdztcbiAgICAgICAgICAgIHZhciBkdXBsaWNhdGUgPSB7fTtcbiAgICAgICAgICAgIHZhciBhY3Rpb25Sb3cgPSBzdGFydFJvd09mZnNldDtcblxuICAgICAgICAgICAgZm9yICh2YXIgb2Zmc2V0Um93ID0gMDsgb2Zmc2V0Um93IDwgZGVsZXRlUm93Q291bnQ7IG9mZnNldFJvdysrKSB7XG4gICAgICAgICAgICAgIHZhciBfbG9vcDIgPSBmdW5jdGlvbiBfbG9vcDIoX29mZnNldENvbDIpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2FjdGlvbkNvbHVtbnNCb3gkYWN0MiA9IGFjdGlvbkNvbHVtbnNCb3hbYWN0aW9uUm93XVtfb2Zmc2V0Q29sMl0sXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbiA9IF9hY3Rpb25Db2x1bW5zQm94JGFjdDIuYWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICBpZCA9IF9hY3Rpb25Db2x1bW5zQm94JGFjdDIuaWQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWR1cGxpY2F0ZVtpZF0gJiYgKGFjdGlvbiA9PT0gbnVsbCB8fCBhY3Rpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFjdGlvbi5lZGl0YWJsZSkpIHtcbiAgICAgICAgICAgICAgICAgIGR1cGxpY2F0ZVtpZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgdmFyIGNvbCA9IHN0YXJ0LmNvbCArIF9vZmZzZXRDb2wyO1xuICAgICAgICAgICAgICAgICAgdmFyIHJvdyA9IHN0YXJ0LnJvdyArIG9mZnNldFJvdztcbiAgICAgICAgICAgICAgICAgICgwLCB1dGlsc18xLnRoZW4pKF90aGlzMTAuZ2V0Um93UmVjb3JkKHJvdyksIGZ1bmN0aW9uIChfcmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgICAgICgwLCB1dGlsc18xLnRoZW4pKF9nZXRDZWxsVmFsdWUoX3RoaXMxMCwgY29sLCByb3cpLCBmdW5jdGlvbiAoX29sZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgYWN0aW9uLm9uRGVsZXRlQ2VsbFJhbmdlQm94KF90aGlzMTAsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbDogY29sLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm93OiByb3dcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgX29mZnNldENvbDIgPSAwOyBfb2Zmc2V0Q29sMiA8IGRlbGV0ZUNvbENvdW50OyBfb2Zmc2V0Q29sMisrKSB7XG4gICAgICAgICAgICAgICAgX2xvb3AyKF9vZmZzZXRDb2wyKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGFjdGlvblJvdysrO1xuXG4gICAgICAgICAgICAgIGlmIChhY3Rpb25Sb3cgPj0gbGF5b3V0TWFwLmJvZHlSb3dDb3VudCkge1xuICAgICAgICAgICAgICAgIGFjdGlvblJvdyA9IDA7XG4gICAgICAgICAgICAgICAgZHVwbGljYXRlID0ge307XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5pbnZhbGlkYXRlQ2VsbFJhbmdlKHNlbGVjdGlvblJhbmdlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogTGlzdEdyaWRcbiAgICAgICAgICAgKiBAY2xhc3NkZXNjIGNoZWV0YWhHcmlkLkxpc3RHcmlkXG4gICAgICAgICAgICogQG1lbWJlcm9mIGNoZWV0YWhHcmlkXG4gICAgICAgICAgICovXG5cblxuICAgICAgICAgIHZhciBMaXN0R3JpZCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0RyYXdHcmlkXzEkRHJhd0dyaWQpIHtcbiAgICAgICAgICAgIF9pbmhlcml0cyhMaXN0R3JpZCwgX0RyYXdHcmlkXzEkRHJhd0dyaWQpO1xuXG4gICAgICAgICAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKExpc3RHcmlkKTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICogQHBhcmFtIG9wdGlvbnMgQ29uc3RydWN0b3Igb3B0aW9uc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBMaXN0R3JpZCgpIHtcbiAgICAgICAgICAgICAgdmFyIF90aGlzMTE7XG5cbiAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMaXN0R3JpZCk7XG5cbiAgICAgICAgICAgICAgdmFyIF9iO1xuXG4gICAgICAgICAgICAgIF90aGlzMTEgPSBfc3VwZXIuY2FsbCh0aGlzLCAoMCwgdXRpbHNfMS5vbWl0KShvcHRpb25zLCBbXCJjb2xDb3VudFwiLCBcInJvd0NvdW50XCIsIFwiZnJvemVuUm93Q291bnRcIl0pKTtcbiAgICAgICAgICAgICAgX3RoaXMxMVtfYV0gPSBfdGhpczExW19dO1xuICAgICAgICAgICAgICBfdGhpczExLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIF90aGlzMTEucmVhZE9ubHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgdmFyIHByb3RlY3RlZFNwYWNlID0gX3RoaXMxMVtfXTtcbiAgICAgICAgICAgICAgcHJvdGVjdGVkU3BhY2UuaGVhZGVyID0gb3B0aW9ucy5oZWFkZXIgfHwgW107XG4gICAgICAgICAgICAgIHByb3RlY3RlZFNwYWNlLmxheW91dCA9IG9wdGlvbnMubGF5b3V0IHx8IFtdO1xuICAgICAgICAgICAgICBwcm90ZWN0ZWRTcGFjZS5oZWFkZXJSb3dIZWlnaHQgPSBvcHRpb25zLmhlYWRlclJvd0hlaWdodCB8fCBbXTtcblxuICAgICAgICAgICAgICBpZiAob3B0aW9ucy5kYXRhU291cmNlKSB7XG4gICAgICAgICAgICAgICAgX3NldERhdGFTb3VyY2UoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczExKSwgb3B0aW9ucy5kYXRhU291cmNlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfc2V0UmVjb3JkcyhfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzMTEpLCBvcHRpb25zLnJlY29yZHMpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcHJvdGVjdGVkU3BhY2UuYWxsb3dSYW5nZVBhc3RlID0gKF9iID0gb3B0aW9ucy5hbGxvd1JhbmdlUGFzdGUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZhbHNlO1xuXG4gICAgICAgICAgICAgIF9yZWZyZXNoSGVhZGVyKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMxMSkpO1xuXG4gICAgICAgICAgICAgIHByb3RlY3RlZFNwYWNlLnNvcnRTdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICBjb2w6IC0xLFxuICAgICAgICAgICAgICAgIHJvdzogLTEsXG4gICAgICAgICAgICAgICAgb3JkZXI6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBwcm90ZWN0ZWRTcGFjZS5ncmlkQ2FudmFzSGVscGVyID0gbmV3IEdyaWRDYW52YXNIZWxwZXJfMS5HcmlkQ2FudmFzSGVscGVyKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMxMSkpO1xuICAgICAgICAgICAgICBwcm90ZWN0ZWRTcGFjZS50aGVtZSA9IHRoZW1lcy5vZihvcHRpb25zLnRoZW1lKTtcbiAgICAgICAgICAgICAgcHJvdGVjdGVkU3BhY2UubWVzc2FnZUhhbmRsZXIgPSBuZXcgTWVzc2FnZUhhbmRsZXJfMS5NZXNzYWdlSGFuZGxlcihfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzMTEpLCBmdW5jdGlvbiAoY29sLCByb3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2dldENlbGxNZXNzYWdlKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMxMSksIGNvbCwgcm93KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHByb3RlY3RlZFNwYWNlLnRvb2x0aXBIYW5kbGVyID0gbmV3IFRvb2x0aXBIYW5kbGVyXzEuVG9vbHRpcEhhbmRsZXIoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczExKSk7XG5cbiAgICAgICAgICAgICAgX3RoaXMxMS5pbnZhbGlkYXRlKCk7XG5cbiAgICAgICAgICAgICAgcHJvdGVjdGVkU3BhY2UuaGFuZGxlci5vbih3aW5kb3csIFwicmVzaXplXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpczExLnVwZGF0ZVNpemUoKTtcblxuICAgICAgICAgICAgICAgIF90aGlzMTEudXBkYXRlU2Nyb2xsKCk7XG5cbiAgICAgICAgICAgICAgICBfdGhpczExLmludmFsaWRhdGUoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczExO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEaXNwb3NlIHRoZSBncmlkIGluc3RhbmNlLlxuICAgICAgICAgICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICAgICAgICAgKi9cblxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoTGlzdEdyaWQsIFt7XG4gICAgICAgICAgICAgIGtleTogXCJkaXNwb3NlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgICAgICAgICAgIHZhciBwcm90ZWN0ZWRTcGFjZSA9IHRoaXNbX107XG4gICAgICAgICAgICAgICAgcHJvdGVjdGVkU3BhY2UubWVzc2FnZUhhbmRsZXIuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIHByb3RlY3RlZFNwYWNlLnRvb2x0aXBIYW5kbGVyLmRpc3Bvc2UoKTtcblxuICAgICAgICAgICAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKExpc3RHcmlkLnByb3RvdHlwZSksIFwiZGlzcG9zZVwiLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBHZXRzIHRoZSBkZWZpbmUgb2YgdGhlIGhlYWRlci5cbiAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImhlYWRlclwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tfXS5oZWFkZXI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIFNldHMgdGhlIGRlZmluZSBvZiB0aGUgaGVhZGVyIHdpdGggdGhlIGdpdmVuIGRhdGEuXG4gICAgICAgICAgICAgICAqIDxwcmU+XG4gICAgICAgICAgICAgICAqIGNvbHVtbiBvcHRpb25zXG4gICAgICAgICAgICAgICAqIC0tLS0tXG4gICAgICAgICAgICAgICAqIGNhcHRpb246IGhlYWRlciBjYXB0aW9uXG4gICAgICAgICAgICAgICAqIGZpZWxkOiBmaWVsZCBuYW1lXG4gICAgICAgICAgICAgICAqIHdpZHRoOiBjb2x1bW4gd2lkdGhcbiAgICAgICAgICAgICAgICogbWluV2lkdGg6IGNvbHVtbiBtaW4gd2lkdGhcbiAgICAgICAgICAgICAgICogbWF4V2lkdGg6IGNvbHVtbiBtYXggd2lkdGhcbiAgICAgICAgICAgICAgICogaWNvbjogaWNvbiBkZWZpbml0aW9uXG4gICAgICAgICAgICAgICAqIG1lc3NhZ2U6IG1lc3NhZ2Uga2V5IG5hbWVcbiAgICAgICAgICAgICAgICogY29sdW1uVHlwZTogY29sdW1uIHR5cGVcbiAgICAgICAgICAgICAgICogYWN0aW9uOiBjb2x1bW4gYWN0aW9uXG4gICAgICAgICAgICAgICAqIHN0eWxlOiBjb2x1bW4gc3R5bGVcbiAgICAgICAgICAgICAgICogaGVhZGVyVHlwZTogaGVhZGVyIHR5cGVcbiAgICAgICAgICAgICAgICogaGVhZGVyU3R5bGU6IGhlYWRlciBzdHlsZVxuICAgICAgICAgICAgICAgKiBoZWFkZXJBY3Rpb246IGhlYWRlciBhY3Rpb25cbiAgICAgICAgICAgICAgICogaGVhZGVyRmllbGQ6IGhlYWRlciBmaWVsZCBuYW1lXG4gICAgICAgICAgICAgICAqIGhlYWRlckljb246IGhlYWRlciBpY29uIGRlZmluaXRpb25cbiAgICAgICAgICAgICAgICogc29ydDogZGVmaW5lIHNvcnQgc2V0dGluZ1xuICAgICAgICAgICAgICAgKiAtLS0tLVxuICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgKiBtdWx0aWxpbmUgaGVhZGVyXG4gICAgICAgICAgICAgICAqIC0tLS0tXG4gICAgICAgICAgICAgICAqIGNhcHRpb246IGhlYWRlciBjYXB0aW9uXG4gICAgICAgICAgICAgICAqIGNvbHVtbnM6IGNvbHVtbnMgZGVmaW5lXG4gICAgICAgICAgICAgICAqIC0tLS0tXG4gICAgICAgICAgICAgICAqIDwvcHJlPlxuICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgLFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChoZWFkZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzW19dLmhlYWRlciA9IGhlYWRlcjtcblxuICAgICAgICAgICAgICAgIF9yZWZyZXNoSGVhZGVyKHRoaXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBHZXRzIHRoZSBkZWZpbmUgb2YgdGhlIGxheW91dC5cbiAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImxheW91dFwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tfXS5sYXlvdXQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIFNldHMgdGhlIGRlZmluZSBvZiB0aGUgbGF5b3V0IHdpdGggdGhlIGdpdmVuIGRhdGEuXG4gICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAsXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGxheW91dCkge1xuICAgICAgICAgICAgICAgIHRoaXNbX10ubGF5b3V0ID0gbGF5b3V0O1xuXG4gICAgICAgICAgICAgICAgX3JlZnJlc2hIZWFkZXIodGhpcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIEdldHMgdGhlIGRlZmluZSBvZiB0aGUgaGVhZGVyUm93SGVpZ2h0LlxuICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiaGVhZGVyUm93SGVpZ2h0XCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW19dLmhlYWRlclJvd0hlaWdodDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogU2V0cyB0aGUgZGVmaW5lIG9mIHRoZSBoZWFkZXJSb3dIZWlnaHQgd2l0aCB0aGUgZ2l2ZW4gZGF0YS5cbiAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoaGVhZGVyUm93SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdGhpc1tfXS5oZWFkZXJSb3dIZWlnaHQgPSBoZWFkZXJSb3dIZWlnaHQgfHwgW107XG5cbiAgICAgICAgICAgICAgICBfcmVmcmVzaEhlYWRlcih0aGlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogR2V0IHRoZSByb3cgY291bnQgcGVyIHJlY29yZFxuICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwicmVjb3JkUm93Q291bnRcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbX10ubGF5b3V0TWFwLmJvZHlSb3dDb3VudDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogR2V0IHRoZSByZWNvcmRzLlxuICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwicmVjb3Jkc1wiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tfXS5yZWNvcmRzIHx8IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIFNldCB0aGUgcmVjb3JkcyBmcm9tIGdpdmVuXG4gICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAsXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHJlY29yZHMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVjb3JkcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX3NldFJlY29yZHModGhpcywgcmVjb3Jkcyk7XG5cbiAgICAgICAgICAgICAgICBfcmVmcmVzaFJvd0NvdW50KHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIEdldCB0aGUgZGF0YSBzb3VyY2UuXG4gICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJkYXRhU291cmNlXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW19dLmRhdGFTb3VyY2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIFNldCB0aGUgZGF0YSBzb3VyY2UgZnJvbSBnaXZlblxuICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgLFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChkYXRhU291cmNlKSB7XG4gICAgICAgICAgICAgICAgX3NldERhdGFTb3VyY2UodGhpcywgZGF0YVNvdXJjZSk7XG5cbiAgICAgICAgICAgICAgICBfcmVmcmVzaFJvd0NvdW50KHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIEdldCB0aGUgdGhlbWUuXG4gICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJ0aGVtZVwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tfXS50aGVtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogU2V0IHRoZSB0aGVtZSBmcm9tIGdpdmVuXG4gICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAsXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHRoZW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tfXS50aGVtZSA9IHRoZW1lcy5vZih0aGVtZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIElmIHNldCB0byB0cnVlIHRvIGFsbG93IHBhc3Rpbmcgb2YgcmFuZ2VzLlxuICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiYWxsb3dSYW5nZVBhc3RlXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW19dLmFsbG93UmFuZ2VQYXN0ZTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoYWxsb3dSYW5nZVBhc3RlKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tfXS5hbGxvd1JhbmdlUGFzdGUgPSBhbGxvd1JhbmdlUGFzdGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIEdldCB0aGUgZm9udCBkZWZpbml0aW9uIGFzIGEgc3RyaW5nLlxuICAgICAgICAgICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImZvbnRcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9nZXQoX2dldFByb3RvdHlwZU9mKExpc3RHcmlkLnByb3RvdHlwZSksIFwiZm9udFwiLCB0aGlzKSB8fCB0aGlzW19dLmdyaWRDYW52YXNIZWxwZXIudGhlbWUuZm9udDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogU2V0IHRoZSBmb250IGRlZmluaXRpb24gd2l0aCB0aGUgZ2l2ZW4gc3RyaW5nLlxuICAgICAgICAgICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoZm9udCkge1xuICAgICAgICAgICAgICAgIF9zZXQoX2dldFByb3RvdHlwZU9mKExpc3RHcmlkLnByb3RvdHlwZSksIFwiZm9udFwiLCBmb250LCB0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogR2V0IHRoZSBiYWNrZ3JvdW5kIGNvbG9yIG9mIHRoZSB1bmRlcmxheS5cbiAgICAgICAgICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJ1bmRlcmxheUJhY2tncm91bmRDb2xvclwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2dldChfZ2V0UHJvdG90eXBlT2YoTGlzdEdyaWQucHJvdG90eXBlKSwgXCJ1bmRlcmxheUJhY2tncm91bmRDb2xvclwiLCB0aGlzKSB8fCB0aGlzW19dLmdyaWRDYW52YXNIZWxwZXIudGhlbWUudW5kZXJsYXlCYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIFNldCB0aGUgYmFja2dyb3VuZCBjb2xvciBvZiB0aGUgdW5kZXJsYXkuXG4gICAgICAgICAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgLFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh1bmRlcmxheUJhY2tncm91bmRDb2xvcikge1xuICAgICAgICAgICAgICAgIF9zZXQoX2dldFByb3RvdHlwZU9mKExpc3RHcmlkLnByb3RvdHlwZSksIFwidW5kZXJsYXlCYWNrZ3JvdW5kQ29sb3JcIiwgdW5kZXJsYXlCYWNrZ3JvdW5kQ29sb3IsIHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBHZXQgdGhlIHNvcnQgc3RhdGUuXG4gICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJzb3J0U3RhdGVcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbX10uc29ydFN0YXRlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBTZXRzIHRoZSBzb3J0IHN0YXRlLlxuICAgICAgICAgICAgICAgKiBJZiBgbnVsbGAgdG8gc2V0LCB0aGUgc29ydCBzdGF0ZSBpcyBpbml0aWFsaXplZC5cbiAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoc29ydFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9sZFN0YXRlID0gdGhpcy5zb3J0U3RhdGU7XG4gICAgICAgICAgICAgICAgdmFyIG9sZEZpZWxkO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9sZFN0YXRlLmNvbCA+PSAwICYmIG9sZFN0YXRlLnJvdyA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICBvbGRGaWVsZCA9IHRoaXMuZ2V0SGVhZGVyRmllbGQob2xkU3RhdGUuY29sLCBvbGRTdGF0ZS5yb3cpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBuZXdTdGF0ZSA9IHRoaXNbX10uc29ydFN0YXRlID0gc29ydFN0YXRlICE9IG51bGwgPyBzb3J0U3RhdGUgOiB7XG4gICAgICAgICAgICAgICAgICBjb2w6IC0xLFxuICAgICAgICAgICAgICAgICAgcm93OiAtMSxcbiAgICAgICAgICAgICAgICAgIG9yZGVyOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciBuZXdGaWVsZDtcblxuICAgICAgICAgICAgICAgIGlmIChuZXdTdGF0ZS5jb2wgPj0gMCAmJiBuZXdTdGF0ZS5yb3cgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgbmV3RmllbGQgPSB0aGlzLmdldEhlYWRlckZpZWxkKG5ld1N0YXRlLmNvbCwgbmV3U3RhdGUucm93KTtcbiAgICAgICAgICAgICAgICB9IC8vIGJpbmQgaGVhZGVyIHZhbHVlXG5cblxuICAgICAgICAgICAgICAgIGlmIChvbGRGaWVsZCAhPSBudWxsICYmIG9sZEZpZWxkICE9PSBuZXdGaWVsZCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5zZXRIZWFkZXJWYWx1ZShvbGRTdGF0ZS5jb2wsIG9sZFN0YXRlLnJvdywgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobmV3RmllbGQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5zZXRIZWFkZXJWYWx1ZShuZXdTdGF0ZS5jb2wsIG5ld1N0YXRlLnJvdywgbmV3U3RhdGUub3JkZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogR2V0IHRoZSBoZWFkZXIgdmFsdWVzLlxuICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiaGVhZGVyVmFsdWVzXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW19dLmhlYWRlclZhbHVlcyB8fCAodGhpc1tfXS5oZWFkZXJWYWx1ZXMgPSBuZXcgTWFwKCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBTZXRzIHRoZSBoZWFkZXIgdmFsdWVzLlxuICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgLFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChoZWFkZXJWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzW19dLmhlYWRlclZhbHVlcyA9IGhlYWRlclZhbHVlcyB8fCBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIEdldCB0aGUgZmllbGQgb2YgdGhlIGdpdmVuIGNvbHVtbiBpbmRleC5cbiAgICAgICAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBjb2wgVGhlIGNvbHVtbiBpbmRleC5cbiAgICAgICAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSByb3cgVGhlIHJvdyBpbmRleC5cbiAgICAgICAgICAgICAgICogQHJldHVybiB7Kn0gVGhlIGZpZWxkIG9iamVjdC5cbiAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImdldEZpZWxkXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGaWVsZChjb2wsIHJvdykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW19dLmxheW91dE1hcC5nZXRCb2R5KGNvbCwgcm93ICE9PSBudWxsICYmIHJvdyAhPT0gdm9pZCAwID8gcm93IDogdGhpc1tfXS5sYXlvdXRNYXAuaGVhZGVyUm93Q291bnQpLmZpZWxkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBHZXQgdGhlIGNvbHVtbiBkZWZpbmUgb2YgdGhlIGdpdmVuIGNvbHVtbiBpbmRleC5cbiAgICAgICAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBjb2wgVGhlIGNvbHVtbiBpbmRleC5cbiAgICAgICAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSByb3cgVGhlIHJvdyBpbmRleC5cbiAgICAgICAgICAgICAgICogQHJldHVybiB7Kn0gVGhlIGNvbHVtbiBkZWZpbmUgb2JqZWN0LlxuICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0Q29sdW1uRGVmaW5lXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb2x1bW5EZWZpbmUoY29sLCByb3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tfXS5sYXlvdXRNYXAuZ2V0Qm9keShjb2wsIHJvdyAhPT0gbnVsbCAmJiByb3cgIT09IHZvaWQgMCA/IHJvdyA6IHRoaXNbX10ubGF5b3V0TWFwLmhlYWRlclJvd0NvdW50KS5kZWZpbmU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImdldENvbHVtblR5cGVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldENvbHVtblR5cGUoY29sLCByb3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tfXS5sYXlvdXRNYXAuZ2V0Qm9keShjb2wsIHJvdykuY29sdW1uVHlwZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0Q29sdW1uQWN0aW9uXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb2x1bW5BY3Rpb24oY29sLCByb3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tfXS5sYXlvdXRNYXAuZ2V0Qm9keShjb2wsIHJvdykuYWN0aW9uO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBHZXQgdGhlIGhlYWRlciBmaWVsZCBvZiB0aGUgZ2l2ZW4gaGVhZGVyIGNlbGwuXG4gICAgICAgICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gY29sIFRoZSBjb2x1bW4gaW5kZXguXG4gICAgICAgICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gcm93IFRoZSBoZWFkZXIgcm93IGluZGV4LlxuICAgICAgICAgICAgICAgKiBAcmV0dXJuIHsqfSBUaGUgZmllbGQgb2JqZWN0LlxuICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0SGVhZGVyRmllbGRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEhlYWRlckZpZWxkKGNvbCwgcm93KSB7XG4gICAgICAgICAgICAgICAgdmFyIGhkID0gdGhpc1tfXS5sYXlvdXRNYXAuZ2V0SGVhZGVyKGNvbCwgcm93KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBoZC5maWVsZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogR2V0IHRoZSBoZWFkZXIgZGVmaW5lIG9mIHRoZSBnaXZlbiBoZWFkZXIgY2VsbC5cbiAgICAgICAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBjb2wgVGhlIGNvbHVtbiBpbmRleC5cbiAgICAgICAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSByb3cgVGhlIGhlYWRlciByb3cgaW5kZXguXG4gICAgICAgICAgICAgICAqIEByZXR1cm4geyp9IFRoZSBoZWFkZXIgZGVmaW5lIG9iamVjdC5cbiAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImdldEhlYWRlckRlZmluZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SGVhZGVyRGVmaW5lKGNvbCwgcm93KSB7XG4gICAgICAgICAgICAgICAgdmFyIGhkID0gdGhpc1tfXS5sYXlvdXRNYXAuZ2V0SGVhZGVyKGNvbCwgcm93KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBoZC5kZWZpbmU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIEdldCB0aGUgcmVjb3JkIG9mIHRoZSBnaXZlbiByb3cgaW5kZXguXG4gICAgICAgICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gcm93IFRoZSByb3cgaW5kZXguXG4gICAgICAgICAgICAgICAqIEByZXR1cm4ge29iamVjdH0gVGhlIHJlY29yZC5cbiAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImdldFJvd1JlY29yZFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Um93UmVjb3JkKHJvdykge1xuICAgICAgICAgICAgICAgIGlmIChyb3cgPCB0aGlzW19dLmxheW91dE1hcC5oZWFkZXJSb3dDb3VudCkge1xuICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW19dLmRhdGFTb3VyY2UuZ2V0KF9nZXRSZWNvcmRJbmRleEJ5Um93KHRoaXMsIHJvdykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogR2V0IHRoZSByZWNvcmQgaW5kZXggb2YgdGhlIGdpdmVuIHJvdyBpbmRleC5cbiAgICAgICAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSByb3cgVGhlIHJvdyBpbmRleC5cbiAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImdldFJlY29yZEluZGV4QnlSb3dcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJlY29yZEluZGV4QnlSb3cocm93KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9nZXRSZWNvcmRJbmRleEJ5Um93KHRoaXMsIHJvdyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIEdldHMgdGhlIHJvdyBpbmRleCBzdGFydGluZyBhdCB0aGUgZ2l2ZW4gcmVjb3JkIGluZGV4LlxuICAgICAgICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGluZGV4IFRoZSByZWNvcmQgaW5kZXguXG4gICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJnZXRSZWNvcmRTdGFydFJvd0J5UmVjb3JkSW5kZXhcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJlY29yZFN0YXJ0Um93QnlSZWNvcmRJbmRleChpbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW19dLmxheW91dE1hcC5nZXRSZWNvcmRTdGFydFJvd0J5UmVjb3JkSW5kZXgoaW5kZXgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBHZXQgdGhlIGNvbHVtbiBpbmRleCBvZiB0aGUgZ2l2ZW4gZmllbGQuXG4gICAgICAgICAgICAgICAqIEBwYXJhbSAgeyp9IGZpZWxkIFRoZSBmaWVsZC5cbiAgICAgICAgICAgICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgY29sdW1uIGluZGV4LlxuICAgICAgICAgICAgICAgKiBAZGVwcmVjYXRlZCB1c2UgYGdldENlbGxSYW5nZUJ5RmllbGRgIGluc3RlYWRcbiAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImdldENvbHVtbkluZGV4QnlGaWVsZFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29sdW1uSW5kZXhCeUZpZWxkKGZpZWxkKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9iO1xuXG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5nZXRDZWxsUmFuZ2VCeUZpZWxkKGZpZWxkLCAwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKF9iID0gcmFuZ2UgPT09IG51bGwgfHwgcmFuZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJhbmdlLnN0YXJ0LmNvbCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogR2V0IHRoZSBjb2x1bW4gaW5kZXggb2YgdGhlIGdpdmVuIGZpZWxkLlxuICAgICAgICAgICAgICAgKiBAcGFyYW0gIHsqfSBmaWVsZCBUaGUgZmllbGQuXG4gICAgICAgICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gaW5kZXggVGhlIHJlY29yZCBpbmRleFxuICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBjb2x1bW4gaW5kZXguXG4gICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJnZXRDZWxsUmFuZ2VCeUZpZWxkXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDZWxsUmFuZ2VCeUZpZWxkKGZpZWxkLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBsYXlvdXRNYXAgPSB0aGlzW19dLmxheW91dE1hcDtcbiAgICAgICAgICAgICAgICB2YXIgY29sT2JqID0gbGF5b3V0TWFwLmNvbHVtbk9iamVjdHMuZmluZChmdW5jdGlvbiAoY29sKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY29sLmZpZWxkID09PSBmaWVsZDtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmIChjb2xPYmopIHtcbiAgICAgICAgICAgICAgICAgIHZhciBsYXlvdXRSYW5nZSA9IGxheW91dE1hcC5nZXRCb2R5TGF5b3V0UmFuZ2VCeUlkKGNvbE9iai5pZCk7XG4gICAgICAgICAgICAgICAgICB2YXIgc3RhcnRSb3cgPSBsYXlvdXRNYXAuZ2V0UmVjb3JkU3RhcnRSb3dCeVJlY29yZEluZGV4KGluZGV4KTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgY29sOiBsYXlvdXRSYW5nZS5zdGFydC5jb2wsXG4gICAgICAgICAgICAgICAgICAgICAgcm93OiBzdGFydFJvdyArIGxheW91dFJhbmdlLnN0YXJ0LnJvd1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICBjb2w6IGxheW91dFJhbmdlLmVuZC5jb2wsXG4gICAgICAgICAgICAgICAgICAgICAgcm93OiBzdGFydFJvdyArIGxheW91dFJhbmdlLmVuZC5yb3dcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogRm9jdXMgdGhlIGNlbGwuXG4gICAgICAgICAgICAgICAqIEBwYXJhbSAgeyp9IGZpZWxkIFRoZSBmaWVsZC5cbiAgICAgICAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBpbmRleCBUaGUgcmVjb3JkIGluZGV4XG4gICAgICAgICAgICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJmb2N1c0dyaWRDZWxsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmb2N1c0dyaWRDZWxsKGZpZWxkLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBfYjtcblxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyRzZWxlY3Rpb24kcmFuZ2UgPSB0aGlzLnNlbGVjdGlvbi5yYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMkc2VsZWN0aW9uJHJhbmdlMiA9IF90aGlzJHNlbGVjdGlvbiRyYW5nZS5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRDb2wgPSBfdGhpcyRzZWxlY3Rpb24kcmFuZ2UyLmNvbCxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRSb3cgPSBfdGhpcyRzZWxlY3Rpb24kcmFuZ2UyLnJvdyxcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMkc2VsZWN0aW9uJHJhbmdlMyA9IF90aGlzJHNlbGVjdGlvbiRyYW5nZS5lbmQsXG4gICAgICAgICAgICAgICAgICAgIGVuZENvbCA9IF90aGlzJHNlbGVjdGlvbiRyYW5nZTMuY29sLFxuICAgICAgICAgICAgICAgICAgICBlbmRSb3cgPSBfdGhpcyRzZWxlY3Rpb24kcmFuZ2UzLnJvdztcbiAgICAgICAgICAgICAgICB2YXIgbmV3Rm9jdXMgPSAoX2IgPSB0aGlzLmdldENlbGxSYW5nZUJ5RmllbGQoZmllbGQsIGluZGV4KSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnN0YXJ0O1xuXG4gICAgICAgICAgICAgICAgaWYgKG5ld0ZvY3VzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmZvY3VzQ2VsbChuZXdGb2N1cy5jb2wsIG5ld0ZvY3VzLnJvdyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24uc2VsZWN0ID0gbmV3Rm9jdXM7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnZhbGlkYXRlR3JpZFJlY3Qoc3RhcnRDb2wsIHN0YXJ0Um93LCBlbmRDb2wsIGVuZFJvdyk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnZhbGlkYXRlQ2VsbChuZXdGb2N1cy5jb2wsIG5ld0ZvY3VzLnJvdyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIFNjcm9sbCB0byB3aGVyZSBjZWxsIGlzIHZpc2libGUuXG4gICAgICAgICAgICAgICAqIEBwYXJhbSAgeyp9IGZpZWxkIFRoZSBmaWVsZC5cbiAgICAgICAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBpbmRleCBUaGUgcmVjb3JkIGluZGV4XG4gICAgICAgICAgICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJtYWtlVmlzaWJsZUdyaWRDZWxsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBtYWtlVmlzaWJsZUdyaWRDZWxsKGZpZWxkLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBfYiwgX2MsIF9kO1xuXG4gICAgICAgICAgICAgICAgdmFyIGNlbGwgPSAoX2IgPSB0aGlzLmdldENlbGxSYW5nZUJ5RmllbGQoZmllbGQsIGluZGV4KSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnN0YXJ0O1xuICAgICAgICAgICAgICAgIHRoaXMubWFrZVZpc2libGVDZWxsKChfYyA9IGNlbGwgPT09IG51bGwgfHwgY2VsbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2VsbC5jb2wpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IDAsIChfZCA9IGNlbGwgPT09IG51bGwgfHwgY2VsbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2VsbC5yb3cpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHRoaXNbX10ubGF5b3V0TWFwLmhlYWRlclJvd0NvdW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0R3JpZENhbnZhc0hlbHBlclwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0R3JpZENhbnZhc0hlbHBlcigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tfXS5ncmlkQ2FudmFzSGVscGVyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBHZXQgY2VsbCByYW5nZSBpbmZvcm1hdGlvbiBmb3IgYSBnaXZlbiBjZWxsLlxuICAgICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sIGNvbHVtbiBpbmRleCBvZiB0aGUgY2VsbFxuICAgICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93IHJvdyBpbmRleCBvZiB0aGUgY2VsbFxuICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBjZWxsIHJhbmdlIGluZm9cbiAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImdldENlbGxSYW5nZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2VsbFJhbmdlKGNvbCwgcm93KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9nZXRDZWxsUmFuZ2UodGhpcywgY29sLCByb3cpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBHZXQgaGVhZGVyIHJhbmdlIGluZm9ybWF0aW9uIGZvciBhIGdpdmVuIGNlbGwuXG4gICAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2wgY29sdW1uIGluZGV4IG9mIHRoZSBjZWxsXG4gICAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3cgcm93IGluZGV4IG9mIHRoZSBjZWxsXG4gICAgICAgICAgICAgICAqIEByZXR1cm5zIHtvYmplY3R9IGNlbGwgcmFuZ2UgaW5mb1xuICAgICAgICAgICAgICAgKiBAZGVwcmVjYXRlZCB1c2UgYGdldENlbGxSYW5nZWAgaW5zdGVhZFxuICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0SGVhZGVyQ2VsbFJhbmdlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRIZWFkZXJDZWxsUmFuZ2UoY29sLCByb3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDZWxsUmFuZ2UoY29sLCByb3cpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJnZXRDb3B5Q2VsbFZhbHVlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb3B5Q2VsbFZhbHVlKGNvbCwgcm93LCByYW5nZSkge1xuICAgICAgICAgICAgICAgIHZhciBjZWxsUmFuZ2UgPSBfZ2V0Q2VsbFJhbmdlKHRoaXMsIGNvbCwgcm93KTtcblxuICAgICAgICAgICAgICAgIHZhciBzdGFydENvbCA9IHJhbmdlID8gTWF0aC5tYXgocmFuZ2Uuc3RhcnQuY29sLCBjZWxsUmFuZ2Uuc3RhcnQuY29sKSA6IGNlbGxSYW5nZS5zdGFydC5jb2w7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0Um93ID0gcmFuZ2UgPyBNYXRoLm1heChyYW5nZS5zdGFydC5yb3csIGNlbGxSYW5nZS5zdGFydC5yb3cpIDogY2VsbFJhbmdlLnN0YXJ0LnJvdztcblxuICAgICAgICAgICAgICAgIGlmIChzdGFydENvbCAhPT0gY29sIHx8IHN0YXJ0Um93ICE9PSByb3cpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IF9nZXRDZWxsVmFsdWUodGhpcywgY29sLCByb3cpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJvdyA8IHRoaXNbX10ubGF5b3V0TWFwLmhlYWRlclJvd0NvdW50KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgaGVhZGVyRGF0YSA9IHRoaXNbX10ubGF5b3V0TWFwLmdldEhlYWRlcihjb2wsIHJvdyk7XG5cbiAgICAgICAgICAgICAgICAgIHJldHVybiBoZWFkZXJEYXRhLmhlYWRlclR5cGUuZ2V0Q29weUNlbGxWYWx1ZSh2YWx1ZSwgdGhpcywge1xuICAgICAgICAgICAgICAgICAgICBjb2w6IGNvbCxcbiAgICAgICAgICAgICAgICAgICAgcm93OiByb3dcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBjb2x1bW5EYXRhID0gdGhpc1tfXS5sYXlvdXRNYXAuZ2V0Qm9keShjb2wsIHJvdyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY29sdW1uRGF0YS5jb2x1bW5UeXBlLmdldENvcHlDZWxsVmFsdWUodmFsdWUsIHRoaXMsIHtcbiAgICAgICAgICAgICAgICAgIGNvbDogY29sLFxuICAgICAgICAgICAgICAgICAgcm93OiByb3dcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwib25EcmF3Q2VsbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25EcmF3Q2VsbChjb2wsIHJvdywgY29udGV4dCkge1xuICAgICAgICAgICAgICAgIHZhciBsYXlvdXRNYXAgPSB0aGlzW19dLmxheW91dE1hcDtcbiAgICAgICAgICAgICAgICB2YXIgZHJhdztcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGU7XG5cbiAgICAgICAgICAgICAgICBpZiAocm93IDwgbGF5b3V0TWFwLmhlYWRlclJvd0NvdW50KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgaGQgPSBsYXlvdXRNYXAuZ2V0SGVhZGVyKGNvbCwgcm93KTtcbiAgICAgICAgICAgICAgICAgIGRyYXcgPSBoZC5oZWFkZXJUeXBlLm9uRHJhd0NlbGw7XG4gICAgICAgICAgICAgICAgICBzdHlsZSA9IGhkLnN0eWxlO1xuXG4gICAgICAgICAgICAgICAgICBfdXBkYXRlUmVjdCh0aGlzLCBjb2wsIHJvdywgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhciBjb2x1bW4gPSBsYXlvdXRNYXAuZ2V0Qm9keShjb2wsIHJvdyk7XG4gICAgICAgICAgICAgICAgICBkcmF3ID0gY29sdW1uLmNvbHVtblR5cGUub25EcmF3Q2VsbDtcbiAgICAgICAgICAgICAgICAgIHN0eWxlID0gY29sdW1uLnN0eWxlO1xuXG4gICAgICAgICAgICAgICAgICBfdXBkYXRlUmVjdCh0aGlzLCBjb2wsIHJvdywgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGNlbGxWYWx1ZSA9IF9nZXRDZWxsVmFsdWUodGhpcywgY29sLCByb3cpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucm93Q291bnQgPD0gcm93KSB7XG4gICAgICAgICAgICAgICAgICAvLyBEZXBlbmRpbmcgb24gdGhlIEZpbHRlckRhdGFTb3VyY2UsIHRoZSByb3dDb3VudCBtYXkgYmUgcmVkdWNlZC5cbiAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9vbkRyYXdWYWx1ZSh0aGlzLCBjZWxsVmFsdWUsIGNvbnRleHQsIHtcbiAgICAgICAgICAgICAgICAgIGNvbDogY29sLFxuICAgICAgICAgICAgICAgICAgcm93OiByb3dcbiAgICAgICAgICAgICAgICB9LCBzdHlsZSwgZHJhdyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImRvR2V0Q2VsbFZhbHVlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkb0dldENlbGxWYWx1ZShjb2wsIHJvdywgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgdmFsdWVDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGlmIChyb3cgPCB0aGlzW19dLmxheW91dE1hcC5oZWFkZXJSb3dDb3VudCkge1xuICAgICAgICAgICAgICAgICAgLy8gbm9wXG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IF9nZXRDZWxsVmFsdWUodGhpcywgY29sLCByb3cpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoKDAsIHV0aWxzXzEuaXNQcm9taXNlKSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy/pgYXlu7bkuK3jga/nhKHoppZcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICB2YWx1ZUNhbGxiYWNrKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZG9DaGFuZ2VWYWx1ZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZG9DaGFuZ2VWYWx1ZShjb2wsIHJvdywgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgY2hhbmdlVmFsdWVDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpczEyID0gdGhpcztcblxuICAgICAgICAgICAgICAgIGlmIChyb3cgPCB0aGlzW19dLmxheW91dE1hcC5oZWFkZXJSb3dDb3VudCkge1xuICAgICAgICAgICAgICAgICAgLy8gbm9wXG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhciByZWNvcmQgPSB0aGlzLmdldFJvd1JlY29yZChyb3cpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoKDAsIHV0aWxzXzEuaXNQcm9taXNlKShyZWNvcmQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8v6YGF5bu25Lit44Gv54Sh6KaWXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgdmFyIGJlZm9yZSA9IF9nZXRDZWxsVmFsdWUodGhpcywgY29sLCByb3cpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoKDAsIHV0aWxzXzEuaXNQcm9taXNlKShiZWZvcmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8v6YGF5bu25Lit44Gv54Sh6KaWXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgdmFyIGFmdGVyID0gY2hhbmdlVmFsdWVDYWxsYmFjayhiZWZvcmUpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoYWZ0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyRfJGxheW91dE1hcCRnZXQgPSB0aGlzW19dLmxheW91dE1hcC5nZXRCb2R5KGNvbCwgcm93KSxcbiAgICAgICAgICAgICAgICAgICAgICBmaWVsZCA9IF90aGlzJF8kbGF5b3V0TWFwJGdldC5maWVsZDtcblxuICAgICAgICAgICAgICAgICAgdGhpcy5maXJlTGlzdGVuZXJzKExHX0VWRU5UX1RZUEVfMS5MR19FVkVOVF9UWVBFLkJFRk9SRV9DSEFOR0VfVkFMVUUsIHtcbiAgICAgICAgICAgICAgICAgICAgY29sOiBjb2wsXG4gICAgICAgICAgICAgICAgICAgIHJvdzogcm93LFxuICAgICAgICAgICAgICAgICAgICByZWNvcmQ6IHJlY29yZCxcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6IGZpZWxkLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogYWZ0ZXIsXG4gICAgICAgICAgICAgICAgICAgIG9sZFZhbHVlOiBiZWZvcmVcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLnRoZW4pKF9zZXRDZWxsVmFsdWUodGhpcywgY29sLCByb3csIGFmdGVyKSwgZnVuY3Rpb24gKHJldCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzMTIkXyRsYXlvdXRNYXAkZyA9IF90aGlzMTJbX10ubGF5b3V0TWFwLmdldEJvZHkoY29sLCByb3cpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBfZmllbGQyID0gX3RoaXMxMiRfJGxheW91dE1hcCRnLmZpZWxkO1xuXG4gICAgICAgICAgICAgICAgICAgICAgX3RoaXMxMi5maXJlTGlzdGVuZXJzKExHX0VWRU5UX1RZUEVfMS5MR19FVkVOVF9UWVBFLkNIQU5HRURfVkFMVUUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbDogY29sLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm93OiByb3csXG4gICAgICAgICAgICAgICAgICAgICAgICByZWNvcmQ6IHJlY29yZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkOiBfZmllbGQyLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGFmdGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWU6IGJlZm9yZVxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZG9TZXRQYXN0ZVZhbHVlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkb1NldFBhc3RlVmFsdWUodGV4dCwgdGVzdCkge1xuICAgICAgICAgICAgICAgIF9vblJhbmdlUGFzdGUuY2FsbCh0aGlzLCB0ZXh0LCB0ZXN0KTtcbiAgICAgICAgICAgICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJnZXRIZWFkZXJWYWx1ZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SGVhZGVyVmFsdWUoY29sLCByb3cpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmllbGQgPSB0aGlzLmdldEhlYWRlckZpZWxkKGNvbCwgcm93KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oZWFkZXJWYWx1ZXMuZ2V0KGZpZWxkKTtcbiAgICAgICAgICAgICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJzZXRIZWFkZXJWYWx1ZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0SGVhZGVyVmFsdWUoY29sLCByb3csIG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpZWxkID0gdGhpcy5nZXRIZWFkZXJGaWVsZChjb2wsIHJvdyk7XG4gICAgICAgICAgICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy5oZWFkZXJWYWx1ZXMuZ2V0KGZpZWxkKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWRlclZhbHVlcy5zZXQoZmllbGQsIG5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmVMaXN0ZW5lcnMoTEdfRVZFTlRfVFlQRV8xLkxHX0VWRU5UX1RZUEUuQ0hBTkdFRF9IRUFERVJfVkFMVUUsIHtcbiAgICAgICAgICAgICAgICAgIGNvbDogY29sLFxuICAgICAgICAgICAgICAgICAgcm93OiByb3csXG4gICAgICAgICAgICAgICAgICBmaWVsZDogZmllbGQsXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogbmV3VmFsdWUsXG4gICAgICAgICAgICAgICAgICBvbGRWYWx1ZTogb2xkVmFsdWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0TGF5b3V0Q2VsbElkXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMYXlvdXRDZWxsSWQoY29sLCByb3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tfXS5sYXlvdXRNYXAuZ2V0Q2VsbElkKGNvbCwgcm93KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiYmluZEV2ZW50c0ludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kRXZlbnRzSW50ZXJuYWwoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzMTMgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgdmFyIGdyaWQgPSB0aGlzO1xuICAgICAgICAgICAgICAgIGdyaWQubGlzdGVuKExHX0VWRU5UX1RZUEVfMS5MR19FVkVOVF9UWVBFLlNFTEVDVEVEX0NFTEwsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBfZ2V0Q2VsbFJhbmdlKF90aGlzMTMsIGUuY29sLCBlLnJvdyk7XG5cbiAgICAgICAgICAgICAgICAgIHZhciBfcmFuZ2Ukc3RhcnQgPSByYW5nZS5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICBzdGFydENvbCA9IF9yYW5nZSRzdGFydC5jb2wsXG4gICAgICAgICAgICAgICAgICAgICAgc3RhcnRSb3cgPSBfcmFuZ2Ukc3RhcnQucm93LFxuICAgICAgICAgICAgICAgICAgICAgIF9yYW5nZSRlbmQgPSByYW5nZS5lbmQsXG4gICAgICAgICAgICAgICAgICAgICAgZW5kQ29sID0gX3JhbmdlJGVuZC5jb2wsXG4gICAgICAgICAgICAgICAgICAgICAgZW5kUm93ID0gX3JhbmdlJGVuZC5yb3c7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChzdGFydENvbCAhPT0gZW5kQ29sIHx8IHN0YXJ0Um93ICE9PSBlbmRSb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMxMy5pbnZhbGlkYXRlQ2VsbFJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBncmlkLmxpc3RlbihMR19FVkVOVF9UWVBFXzEuTEdfRVZFTlRfVFlQRS5QQVNURV9DRUxMLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpczEzW19dLmFsbG93UmFuZ2VQYXN0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHZhciBfdGhpczEzJHNlbGVjdGlvbiRyYW4gPSBfdGhpczEzLnNlbGVjdGlvbi5yYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IF90aGlzMTMkc2VsZWN0aW9uJHJhbi5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICBlbmQgPSBfdGhpczEzJHNlbGVjdGlvbiRyYW4uZW5kO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoIWUubXVsdGkgJiYgKDAsIHV0aWxzXzEuY2VsbEVxdWFscykoc3RhcnQsIGVuZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICB2YXIgbGF5b3V0TWFwID0gX3RoaXMxM1tfXS5sYXlvdXRNYXA7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChzdGFydC5yb3cgPCBsYXlvdXRNYXAuaGVhZGVyUm93Q291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICB1dGlsc18xLmV2ZW50LmNhbmNlbChlLmV2ZW50KTtcblxuICAgICAgICAgICAgICAgICAgX29uUmFuZ2VQYXN0ZS5jYWxsKF90aGlzMTMsIGUubm9ybWFsaXplVmFsdWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGdyaWQubGlzdGVuKExHX0VWRU5UX1RZUEVfMS5MR19FVkVOVF9UWVBFLkRFTEVURV9DRUxMLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gX3RoaXMxMy5zZWxlY3Rpb24ucmFuZ2Uuc3RhcnQ7XG4gICAgICAgICAgICAgICAgICB2YXIgbGF5b3V0TWFwID0gX3RoaXMxM1tfXS5sYXlvdXRNYXA7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChzdGFydC5yb3cgPCBsYXlvdXRNYXAuaGVhZGVyUm93Q291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICB1dGlsc18xLmV2ZW50LmNhbmNlbChlLmV2ZW50KTtcblxuICAgICAgICAgICAgICAgICAgX29uUmFuZ2VEZWxldGUuY2FsbChfdGhpczEzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0TW92ZUxlZnRDb2xCeUtleURvd25JbnRlcm5hbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TW92ZUxlZnRDb2xCeUtleURvd25JbnRlcm5hbChfcmVmMTgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29sID0gX3JlZjE4LmNvbCxcbiAgICAgICAgICAgICAgICAgICAgcm93ID0gX3JlZjE4LnJvdztcblxuICAgICAgICAgICAgICAgIHZhciBfZ2V0Q2VsbFJhbmdlMyA9IF9nZXRDZWxsUmFuZ2UodGhpcywgY29sLCByb3cpLFxuICAgICAgICAgICAgICAgICAgICBzdGFydENvbCA9IF9nZXRDZWxsUmFuZ2UzLnN0YXJ0LmNvbDtcblxuICAgICAgICAgICAgICAgIGNvbCA9IHN0YXJ0Q29sO1xuICAgICAgICAgICAgICAgIHJldHVybiBfZ2V0KF9nZXRQcm90b3R5cGVPZihMaXN0R3JpZC5wcm90b3R5cGUpLCBcImdldE1vdmVMZWZ0Q29sQnlLZXlEb3duSW50ZXJuYWxcIiwgdGhpcykuY2FsbCh0aGlzLCB7XG4gICAgICAgICAgICAgICAgICBjb2w6IGNvbCxcbiAgICAgICAgICAgICAgICAgIHJvdzogcm93XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImdldE1vdmVSaWdodENvbEJ5S2V5RG93bkludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNb3ZlUmlnaHRDb2xCeUtleURvd25JbnRlcm5hbChfcmVmMTkpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29sID0gX3JlZjE5LmNvbCxcbiAgICAgICAgICAgICAgICAgICAgcm93ID0gX3JlZjE5LnJvdztcblxuICAgICAgICAgICAgICAgIHZhciBfZ2V0Q2VsbFJhbmdlNCA9IF9nZXRDZWxsUmFuZ2UodGhpcywgY29sLCByb3cpLFxuICAgICAgICAgICAgICAgICAgICBlbmRDb2wgPSBfZ2V0Q2VsbFJhbmdlNC5lbmQuY29sO1xuXG4gICAgICAgICAgICAgICAgY29sID0gZW5kQ29sO1xuICAgICAgICAgICAgICAgIHJldHVybiBfZ2V0KF9nZXRQcm90b3R5cGVPZihMaXN0R3JpZC5wcm90b3R5cGUpLCBcImdldE1vdmVSaWdodENvbEJ5S2V5RG93bkludGVybmFsXCIsIHRoaXMpLmNhbGwodGhpcywge1xuICAgICAgICAgICAgICAgICAgY29sOiBjb2wsXG4gICAgICAgICAgICAgICAgICByb3c6IHJvd1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJnZXRNb3ZlVXBSb3dCeUtleURvd25JbnRlcm5hbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TW92ZVVwUm93QnlLZXlEb3duSW50ZXJuYWwoX3JlZjIwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbCA9IF9yZWYyMC5jb2wsXG4gICAgICAgICAgICAgICAgICAgIHJvdyA9IF9yZWYyMC5yb3c7XG5cbiAgICAgICAgICAgICAgICB2YXIgX2dldENlbGxSYW5nZTUgPSBfZ2V0Q2VsbFJhbmdlKHRoaXMsIGNvbCwgcm93KSxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRSb3cgPSBfZ2V0Q2VsbFJhbmdlNS5zdGFydC5yb3c7XG5cbiAgICAgICAgICAgICAgICByb3cgPSBzdGFydFJvdztcbiAgICAgICAgICAgICAgICByZXR1cm4gX2dldChfZ2V0UHJvdG90eXBlT2YoTGlzdEdyaWQucHJvdG90eXBlKSwgXCJnZXRNb3ZlVXBSb3dCeUtleURvd25JbnRlcm5hbFwiLCB0aGlzKS5jYWxsKHRoaXMsIHtcbiAgICAgICAgICAgICAgICAgIGNvbDogY29sLFxuICAgICAgICAgICAgICAgICAgcm93OiByb3dcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0TW92ZURvd25Sb3dCeUtleURvd25JbnRlcm5hbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TW92ZURvd25Sb3dCeUtleURvd25JbnRlcm5hbChfcmVmMjEpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29sID0gX3JlZjIxLmNvbCxcbiAgICAgICAgICAgICAgICAgICAgcm93ID0gX3JlZjIxLnJvdztcblxuICAgICAgICAgICAgICAgIHZhciBfZ2V0Q2VsbFJhbmdlNiA9IF9nZXRDZWxsUmFuZ2UodGhpcywgY29sLCByb3cpLFxuICAgICAgICAgICAgICAgICAgICBlbmRSb3cgPSBfZ2V0Q2VsbFJhbmdlNi5lbmQucm93O1xuXG4gICAgICAgICAgICAgICAgcm93ID0gZW5kUm93O1xuICAgICAgICAgICAgICAgIHJldHVybiBfZ2V0KF9nZXRQcm90b3R5cGVPZihMaXN0R3JpZC5wcm90b3R5cGUpLCBcImdldE1vdmVEb3duUm93QnlLZXlEb3duSW50ZXJuYWxcIiwgdGhpcykuY2FsbCh0aGlzLCB7XG4gICAgICAgICAgICAgICAgICBjb2w6IGNvbCxcbiAgICAgICAgICAgICAgICAgIHJvdzogcm93XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImdldE9mZnNldEludmFsaWRhdGVDZWxsc1wiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0T2Zmc2V0SW52YWxpZGF0ZUNlbGxzKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJnZXRDb3B5UmFuZ2VJbnRlcm5hbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29weVJhbmdlSW50ZXJuYWwocmFuZ2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMkZ2V0Q2VsbFJhbmdlNSA9IHRoaXMuZ2V0Q2VsbFJhbmdlKHJhbmdlLnN0YXJ0LmNvbCwgcmFuZ2Uuc3RhcnQucm93KSxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBfdGhpcyRnZXRDZWxsUmFuZ2U1LnN0YXJ0O1xuXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzJGdldENlbGxSYW5nZTYgPSB0aGlzLmdldENlbGxSYW5nZShyYW5nZS5lbmQuY29sLCByYW5nZS5lbmQucm93KSxcbiAgICAgICAgICAgICAgICAgICAgZW5kID0gX3RoaXMkZ2V0Q2VsbFJhbmdlNi5lbmQ7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgZW5kOiBlbmRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJmaXJlTGlzdGVuZXJzXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmaXJlTGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2dldDI7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGV2ZW50ID0gbmV3IEFycmF5KF9sZW4zID4gMSA/IF9sZW4zIC0gMSA6IDApLCBfa2V5MyA9IDE7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgICAgICAgICAgICAgIGV2ZW50W19rZXkzIC0gMV0gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgcmV0dXJuIChfZ2V0MiA9IF9nZXQoX2dldFByb3RvdHlwZU9mKExpc3RHcmlkLnByb3RvdHlwZSksIFwiZmlyZUxpc3RlbmVyc1wiLCB0aGlzKSkuY2FsbC5hcHBseShfZ2V0MiwgW3RoaXMsIHR5cGVdLmNvbmNhdChldmVudCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSwgW3tcbiAgICAgICAgICAgICAga2V5OiBcIkVWRU5UX1RZUEVcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIExHX0VWRU5UX1RZUEVfMS5MR19FVkVOVF9UWVBFO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBMaXN0R3JpZDtcbiAgICAgICAgICB9KERyYXdHcmlkXzEuRHJhd0dyaWQpO1xuXG4gICAgICAgICAgZXhwb3J0cy5MaXN0R3JpZCA9IExpc3RHcmlkO1xuICAgICAgICAgIF9hID0gXztcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9jb2x1bW5zLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9jb2x1bW5zLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBjb2x1bW5zSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICB2YXIgX19jcmVhdGVCaW5kaW5nID0gdGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZyB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICAgICAgICAgICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcblxuICAgICAgICAgICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgICAgICAgICAgZGVzYyA9IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ba107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xuICAgICAgICAgIH0gOiBmdW5jdGlvbiAobywgbSwgaywgazIpIHtcbiAgICAgICAgICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgICAgICAgICBvW2syXSA9IG1ba107XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gdGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCB2KSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHtcbiAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gOiBmdW5jdGlvbiAobywgdikge1xuICAgICAgICAgICAgb1tcImRlZmF1bHRcIl0gPSB2O1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIF9faW1wb3J0U3RhciA9IHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgICAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIHtcbiAgICAgICAgICAgICAgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5zdHlsZSA9IGV4cG9ydHMudHlwZSA9IGV4cG9ydHMuYWN0aW9uID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIGFjdGlvbiA9IF9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL2NvbHVtbnMvYWN0aW9uICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvYWN0aW9uLmpzXCIpKTtcblxuICAgICAgICAgIGV4cG9ydHMuYWN0aW9uID0gYWN0aW9uO1xuXG4gICAgICAgICAgdmFyIHN0eWxlID0gX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vY29sdW1ucy9zdHlsZSAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3N0eWxlLmpzXCIpKTtcblxuICAgICAgICAgIGV4cG9ydHMuc3R5bGUgPSBzdHlsZTtcblxuICAgICAgICAgIHZhciB0eXBlID0gX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vY29sdW1ucy90eXBlICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvdHlwZS5qc1wiKSk7XG5cbiAgICAgICAgICBleHBvcnRzLnR5cGUgPSB0eXBlO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2NvbHVtbnMvYWN0aW9uLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vY29sdW1ucy9hY3Rpb24uanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBjb2x1bW5zQWN0aW9uSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5vZiA9IGV4cG9ydHMuSW5saW5lTWVudUVkaXRvciA9IGV4cG9ydHMuSW5saW5lSW5wdXRFZGl0b3IgPSBleHBvcnRzLlNtYWxsRGlhbG9nSW5wdXRFZGl0b3IgPSBleHBvcnRzLkJ1dHRvbkFjdGlvbiA9IGV4cG9ydHMuUmFkaW9FZGl0b3IgPSBleHBvcnRzLkNoZWNrRWRpdG9yID0gZXhwb3J0cy5BY3Rpb24gPSBleHBvcnRzLkVkaXRvciA9IGV4cG9ydHMuQmFzZUFjdGlvbiA9IGV4cG9ydHMuQUNUSU9OUyA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBBY3Rpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vYWN0aW9uL0FjdGlvbiAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL2FjdGlvbi9BY3Rpb24uanNcIik7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBY3Rpb25cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICByZXR1cm4gQWN0aW9uXzEuQWN0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIEJhc2VBY3Rpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vYWN0aW9uL0Jhc2VBY3Rpb24gKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9hY3Rpb24vQmFzZUFjdGlvbi5qc1wiKTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJhc2VBY3Rpb25cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICByZXR1cm4gQmFzZUFjdGlvbl8xLkJhc2VBY3Rpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgQnV0dG9uQWN0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL2FjdGlvbi9CdXR0b25BY3Rpb24gKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9hY3Rpb24vQnV0dG9uQWN0aW9uLmpzXCIpO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQnV0dG9uQWN0aW9uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIEJ1dHRvbkFjdGlvbl8xLkJ1dHRvbkFjdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBDaGVja0VkaXRvcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9hY3Rpb24vQ2hlY2tFZGl0b3IgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9hY3Rpb24vQ2hlY2tFZGl0b3IuanNcIik7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDaGVja0VkaXRvclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBDaGVja0VkaXRvcl8xLkNoZWNrRWRpdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIEVkaXRvcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9hY3Rpb24vRWRpdG9yICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvYWN0aW9uL0VkaXRvci5qc1wiKTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkVkaXRvclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBFZGl0b3JfMS5FZGl0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgSW5saW5lSW5wdXRFZGl0b3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vYWN0aW9uL0lubGluZUlucHV0RWRpdG9yICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvYWN0aW9uL0lubGluZUlucHV0RWRpdG9yLmpzXCIpO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW5saW5lSW5wdXRFZGl0b3JcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICByZXR1cm4gSW5saW5lSW5wdXRFZGl0b3JfMS5JbmxpbmVJbnB1dEVkaXRvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBJbmxpbmVNZW51RWRpdG9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL2FjdGlvbi9JbmxpbmVNZW51RWRpdG9yICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvYWN0aW9uL0lubGluZU1lbnVFZGl0b3IuanNcIik7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbmxpbmVNZW51RWRpdG9yXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIElubGluZU1lbnVFZGl0b3JfMS5JbmxpbmVNZW51RWRpdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIFJhZGlvRWRpdG9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL2FjdGlvbi9SYWRpb0VkaXRvciAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL2FjdGlvbi9SYWRpb0VkaXRvci5qc1wiKTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJhZGlvRWRpdG9yXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFJhZGlvRWRpdG9yXzEuUmFkaW9FZGl0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgU21hbGxEaWFsb2dJbnB1dEVkaXRvcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9hY3Rpb24vU21hbGxEaWFsb2dJbnB1dEVkaXRvciAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL2FjdGlvbi9TbWFsbERpYWxvZ0lucHV0RWRpdG9yLmpzXCIpO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU21hbGxEaWFsb2dJbnB1dEVkaXRvclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBTbWFsbERpYWxvZ0lucHV0RWRpdG9yXzEuU21hbGxEaWFsb2dJbnB1dEVkaXRvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcblxuICAgICAgICAgIHZhciBJbW11dGFibGVDaGVja0VkaXRvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0NoZWNrRWRpdG9yXzEkQ2hlY2tFKSB7XG4gICAgICAgICAgICBfaW5oZXJpdHMoSW1tdXRhYmxlQ2hlY2tFZGl0b3IsIF9DaGVja0VkaXRvcl8xJENoZWNrRSk7XG5cbiAgICAgICAgICAgIHZhciBfc3VwZXIyID0gX2NyZWF0ZVN1cGVyKEltbXV0YWJsZUNoZWNrRWRpdG9yKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gSW1tdXRhYmxlQ2hlY2tFZGl0b3IoKSB7XG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbW11dGFibGVDaGVja0VkaXRvcik7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlcjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKEltbXV0YWJsZUNoZWNrRWRpdG9yLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiZGlzYWJsZWRcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc2FibGVkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJyZWFkT25seVwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVhZE9ubHk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIEltbXV0YWJsZUNoZWNrRWRpdG9yO1xuICAgICAgICAgIH0oQ2hlY2tFZGl0b3JfMS5DaGVja0VkaXRvcik7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5cblxuICAgICAgICAgIHZhciBJbW11dGFibGVSYWRpb0VkaXRvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JhZGlvRWRpdG9yXzEkUmFkaW9FKSB7XG4gICAgICAgICAgICBfaW5oZXJpdHMoSW1tdXRhYmxlUmFkaW9FZGl0b3IsIF9SYWRpb0VkaXRvcl8xJFJhZGlvRSk7XG5cbiAgICAgICAgICAgIHZhciBfc3VwZXIzID0gX2NyZWF0ZVN1cGVyKEltbXV0YWJsZVJhZGlvRWRpdG9yKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gSW1tdXRhYmxlUmFkaW9FZGl0b3IoKSB7XG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbW11dGFibGVSYWRpb0VkaXRvcik7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlcjMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKEltbXV0YWJsZVJhZGlvRWRpdG9yLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiZGlzYWJsZWRcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc2FibGVkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJyZWFkT25seVwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVhZE9ubHk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIEltbXV0YWJsZVJhZGlvRWRpdG9yO1xuICAgICAgICAgIH0oUmFkaW9FZGl0b3JfMS5SYWRpb0VkaXRvcik7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5cblxuICAgICAgICAgIHZhciBJbW11dGFibGVJbnB1dEVkaXRvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1NtYWxsRGlhbG9nSW5wdXRFZGl0KSB7XG4gICAgICAgICAgICBfaW5oZXJpdHMoSW1tdXRhYmxlSW5wdXRFZGl0b3IsIF9TbWFsbERpYWxvZ0lucHV0RWRpdCk7XG5cbiAgICAgICAgICAgIHZhciBfc3VwZXI0ID0gX2NyZWF0ZVN1cGVyKEltbXV0YWJsZUlucHV0RWRpdG9yKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gSW1tdXRhYmxlSW5wdXRFZGl0b3IoKSB7XG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbW11dGFibGVJbnB1dEVkaXRvcik7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlcjQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKEltbXV0YWJsZUlucHV0RWRpdG9yLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiZGlzYWJsZWRcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc2FibGVkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJyZWFkT25seVwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVhZE9ubHk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIEltbXV0YWJsZUlucHV0RWRpdG9yO1xuICAgICAgICAgIH0oU21hbGxEaWFsb2dJbnB1dEVkaXRvcl8xLlNtYWxsRGlhbG9nSW5wdXRFZGl0b3IpO1xuXG4gICAgICAgICAgZXhwb3J0cy5BQ1RJT05TID0ge1xuICAgICAgICAgICAgQ0hFQ0s6IG5ldyBJbW11dGFibGVDaGVja0VkaXRvcigpLFxuICAgICAgICAgICAgSU5QVVQ6IG5ldyBJbW11dGFibGVJbnB1dEVkaXRvcigpLFxuICAgICAgICAgICAgUkFESU86IG5ldyBJbW11dGFibGVSYWRpb0VkaXRvcigpXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGZ1bmN0aW9uIG9mKGNvbHVtbkFjdGlvbikge1xuICAgICAgICAgICAgaWYgKCFjb2x1bW5BY3Rpb24pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbHVtbkFjdGlvbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICB2YXIga2V5ID0gY29sdW1uQWN0aW9uLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkFDVElPTlNba2V5XSB8fCBvZihudWxsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBjb2x1bW5BY3Rpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5vZiA9IG9mO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2NvbHVtbnMvYWN0aW9uL0FjdGlvbi5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9jb2x1bW5zL2FjdGlvbi9BY3Rpb24uanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gY29sdW1uc0FjdGlvbkFjdGlvbkpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuQWN0aW9uID0gZXhwb3J0cy5BYnN0cmFjdEFjdGlvbiA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBhY3Rpb25CaW5kXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL2FjdGlvbkJpbmQgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9hY3Rpb24vYWN0aW9uQmluZC5qc1wiKTtcblxuICAgICAgICAgIHZhciBCYXNlQWN0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL0Jhc2VBY3Rpb24gKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9hY3Rpb24vQmFzZUFjdGlvbi5qc1wiKTtcblxuICAgICAgICAgIHZhciB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vaW50ZXJuYWwvdXRpbHMgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvdXRpbHMuanNcIik7XG5cbiAgICAgICAgICB2YXIgYWN0aW9uX3V0aWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL2FjdGlvbi11dGlscyAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL2FjdGlvbi9hY3Rpb24tdXRpbHMuanNcIik7XG5cbiAgICAgICAgICB2YXIgQWJzdHJhY3RBY3Rpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXNlQWN0aW9uXzEkQmFzZUFjdCkge1xuICAgICAgICAgICAgX2luaGVyaXRzKEFic3RyYWN0QWN0aW9uLCBfQmFzZUFjdGlvbl8xJEJhc2VBY3QpO1xuXG4gICAgICAgICAgICB2YXIgX3N1cGVyNSA9IF9jcmVhdGVTdXBlcihBYnN0cmFjdEFjdGlvbik7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIEFic3RyYWN0QWN0aW9uKCkge1xuICAgICAgICAgICAgICB2YXIgX3RoaXMxNDtcblxuICAgICAgICAgICAgICB2YXIgb3B0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQWJzdHJhY3RBY3Rpb24pO1xuXG4gICAgICAgICAgICAgIF90aGlzMTQgPSBfc3VwZXI1LmNhbGwodGhpcywgb3B0aW9uKTtcblxuICAgICAgICAgICAgICBfdGhpczE0Ll9hY3Rpb24gPSBvcHRpb24uYWN0aW9uIHx8IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczE0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoQWJzdHJhY3RBY3Rpb24sIFt7XG4gICAgICAgICAgICAgIGtleTogXCJlZGl0YWJsZVwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImFjdGlvblwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYWN0aW9uO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rpb24gPSBhY3Rpb247XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImJpbmRHcmlkRXZlbnRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRHcmlkRXZlbnQoZ3JpZCwgY2VsbElkKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzMTUgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5nZXRTdGF0ZShncmlkKTtcblxuICAgICAgICAgICAgICAgIHZhciBhY3Rpb24gPSBmdW5jdGlvbiBhY3Rpb24oY2VsbCkge1xuICAgICAgICAgICAgICAgICAgaWYgKCgwLCBhY3Rpb25fdXRpbHNfMS5pc0Rpc2FibGVkUmVjb3JkKShfdGhpczE1LmRpc2FibGVkLCBncmlkLCBjZWxsLnJvdykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICB2YXIgcmVjb3JkID0gZ3JpZC5nZXRSb3dSZWNvcmQoY2VsbC5yb3cpO1xuXG4gICAgICAgICAgICAgICAgICBfdGhpczE1Ll9hY3Rpb24ocmVjb3JkLCAoMCwgdXRpbHNfMS5leHRlbmQpKGNlbGwsIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JpZDogZ3JpZFxuICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheSgoMCwgYWN0aW9uQmluZF8xLmJpbmRDZWxsQ2xpY2tBY3Rpb24pKGdyaWQsIGNlbGxJZCwge1xuICAgICAgICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgICAgICAgICAgICBtb3VzZU92ZXI6IGZ1bmN0aW9uIG1vdXNlT3ZlcihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoMCwgYWN0aW9uX3V0aWxzXzEuaXNEaXNhYmxlZFJlY29yZCkoX3RoaXMxNS5kaXNhYmxlZCwgZ3JpZCwgZS5yb3cpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgc3RhdGUubW91c2VBY3RpdmVDZWxsID0ge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbDogZS5jb2wsXG4gICAgICAgICAgICAgICAgICAgICAgcm93OiBlLnJvd1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBncmlkLmdldENlbGxSYW5nZShlLmNvbCwgZS5yb3cpO1xuICAgICAgICAgICAgICAgICAgICBncmlkLmludmFsaWRhdGVDZWxsUmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBtb3VzZU91dDogZnVuY3Rpb24gbW91c2VPdXQoZSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc3RhdGUubW91c2VBY3RpdmVDZWxsO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBncmlkLmdldENlbGxSYW5nZShlLmNvbCwgZS5yb3cpO1xuICAgICAgICAgICAgICAgICAgICBncmlkLmludmFsaWRhdGVDZWxsUmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIGFyZWE6IGZ1bmN0aW9uIGFyZWEoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV90aGlzMTUuYXJlYSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50ID0gZS5ldmVudDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsaWVudFggPSBldmVudC5jbGllbnRYIHx8IGV2ZW50LnBhZ2VYICsgd2luZG93LnNjcm9sbFg7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjbGllbnRZID0gZXZlbnQuY2xpZW50WSB8fCBldmVudC5wYWdlWSArIHdpbmRvdy5zY3JvbGxZO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2FudmFzUmVjdCA9IGdyaWQuY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeEluQ2FudmFzID0gY2xpZW50WCAtIGNhbnZhc1JlY3QubGVmdDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHlJbkNhbnZhcyA9IGNsaWVudFkgLSBjYW52YXNSZWN0LnRvcDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlY3QgPSBncmlkLmdldENlbGxSZWN0KGUuY29sLCBlLnJvdyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczE1LmFyZWEoe1xuICAgICAgICAgICAgICAgICAgICAgIGNvbDogZS5jb2wsXG4gICAgICAgICAgICAgICAgICAgICAgcm93OiBlLnJvdyxcbiAgICAgICAgICAgICAgICAgICAgICBncmlkOiBncmlkLFxuICAgICAgICAgICAgICAgICAgICAgIHBvaW50SW5DZWxsOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiB4SW5DYW52YXMgLSByZWN0LmxlZnQgKyBncmlkLnNjcm9sbExlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiB5SW5DYW52YXMgLSByZWN0LnRvcCArIGdyaWQuc2Nyb2xsVG9wXG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICBwb2ludEluRHJhd2luZ0NhbnZhczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogeEluQ2FudmFzLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogeUluQ2FudmFzXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSksIF90b0NvbnN1bWFibGVBcnJheSgoMCwgYWN0aW9uQmluZF8xLmJpbmRDZWxsS2V5QWN0aW9uKShncmlkLCBjZWxsSWQsIHtcbiAgICAgICAgICAgICAgICAgIGFjdGlvbjogYWN0aW9uXG4gICAgICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwib25QYXN0ZUNlbGxSYW5nZUJveFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25QYXN0ZUNlbGxSYW5nZUJveCgpIHsvLyBub29wXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIm9uRGVsZXRlQ2VsbFJhbmdlQm94XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbkRlbGV0ZUNlbGxSYW5nZUJveCgpIHsvLyBub29wXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIEFic3RyYWN0QWN0aW9uO1xuICAgICAgICAgIH0oQmFzZUFjdGlvbl8xLkJhc2VBY3Rpb24pO1xuXG4gICAgICAgICAgZXhwb3J0cy5BYnN0cmFjdEFjdGlvbiA9IEFic3RyYWN0QWN0aW9uO1xuXG4gICAgICAgICAgdmFyIEFjdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Fic3RyYWN0QWN0aW9uKSB7XG4gICAgICAgICAgICBfaW5oZXJpdHMoQWN0aW9uLCBfQWJzdHJhY3RBY3Rpb24pO1xuXG4gICAgICAgICAgICB2YXIgX3N1cGVyNiA9IF9jcmVhdGVTdXBlcihBY3Rpb24pO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBBY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHZhciBfdGhpczE2O1xuXG4gICAgICAgICAgICAgIHZhciBvcHRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBY3Rpb24pO1xuXG4gICAgICAgICAgICAgIF90aGlzMTYgPSBfc3VwZXI2LmNhbGwodGhpcywgb3B0aW9uKTtcbiAgICAgICAgICAgICAgX3RoaXMxNi5fYXJlYSA9IG9wdGlvbi5hcmVhO1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMxNjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKEFjdGlvbiwgW3tcbiAgICAgICAgICAgICAga2V5OiBcImFyZWFcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FyZWE7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGFyZWEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hcmVhID0gYXJlYTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY2xvbmVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQWN0aW9uKHRoaXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJnZXRTdGF0ZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U3RhdGUoX2dyaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIEFjdGlvbjtcbiAgICAgICAgICB9KEFic3RyYWN0QWN0aW9uKTtcblxuICAgICAgICAgIGV4cG9ydHMuQWN0aW9uID0gQWN0aW9uO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2NvbHVtbnMvYWN0aW9uL0Jhc2VBY3Rpb24uanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2NvbHVtbnMvYWN0aW9uL0Jhc2VBY3Rpb24uanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGNvbHVtbnNBY3Rpb25CYXNlQWN0aW9uSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5CYXNlQWN0aW9uID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIEJhc2VBY3Rpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gQmFzZUFjdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIG9wdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJhc2VBY3Rpb24pO1xuXG4gICAgICAgICAgICAgIHRoaXMuX2Rpc2FibGVkID0gb3B0aW9uLmRpc2FibGVkIHx8IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoQmFzZUFjdGlvbiwgW3tcbiAgICAgICAgICAgICAga2V5OiBcImRpc2FibGVkXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaXNhYmxlZDtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXNhYmxlZCA9IGRpc2FibGVkO1xuICAgICAgICAgICAgICAgIHRoaXMub25DaGFuZ2VEaXNhYmxlZEludGVybmFsKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIm9uQ2hhbmdlRGlzYWJsZWRJbnRlcm5hbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25DaGFuZ2VEaXNhYmxlZEludGVybmFsKCkgey8vIGFic3RyYWN0XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIEJhc2VBY3Rpb247XG4gICAgICAgICAgfSgpO1xuXG4gICAgICAgICAgZXhwb3J0cy5CYXNlQWN0aW9uID0gQmFzZUFjdGlvbjtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9jb2x1bW5zL2FjdGlvbi9CYXNlSW5wdXRFZGl0b3IuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vY29sdW1ucy9hY3Rpb24vQmFzZUlucHV0RWRpdG9yLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGNvbHVtbnNBY3Rpb25CYXNlSW5wdXRFZGl0b3JKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLkJhc2VJbnB1dEVkaXRvciA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vaW50ZXJuYWwvdXRpbHMgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvdXRpbHMuanNcIik7XG5cbiAgICAgICAgICB2YXIgYWN0aW9uX3V0aWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL2FjdGlvbi11dGlscyAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL2FjdGlvbi9hY3Rpb24tdXRpbHMuanNcIik7XG5cbiAgICAgICAgICB2YXIgREdfRVZFTlRfVFlQRV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vY29yZS9ER19FVkVOVF9UWVBFICovXG4gICAgICAgICAgXCIuL2NvcmUvREdfRVZFTlRfVFlQRS5qc1wiKTtcblxuICAgICAgICAgIHZhciBFZGl0b3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vRWRpdG9yICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvYWN0aW9uL0VkaXRvci5qc1wiKTtcblxuICAgICAgICAgIHZhciBLRVlfRU5URVIgPSAxMztcbiAgICAgICAgICB2YXIgS0VZX0YyID0gMTEzO1xuXG4gICAgICAgICAgdmFyIEJhc2VJbnB1dEVkaXRvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0VkaXRvcl8xJEVkaXRvcikge1xuICAgICAgICAgICAgX2luaGVyaXRzKEJhc2VJbnB1dEVkaXRvciwgX0VkaXRvcl8xJEVkaXRvcik7XG5cbiAgICAgICAgICAgIHZhciBfc3VwZXI3ID0gX2NyZWF0ZVN1cGVyKEJhc2VJbnB1dEVkaXRvcik7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIEJhc2VJbnB1dEVkaXRvcigpIHtcbiAgICAgICAgICAgICAgdmFyIG9wdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJhc2VJbnB1dEVkaXRvcik7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlcjcuY2FsbCh0aGlzLCBvcHRpb24pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoQmFzZUlucHV0RWRpdG9yLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiYmluZEdyaWRFdmVudFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYmluZEdyaWRFdmVudChncmlkLCBjZWxsSWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMxNyA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICB2YXIgb3BlbiA9IGZ1bmN0aW9uIG9wZW4oY2VsbCkge1xuICAgICAgICAgICAgICAgICAgaWYgKCgwLCBhY3Rpb25fdXRpbHNfMS5pc1JlYWRPbmx5UmVjb3JkKShfdGhpczE3LnJlYWRPbmx5LCBncmlkLCBjZWxsLnJvdykgfHwgKDAsIGFjdGlvbl91dGlsc18xLmlzRGlzYWJsZWRSZWNvcmQpKF90aGlzMTcuZGlzYWJsZWQsIGdyaWQsIGNlbGwucm93KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIF90aGlzMTcub25PcGVuQ2VsbEludGVybmFsKGdyaWQsIGNlbGwpO1xuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gZnVuY3Rpb24gaW5wdXQoY2VsbCwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICgoMCwgYWN0aW9uX3V0aWxzXzEuaXNSZWFkT25seVJlY29yZCkoX3RoaXMxNy5yZWFkT25seSwgZ3JpZCwgY2VsbC5yb3cpIHx8ICgwLCBhY3Rpb25fdXRpbHNfMS5pc0Rpc2FibGVkUmVjb3JkKShfdGhpczE3LmRpc2FibGVkLCBncmlkLCBjZWxsLnJvdykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBfdGhpczE3Lm9uSW5wdXRDZWxsSW50ZXJuYWwoZ3JpZCwgY2VsbCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBpc1RhcmdldChjb2wsIHJvdykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGdyaWQuZ2V0TGF5b3V0Q2VsbElkKGNvbCwgcm93KSA9PT0gY2VsbElkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBbZ3JpZC5saXN0ZW4oREdfRVZFTlRfVFlQRV8xLkRHX0VWRU5UX1RZUEUuSU5QVVRfQ0VMTCwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICghaXNUYXJnZXQoZS5jb2wsIGUucm93KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGlucHV0KHtcbiAgICAgICAgICAgICAgICAgICAgY29sOiBlLmNvbCxcbiAgICAgICAgICAgICAgICAgICAgcm93OiBlLnJvd1xuICAgICAgICAgICAgICAgICAgfSwgZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSksIGdyaWQubGlzdGVuKERHX0VWRU5UX1RZUEVfMS5ER19FVkVOVF9UWVBFLlBBU1RFX0NFTEwsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZS5tdWx0aSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgbXVsdGkgY2VsbCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICB2YXIgc2VsZWN0aW9uUmFuZ2UgPSBncmlkLnNlbGVjdGlvbi5yYW5nZTtcblxuICAgICAgICAgICAgICAgICAgaWYgKCEoMCwgdXRpbHNfMS5jZWxsRXF1YWxzKShzZWxlY3Rpb25SYW5nZS5zdGFydCwgc2VsZWN0aW9uUmFuZ2UuZW5kKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgbXVsdGkgcGFzdGUgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgaWYgKCFpc1RhcmdldChlLmNvbCwgZS5yb3cpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgdXRpbHNfMS5ldmVudC5jYW5jZWwoZS5ldmVudCk7XG4gICAgICAgICAgICAgICAgICBpbnB1dCh7XG4gICAgICAgICAgICAgICAgICAgIGNvbDogZS5jb2wsXG4gICAgICAgICAgICAgICAgICAgIHJvdzogZS5yb3dcbiAgICAgICAgICAgICAgICAgIH0sIGUubm9ybWFsaXplVmFsdWUpO1xuICAgICAgICAgICAgICAgIH0pLCBncmlkLmxpc3RlbihER19FVkVOVF9UWVBFXzEuREdfRVZFTlRfVFlQRS5EQkxDTElDS19DRUxMLCBmdW5jdGlvbiAoY2VsbCkge1xuICAgICAgICAgICAgICAgICAgaWYgKCFpc1RhcmdldChjZWxsLmNvbCwgY2VsbC5yb3cpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgb3Blbih7XG4gICAgICAgICAgICAgICAgICAgIGNvbDogY2VsbC5jb2wsXG4gICAgICAgICAgICAgICAgICAgIHJvdzogY2VsbC5yb3dcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pLCBncmlkLmxpc3RlbihER19FVkVOVF9UWVBFXzEuREdfRVZFTlRfVFlQRS5EQkxUQVBfQ0VMTCwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICghaXNUYXJnZXQoZS5jb2wsIGUucm93KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIG9wZW4oe1xuICAgICAgICAgICAgICAgICAgICBjb2w6IGUuY29sLFxuICAgICAgICAgICAgICAgICAgICByb3c6IGUucm93XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIHV0aWxzXzEuZXZlbnQuY2FuY2VsKGUuZXZlbnQpO1xuICAgICAgICAgICAgICAgIH0pLCBncmlkLmxpc3RlbihER19FVkVOVF9UWVBFXzEuREdfRVZFTlRfVFlQRS5LRVlET1dOLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGUua2V5Q29kZSAhPT0gS0VZX0YyICYmIGUua2V5Q29kZSAhPT0gS0VZX0VOVEVSKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgdmFyIHNlbCA9IGdyaWQuc2VsZWN0aW9uLnNlbGVjdDtcblxuICAgICAgICAgICAgICAgICAgaWYgKCFpc1RhcmdldChzZWwuY29sLCBzZWwucm93KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGlmIChvcGVuKHtcbiAgICAgICAgICAgICAgICAgICAgY29sOiBzZWwuY29sLFxuICAgICAgICAgICAgICAgICAgICByb3c6IHNlbC5yb3dcbiAgICAgICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc3RvcENlbGxNb3ZpbmcoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSwgZ3JpZC5saXN0ZW4oREdfRVZFTlRfVFlQRV8xLkRHX0VWRU5UX1RZUEUuU0VMRUNURURfQ0VMTCwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICghaXNUYXJnZXQoZS5jb2wsIGUucm93KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIF90aGlzMTcub25DaGFuZ2VTZWxlY3RDZWxsSW50ZXJuYWwoZ3JpZCwge1xuICAgICAgICAgICAgICAgICAgICBjb2w6IGUuY29sLFxuICAgICAgICAgICAgICAgICAgICByb3c6IGUucm93XG4gICAgICAgICAgICAgICAgICB9LCBlLnNlbGVjdGVkKTtcbiAgICAgICAgICAgICAgICB9KSwgZ3JpZC5saXN0ZW4oREdfRVZFTlRfVFlQRV8xLkRHX0VWRU5UX1RZUEUuU0NST0xMLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICBfdGhpczE3Lm9uR3JpZFNjcm9sbEludGVybmFsKGdyaWQpO1xuICAgICAgICAgICAgICAgIH0pLCBncmlkLmxpc3RlbihER19FVkVOVF9UWVBFXzEuREdfRVZFTlRfVFlQRS5FRElUQUJMRUlOUFVUX0NFTEwsIGZ1bmN0aW9uIChjZWxsKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIWlzVGFyZ2V0KGNlbGwuY29sLCBjZWxsLnJvdykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBpZiAoKDAsIGFjdGlvbl91dGlsc18xLmlzUmVhZE9ubHlSZWNvcmQpKF90aGlzMTcucmVhZE9ubHksIGdyaWQsIGNlbGwucm93KSB8fCAoMCwgYWN0aW9uX3V0aWxzXzEuaXNEaXNhYmxlZFJlY29yZCkoX3RoaXMxNy5kaXNhYmxlZCwgZ3JpZCwgY2VsbC5yb3cpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSksIGdyaWQubGlzdGVuKERHX0VWRU5UX1RZUEVfMS5ER19FVkVOVF9UWVBFLk1PRElGWV9TVEFUVVNfRURJVEFCTEVJTlBVVF9DRUxMLCBmdW5jdGlvbiAoY2VsbCkge1xuICAgICAgICAgICAgICAgICAgaWYgKCFpc1RhcmdldChjZWxsLmNvbCwgY2VsbC5yb3cpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgaWYgKCgwLCBhY3Rpb25fdXRpbHNfMS5pc1JlYWRPbmx5UmVjb3JkKShfdGhpczE3LnJlYWRPbmx5LCBncmlkLCBjZWxsLnJvdykgfHwgKDAsIGFjdGlvbl91dGlsc18xLmlzRGlzYWJsZWRSZWNvcmQpKF90aGlzMTcuZGlzYWJsZWQsIGdyaWQsIGNlbGwucm93KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IGdyaWQuZ2V0Q2VsbFJhbmdlKGNlbGwuY29sLCBjZWxsLnJvdyk7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChyYW5nZS5zdGFydC5jb2wgIT09IHJhbmdlLmVuZC5jb2wgfHwgcmFuZ2Uuc3RhcnQucm93ICE9PSByYW5nZS5lbmQucm93KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfaW5wdXQgPSBjZWxsLmlucHV0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmFzZVJlY3QgPSBncmlkLmdldENlbGxSZWN0KGNlbGwuY29sLCBjZWxsLnJvdyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByYW5nZVJlY3QgPSBncmlkLmdldENlbGxSYW5nZVJlY3QocmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICBfaW5wdXQuc3R5bGUudG9wID0gXCJcIi5jb25jYXQoKHBhcnNlRmxvYXQoX2lucHV0LnN0eWxlLnRvcCkgKyAocmFuZ2VSZWN0LnRvcCAtIGJhc2VSZWN0LnRvcCkpLnRvRml4ZWQoKSwgXCJweFwiKTtcbiAgICAgICAgICAgICAgICAgICAgX2lucHV0LnN0eWxlLmxlZnQgPSBcIlwiLmNvbmNhdCgocGFyc2VGbG9hdChfaW5wdXQuc3R5bGUubGVmdCkgKyAocmFuZ2VSZWN0LmxlZnQgLSBiYXNlUmVjdC5sZWZ0KSkudG9GaXhlZCgpLCBcInB4XCIpO1xuICAgICAgICAgICAgICAgICAgICBfaW5wdXQuc3R5bGUud2lkdGggPSBcIlwiLmNvbmNhdChyYW5nZVJlY3Qud2lkdGgudG9GaXhlZCgpLCBcInB4XCIpO1xuICAgICAgICAgICAgICAgICAgICBfaW5wdXQuc3R5bGUuaGVpZ2h0ID0gXCJcIi5jb25jYXQocmFuZ2VSZWN0LmhlaWdodC50b0ZpeGVkKCksIFwicHhcIik7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIF90aGlzMTcub25TZXRJbnB1dEF0dHJzSW50ZXJuYWwoZ3JpZCwge1xuICAgICAgICAgICAgICAgICAgICBjb2w6IGNlbGwuY29sLFxuICAgICAgICAgICAgICAgICAgICByb3c6IGNlbGwucm93XG4gICAgICAgICAgICAgICAgICB9LCBjZWxsLmlucHV0KTtcbiAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIm9uUGFzdGVDZWxsUmFuZ2VCb3hcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uUGFzdGVDZWxsUmFuZ2VCb3goZ3JpZCwgY2VsbCwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMxOCA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICBpZiAoKDAsIGFjdGlvbl91dGlsc18xLmlzUmVhZE9ubHlSZWNvcmQpKHRoaXMucmVhZE9ubHksIGdyaWQsIGNlbGwucm93KSB8fCAoMCwgYWN0aW9uX3V0aWxzXzEuaXNEaXNhYmxlZFJlY29yZCkodGhpcy5kaXNhYmxlZCwgZ3JpZCwgY2VsbC5yb3cpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZ3JpZC5kb0NoYW5nZVZhbHVlKGNlbGwuY29sLCBjZWxsLnJvdywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgaWYgKF90aGlzMTguaXNTdXBwb3J0TXVsdGlsaW5lVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKC9cXHI/XFxuL2csIFwiIFwiKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwib25EZWxldGVDZWxsUmFuZ2VCb3hcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uRGVsZXRlQ2VsbFJhbmdlQm94KGdyaWQsIGNlbGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoKDAsIGFjdGlvbl91dGlsc18xLmlzUmVhZE9ubHlSZWNvcmQpKHRoaXMucmVhZE9ubHksIGdyaWQsIGNlbGwucm93KSB8fCAoMCwgYWN0aW9uX3V0aWxzXzEuaXNEaXNhYmxlZFJlY29yZCkodGhpcy5kaXNhYmxlZCwgZ3JpZCwgY2VsbC5yb3cpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZ3JpZC5kb0NoYW5nZVZhbHVlKGNlbGwuY29sLCBjZWxsLnJvdywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImlzU3VwcG9ydE11bHRpbGluZVZhbHVlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc1N1cHBvcnRNdWx0aWxpbmVWYWx1ZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIEJhc2VJbnB1dEVkaXRvcjtcbiAgICAgICAgICB9KEVkaXRvcl8xLkVkaXRvcik7XG5cbiAgICAgICAgICBleHBvcnRzLkJhc2VJbnB1dEVkaXRvciA9IEJhc2VJbnB1dEVkaXRvcjtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9jb2x1bW5zL2FjdGlvbi9CdXR0b25BY3Rpb24uanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vY29sdW1ucy9hY3Rpb24vQnV0dG9uQWN0aW9uLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGNvbHVtbnNBY3Rpb25CdXR0b25BY3Rpb25Kcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLkJ1dHRvbkFjdGlvbiA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBBY3Rpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vQWN0aW9uICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvYWN0aW9uL0FjdGlvbi5qc1wiKTtcblxuICAgICAgICAgIHZhciBzeW1ib2xNYW5hZ2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi9pbnRlcm5hbC9zeW1ib2xNYW5hZ2VyICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL3N5bWJvbE1hbmFnZXIuanNcIik7XG5cbiAgICAgICAgICB2YXIgdXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uL2ludGVybmFsL3V0aWxzICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL3V0aWxzLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIEJVVFRPTl9DT0xVTU5fU1RBVEVfSUQgPSAoMCwgc3ltYm9sTWFuYWdlcl8xLmdldEJ1dHRvbkNvbHVtblN0YXRlSWQpKCk7XG5cbiAgICAgICAgICB2YXIgQnV0dG9uQWN0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQWN0aW9uXzEkQWJzdHJhY3RBY3QpIHtcbiAgICAgICAgICAgIF9pbmhlcml0cyhCdXR0b25BY3Rpb24sIF9BY3Rpb25fMSRBYnN0cmFjdEFjdCk7XG5cbiAgICAgICAgICAgIHZhciBfc3VwZXI4ID0gX2NyZWF0ZVN1cGVyKEJ1dHRvbkFjdGlvbik7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIEJ1dHRvbkFjdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIG9wdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJ1dHRvbkFjdGlvbik7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlcjguY2FsbCh0aGlzLCBvcHRpb24pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoQnV0dG9uQWN0aW9uLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiYXJlYVwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChfYXJlYSkgey8vIG5vb3BcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY2xvbmVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQnV0dG9uQWN0aW9uKHRoaXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJnZXRTdGF0ZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U3RhdGUoZ3JpZCkge1xuICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IGdyaWRbQlVUVE9OX0NPTFVNTl9TVEFURV9JRF07XG5cbiAgICAgICAgICAgICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICBzdGF0ZSA9IHt9O1xuICAgICAgICAgICAgICAgICAgdXRpbHNfMS5vYmouc2V0UmVhZG9ubHkoZ3JpZCwgQlVUVE9OX0NPTFVNTl9TVEFURV9JRCwgc3RhdGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gQnV0dG9uQWN0aW9uO1xuICAgICAgICAgIH0oQWN0aW9uXzEuQWJzdHJhY3RBY3Rpb24pO1xuXG4gICAgICAgICAgZXhwb3J0cy5CdXR0b25BY3Rpb24gPSBCdXR0b25BY3Rpb247XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vY29sdW1ucy9hY3Rpb24vQ2hlY2tFZGl0b3IuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9jb2x1bW5zL2FjdGlvbi9DaGVja0VkaXRvci5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGNvbHVtbnNBY3Rpb25DaGVja0VkaXRvckpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuQ2hlY2tFZGl0b3IgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgYWN0aW9uQmluZF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9hY3Rpb25CaW5kICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvYWN0aW9uL2FjdGlvbkJpbmQuanNcIik7XG5cbiAgICAgICAgICB2YXIgdXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uL2ludGVybmFsL3V0aWxzICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL3V0aWxzLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIGFjdGlvbl91dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9hY3Rpb24tdXRpbHMgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9hY3Rpb24vYWN0aW9uLXV0aWxzLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIERHX0VWRU5UX1RZUEVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uL2NvcmUvREdfRVZFTlRfVFlQRSAqL1xuICAgICAgICAgIFwiLi9jb3JlL0RHX0VWRU5UX1RZUEUuanNcIik7XG5cbiAgICAgICAgICB2YXIgRWRpdG9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL0VkaXRvciAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL2FjdGlvbi9FZGl0b3IuanNcIik7XG5cbiAgICAgICAgICB2YXIgYW5pbWF0ZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vaW50ZXJuYWwvYW5pbWF0ZSAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC9hbmltYXRlLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIHN5bWJvbE1hbmFnZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uL2ludGVybmFsL3N5bWJvbE1hbmFnZXIgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvc3ltYm9sTWFuYWdlci5qc1wiKTtcblxuICAgICAgICAgIHZhciBDSEVDS19DT0xVTU5fU1RBVEVfSUQgPSAoMCwgc3ltYm9sTWFuYWdlcl8xLmdldENoZWNrQ29sdW1uU3RhdGVJZCkoKTtcblxuICAgICAgICAgIHZhciBDaGVja0VkaXRvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0VkaXRvcl8xJEVkaXRvcjIpIHtcbiAgICAgICAgICAgIF9pbmhlcml0cyhDaGVja0VkaXRvciwgX0VkaXRvcl8xJEVkaXRvcjIpO1xuXG4gICAgICAgICAgICB2YXIgX3N1cGVyOSA9IF9jcmVhdGVTdXBlcihDaGVja0VkaXRvcik7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIENoZWNrRWRpdG9yKCkge1xuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2hlY2tFZGl0b3IpO1xuXG4gICAgICAgICAgICAgIHJldHVybiBfc3VwZXI5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhDaGVja0VkaXRvciwgW3tcbiAgICAgICAgICAgICAga2V5OiBcImNsb25lXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENoZWNrRWRpdG9yKHRoaXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJiaW5kR3JpZEV2ZW50XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kR3JpZEV2ZW50KGdyaWQsIGNlbGxJZCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpczE5ID0gdGhpcztcblxuICAgICAgICAgICAgICAgIHZhciBfc3RhdGUgPSBncmlkW0NIRUNLX0NPTFVNTl9TVEFURV9JRF07XG5cbiAgICAgICAgICAgICAgICBpZiAoIV9zdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgX3N0YXRlID0ge1xuICAgICAgICAgICAgICAgICAgICBibG9jazoge30sXG4gICAgICAgICAgICAgICAgICAgIGVsYXBzZWQ6IHt9XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgdXRpbHNfMS5vYmouc2V0UmVhZG9ubHkoZ3JpZCwgQ0hFQ0tfQ09MVU1OX1NUQVRFX0lELCBfc3RhdGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IF9zdGF0ZTtcblxuICAgICAgICAgICAgICAgIHZhciBfYWN0aW9uID0gZnVuY3Rpb24gYWN0aW9uKGNlbGwpIHtcbiAgICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IGdyaWQuZ2V0Q2VsbFJhbmdlKGNlbGwuY29sLCBjZWxsLnJvdyk7XG4gICAgICAgICAgICAgICAgICB2YXIgY2VsbEtleSA9IFwiXCIuY29uY2F0KHJhbmdlLnN0YXJ0LmNvbCwgXCI6XCIpLmNvbmNhdChyYW5nZS5zdGFydC5yb3cpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoKDAsIGFjdGlvbl91dGlsc18xLmlzUmVhZE9ubHlSZWNvcmQpKF90aGlzMTkucmVhZE9ubHksIGdyaWQsIGNlbGwucm93KSB8fCAoMCwgYWN0aW9uX3V0aWxzXzEuaXNEaXNhYmxlZFJlY29yZCkoX3RoaXMxOS5kaXNhYmxlZCwgZ3JpZCwgY2VsbC5yb3cpIHx8IHN0YXRlLmJsb2NrW2NlbGxLZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgdmFyIHJldCA9IGdyaWQuZG9DaGFuZ2VWYWx1ZShjZWxsLmNvbCwgY2VsbC5yb3csIGFjdGlvbl91dGlsc18xLnRvZ2dsZVZhbHVlKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb25DaGFuZ2UgPSBmdW5jdGlvbiBvbkNoYW5nZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVja2JveCBhbmltYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAoMCwgYW5pbWF0ZV8xLmFuaW1hdGUpKDIwMCwgZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9pbnQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHN0YXRlLmVsYXBzZWRbY2VsbEtleV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5lbGFwc2VkW2NlbGxLZXldID0gcG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGdyaWQuaW52YWxpZGF0ZUNlbGxSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCB1dGlsc18xLmlzUHJvbWlzZSkocmV0KSkge1xuICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmJsb2NrW2NlbGxLZXldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICByZXQudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgc3RhdGUuYmxvY2tbY2VsbEtleV07XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gaXNUYXJnZXQoY29sLCByb3cpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBncmlkLmdldExheW91dENlbGxJZChjb2wsIHJvdykgPT09IGNlbGxJZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheSgoMCwgYWN0aW9uQmluZF8xLmJpbmRDZWxsQ2xpY2tBY3Rpb24pKGdyaWQsIGNlbGxJZCwge1xuICAgICAgICAgICAgICAgICAgYWN0aW9uOiBfYWN0aW9uLFxuICAgICAgICAgICAgICAgICAgbW91c2VPdmVyOiBmdW5jdGlvbiBtb3VzZU92ZXIoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKDAsIGFjdGlvbl91dGlsc18xLmlzRGlzYWJsZWRSZWNvcmQpKF90aGlzMTkuZGlzYWJsZWQsIGdyaWQsIGUucm93KSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLm1vdXNlQWN0aXZlQ2VsbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICBjb2w6IGUuY29sLFxuICAgICAgICAgICAgICAgICAgICAgIHJvdzogZS5yb3dcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gZ3JpZC5nZXRDZWxsUmFuZ2UoZS5jb2wsIGUucm93KTtcbiAgICAgICAgICAgICAgICAgICAgZ3JpZC5pbnZhbGlkYXRlQ2VsbFJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgbW91c2VPdXQ6IGZ1bmN0aW9uIG1vdXNlT3V0KGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHN0YXRlLm1vdXNlQWN0aXZlQ2VsbDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gZ3JpZC5nZXRDZWxsUmFuZ2UoZS5jb2wsIGUucm93KTtcbiAgICAgICAgICAgICAgICAgICAgZ3JpZC5pbnZhbGlkYXRlQ2VsbFJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSksIF90b0NvbnN1bWFibGVBcnJheSgoMCwgYWN0aW9uQmluZF8xLmJpbmRDZWxsS2V5QWN0aW9uKShncmlkLCBjZWxsSWQsIHtcbiAgICAgICAgICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24gYWN0aW9uKF9lKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWxyYW5nZSA9IGdyaWQuc2VsZWN0aW9uLnJhbmdlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29sID0gZ3JpZC5zZWxlY3Rpb24uc2VsZWN0LmNvbDtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciByb3cgPSBzZWxyYW5nZS5zdGFydC5yb3c7IHJvdyA8PSBzZWxyYW5nZS5lbmQucm93OyByb3crKykge1xuICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNUYXJnZXQoY29sLCByb3cpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICBfYWN0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbDogY29sLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm93OiByb3dcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKSwgWy8vIHBhc3RlIHZhbHVlXG4gICAgICAgICAgICAgICAgZ3JpZC5saXN0ZW4oREdfRVZFTlRfVFlQRV8xLkRHX0VWRU5UX1RZUEUuUEFTVEVfQ0VMTCwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChlLm11bHRpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBtdWx0aSBjZWxsIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3Rpb25SYW5nZSA9IGdyaWQuc2VsZWN0aW9uLnJhbmdlO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoISgwLCB1dGlsc18xLmNlbGxFcXVhbHMpKHNlbGVjdGlvblJhbmdlLnN0YXJ0LCBzZWxlY3Rpb25SYW5nZS5lbmQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBtdWx0aSBwYXN0ZSB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBpZiAoIWlzVGFyZ2V0KGUuY29sLCBlLnJvdykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICB1dGlsc18xLmV2ZW50LmNhbmNlbChlLmV2ZW50KTtcbiAgICAgICAgICAgICAgICAgIHZhciBwYXN0ZVZhbHVlID0gZS5ub3JtYWxpemVWYWx1ZS50cmltKCk7XG4gICAgICAgICAgICAgICAgICBncmlkLmRvR2V0Q2VsbFZhbHVlKGUuY29sLCBlLnJvdywgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9ICgwLCBhY3Rpb25fdXRpbHNfMS50b2dnbGVWYWx1ZSkodmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChcIlwiLmNvbmNhdChuZXdWYWx1ZSkudHJpbSgpID09PSBwYXN0ZVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgX2FjdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2w6IGUuY29sLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm93OiBlLnJvd1xuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzUmVqZWN0VmFsdWUodmFsdWUsIHBhc3RlVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHJlY29yZCA9IGdyaWQuZ2V0Um93UmVjb3JkKGUucm93KTtcblxuICAgICAgICAgICAgICAgICAgICAgIGlmICghKDAsIHV0aWxzXzEuaXNQcm9taXNlKShyZWNvcmQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBncmlkLmZpcmVMaXN0ZW5lcnMoXCJyZWplY3RlZF9wYXN0ZV92YWx1ZXNcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWw6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sOiBlLmNvbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3c6IGUucm93LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZDogcmVjb3JkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmluZTogZ3JpZC5nZXRDb2x1bW5EZWZpbmUoZS5jb2wsIGUucm93KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXN0ZVZhbHVlOiBwYXN0ZVZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIm9uUGFzdGVDZWxsUmFuZ2VCb3hcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uUGFzdGVDZWxsUmFuZ2VCb3goZ3JpZCwgY2VsbCwgdmFsdWUsIGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoKDAsIGFjdGlvbl91dGlsc18xLmlzUmVhZE9ubHlSZWNvcmQpKHRoaXMucmVhZE9ubHksIGdyaWQsIGNlbGwucm93KSB8fCAoMCwgYWN0aW9uX3V0aWxzXzEuaXNEaXNhYmxlZFJlY29yZCkodGhpcy5kaXNhYmxlZCwgZ3JpZCwgY2VsbC5yb3cpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHBhc3RlVmFsdWUgPSB2YWx1ZS50cmltKCk7XG4gICAgICAgICAgICAgICAgZ3JpZC5kb0dldENlbGxWYWx1ZShjZWxsLmNvbCwgY2VsbC5yb3csIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gKDAsIGFjdGlvbl91dGlsc18xLnRvZ2dsZVZhbHVlKSh2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChcIlwiLmNvbmNhdChuZXdWYWx1ZSkudHJpbSgpID09PSBwYXN0ZVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyaWQuZG9DaGFuZ2VWYWx1ZShjZWxsLmNvbCwgY2VsbC5yb3csIGFjdGlvbl91dGlsc18xLnRvZ2dsZVZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNSZWplY3RWYWx1ZSh2YWx1ZSwgcGFzdGVWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5yZWplY3QoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwib25EZWxldGVDZWxsUmFuZ2VCb3hcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uRGVsZXRlQ2VsbFJhbmdlQm94KCkgey8vIG5vb3BcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gQ2hlY2tFZGl0b3I7XG4gICAgICAgICAgfShFZGl0b3JfMS5FZGl0b3IpO1xuXG4gICAgICAgICAgZXhwb3J0cy5DaGVja0VkaXRvciA9IENoZWNrRWRpdG9yO1xuXG4gICAgICAgICAgZnVuY3Rpb24gaXNSZWplY3RWYWx1ZShvbGRWYWx1ZSwgcGFzdGVWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKChvbGRWYWx1ZSAhPSBudWxsID8gXCJcIi5jb25jYXQob2xkVmFsdWUpLnRyaW0oKSA6IFwiXCIpID09PSBwYXN0ZVZhbHVlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gKDAsIGFjdGlvbl91dGlsc18xLnRvZ2dsZVZhbHVlKShvbGRWYWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQobmV3VmFsdWUpLnRyaW0oKSAhPT0gcGFzdGVWYWx1ZSAmJiBcIlwiLmNvbmNhdCgoMCwgYWN0aW9uX3V0aWxzXzEudG9nZ2xlVmFsdWUpKG5ld1ZhbHVlKSkudHJpbSgpICE9PSBwYXN0ZVZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKioqL1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2NvbHVtbnMvYWN0aW9uL0VkaXRvci5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9jb2x1bW5zL2FjdGlvbi9FZGl0b3IuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gY29sdW1uc0FjdGlvbkVkaXRvckpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuRWRpdG9yID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIEJhc2VBY3Rpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vQmFzZUFjdGlvbiAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL2FjdGlvbi9CYXNlQWN0aW9uLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIEVkaXRvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Jhc2VBY3Rpb25fMSRCYXNlQWN0Mikge1xuICAgICAgICAgICAgX2luaGVyaXRzKEVkaXRvciwgX0Jhc2VBY3Rpb25fMSRCYXNlQWN0Mik7XG5cbiAgICAgICAgICAgIHZhciBfc3VwZXIxMCA9IF9jcmVhdGVTdXBlcihFZGl0b3IpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBFZGl0b3IoKSB7XG4gICAgICAgICAgICAgIHZhciBfdGhpczIwO1xuXG4gICAgICAgICAgICAgIHZhciBvcHRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFZGl0b3IpO1xuXG4gICAgICAgICAgICAgIF90aGlzMjAgPSBfc3VwZXIxMC5jYWxsKHRoaXMsIG9wdGlvbik7XG4gICAgICAgICAgICAgIF90aGlzMjAuX3JlYWRPbmx5ID0gb3B0aW9uLnJlYWRPbmx5IHx8IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMyMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKEVkaXRvciwgW3tcbiAgICAgICAgICAgICAga2V5OiBcImVkaXRhYmxlXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJyZWFkT25seVwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVhZE9ubHk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHJlYWRPbmx5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVhZE9ubHkgPSByZWFkT25seTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ2hhbmdlUmVhZE9ubHlJbnRlcm5hbCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJvbkNoYW5nZVJlYWRPbmx5SW50ZXJuYWxcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uQ2hhbmdlUmVhZE9ubHlJbnRlcm5hbCgpIHsvLyBhYnN0cnVjdFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBFZGl0b3I7XG4gICAgICAgICAgfShCYXNlQWN0aW9uXzEuQmFzZUFjdGlvbik7XG5cbiAgICAgICAgICBleHBvcnRzLkVkaXRvciA9IEVkaXRvcjtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9jb2x1bW5zL2FjdGlvbi9JbmxpbmVJbnB1dEVkaXRvci5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2NvbHVtbnMvYWN0aW9uL0lubGluZUlucHV0RWRpdG9yLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gY29sdW1uc0FjdGlvbklubGluZUlucHV0RWRpdG9ySnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5JbmxpbmVJbnB1dEVkaXRvciA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBCYXNlSW5wdXRFZGl0b3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vQmFzZUlucHV0RWRpdG9yICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvYWN0aW9uL0Jhc2VJbnB1dEVkaXRvci5qc1wiKTtcblxuICAgICAgICAgIHZhciBJbmxpbmVJbnB1dEVsZW1lbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vaW50ZXJuYWwvSW5saW5lSW5wdXRFbGVtZW50ICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvYWN0aW9uL2ludGVybmFsL0lubGluZUlucHV0RWxlbWVudC5qc1wiKTtcblxuICAgICAgICAgIHZhciBzeW1ib2xNYW5hZ2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi9pbnRlcm5hbC9zeW1ib2xNYW5hZ2VyICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL3N5bWJvbE1hbmFnZXIuanNcIik7XG5cbiAgICAgICAgICB2YXIgdXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uL2ludGVybmFsL3V0aWxzICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL3V0aWxzLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIF8gPSAoMCwgc3ltYm9sTWFuYWdlcl8xLmdldElubGluZUlucHV0RWRpdG9yU3RhdGVJZCkoKTtcblxuICAgICAgICAgIGZ1bmN0aW9uIGdldFN0YXRlKGdyaWQpIHtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IGdyaWRbX107XG5cbiAgICAgICAgICAgIGlmICghc3RhdGUpIHtcbiAgICAgICAgICAgICAgc3RhdGUgPSB7fTtcbiAgICAgICAgICAgICAgdXRpbHNfMS5vYmouc2V0UmVhZG9ubHkoZ3JpZCwgXywgc3RhdGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXG5cbiAgICAgICAgICB2YXIgZ2xvYmFsRWxlbWVudCA9IG51bGw7XG4gICAgICAgICAgdmFyIGJpbmRHcmlkQ291bnQgPSAwO1xuXG4gICAgICAgICAgZnVuY3Rpb24gYXR0YWNoSW5wdXQoZ3JpZCwgY2VsbCwgZWRpdG9yLCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHN0YXRlID0gZ2V0U3RhdGUoZ3JpZCk7XG5cbiAgICAgICAgICAgIGlmICghZ2xvYmFsRWxlbWVudCkge1xuICAgICAgICAgICAgICBnbG9iYWxFbGVtZW50ID0gbmV3IElubGluZUlucHV0RWxlbWVudF8xLklubGluZUlucHV0RWxlbWVudCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXN0YXRlLmVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgc3RhdGUuZWxlbWVudCA9IGdsb2JhbEVsZW1lbnQ7XG4gICAgICAgICAgICAgIGJpbmRHcmlkQ291bnQrKztcbiAgICAgICAgICAgICAgZ3JpZC5hZGREaXNwb3NhYmxlKHtcbiAgICAgICAgICAgICAgICBkaXNwb3NlOiBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgICAgICAgICAgICAgYmluZEdyaWRDb3VudC0tO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoIWJpbmRHcmlkQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsRWxlbWVudCA9PT0gbnVsbCB8fCBnbG9iYWxFbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBnbG9iYWxFbGVtZW50LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsRWxlbWVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmVsZW1lbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdsb2JhbEVsZW1lbnQuYXR0YWNoKGdyaWQsIGVkaXRvciwgY2VsbC5jb2wsIGNlbGwucm93LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gZGV0YWNoSW5wdXQoZ3JpZEZvY3VzKSB7XG4gICAgICAgICAgICBpZiAoZ2xvYmFsRWxlbWVudCkge1xuICAgICAgICAgICAgICBnbG9iYWxFbGVtZW50LmRldGFjaChncmlkRm9jdXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGRvQ2hhbmdlVmFsdWUoX2dyaWQpIHtcbiAgICAgICAgICAgIGlmIChnbG9iYWxFbGVtZW50KSB7XG4gICAgICAgICAgICAgIGdsb2JhbEVsZW1lbnQuZG9DaGFuZ2VWYWx1ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBJbmxpbmVJbnB1dEVkaXRvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Jhc2VJbnB1dEVkaXRvcl8xJEJhKSB7XG4gICAgICAgICAgICBfaW5oZXJpdHMoSW5saW5lSW5wdXRFZGl0b3IsIF9CYXNlSW5wdXRFZGl0b3JfMSRCYSk7XG5cbiAgICAgICAgICAgIHZhciBfc3VwZXIxMSA9IF9jcmVhdGVTdXBlcihJbmxpbmVJbnB1dEVkaXRvcik7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIElubGluZUlucHV0RWRpdG9yKCkge1xuICAgICAgICAgICAgICB2YXIgX3RoaXMyMTtcblxuICAgICAgICAgICAgICB2YXIgb3B0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5saW5lSW5wdXRFZGl0b3IpO1xuXG4gICAgICAgICAgICAgIF90aGlzMjEgPSBfc3VwZXIxMS5jYWxsKHRoaXMsIG9wdGlvbik7XG4gICAgICAgICAgICAgIF90aGlzMjEuX2NsYXNzTGlzdCA9IG9wdGlvbi5jbGFzc0xpc3Q7XG4gICAgICAgICAgICAgIF90aGlzMjEuX3R5cGUgPSBvcHRpb24udHlwZTtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMjE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhJbmxpbmVJbnB1dEVkaXRvciwgW3tcbiAgICAgICAgICAgICAga2V5OiBcImNsYXNzTGlzdFwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2NsYXNzTGlzdCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0aGlzLl9jbGFzc0xpc3QpID8gdGhpcy5fY2xhc3NMaXN0IDogW3RoaXMuX2NsYXNzTGlzdF07XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGNsYXNzTGlzdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NsYXNzTGlzdCA9IGNsYXNzTGlzdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwidHlwZVwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdHlwZTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodHlwZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3R5cGUgPSB0eXBlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjbG9uZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbmxpbmVJbnB1dEVkaXRvcih0aGlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwib25JbnB1dENlbGxJbnRlcm5hbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25JbnB1dENlbGxJbnRlcm5hbChncmlkLCBjZWxsLCBpbnB1dFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYXR0YWNoSW5wdXQoZ3JpZCwgY2VsbCwgdGhpcywgaW5wdXRWYWx1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIm9uT3BlbkNlbGxJbnRlcm5hbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25PcGVuQ2VsbEludGVybmFsKGdyaWQsIGNlbGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMyMiA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICBncmlkLmRvR2V0Q2VsbFZhbHVlKGNlbGwuY29sLCBjZWxsLnJvdywgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICBhdHRhY2hJbnB1dChncmlkLCBjZWxsLCBfdGhpczIyLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIm9uQ2hhbmdlU2VsZWN0Q2VsbEludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbkNoYW5nZVNlbGVjdENlbGxJbnRlcm5hbChncmlkLCBfY2VsbCwgX3NlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgZG9DaGFuZ2VWYWx1ZShncmlkKTtcbiAgICAgICAgICAgICAgICBkZXRhY2hJbnB1dCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJvbkdyaWRTY3JvbGxJbnRlcm5hbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25HcmlkU2Nyb2xsSW50ZXJuYWwoZ3JpZCkge1xuICAgICAgICAgICAgICAgIGRvQ2hhbmdlVmFsdWUoZ3JpZCk7XG4gICAgICAgICAgICAgICAgZGV0YWNoSW5wdXQodHJ1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIm9uQ2hhbmdlRGlzYWJsZWRJbnRlcm5hbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25DaGFuZ2VEaXNhYmxlZEludGVybmFsKCkge1xuICAgICAgICAgICAgICAgIC8vIGNhbmNlbCBpbnB1dFxuICAgICAgICAgICAgICAgIGRldGFjaElucHV0KHRydWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJvbkNoYW5nZVJlYWRPbmx5SW50ZXJuYWxcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uQ2hhbmdlUmVhZE9ubHlJbnRlcm5hbCgpIHtcbiAgICAgICAgICAgICAgICAvLyBjYW5jZWwgaW5wdXRcbiAgICAgICAgICAgICAgICBkZXRhY2hJbnB1dCh0cnVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwib25TZXRJbnB1dEF0dHJzSW50ZXJuYWxcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uU2V0SW5wdXRBdHRyc0ludGVybmFsKGdyaWQsIF9jZWxsLCBpbnB1dCkge1xuICAgICAgICAgICAgICAgIElubGluZUlucHV0RWxlbWVudF8xLklubGluZUlucHV0RWxlbWVudC5zZXRJbnB1dEF0dHJzKHRoaXMsIGdyaWQsIGlucHV0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gSW5saW5lSW5wdXRFZGl0b3I7XG4gICAgICAgICAgfShCYXNlSW5wdXRFZGl0b3JfMS5CYXNlSW5wdXRFZGl0b3IpO1xuXG4gICAgICAgICAgZXhwb3J0cy5JbmxpbmVJbnB1dEVkaXRvciA9IElubGluZUlucHV0RWRpdG9yO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2NvbHVtbnMvYWN0aW9uL0lubGluZU1lbnVFZGl0b3IuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2NvbHVtbnMvYWN0aW9uL0lubGluZU1lbnVFZGl0b3IuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGNvbHVtbnNBY3Rpb25JbmxpbmVNZW51RWRpdG9ySnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5JbmxpbmVNZW51RWRpdG9yID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIHV0aWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi9pbnRlcm5hbC91dGlscyAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC91dGlscy5qc1wiKTtcblxuICAgICAgICAgIHZhciBhY3Rpb25fdXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vYWN0aW9uLXV0aWxzICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvYWN0aW9uL2FjdGlvbi11dGlscy5qc1wiKTtcblxuICAgICAgICAgIHZhciBER19FVkVOVF9UWVBFXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi9jb3JlL0RHX0VWRU5UX1RZUEUgKi9cbiAgICAgICAgICBcIi4vY29yZS9ER19FVkVOVF9UWVBFLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIEVkaXRvcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9FZGl0b3IgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9hY3Rpb24vRWRpdG9yLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIElubGluZU1lbnVFbGVtZW50XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL2ludGVybmFsL0lubGluZU1lbnVFbGVtZW50ICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvYWN0aW9uL2ludGVybmFsL0lubGluZU1lbnVFbGVtZW50LmpzXCIpO1xuXG4gICAgICAgICAgdmFyIHR5cGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uL3R5cGUgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy90eXBlLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIHN5bWJvbE1hbmFnZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uL2ludGVybmFsL3N5bWJvbE1hbmFnZXIgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvc3ltYm9sTWFuYWdlci5qc1wiKTtcblxuICAgICAgICAgIHZhciBtZW51X2l0ZW1zXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi9pbnRlcm5hbC9tZW51LWl0ZW1zICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL21lbnUtaXRlbXMuanNcIik7XG5cbiAgICAgICAgICB2YXIgXyA9ICgwLCBzeW1ib2xNYW5hZ2VyXzEuZ2V0SW5saW5lTWVudUVkaXRvclN0YXRlSWQpKCk7XG5cbiAgICAgICAgICBmdW5jdGlvbiBnZXRTdGF0ZShncmlkKSB7XG4gICAgICAgICAgICB2YXIgc3RhdGUgPSBncmlkW19dO1xuXG4gICAgICAgICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgICAgICAgIHN0YXRlID0ge307XG4gICAgICAgICAgICAgIHV0aWxzXzEub2JqLnNldFJlYWRvbmx5KGdyaWQsIF8sIHN0YXRlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcblxuXG4gICAgICAgICAgdmFyIGdsb2JhbEVsZW1lbnQgPSBudWxsO1xuICAgICAgICAgIHZhciBiaW5kR3JpZENvdW50ID0gMDtcblxuICAgICAgICAgIGZ1bmN0aW9uIGF0dGFjaE1lbnUoZ3JpZCwgY2VsbCwgZWRpdG9yLCB2YWx1ZSwgcmVjb3JkKSB7XG4gICAgICAgICAgICB2YXIgc3RhdGUgPSBnZXRTdGF0ZShncmlkKTtcblxuICAgICAgICAgICAgaWYgKCFnbG9iYWxFbGVtZW50KSB7XG4gICAgICAgICAgICAgIGdsb2JhbEVsZW1lbnQgPSBuZXcgSW5saW5lTWVudUVsZW1lbnRfMS5JbmxpbmVNZW51RWxlbWVudCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXN0YXRlLmVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgc3RhdGUuZWxlbWVudCA9IGdsb2JhbEVsZW1lbnQ7XG4gICAgICAgICAgICAgIGJpbmRHcmlkQ291bnQrKztcbiAgICAgICAgICAgICAgZ3JpZC5hZGREaXNwb3NhYmxlKHtcbiAgICAgICAgICAgICAgICBkaXNwb3NlOiBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgICAgICAgICAgICAgYmluZEdyaWRDb3VudC0tO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoIWJpbmRHcmlkQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsRWxlbWVudCA9PT0gbnVsbCB8fCBnbG9iYWxFbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBnbG9iYWxFbGVtZW50LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsRWxlbWVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmVsZW1lbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdsb2JhbEVsZW1lbnQuYXR0YWNoKGdyaWQsIGVkaXRvciwgY2VsbC5jb2wsIGNlbGwucm93LCB2YWx1ZSwgcmVjb3JkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBkZXRhY2hNZW51KGdyaWRGb2N1cykge1xuICAgICAgICAgICAgaWYgKGdsb2JhbEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgZ2xvYmFsRWxlbWVudC5kZXRhY2goZ3JpZEZvY3VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgS0VZX0VOVEVSID0gMTM7XG4gICAgICAgICAgdmFyIEtFWV9GMiA9IDExMztcblxuICAgICAgICAgIHZhciBJbmxpbmVNZW51RWRpdG9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRWRpdG9yXzEkRWRpdG9yMykge1xuICAgICAgICAgICAgX2luaGVyaXRzKElubGluZU1lbnVFZGl0b3IsIF9FZGl0b3JfMSRFZGl0b3IzKTtcblxuICAgICAgICAgICAgdmFyIF9zdXBlcjEyID0gX2NyZWF0ZVN1cGVyKElubGluZU1lbnVFZGl0b3IpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBJbmxpbmVNZW51RWRpdG9yKCkge1xuICAgICAgICAgICAgICB2YXIgX3RoaXMyMztcblxuICAgICAgICAgICAgICB2YXIgb3B0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5saW5lTWVudUVkaXRvcik7XG5cbiAgICAgICAgICAgICAgX3RoaXMyMyA9IF9zdXBlcjEyLmNhbGwodGhpcywgb3B0aW9uKTtcbiAgICAgICAgICAgICAgX3RoaXMyMy5fY2xhc3NMaXN0ID0gb3B0aW9uLmNsYXNzTGlzdDtcbiAgICAgICAgICAgICAgX3RoaXMyMy5fb3B0aW9ucyA9ICgwLCBtZW51X2l0ZW1zXzEubm9ybWFsaXplVG9Gbikob3B0aW9uLm9wdGlvbnMpO1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMyMztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKElubGluZU1lbnVFZGl0b3IsIFt7XG4gICAgICAgICAgICAgIGtleTogXCJkaXNwb3NlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwb3NlKCkgey8vIG5vb3BcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY2xhc3NMaXN0XCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fY2xhc3NMaXN0KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHRoaXMuX2NsYXNzTGlzdCkgPyB0aGlzLl9jbGFzc0xpc3QgOiBbdGhpcy5fY2xhc3NMaXN0XTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoY2xhc3NMaXN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xhc3NMaXN0ID0gY2xhc3NMaXN0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJvcHRpb25zXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcHRpb25zO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb3B0aW9ucyA9ICgwLCBtZW51X2l0ZW1zXzEubm9ybWFsaXplVG9Gbikob3B0aW9ucyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNsb25lXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IElubGluZU1lbnVFZGl0b3IodGhpcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIm9uQ2hhbmdlRGlzYWJsZWRJbnRlcm5hbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25DaGFuZ2VEaXNhYmxlZEludGVybmFsKCkge1xuICAgICAgICAgICAgICAgIC8vIGNhbmNlbCBpbnB1dFxuICAgICAgICAgICAgICAgIGRldGFjaE1lbnUodHJ1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIm9uQ2hhbmdlUmVhZE9ubHlJbnRlcm5hbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25DaGFuZ2VSZWFkT25seUludGVybmFsKCkge1xuICAgICAgICAgICAgICAgIC8vIGNhbmNlbCBpbnB1dFxuICAgICAgICAgICAgICAgIGRldGFjaE1lbnUodHJ1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImJpbmRHcmlkRXZlbnRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRHcmlkRXZlbnQoZ3JpZCwgY2VsbElkKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzMjQgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgdmFyIG9wZW4gPSBmdW5jdGlvbiBvcGVuKGNlbGwpIHtcbiAgICAgICAgICAgICAgICAgIGlmICgoMCwgYWN0aW9uX3V0aWxzXzEuaXNSZWFkT25seVJlY29yZCkoX3RoaXMyNC5yZWFkT25seSwgZ3JpZCwgY2VsbC5yb3cpIHx8ICgwLCBhY3Rpb25fdXRpbHNfMS5pc0Rpc2FibGVkUmVjb3JkKShfdGhpczI0LmRpc2FibGVkLCBncmlkLCBjZWxsLnJvdykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBncmlkLmRvR2V0Q2VsbFZhbHVlKGNlbGwuY29sLCBjZWxsLnJvdywgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWNvcmQgPSBncmlkLmdldFJvd1JlY29yZChjZWxsLnJvdyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCB1dGlsc18xLmlzUHJvbWlzZSkocmVjb3JkKSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGF0dGFjaE1lbnUoZ3JpZCwgY2VsbCwgX3RoaXMyNCwgdmFsdWUsIHJlY29yZCk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBpc1RhcmdldChjb2wsIHJvdykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGdyaWQuZ2V0TGF5b3V0Q2VsbElkKGNvbCwgcm93KSA9PT0gY2VsbElkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBbZ3JpZC5saXN0ZW4oREdfRVZFTlRfVFlQRV8xLkRHX0VWRU5UX1RZUEUuQ0xJQ0tfQ0VMTCwgZnVuY3Rpb24gKGNlbGwpIHtcbiAgICAgICAgICAgICAgICAgIGlmICghaXNUYXJnZXQoY2VsbC5jb2wsIGNlbGwucm93KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIG9wZW4oe1xuICAgICAgICAgICAgICAgICAgICBjb2w6IGNlbGwuY29sLFxuICAgICAgICAgICAgICAgICAgICByb3c6IGNlbGwucm93XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KSwgZ3JpZC5saXN0ZW4oREdfRVZFTlRfVFlQRV8xLkRHX0VWRU5UX1RZUEUuS0VZRE9XTiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChlLmtleUNvZGUgIT09IEtFWV9GMiAmJiBlLmtleUNvZGUgIT09IEtFWV9FTlRFUikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHZhciBzZWwgPSBncmlkLnNlbGVjdGlvbi5zZWxlY3Q7XG5cbiAgICAgICAgICAgICAgICAgIGlmICghaXNUYXJnZXQoc2VsLmNvbCwgc2VsLnJvdykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBpZiAob3Blbih7XG4gICAgICAgICAgICAgICAgICAgIGNvbDogc2VsLmNvbCxcbiAgICAgICAgICAgICAgICAgICAgcm93OiBzZWwucm93XG4gICAgICAgICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgICAgICBlLnN0b3BDZWxsTW92aW5nKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSksIGdyaWQubGlzdGVuKERHX0VWRU5UX1RZUEVfMS5ER19FVkVOVF9UWVBFLlNFTEVDVEVEX0NFTEwsIGZ1bmN0aW9uIChfZSkge1xuICAgICAgICAgICAgICAgICAgZGV0YWNoTWVudSgpO1xuICAgICAgICAgICAgICAgIH0pLCBncmlkLmxpc3RlbihER19FVkVOVF9UWVBFXzEuREdfRVZFTlRfVFlQRS5TQ1JPTEwsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIGRldGFjaE1lbnUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSksIC8vIG1vdXNlIG1vdmVcbiAgICAgICAgICAgICAgICBncmlkLmxpc3RlbihER19FVkVOVF9UWVBFXzEuREdfRVZFTlRfVFlQRS5NT1VTRU9WRVJfQ0VMTCwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICghaXNUYXJnZXQoZS5jb2wsIGUucm93KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGlmICgoMCwgYWN0aW9uX3V0aWxzXzEuaXNSZWFkT25seVJlY29yZCkoX3RoaXMyNC5yZWFkT25seSwgZ3JpZCwgZS5yb3cpIHx8ICgwLCBhY3Rpb25fdXRpbHNfMS5pc0Rpc2FibGVkUmVjb3JkKShfdGhpczI0LmRpc2FibGVkLCBncmlkLCBlLnJvdykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBncmlkLmdldEVsZW1lbnQoKS5zdHlsZS5jdXJzb3IgPSBcInBvaW50ZXJcIjtcbiAgICAgICAgICAgICAgICB9KSwgZ3JpZC5saXN0ZW4oREdfRVZFTlRfVFlQRV8xLkRHX0VWRU5UX1RZUEUuTU9VU0VNT1ZFX0NFTEwsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIWlzVGFyZ2V0KGUuY29sLCBlLnJvdykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBpZiAoKDAsIGFjdGlvbl91dGlsc18xLmlzUmVhZE9ubHlSZWNvcmQpKF90aGlzMjQucmVhZE9ubHksIGdyaWQsIGUucm93KSB8fCAoMCwgYWN0aW9uX3V0aWxzXzEuaXNEaXNhYmxlZFJlY29yZCkoX3RoaXMyNC5kaXNhYmxlZCwgZ3JpZCwgZS5yb3cpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgaWYgKCFncmlkLmdldEVsZW1lbnQoKS5zdHlsZS5jdXJzb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JpZC5nZXRFbGVtZW50KCkuc3R5bGUuY3Vyc29yID0gXCJwb2ludGVyXCI7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSksIGdyaWQubGlzdGVuKERHX0VWRU5UX1RZUEVfMS5ER19FVkVOVF9UWVBFLk1PVVNFT1VUX0NFTEwsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIWlzVGFyZ2V0KGUuY29sLCBlLnJvdykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBncmlkLmdldEVsZW1lbnQoKS5zdHlsZS5jdXJzb3IgPSBcIlwiO1xuICAgICAgICAgICAgICAgIH0pLCAvLyBwYXN0ZSB2YWx1ZVxuICAgICAgICAgICAgICAgIGdyaWQubGlzdGVuKERHX0VWRU5UX1RZUEVfMS5ER19FVkVOVF9UWVBFLlBBU1RFX0NFTEwsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZS5tdWx0aSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgbXVsdGkgY2VsbCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICB2YXIgc2VsZWN0aW9uUmFuZ2UgPSBncmlkLnNlbGVjdGlvbi5yYW5nZTtcblxuICAgICAgICAgICAgICAgICAgaWYgKCEoMCwgdXRpbHNfMS5jZWxsRXF1YWxzKShzZWxlY3Rpb25SYW5nZS5zdGFydCwgc2VsZWN0aW9uUmFuZ2UuZW5kKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgbXVsdGkgcGFzdGUgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgaWYgKCFpc1RhcmdldChlLmNvbCwgZS5yb3cpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgaWYgKCgwLCBhY3Rpb25fdXRpbHNfMS5pc1JlYWRPbmx5UmVjb3JkKShfdGhpczI0LnJlYWRPbmx5LCBncmlkLCBlLnJvdykgfHwgKDAsIGFjdGlvbl91dGlsc18xLmlzRGlzYWJsZWRSZWNvcmQpKF90aGlzMjQuZGlzYWJsZWQsIGdyaWQsIGUucm93KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHZhciByZWNvcmQgPSBncmlkLmdldFJvd1JlY29yZChlLnJvdyk7XG5cbiAgICAgICAgICAgICAgICAgIGlmICgoMCwgdXRpbHNfMS5pc1Byb21pc2UpKHJlY29yZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICB2YXIgcGFzdGVPcHQgPSBfdGhpczI0Ll9wYXN0ZURhdGFUb09wdGlvblZhbHVlKGUubm9ybWFsaXplVmFsdWUsIGdyaWQsIGUsIHJlY29yZCk7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChwYXN0ZU9wdCkge1xuICAgICAgICAgICAgICAgICAgICB1dGlsc18xLmV2ZW50LmNhbmNlbChlLmV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgKDAsIHV0aWxzXzEudGhlbikoZ3JpZC5kb0NoYW5nZVZhbHVlKGUuY29sLCBlLnJvdywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXN0ZU9wdC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBncmlkLmdldENlbGxSYW5nZShlLmNvbCwgZS5yb3cpO1xuICAgICAgICAgICAgICAgICAgICAgIGdyaWQuaW52YWxpZGF0ZUNlbGxSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JpZC5maXJlTGlzdGVuZXJzKFwicmVqZWN0ZWRfcGFzdGVfdmFsdWVzXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICBkZXRhaWw6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2w6IGUuY29sLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm93OiBlLnJvdyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZDogcmVjb3JkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmaW5lOiBncmlkLmdldENvbHVtbkRlZmluZShlLmNvbCwgZS5yb3cpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFzdGVWYWx1ZTogZS5ub3JtYWxpemVWYWx1ZVxuICAgICAgICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwib25QYXN0ZUNlbGxSYW5nZUJveFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25QYXN0ZUNlbGxSYW5nZUJveChncmlkLCBjZWxsLCB2YWx1ZSwgY29udGV4dCkge1xuICAgICAgICAgICAgICAgIGlmICgoMCwgYWN0aW9uX3V0aWxzXzEuaXNSZWFkT25seVJlY29yZCkodGhpcy5yZWFkT25seSwgZ3JpZCwgY2VsbC5yb3cpIHx8ICgwLCBhY3Rpb25fdXRpbHNfMS5pc0Rpc2FibGVkUmVjb3JkKSh0aGlzLmRpc2FibGVkLCBncmlkLCBjZWxsLnJvdykpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcmVjb3JkID0gZ3JpZC5nZXRSb3dSZWNvcmQoY2VsbC5yb3cpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCgwLCB1dGlsc18xLmlzUHJvbWlzZSkocmVjb3JkKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBwYXN0ZU9wdCA9IHRoaXMuX3Bhc3RlRGF0YVRvT3B0aW9uVmFsdWUodmFsdWUsIGdyaWQsIGNlbGwsIHJlY29yZCk7XG5cbiAgICAgICAgICAgICAgICBpZiAocGFzdGVPcHQpIHtcbiAgICAgICAgICAgICAgICAgIGdyaWQuZG9DaGFuZ2VWYWx1ZShjZWxsLmNvbCwgY2VsbC5yb3csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhc3RlT3B0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIHVua25vd25cbiAgICAgICAgICAgICAgICAgIGNvbnRleHQucmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJvbkRlbGV0ZUNlbGxSYW5nZUJveFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25EZWxldGVDZWxsUmFuZ2VCb3goZ3JpZCwgY2VsbCkge1xuICAgICAgICAgICAgICAgIGlmICgoMCwgYWN0aW9uX3V0aWxzXzEuaXNSZWFkT25seVJlY29yZCkodGhpcy5yZWFkT25seSwgZ3JpZCwgY2VsbC5yb3cpIHx8ICgwLCBhY3Rpb25fdXRpbHNfMS5pc0Rpc2FibGVkUmVjb3JkKSh0aGlzLmRpc2FibGVkLCBncmlkLCBjZWxsLnJvdykpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcmVjb3JkID0gZ3JpZC5nZXRSb3dSZWNvcmQoY2VsbC5yb3cpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCgwLCB1dGlsc18xLmlzUHJvbWlzZSkocmVjb3JkKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBwYXN0ZU9wdCA9IHRoaXMuX3Bhc3RlRGF0YVRvT3B0aW9uVmFsdWUoXCJcIiwgZ3JpZCwgY2VsbCwgcmVjb3JkKTtcblxuICAgICAgICAgICAgICAgIGlmIChwYXN0ZU9wdCkge1xuICAgICAgICAgICAgICAgICAgZ3JpZC5kb0NoYW5nZVZhbHVlKGNlbGwuY29sLCBjZWxsLnJvdywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFzdGVPcHQudmFsdWU7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIl9wYXN0ZURhdGFUb09wdGlvblZhbHVlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcGFzdGVEYXRhVG9PcHRpb25WYWx1ZSh2YWx1ZSwgZ3JpZCwgY2VsbCwgcmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zKHJlY29yZCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgcGFzdGVPcHQgPSBfdGV4dFRvT3B0aW9uVmFsdWUodmFsdWUsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHBhc3RlT3B0KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcGFzdGVPcHQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGNvbHVtblR5cGUgPSBncmlkLmdldENvbHVtblR5cGUoY2VsbC5jb2wsIGNlbGwucm93KTtcblxuICAgICAgICAgICAgICAgIGlmIChoYXNPcHRpb25zKGNvbHVtblR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAvLyBGaW5kIHdpdGggY2FwdGlvbi5cbiAgICAgICAgICAgICAgICAgIHZhciBwYXN0ZVZhbHVlID0gbm9ybWFsaXplUGFzdGVWYWx1ZVN0cih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICB2YXIgY2FwdGlvbk9wdCA9IHV0aWxzXzEuYXJyYXkuZmluZChjb2x1bW5UeXBlLm9wdGlvbnMsIGZ1bmN0aW9uIChvcHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZVBhc3RlVmFsdWVTdHIob3B0LmxhYmVsKSA9PT0gcGFzdGVWYWx1ZTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoY2FwdGlvbk9wdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RleHRUb09wdGlvblZhbHVlKGNhcHRpb25PcHQudmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIElubGluZU1lbnVFZGl0b3I7XG4gICAgICAgICAgfShFZGl0b3JfMS5FZGl0b3IpO1xuXG4gICAgICAgICAgZXhwb3J0cy5JbmxpbmVNZW51RWRpdG9yID0gSW5saW5lTWVudUVkaXRvcjtcblxuICAgICAgICAgIGZ1bmN0aW9uIF90ZXh0VG9PcHRpb25WYWx1ZSh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIHBhc3RlVmFsdWUgPSBub3JtYWxpemVQYXN0ZVZhbHVlU3RyKHZhbHVlKTtcbiAgICAgICAgICAgIHZhciBwYXN0ZU9wdCA9IHV0aWxzXzEuYXJyYXkuZmluZChvcHRpb25zLCBmdW5jdGlvbiAob3B0KSB7XG4gICAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVQYXN0ZVZhbHVlU3RyKG9wdC52YWx1ZSkgPT09IHBhc3RlVmFsdWU7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKHBhc3RlT3B0KSB7XG4gICAgICAgICAgICAgIHJldHVybiBwYXN0ZU9wdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5cblxuICAgICAgICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVBhc3RlVmFsdWVTdHIodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQodmFsdWUpLnRyaW0oKTtcbiAgICAgICAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5cblxuICAgICAgICAgIGZ1bmN0aW9uIGhhc09wdGlvbnMoY29sdW1uVHlwZSkge1xuICAgICAgICAgICAgaWYgKGNvbHVtblR5cGUgaW5zdGFuY2VvZiB0eXBlXzEuTWVudUNvbHVtbikge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcblxuXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjb2x1bW5UeXBlLm9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKiovXG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vY29sdW1ucy9hY3Rpb24vUmFkaW9FZGl0b3IuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9jb2x1bW5zL2FjdGlvbi9SYWRpb0VkaXRvci5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGNvbHVtbnNBY3Rpb25SYWRpb0VkaXRvckpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuUmFkaW9FZGl0b3IgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgYWN0aW9uQmluZF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9hY3Rpb25CaW5kICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvYWN0aW9uL2FjdGlvbkJpbmQuanNcIik7XG5cbiAgICAgICAgICB2YXIgdXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uL2ludGVybmFsL3V0aWxzICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL3V0aWxzLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIGFjdGlvbl91dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9hY3Rpb24tdXRpbHMgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9hY3Rpb24vYWN0aW9uLXV0aWxzLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIERHX0VWRU5UX1RZUEVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uL2NvcmUvREdfRVZFTlRfVFlQRSAqL1xuICAgICAgICAgIFwiLi9jb3JlL0RHX0VWRU5UX1RZUEUuanNcIik7XG5cbiAgICAgICAgICB2YXIgRWRpdG9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL0VkaXRvciAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL2FjdGlvbi9FZGl0b3IuanNcIik7XG5cbiAgICAgICAgICB2YXIgYW5pbWF0ZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vaW50ZXJuYWwvYW5pbWF0ZSAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC9hbmltYXRlLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIHN5bWJvbE1hbmFnZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uL2ludGVybmFsL3N5bWJvbE1hbmFnZXIgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvc3ltYm9sTWFuYWdlci5qc1wiKTtcblxuICAgICAgICAgIHZhciB1dGlsc18yID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vdXRpbHMgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy91dGlscy9pbmRleC5qc1wiKTtcblxuICAgICAgICAgIHZhciBSQURJT19DT0xVTU5fU1RBVEVfSUQgPSAoMCwgc3ltYm9sTWFuYWdlcl8xLmdldFJhZGlvQ29sdW1uU3RhdGVJZCkoKTtcblxuICAgICAgICAgIHZhciBSYWRpb0VkaXRvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0VkaXRvcl8xJEVkaXRvcjQpIHtcbiAgICAgICAgICAgIF9pbmhlcml0cyhSYWRpb0VkaXRvciwgX0VkaXRvcl8xJEVkaXRvcjQpO1xuXG4gICAgICAgICAgICB2YXIgX3N1cGVyMTMgPSBfY3JlYXRlU3VwZXIoUmFkaW9FZGl0b3IpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBSYWRpb0VkaXRvcigpIHtcbiAgICAgICAgICAgICAgdmFyIF90aGlzMjU7XG5cbiAgICAgICAgICAgICAgdmFyIG9wdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJhZGlvRWRpdG9yKTtcblxuICAgICAgICAgICAgICBfdGhpczI1ID0gX3N1cGVyMTMuY2FsbCh0aGlzLCBvcHRpb24pO1xuICAgICAgICAgICAgICBfdGhpczI1Ll9ncm91cCA9IG9wdGlvbi5ncm91cDtcbiAgICAgICAgICAgICAgX3RoaXMyNS5fY2hlY2tBY3Rpb24gPSBvcHRpb24uY2hlY2tBY3Rpb247XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczI1O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoUmFkaW9FZGl0b3IsIFt7XG4gICAgICAgICAgICAgIGtleTogXCJjbG9uZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSYWRpb0VkaXRvcih0aGlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKiogQGRlcHJlY2F0ZWQgVXNlIGNoZWNrQWN0aW9uIGluc3RlYWQuICovXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImdyb3VwXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ncm91cDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKiogQGRlcHJlY2F0ZWQgVXNlIGNoZWNrQWN0aW9uIGluc3RlYWQuICovXG4gICAgICAgICAgICAgICxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoZ3JvdXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ncm91cCA9IGdyb3VwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjaGVja0FjdGlvblwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tBY3Rpb247XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGNoZWNrQWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hlY2tBY3Rpb24gPSBjaGVja0FjdGlvbjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiYmluZEdyaWRFdmVudFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYmluZEdyaWRFdmVudChncmlkLCBjZWxsSWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMyNiA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICB2YXIgX3N0YXRlID0gZ3JpZFtSQURJT19DT0xVTU5fU1RBVEVfSURdO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFfc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgIF9zdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2s6IHt9LFxuICAgICAgICAgICAgICAgICAgICBlbGFwc2VkOiB7fVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIHV0aWxzXzEub2JqLnNldFJlYWRvbmx5KGdyaWQsIFJBRElPX0NPTFVNTl9TVEFURV9JRCwgX3N0YXRlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgc3RhdGUgPSBfc3RhdGU7XG5cbiAgICAgICAgICAgICAgICB2YXIgYWN0aW9uID0gZnVuY3Rpb24gYWN0aW9uKGNlbGwpIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzMjYuX2FjdGlvbihncmlkLCBjZWxsKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gaXNUYXJnZXQoY29sLCByb3cpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBncmlkLmdldExheW91dENlbGxJZChjb2wsIHJvdykgPT09IGNlbGxJZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheSgoMCwgYWN0aW9uQmluZF8xLmJpbmRDZWxsQ2xpY2tBY3Rpb24pKGdyaWQsIGNlbGxJZCwge1xuICAgICAgICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgICAgICAgICAgICBtb3VzZU92ZXI6IGZ1bmN0aW9uIG1vdXNlT3ZlcihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoMCwgYWN0aW9uX3V0aWxzXzEuaXNEaXNhYmxlZFJlY29yZCkoX3RoaXMyNi5kaXNhYmxlZCwgZ3JpZCwgZS5yb3cpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgc3RhdGUubW91c2VBY3RpdmVDZWxsID0ge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbDogZS5jb2wsXG4gICAgICAgICAgICAgICAgICAgICAgcm93OiBlLnJvd1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBncmlkLmdldENlbGxSYW5nZShlLmNvbCwgZS5yb3cpO1xuICAgICAgICAgICAgICAgICAgICBncmlkLmludmFsaWRhdGVDZWxsUmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBtb3VzZU91dDogZnVuY3Rpb24gbW91c2VPdXQoZSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc3RhdGUubW91c2VBY3RpdmVDZWxsO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBncmlkLmdldENlbGxSYW5nZShlLmNvbCwgZS5yb3cpO1xuICAgICAgICAgICAgICAgICAgICBncmlkLmludmFsaWRhdGVDZWxsUmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKSwgX3RvQ29uc3VtYWJsZUFycmF5KCgwLCBhY3Rpb25CaW5kXzEuYmluZENlbGxLZXlBY3Rpb24pKGdyaWQsIGNlbGxJZCwge1xuICAgICAgICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb25cbiAgICAgICAgICAgICAgICB9KSksIFsvLyBwYXN0ZSB2YWx1ZVxuICAgICAgICAgICAgICAgIGdyaWQubGlzdGVuKERHX0VWRU5UX1RZUEVfMS5ER19FVkVOVF9UWVBFLlBBU1RFX0NFTEwsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZS5tdWx0aSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgbXVsdGkgY2VsbCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICB2YXIgc2VsZWN0aW9uUmFuZ2UgPSBncmlkLnNlbGVjdGlvbi5yYW5nZTtcblxuICAgICAgICAgICAgICAgICAgaWYgKCEoMCwgdXRpbHNfMS5jZWxsRXF1YWxzKShzZWxlY3Rpb25SYW5nZS5zdGFydCwgc2VsZWN0aW9uUmFuZ2UuZW5kKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgbXVsdGkgcGFzdGUgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgaWYgKCFpc1RhcmdldChlLmNvbCwgZS5yb3cpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgdXRpbHNfMS5ldmVudC5jYW5jZWwoZS5ldmVudCk7XG4gICAgICAgICAgICAgICAgICB2YXIgcGFzdGVWYWx1ZSA9IGUubm9ybWFsaXplVmFsdWUudHJpbSgpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoaXNSZWplY3RWYWx1ZShwYXN0ZVZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBOb3QgYSBib29sZWFuXG4gICAgICAgICAgICAgICAgICAgIHZhciByZWNvcmQgPSBncmlkLmdldFJvd1JlY29yZChlLnJvdyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoMCwgdXRpbHNfMS5pc1Byb21pc2UpKHJlY29yZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBncmlkLmZpcmVMaXN0ZW5lcnMoXCJyZWplY3RlZF9wYXN0ZV92YWx1ZXNcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjb2w6IGUuY29sLFxuICAgICAgICAgICAgICAgICAgICAgICAgICByb3c6IGUucm93LFxuICAgICAgICAgICAgICAgICAgICAgICAgICByZWNvcmQ6IHJlY29yZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmaW5lOiBncmlkLmdldENvbHVtbkRlZmluZShlLmNvbCwgZS5yb3cpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBwYXN0ZVZhbHVlOiBwYXN0ZVZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBpZiAoISgwLCB1dGlsc18yLnRvQm9vbGVhbikocGFzdGVWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBhY3Rpb24oe1xuICAgICAgICAgICAgICAgICAgICBjb2w6IGUuY29sLFxuICAgICAgICAgICAgICAgICAgICByb3c6IGUucm93XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KV0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJvblBhc3RlQ2VsbFJhbmdlQm94XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvblBhc3RlQ2VsbFJhbmdlQm94KGdyaWQsIGNlbGwsIHZhbHVlLCBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBhY3Rpb25fdXRpbHNfMS5pc1JlYWRPbmx5UmVjb3JkKSh0aGlzLnJlYWRPbmx5LCBncmlkLCBjZWxsLnJvdykgfHwgKDAsIGFjdGlvbl91dGlsc18xLmlzRGlzYWJsZWRSZWNvcmQpKHRoaXMuZGlzYWJsZWQsIGdyaWQsIGNlbGwucm93KSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBwYXN0ZVZhbHVlID0gdmFsdWUudHJpbSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzUmVqZWN0VmFsdWUocGFzdGVWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIE5vdCBhIGJvb2xlYW5cbiAgICAgICAgICAgICAgICAgIGNvbnRleHQucmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCEoMCwgdXRpbHNfMi50b0Jvb2xlYW4pKHBhc3RlVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aW9uKGdyaWQsIHtcbiAgICAgICAgICAgICAgICAgIGNvbDogY2VsbC5jb2wsXG4gICAgICAgICAgICAgICAgICByb3c6IGNlbGwucm93XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIm9uRGVsZXRlQ2VsbFJhbmdlQm94XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbkRlbGV0ZUNlbGxSYW5nZUJveCgpIHsvLyBub29wXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIl9hY3Rpb25cIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9hY3Rpb24oZ3JpZCwgY2VsbCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpczI3ID0gdGhpcztcblxuICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IGdyaWRbUkFESU9fQ09MVU1OX1NUQVRFX0lEXTtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBncmlkLmdldENlbGxSYW5nZShjZWxsLmNvbCwgY2VsbC5yb3cpO1xuICAgICAgICAgICAgICAgIHZhciBjZWxsS2V5ID0gXCJcIi5jb25jYXQocmFuZ2Uuc3RhcnQuY29sLCBcIjpcIikuY29uY2F0KHJhbmdlLnN0YXJ0LnJvdyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoKDAsIGFjdGlvbl91dGlsc18xLmlzUmVhZE9ubHlSZWNvcmQpKHRoaXMucmVhZE9ubHksIGdyaWQsIGNlbGwucm93KSB8fCAoMCwgYWN0aW9uX3V0aWxzXzEuaXNEaXNhYmxlZFJlY29yZCkodGhpcy5kaXNhYmxlZCwgZ3JpZCwgY2VsbC5yb3cpIHx8IHN0YXRlLmJsb2NrW2NlbGxLZXldKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZ3JpZC5kb0dldENlbGxWYWx1ZShjZWxsLmNvbCwgY2VsbC5yb3csIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKCgwLCB1dGlsc18yLnRvQm9vbGVhbikodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgaWYgKF90aGlzMjcuX2NoZWNrQWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZXIgYmVoYXZpb3JcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlY29yZCA9IGdyaWQuZ2V0Um93UmVjb3JkKGNlbGwucm93KTtcblxuICAgICAgICAgICAgICAgICAgICBfdGhpczI3Ll9jaGVja0FjdGlvbihyZWNvcmQsICgwLCB1dGlsc18xLmV4dGVuZCkoY2VsbCwge1xuICAgICAgICAgICAgICAgICAgICAgIGdyaWQ6IGdyaWRcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgaWYgKF90aGlzMjcuX2dyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9zdGF0ZTIgPSBncmlkW1JBRElPX0NPTFVNTl9TVEFURV9JRF07XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldHMgPSBfdGhpczI3Ll9ncm91cCh7XG4gICAgICAgICAgICAgICAgICAgICAgZ3JpZDogZ3JpZCxcbiAgICAgICAgICAgICAgICAgICAgICBjb2w6IGNlbGwuY29sLFxuICAgICAgICAgICAgICAgICAgICAgIHJvdzogY2VsbC5yb3dcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmMjIpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sID0gX3JlZjIyLmNvbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcm93ID0gX3JlZjIyLnJvdztcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBncmlkLmdldENlbGxSYW5nZShjb2wsIHJvdyk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGNlbGxLZXkgPSBcIlwiLmNvbmNhdChyYW5nZS5zdGFydC5jb2wsIFwiOlwiKS5jb25jYXQocmFuZ2Uuc3RhcnQucm93KTtcblxuICAgICAgICAgICAgICAgICAgICAgIGlmICgoMCwgYWN0aW9uX3V0aWxzXzEuaXNSZWFkT25seVJlY29yZCkoX3RoaXMyNy5yZWFkT25seSwgZ3JpZCwgY2VsbC5yb3cpIHx8ICgwLCBhY3Rpb25fdXRpbHNfMS5pc0Rpc2FibGVkUmVjb3JkKShfdGhpczI3LmRpc2FibGVkLCBncmlkLCBjZWxsLnJvdykgfHwgX3N0YXRlMi5ibG9ja1tjZWxsS2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbkNlbGwoZ3JpZCwgY29sLCByb3csIGNvbCA9PT0gY2VsbC5jb2wgJiYgcm93ID09PSBjZWxsLnJvdyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9IC8vIGRlZmF1bHQgYmVoYXZpb3JcblxuXG4gICAgICAgICAgICAgICAgICB2YXIgZmllbGQgPSBncmlkLmdldEZpZWxkKGNlbGwuY29sLCBjZWxsLnJvdyk7XG4gICAgICAgICAgICAgICAgICB2YXIgcmVjb3JkU3RhcnRSb3cgPSBncmlkLmdldFJlY29yZFN0YXJ0Um93QnlSZWNvcmRJbmRleChncmlkLmdldFJlY29yZEluZGV4QnlSb3coY2VsbC5yb3cpKTtcbiAgICAgICAgICAgICAgICAgIC8qKiBPcmlnaW5hbCBEYXRhU291cmNlICovXG5cbiAgICAgICAgICAgICAgICAgIHZhciBkYXRhU291cmNlID0gZ3JpZC5kYXRhU291cmNlLmRhdGFTb3VyY2U7XG4gICAgICAgICAgICAgICAgICB2YXIgZ2lyZFJlY29yZHMgPSBnZXRBbGxSZWNvcmRzRnJvbUdyaWQoZ3JpZCk7XG5cbiAgICAgICAgICAgICAgICAgIHZhciBfbG9vcDMgPSBmdW5jdGlvbiBfbG9vcDMoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlY29yZCA9IGRhdGFTb3VyY2UuZ2V0KGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNob3dEYXRhID0gZ2lyZFJlY29yZHMuZmluZChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkLnJlY29yZCA9PT0gcmVjb3JkO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvd0RhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25DZWxsKGdyaWQsIGNlbGwuY29sLCBzaG93RGF0YS5yb3csIHNob3dEYXRhLnJvdyA9PT0gcmVjb3JkU3RhcnRSb3cpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIEhpZGRlbiByZWNvcmRcbiAgICAgICAgICAgICAgICAgICAgICAoMCwgdXRpbHNfMS50aGVuKShkYXRhU291cmNlLmdldEZpZWxkKGluZGV4LCBmaWVsZCksIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoMCwgdXRpbHNfMi50b0Jvb2xlYW4pKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFTb3VyY2Uuc2V0RmllbGQoaW5kZXgsIGZpZWxkLCAoMCwgYWN0aW9uX3V0aWxzXzEudG9nZ2xlVmFsdWUpKHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBkYXRhU291cmNlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICBfbG9vcDMoaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBSYWRpb0VkaXRvcjtcbiAgICAgICAgICB9KEVkaXRvcl8xLkVkaXRvcik7XG5cbiAgICAgICAgICBleHBvcnRzLlJhZGlvRWRpdG9yID0gUmFkaW9FZGl0b3I7XG5cbiAgICAgICAgICBmdW5jdGlvbiBnZXRBbGxSZWNvcmRzRnJvbUdyaWQoZ3JpZCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgdmFyIHJvd0NvdW50ID0gZ3JpZC5yb3dDb3VudCxcbiAgICAgICAgICAgICAgICByZWNvcmRSb3dDb3VudCA9IGdyaWQucmVjb3JkUm93Q291bnQ7XG5cbiAgICAgICAgICAgIGZvciAodmFyIHRhcmdldFJvdyA9IGdyaWQuZnJvemVuUm93Q291bnQ7IHRhcmdldFJvdyA8IHJvd0NvdW50OyB0YXJnZXRSb3cgKz0gcmVjb3JkUm93Q291bnQpIHtcbiAgICAgICAgICAgICAgdmFyIHJlY29yZCA9IGdyaWQuZ2V0Um93UmVjb3JkKHRhcmdldFJvdyk7XG4gICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICByb3c6IHRhcmdldFJvdyxcbiAgICAgICAgICAgICAgICByZWNvcmQ6IHJlY29yZFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBhY3Rpb25DZWxsKGdyaWQsIGNvbCwgcm93LCBmbGFnKSB7XG4gICAgICAgICAgICBncmlkLmRvR2V0Q2VsbFZhbHVlKGNvbCwgcm93LCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgaWYgKCgwLCB1dGlsc18yLnRvQm9vbGVhbikodmFsdWUpID09PSBmbGFnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIHN0YXRlID0gZ3JpZFtSQURJT19DT0xVTU5fU1RBVEVfSURdO1xuICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBncmlkLmdldENlbGxSYW5nZShjb2wsIHJvdyk7XG4gICAgICAgICAgICAgIHZhciBjZWxsS2V5ID0gXCJcIi5jb25jYXQocmFuZ2Uuc3RhcnQuY29sLCBcIjpcIikuY29uY2F0KHJhbmdlLnN0YXJ0LnJvdyk7XG4gICAgICAgICAgICAgIHZhciByZXQgPSBncmlkLmRvQ2hhbmdlVmFsdWUoY29sLCByb3csIGFjdGlvbl91dGlsc18xLnRvZ2dsZVZhbHVlKTtcblxuICAgICAgICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgICAgICAgdmFyIG9uQ2hhbmdlID0gZnVuY3Rpb24gb25DaGFuZ2UoKSB7XG4gICAgICAgICAgICAgICAgICAvLyBjaGVja2JveCBhbmltYXRpb25cbiAgICAgICAgICAgICAgICAgICgwLCBhbmltYXRlXzEuYW5pbWF0ZSkoMjAwLCBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvaW50ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHN0YXRlLmVsYXBzZWRbY2VsbEtleV07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgc3RhdGUuZWxhcHNlZFtjZWxsS2V5XSA9IHBvaW50O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZ3JpZC5pbnZhbGlkYXRlQ2VsbFJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAoKDAsIHV0aWxzXzEuaXNQcm9taXNlKShyZXQpKSB7XG4gICAgICAgICAgICAgICAgICBzdGF0ZS5ibG9ja1tjZWxsS2V5XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICByZXQudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzdGF0ZS5ibG9ja1tjZWxsS2V5XTtcbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBvbkNoYW5nZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gaXNSZWplY3RWYWx1ZShwYXN0ZVZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGFjdGlvbl91dGlsc18xLnRvZ2dsZVZhbHVlKSgoMCwgYWN0aW9uX3V0aWxzXzEudG9nZ2xlVmFsdWUpKHBhc3RlVmFsdWUpKSAhPT0gcGFzdGVWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqKi9cblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9jb2x1bW5zL2FjdGlvbi9TbWFsbERpYWxvZ0lucHV0RWRpdG9yLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9jb2x1bW5zL2FjdGlvbi9TbWFsbERpYWxvZ0lucHV0RWRpdG9yLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBjb2x1bW5zQWN0aW9uU21hbGxEaWFsb2dJbnB1dEVkaXRvckpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuU21hbGxEaWFsb2dJbnB1dEVkaXRvciA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBCYXNlSW5wdXRFZGl0b3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vQmFzZUlucHV0RWRpdG9yICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvYWN0aW9uL0Jhc2VJbnB1dEVkaXRvci5qc1wiKTtcblxuICAgICAgICAgIHZhciBTbWFsbERpYWxvZ0lucHV0RWxlbWVudF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9pbnRlcm5hbC9TbWFsbERpYWxvZ0lucHV0RWxlbWVudCAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL2FjdGlvbi9pbnRlcm5hbC9TbWFsbERpYWxvZ0lucHV0RWxlbWVudC5qc1wiKTtcblxuICAgICAgICAgIHZhciBzeW1ib2xNYW5hZ2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi9pbnRlcm5hbC9zeW1ib2xNYW5hZ2VyICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL3N5bWJvbE1hbmFnZXIuanNcIik7XG5cbiAgICAgICAgICB2YXIgdXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uL2ludGVybmFsL3V0aWxzICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL3V0aWxzLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIF8gPSAoMCwgc3ltYm9sTWFuYWdlcl8xLmdldFNtYWxsRGlhbG9nSW5wdXRFZGl0b3JTdGF0ZUlkKSgpO1xuXG4gICAgICAgICAgZnVuY3Rpb24gZ2V0U3RhdGUoZ3JpZCkge1xuICAgICAgICAgICAgdmFyIHN0YXRlID0gZ3JpZFtfXTtcblxuICAgICAgICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICAgICAgICBzdGF0ZSA9IHt9O1xuICAgICAgICAgICAgICB1dGlsc18xLm9iai5zZXRSZWFkb25seShncmlkLCBfLCBzdGF0ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5cblxuICAgICAgICAgIHZhciBnbG9iYWxFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgICB2YXIgYmluZEdyaWRDb3VudCA9IDA7XG5cbiAgICAgICAgICBmdW5jdGlvbiBhdHRhY2hJbnB1dChncmlkLCBjZWxsLCBlZGl0b3IsIHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgc3RhdGUgPSBnZXRTdGF0ZShncmlkKTtcblxuICAgICAgICAgICAgaWYgKCFnbG9iYWxFbGVtZW50KSB7XG4gICAgICAgICAgICAgIGdsb2JhbEVsZW1lbnQgPSBuZXcgU21hbGxEaWFsb2dJbnB1dEVsZW1lbnRfMS5TbWFsbERpYWxvZ0lucHV0RWxlbWVudCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXN0YXRlLmVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgc3RhdGUuZWxlbWVudCA9IGdsb2JhbEVsZW1lbnQ7XG4gICAgICAgICAgICAgIGJpbmRHcmlkQ291bnQrKztcbiAgICAgICAgICAgICAgZ3JpZC5hZGREaXNwb3NhYmxlKHtcbiAgICAgICAgICAgICAgICBkaXNwb3NlOiBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgICAgICAgICAgICAgYmluZEdyaWRDb3VudC0tO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoIWJpbmRHcmlkQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsRWxlbWVudCA9PT0gbnVsbCB8fCBnbG9iYWxFbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBnbG9iYWxFbGVtZW50LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsRWxlbWVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmVsZW1lbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdsb2JhbEVsZW1lbnQuYXR0YWNoKGdyaWQsIGVkaXRvciwgY2VsbC5jb2wsIGNlbGwucm93LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gZGV0YWNoSW5wdXQoZ3JpZEZvY3VzKSB7XG4gICAgICAgICAgICBpZiAoZ2xvYmFsRWxlbWVudCkge1xuICAgICAgICAgICAgICBnbG9iYWxFbGVtZW50LmRldGFjaChncmlkRm9jdXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBTbWFsbERpYWxvZ0lucHV0RWRpdG9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZUlucHV0RWRpdG9yXzEkQmEyKSB7XG4gICAgICAgICAgICBfaW5oZXJpdHMoU21hbGxEaWFsb2dJbnB1dEVkaXRvciwgX0Jhc2VJbnB1dEVkaXRvcl8xJEJhMik7XG5cbiAgICAgICAgICAgIHZhciBfc3VwZXIxNCA9IF9jcmVhdGVTdXBlcihTbWFsbERpYWxvZ0lucHV0RWRpdG9yKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gU21hbGxEaWFsb2dJbnB1dEVkaXRvcigpIHtcbiAgICAgICAgICAgICAgdmFyIF90aGlzMjg7XG5cbiAgICAgICAgICAgICAgdmFyIG9wdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNtYWxsRGlhbG9nSW5wdXRFZGl0b3IpO1xuXG4gICAgICAgICAgICAgIF90aGlzMjggPSBfc3VwZXIxNC5jYWxsKHRoaXMsIG9wdGlvbik7XG4gICAgICAgICAgICAgIF90aGlzMjguX2hlbHBlclRleHQgPSBvcHRpb24uaGVscGVyVGV4dDtcbiAgICAgICAgICAgICAgX3RoaXMyOC5faW5wdXRWYWxpZGF0b3IgPSBvcHRpb24uaW5wdXRWYWxpZGF0b3I7XG4gICAgICAgICAgICAgIF90aGlzMjguX3ZhbGlkYXRvciA9IG9wdGlvbi52YWxpZGF0b3I7XG4gICAgICAgICAgICAgIF90aGlzMjguX2NsYXNzTGlzdCA9IG9wdGlvbi5jbGFzc0xpc3Q7XG4gICAgICAgICAgICAgIF90aGlzMjguX3R5cGUgPSBvcHRpb24udHlwZTtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMjg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhTbWFsbERpYWxvZ0lucHV0RWRpdG9yLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiZGlzcG9zZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGlzcG9zZSgpIHsvL25vb3BcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY2xhc3NMaXN0XCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fY2xhc3NMaXN0KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHRoaXMuX2NsYXNzTGlzdCkgPyB0aGlzLl9jbGFzc0xpc3QgOiBbdGhpcy5fY2xhc3NMaXN0XTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoY2xhc3NMaXN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xhc3NMaXN0ID0gY2xhc3NMaXN0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJ0eXBlXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90eXBlO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh0eXBlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHlwZSA9IHR5cGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImhlbHBlclRleHRcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hlbHBlclRleHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImlucHV0VmFsaWRhdG9yXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnB1dFZhbGlkYXRvcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwidmFsaWRhdG9yXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92YWxpZGF0b3I7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNsb25lXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNtYWxsRGlhbG9nSW5wdXRFZGl0b3IodGhpcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIm9uSW5wdXRDZWxsSW50ZXJuYWxcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uSW5wdXRDZWxsSW50ZXJuYWwoZ3JpZCwgY2VsbCwgaW5wdXRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGF0dGFjaElucHV0KGdyaWQsIGNlbGwsIHRoaXMsIGlucHV0VmFsdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJvbk9wZW5DZWxsSW50ZXJuYWxcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uT3BlbkNlbGxJbnRlcm5hbChncmlkLCBjZWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzMjkgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgZ3JpZC5kb0dldENlbGxWYWx1ZShjZWxsLmNvbCwgY2VsbC5yb3csIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgYXR0YWNoSW5wdXQoZ3JpZCwgY2VsbCwgX3RoaXMyOSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJvbkNoYW5nZVNlbGVjdENlbGxJbnRlcm5hbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25DaGFuZ2VTZWxlY3RDZWxsSW50ZXJuYWwoX2dyaWQsIF9jZWxsLCBfc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBjYW5jZWwgaW5wdXRcbiAgICAgICAgICAgICAgICBkZXRhY2hJbnB1dCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJvbkdyaWRTY3JvbGxJbnRlcm5hbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25HcmlkU2Nyb2xsSW50ZXJuYWwoX2dyaWQpIHtcbiAgICAgICAgICAgICAgICAvLyBjYW5jZWwgaW5wdXRcbiAgICAgICAgICAgICAgICBkZXRhY2hJbnB1dCh0cnVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwib25DaGFuZ2VEaXNhYmxlZEludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbkNoYW5nZURpc2FibGVkSW50ZXJuYWwoKSB7XG4gICAgICAgICAgICAgICAgLy8gY2FuY2VsIGlucHV0XG4gICAgICAgICAgICAgICAgZGV0YWNoSW5wdXQodHJ1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIm9uQ2hhbmdlUmVhZE9ubHlJbnRlcm5hbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25DaGFuZ2VSZWFkT25seUludGVybmFsKCkge1xuICAgICAgICAgICAgICAgIC8vIGNhbmNlbCBpbnB1dFxuICAgICAgICAgICAgICAgIGRldGFjaElucHV0KHRydWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJvblNldElucHV0QXR0cnNJbnRlcm5hbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25TZXRJbnB1dEF0dHJzSW50ZXJuYWwoZ3JpZCwgX2NlbGwsIGlucHV0KSB7XG4gICAgICAgICAgICAgICAgU21hbGxEaWFsb2dJbnB1dEVsZW1lbnRfMS5TbWFsbERpYWxvZ0lucHV0RWxlbWVudC5zZXRJbnB1dEF0dHJzKHRoaXMsIGdyaWQsIGlucHV0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gU21hbGxEaWFsb2dJbnB1dEVkaXRvcjtcbiAgICAgICAgICB9KEJhc2VJbnB1dEVkaXRvcl8xLkJhc2VJbnB1dEVkaXRvcik7XG5cbiAgICAgICAgICBleHBvcnRzLlNtYWxsRGlhbG9nSW5wdXRFZGl0b3IgPSBTbWFsbERpYWxvZ0lucHV0RWRpdG9yO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2NvbHVtbnMvYWN0aW9uL2FjdGlvbi11dGlscy5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9jb2x1bW5zL2FjdGlvbi9hY3Rpb24tdXRpbHMuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gY29sdW1uc0FjdGlvbkFjdGlvblV0aWxzSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy50b2dnbGVWYWx1ZSA9IGV4cG9ydHMuaXNSZWFkT25seVJlY29yZCA9IGV4cG9ydHMuaXNEaXNhYmxlZFJlY29yZCA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vaW50ZXJuYWwvdXRpbHMgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvdXRpbHMuanNcIik7XG5cbiAgICAgICAgICBmdW5jdGlvbiBpc0Rpc2FibGVkUmVjb3JkKG9wdGlvbiwgZ3JpZCwgcm93KSB7XG4gICAgICAgICAgICBpZiAoZ3JpZC5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGdldEJvb2xlYW5PcHRpb25PZlJlY29yZChvcHRpb24sIGdyaWQsIHJvdyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5pc0Rpc2FibGVkUmVjb3JkID0gaXNEaXNhYmxlZFJlY29yZDtcblxuICAgICAgICAgIGZ1bmN0aW9uIGlzUmVhZE9ubHlSZWNvcmQob3B0aW9uLCBncmlkLCByb3cpIHtcbiAgICAgICAgICAgIGlmIChncmlkLnJlYWRPbmx5KSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZ2V0Qm9vbGVhbk9wdGlvbk9mUmVjb3JkKG9wdGlvbiwgZ3JpZCwgcm93KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRzLmlzUmVhZE9ubHlSZWNvcmQgPSBpc1JlYWRPbmx5UmVjb3JkO1xuXG4gICAgICAgICAgZnVuY3Rpb24gdG9nZ2xlVmFsdWUodmFsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICBpZiAodmFsID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICBpZiAodmFsID09PSBcImZhbHNlXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJ0cnVlXCI7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsID09PSBcIm9mZlwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwib25cIjtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICgvXjArJC8uZXhlYyh2YWwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbC5yZXBsYWNlKC9eKDAqKTAkLywgXCIkMTFcIik7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsID09PSBcInRydWVcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBcImZhbHNlXCI7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsID09PSBcIm9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJvZmZcIjtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICgvXjAqMSQvLmV4ZWModmFsKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWwucmVwbGFjZSgvXigwKikxJC8sIFwiJDEwXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAhdmFsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMudG9nZ2xlVmFsdWUgPSB0b2dnbGVWYWx1ZTtcblxuICAgICAgICAgIGZ1bmN0aW9uIGdldEJvb2xlYW5PcHRpb25PZlJlY29yZChvcHRpb24sIGdyaWQsIHJvdykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICB2YXIgcmVjb3JkID0gZ3JpZC5nZXRSb3dSZWNvcmQocm93KTtcblxuICAgICAgICAgICAgICBpZiAoKDAsIHV0aWxzXzEuaXNQcm9taXNlKShyZWNvcmQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gISFvcHRpb24ocmVjb3JkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuICEhb3B0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKioqL1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2NvbHVtbnMvYWN0aW9uL2FjdGlvbkJpbmQuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2NvbHVtbnMvYWN0aW9uL2FjdGlvbkJpbmQuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGNvbHVtbnNBY3Rpb25BY3Rpb25CaW5kSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5iaW5kQ2VsbEtleUFjdGlvbiA9IGV4cG9ydHMuYmluZENlbGxDbGlja0FjdGlvbiA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vaW50ZXJuYWwvdXRpbHMgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvdXRpbHMuanNcIik7XG5cbiAgICAgICAgICB2YXIgREdfRVZFTlRfVFlQRV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vY29yZS9ER19FVkVOVF9UWVBFICovXG4gICAgICAgICAgXCIuL2NvcmUvREdfRVZFTlRfVFlQRS5qc1wiKTtcblxuICAgICAgICAgIHZhciBLRVlfRU5URVIgPSAxMztcbiAgICAgICAgICB2YXIgS0VZX1NQQUNFID0gMzI7XG5cbiAgICAgICAgICBmdW5jdGlvbiBiaW5kQ2VsbENsaWNrQWN0aW9uKGdyaWQsIGNlbGxJZCwgX3JlZjIzKSB7XG4gICAgICAgICAgICB2YXIgYWN0aW9uID0gX3JlZjIzLmFjdGlvbixcbiAgICAgICAgICAgICAgICBtb3VzZU92ZXIgPSBfcmVmMjMubW91c2VPdmVyLFxuICAgICAgICAgICAgICAgIG1vdXNlT3V0ID0gX3JlZjIzLm1vdXNlT3V0LFxuICAgICAgICAgICAgICAgIGFyZWEgPSBfcmVmMjMuYXJlYTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gaXNUYXJnZXQoY29sLCByb3cpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdyaWQuZ2V0TGF5b3V0Q2VsbElkKGNvbCwgcm93KSA9PT0gY2VsbElkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbW91c2VJc0luQ2VsbCA9IG51bGw7XG4gICAgICAgICAgICB2YXIgbW91c2VPdmVyZWQgPSBudWxsO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBwcm9jZXNzTW91c2VPdmVyKGUpIHtcbiAgICAgICAgICAgICAgbW91c2VPdmVyZWQgPSBlO1xuXG4gICAgICAgICAgICAgIGlmIChtb3VzZU92ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW1vdXNlT3Zlcih7XG4gICAgICAgICAgICAgICAgICBjb2w6IGUuY29sLFxuICAgICAgICAgICAgICAgICAgcm93OiBlLnJvd1xuICAgICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZ3JpZC5nZXRFbGVtZW50KCkuc3R5bGUuY3Vyc29yID0gXCJwb2ludGVyXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHByb2Nlc3NNb3VzZU91dChlKSB7XG4gICAgICAgICAgICAgIGlmIChtb3VzZU91dCkge1xuICAgICAgICAgICAgICAgIG1vdXNlT3V0KHtcbiAgICAgICAgICAgICAgICAgIGNvbDogZS5jb2wsXG4gICAgICAgICAgICAgICAgICByb3c6IGUucm93XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBtb3VzZU92ZXJlZCA9IG51bGw7XG4gICAgICAgICAgICAgIGdyaWQuZ2V0RWxlbWVudCgpLnN0eWxlLmN1cnNvciA9IFwiXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkaXNwb3NhYmxlcyA9IFsvLyBjbGlja1xuICAgICAgICAgICAgZ3JpZC5saXN0ZW4oREdfRVZFTlRfVFlQRV8xLkRHX0VWRU5UX1RZUEUuQ0xJQ0tfQ0VMTCwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc1RhcmdldChlLmNvbCwgZS5yb3cpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCgwLCB1dGlsc18xLmlzUHJvbWlzZSkoZ3JpZC5nZXRSb3dSZWNvcmQoZS5yb3cpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChhcmVhKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFhcmVhKGUpKSByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBhY3Rpb24oe1xuICAgICAgICAgICAgICAgIGNvbDogZS5jb2wsXG4gICAgICAgICAgICAgICAgcm93OiBlLnJvd1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pLCAvLyBtb3VzZSBtb3ZlXG4gICAgICAgICAgICBncmlkLmxpc3RlbihER19FVkVOVF9UWVBFXzEuREdfRVZFTlRfVFlQRS5NT1VTRU9WRVJfQ0VMTCwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc1RhcmdldChlLmNvbCwgZS5yb3cpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCgwLCB1dGlsc18xLmlzUHJvbWlzZSkoZ3JpZC5nZXRSb3dSZWNvcmQoZS5yb3cpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG1vdXNlSXNJbkNlbGwgPSBlO1xuXG4gICAgICAgICAgICAgIGlmIChhcmVhKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFhcmVhKGUpKSByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBwcm9jZXNzTW91c2VPdmVyKGUpO1xuICAgICAgICAgICAgfSksIGdyaWQubGlzdGVuKERHX0VWRU5UX1RZUEVfMS5ER19FVkVOVF9UWVBFLk1PVVNFT1VUX0NFTEwsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIGlmICghbW91c2VJc0luQ2VsbCB8fCBtb3VzZUlzSW5DZWxsLmNvbCAhPT0gZS5jb2wgfHwgbW91c2VJc0luQ2VsbC5yb3cgIT09IGUucm93KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCFtb3VzZU92ZXJlZCkge1xuICAgICAgICAgICAgICAgIHByb2Nlc3NNb3VzZU91dChlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSldO1xuXG4gICAgICAgICAgICBpZiAoYXJlYSkge1xuICAgICAgICAgICAgICBkaXNwb3NhYmxlcy5wdXNoKGdyaWQubGlzdGVuKERHX0VWRU5UX1RZUEVfMS5ER19FVkVOVF9UWVBFLk1PVVNFTU9WRV9DRUxMLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGlmICghbW91c2VJc0luQ2VsbCB8fCBtb3VzZUlzSW5DZWxsLmNvbCAhPT0gZS5jb2wgfHwgbW91c2VJc0luQ2VsbC5yb3cgIT09IGUucm93KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGlzSW5BcmVhID0gYXJlYShlKTtcblxuICAgICAgICAgICAgICAgIGlmICghbW91c2VPdmVyZWQpIHtcbiAgICAgICAgICAgICAgICAgIGlmICghaXNJbkFyZWEpIHJldHVybjsgLy8gbW91c2Ugb3ZlclxuXG4gICAgICAgICAgICAgICAgICBwcm9jZXNzTW91c2VPdmVyKGUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaXNJbkFyZWEpIHJldHVybjsgLy8gbW91c2Ugb3V0XG5cbiAgICAgICAgICAgICAgICAgIHByb2Nlc3NNb3VzZU91dChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGRpc3Bvc2FibGVzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMuYmluZENlbGxDbGlja0FjdGlvbiA9IGJpbmRDZWxsQ2xpY2tBY3Rpb247XG5cbiAgICAgICAgICBmdW5jdGlvbiBiaW5kQ2VsbEtleUFjdGlvbihncmlkLCBjZWxsSWQsIF9yZWYyNCkge1xuICAgICAgICAgICAgdmFyIGFjdGlvbiA9IF9yZWYyNC5hY3Rpb24sXG4gICAgICAgICAgICAgICAgX3JlZjI0JGFjY2VwdEtleXMgPSBfcmVmMjQuYWNjZXB0S2V5cyxcbiAgICAgICAgICAgICAgICBhY2NlcHRLZXlzID0gX3JlZjI0JGFjY2VwdEtleXMgPT09IHZvaWQgMCA/IFtdIDogX3JlZjI0JGFjY2VwdEtleXM7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGlzVGFyZ2V0KGNvbCwgcm93KSB7XG4gICAgICAgICAgICAgIHJldHVybiBncmlkLmdldExheW91dENlbGxJZChjb2wsIHJvdykgPT09IGNlbGxJZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYWNjZXB0S2V5cyA9IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoYWNjZXB0S2V5cyksIFtLRVlfRU5URVIsIEtFWV9TUEFDRV0pO1xuICAgICAgICAgICAgcmV0dXJuIFsvLyBlbnRlciBrZXkgZG93blxuICAgICAgICAgICAgZ3JpZC5saXN0ZW4oREdfRVZFTlRfVFlQRV8xLkRHX0VWRU5UX1RZUEUuS0VZRE9XTiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgdmFyIF9hO1xuXG4gICAgICAgICAgICAgIGlmIChhY2NlcHRLZXlzLmluZGV4T2YoZS5rZXlDb2RlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoKChfYSA9IGdyaWQua2V5Ym9hcmRPcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubW92ZUNlbGxPbkVudGVyKSAmJiBlLmtleUNvZGUgPT09IEtFWV9FTlRFUikge1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gbW92aW5nIHdpdGggdGhlIGVudGVyIGtleSwgbm8gYWN0aW9uIGlzIHRha2VuIHdpdGggdGhlIGVudGVyIGtleS5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgc2VsID0gZ3JpZC5zZWxlY3Rpb24uc2VsZWN0O1xuXG4gICAgICAgICAgICAgIGlmICghaXNUYXJnZXQoc2VsLmNvbCwgc2VsLnJvdykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoKDAsIHV0aWxzXzEuaXNQcm9taXNlKShncmlkLmdldFJvd1JlY29yZChzZWwucm93KSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBhY3Rpb24oe1xuICAgICAgICAgICAgICAgIGNvbDogc2VsLmNvbCxcbiAgICAgICAgICAgICAgICByb3c6IHNlbC5yb3dcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHV0aWxzXzEuZXZlbnQuY2FuY2VsKGUuZXZlbnQpO1xuICAgICAgICAgICAgfSldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMuYmluZENlbGxLZXlBY3Rpb24gPSBiaW5kQ2VsbEtleUFjdGlvbjtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9jb2x1bW5zL2FjdGlvbi9pbnRlcm5hbC9JbmxpbmVJbnB1dEVsZW1lbnQuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vY29sdW1ucy9hY3Rpb24vaW50ZXJuYWwvSW5saW5lSW5wdXRFbGVtZW50LmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGNvbHVtbnNBY3Rpb25JbnRlcm5hbElubGluZUlucHV0RWxlbWVudEpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuSW5saW5lSW5wdXRFbGVtZW50ID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIEV2ZW50SGFuZGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vLi4vaW50ZXJuYWwvRXZlbnRIYW5kbGVyICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL0V2ZW50SGFuZGxlci5qc1wiKTtcblxuICAgICAgICAgIHZhciBkb21fMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uLy4uL2ludGVybmFsL2RvbSAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC9kb20uanNcIik7XG5cbiAgICAgICAgICB2YXIgdXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uLy4uL2ludGVybmFsL3V0aWxzICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL3V0aWxzLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIGlucHV0X3ZhbHVlX2hhbmRsZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vaW5wdXQtdmFsdWUtaGFuZGxlciAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL2FjdGlvbi9pbnRlcm5hbC9pbnB1dC12YWx1ZS1oYW5kbGVyLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIEtFWV9UQUIgPSA5O1xuICAgICAgICAgIHZhciBLRVlfRU5URVIgPSAxMztcbiAgICAgICAgICB2YXIgQ0xBU1NOQU1FID0gXCJjaGVldGFoLWdyaWRfX2lubGluZS1pbnB1dFwiO1xuXG4gICAgICAgICAgZnVuY3Rpb24gY3JlYXRlSW5wdXRFbGVtZW50KCkge1xuICAgICAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISBAL2NvbHVtbnMvYWN0aW9uL2ludGVybmFsL0lubGluZUlucHV0RWxlbWVudC5jc3MgKi9cbiAgICAgICAgICAgIFwiLi4vc3JjL2pzL2NvbHVtbnMvYWN0aW9uL2ludGVybmFsL0lubGluZUlucHV0RWxlbWVudC5jc3NcIik7XG5cbiAgICAgICAgICAgIHJldHVybiAoMCwgZG9tXzEuY3JlYXRlRWxlbWVudCkoXCJpbnB1dFwiLCB7XG4gICAgICAgICAgICAgIGNsYXNzTGlzdDogQ0xBU1NOQU1FXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBfc2V0SW5wdXRBdHRycyhlZGl0b3IsIF9ncmlkLCBpbnB1dCkge1xuICAgICAgICAgICAgdmFyIGNsYXNzTGlzdCA9IGVkaXRvci5jbGFzc0xpc3QsXG4gICAgICAgICAgICAgICAgdHlwZSA9IGVkaXRvci50eXBlO1xuXG4gICAgICAgICAgICBpZiAoY2xhc3NMaXN0KSB7XG4gICAgICAgICAgICAgIHZhciBfaW5wdXQkY2xhc3NMaXN0O1xuXG4gICAgICAgICAgICAgIChfaW5wdXQkY2xhc3NMaXN0ID0gaW5wdXQuY2xhc3NMaXN0KS5hZGQuYXBwbHkoX2lucHV0JGNsYXNzTGlzdCwgX3RvQ29uc3VtYWJsZUFycmF5KGNsYXNzTGlzdCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpbnB1dC50eXBlID0gdHlwZSB8fCBcIlwiO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBJbmxpbmVJbnB1dEVsZW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gSW5saW5lSW5wdXRFbGVtZW50KCkge1xuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5saW5lSW5wdXRFbGVtZW50KTtcblxuICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyID0gbmV3IEV2ZW50SGFuZGxlcl8xLkV2ZW50SGFuZGxlcigpO1xuICAgICAgICAgICAgICB0aGlzLl9pbnB1dCA9IGNyZWF0ZUlucHV0RWxlbWVudCgpO1xuXG4gICAgICAgICAgICAgIHRoaXMuX2JpbmRJbnB1dEV2ZW50cygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoSW5saW5lSW5wdXRFbGVtZW50LCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiZGlzcG9zZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG5cbiAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLl9pbnB1dDtcbiAgICAgICAgICAgICAgICB0aGlzLmRldGFjaCgpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlci5kaXNwb3NlKCk7IC8vIEB0cy1leHBlY3QtZXJyb3IgLS0gaWdub3JlXG5cblxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9pbnB1dDtcbiAgICAgICAgICAgICAgICB0aGlzLl9iZWZvcmVQcm9wRWRpdG9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICAoX2EgPSBpbnB1dC5wYXJlbnRFbGVtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlQ2hpbGQoaW5wdXQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJhdHRhY2hcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGF0dGFjaChncmlkLCBlZGl0b3IsIGNvbCwgcm93LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpczMwID0gdGhpcztcblxuICAgICAgICAgICAgICAgIHZhciBpbnB1dCA9IHRoaXMuX2lucHV0O1xuICAgICAgICAgICAgICAgIHZhciBoYW5kbGVyID0gdGhpcy5faGFuZGxlcjtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9iZWZvcmVQcm9wRWRpdG9yKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY2xhc3NMaXN0ID0gdGhpcy5fYmVmb3JlUHJvcEVkaXRvci5jbGFzc0xpc3Q7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChjbGFzc0xpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9pbnB1dCRjbGFzc0xpc3QyO1xuXG4gICAgICAgICAgICAgICAgICAgIChfaW5wdXQkY2xhc3NMaXN0MiA9IGlucHV0LmNsYXNzTGlzdCkucmVtb3ZlLmFwcGx5KF9pbnB1dCRjbGFzc0xpc3QyLCBfdG9Db25zdW1hYmxlQXJyYXkoY2xhc3NMaXN0KSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaW5wdXQuc3R5bGUuZm9udCA9IGdyaWQuZm9udCB8fCBcIjE2cHggc2Fucy1zZXJpZlwiO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9ncmlkJGdldEF0dGFjaENlbGxzQSA9IGdyaWQuZ2V0QXR0YWNoQ2VsbHNBcmVhKGdyaWQuZ2V0Q2VsbFJhbmdlKGNvbCwgcm93KSksXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBfZ3JpZCRnZXRBdHRhY2hDZWxsc0EuZWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgcmVjdCA9IF9ncmlkJGdldEF0dGFjaENlbGxzQS5yZWN0O1xuXG4gICAgICAgICAgICAgICAgaW5wdXQuc3R5bGUudG9wID0gXCJcIi5jb25jYXQocmVjdC50b3AudG9GaXhlZCgpLCBcInB4XCIpO1xuICAgICAgICAgICAgICAgIGlucHV0LnN0eWxlLmxlZnQgPSBcIlwiLmNvbmNhdChyZWN0LmxlZnQudG9GaXhlZCgpLCBcInB4XCIpO1xuICAgICAgICAgICAgICAgIGlucHV0LnN0eWxlLndpZHRoID0gXCJcIi5jb25jYXQocmVjdC53aWR0aC50b0ZpeGVkKCksIFwicHhcIik7XG4gICAgICAgICAgICAgICAgaW5wdXQuc3R5bGUuaGVpZ2h0ID0gXCJcIi5jb25jYXQocmVjdC5oZWlnaHQudG9GaXhlZCgpLCBcInB4XCIpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoaW5wdXQpO1xuXG4gICAgICAgICAgICAgICAgX3NldElucHV0QXR0cnMoZWRpdG9yLCBncmlkLCBpbnB1dCk7XG5cbiAgICAgICAgICAgICAgICAoMCwgaW5wdXRfdmFsdWVfaGFuZGxlcl8xLnNldElucHV0VmFsdWUpKGlucHV0LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlRGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgIGdyaWQ6IGdyaWQsXG4gICAgICAgICAgICAgICAgICBjb2w6IGNvbCxcbiAgICAgICAgICAgICAgICAgIHJvdzogcm93LFxuICAgICAgICAgICAgICAgICAgZWRpdG9yOiBlZGl0b3JcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMuX2JlZm9yZVByb3BFZGl0b3IgPSBlZGl0b3I7XG5cbiAgICAgICAgICAgICAgICB2YXIgZm9jdXMgPSBmdW5jdGlvbiBmb2N1cygpIHtcbiAgICAgICAgICAgICAgICAgIGlucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICB2YXIgZW5kID0gaW5wdXQudmFsdWUubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0LnNlbGVjdGlvblN0YXJ0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaW5wdXQuc2VsZWN0aW9uU3RhcnQgPSBlbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgaW5wdXQuc2VsZWN0aW9uRW5kID0gZW5kO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkgey8vaWdub3JlXG4gICAgICAgICAgICAgICAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5cblxuICAgICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50LnNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBpbnB1dC5jcmVhdGVUZXh0UmFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UuY29sbGFwc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UubW92ZUVuZChcImNoYXJhY3RlclwiLCBlbmQpO1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5tb3ZlU3RhcnQoXCJjaGFyYWN0ZXJcIiwgZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc2VsZWN0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGhhbmRsZXIudHJ5V2l0aE9mZkV2ZW50cyhpbnB1dCwgXCJibHVyXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIGZvY3VzKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXR0YWNoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZSBfdGhpczMwLl9hdHRhY2hpbmc7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImRldGFjaFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGV0YWNoKGdyaWRGb2N1cykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc0FjdGl2ZSgpKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgX3RoaXMkX2FjdGl2ZURhdGEgPSB0aGlzLl9hY3RpdmVEYXRhLFxuICAgICAgICAgICAgICAgICAgICAgIGdyaWQgPSBfdGhpcyRfYWN0aXZlRGF0YS5ncmlkLFxuICAgICAgICAgICAgICAgICAgICAgIGNvbCA9IF90aGlzJF9hY3RpdmVEYXRhLmNvbCxcbiAgICAgICAgICAgICAgICAgICAgICByb3cgPSBfdGhpcyRfYWN0aXZlRGF0YS5yb3c7XG4gICAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLl9pbnB1dDtcblxuICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlci50cnlXaXRoT2ZmRXZlbnRzKGlucHV0LCBcImJsdXJcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG5cbiAgICAgICAgICAgICAgICAgICAgKF9hID0gaW5wdXQucGFyZW50RWxlbWVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZUNoaWxkKGlucHV0KTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBncmlkLmdldENlbGxSYW5nZShjb2wsIHJvdyk7XG4gICAgICAgICAgICAgICAgICBncmlkLmludmFsaWRhdGVDZWxsUmFuZ2UocmFuZ2UpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoZ3JpZEZvY3VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyaWQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmVEYXRhID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZG9DaGFuZ2VWYWx1ZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZG9DaGFuZ2VWYWx1ZSgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2lzQWN0aXZlKCkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLl9pbnB1dDtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBpbnB1dC52YWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMkX2FjdGl2ZURhdGEyID0gdGhpcy5fYWN0aXZlRGF0YSxcbiAgICAgICAgICAgICAgICAgICAgZ3JpZCA9IF90aGlzJF9hY3RpdmVEYXRhMi5ncmlkLFxuICAgICAgICAgICAgICAgICAgICBjb2wgPSBfdGhpcyRfYWN0aXZlRGF0YTIuY29sLFxuICAgICAgICAgICAgICAgICAgICByb3cgPSBfdGhpcyRfYWN0aXZlRGF0YTIucm93O1xuICAgICAgICAgICAgICAgIGdyaWQuZG9DaGFuZ2VWYWx1ZShjb2wsIHJvdywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJfaXNBY3RpdmVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9pc0FjdGl2ZSgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLl9pbnB1dDtcblxuICAgICAgICAgICAgICAgIGlmICghaW5wdXQgfHwgIWlucHV0LnBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2FjdGl2ZURhdGEpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiX2JpbmRJbnB1dEV2ZW50c1wiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2JpbmRJbnB1dEV2ZW50cygpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMzMSA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICB2YXIgaGFuZGxlciA9IHRoaXMuX2hhbmRsZXI7XG4gICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5faW5wdXQ7XG5cbiAgICAgICAgICAgICAgICB2YXIgc3RvcFByb3BhZ2F0aW9uT25seSA9IGZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbk9ubHkoZSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgfTsgLy8gZ3JpZOOBq+OCpOODmeODs+ODiOOBjOS8neaSreOBl+OBquOBhOOCiOOBhuOBq1xuXG5cbiAgICAgICAgICAgICAgICBoYW5kbGVyLm9uKGlucHV0LCBcImNsaWNrXCIsIHN0b3BQcm9wYWdhdGlvbk9ubHkpO1xuICAgICAgICAgICAgICAgIGhhbmRsZXIub24oaW5wdXQsIFwibW91c2Vkb3duXCIsIHN0b3BQcm9wYWdhdGlvbk9ubHkpO1xuICAgICAgICAgICAgICAgIGhhbmRsZXIub24oaW5wdXQsIFwidG91Y2hzdGFydFwiLCBzdG9wUHJvcGFnYXRpb25Pbmx5KTtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLm9uKGlucHV0LCBcImRibGNsaWNrXCIsIHN0b3BQcm9wYWdhdGlvbk9ubHkpO1xuICAgICAgICAgICAgICAgIGhhbmRsZXIub24oaW5wdXQsIFwiY29tcG9zaXRpb25zdGFydFwiLCBmdW5jdGlvbiAoX2UpIHtcbiAgICAgICAgICAgICAgICAgIGlucHV0LmNsYXNzTGlzdC5hZGQoXCJjb21wb3NpdGlvblwiKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLm9uKGlucHV0LCBcImNvbXBvc2l0aW9uZW5kXCIsIGZ1bmN0aW9uIChfZSkge1xuICAgICAgICAgICAgICAgICAgaW5wdXQuY2xhc3NMaXN0LnJlbW92ZShcImNvbXBvc2l0aW9uXCIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGhhbmRsZXIub24oaW5wdXQsIFwia2V5ZG93blwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LmNsYXNzTGlzdC5jb250YWlucyhcImNvbXBvc2l0aW9uXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgdmFyIGtleUNvZGUgPSB1dGlsc18xLmV2ZW50LmdldEtleUNvZGUoZSk7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChrZXlDb2RlID09PSBLRVlfRU5URVIpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMzMS5fb25LZXlkb3duRW50ZXIoZSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtleUNvZGUgPT09IEtFWV9UQUIpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMzMS5fb25LZXlkb3duVGFiKGUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGhhbmRsZXIub24oaW5wdXQsIFwiYmx1clwiLCBmdW5jdGlvbiAoX2UpIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzMzEuZG9DaGFuZ2VWYWx1ZSgpO1xuXG4gICAgICAgICAgICAgICAgICBfdGhpczMxLmRldGFjaCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJfb25LZXlkb3duRW50ZXJcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9vbktleWRvd25FbnRlcihlKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pc0FjdGl2ZSgpIHx8IHRoaXMuX2F0dGFjaGluZykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBncmlkID0gdGhpcy5fYWN0aXZlRGF0YS5ncmlkO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9DaGFuZ2VWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGV0YWNoKHRydWUpO1xuICAgICAgICAgICAgICAgIHV0aWxzXzEuZXZlbnQuY2FuY2VsKGUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKChfYSA9IGdyaWQua2V5Ym9hcmRPcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubW92ZUNlbGxPbkVudGVyKSB7XG4gICAgICAgICAgICAgICAgICBncmlkLm9uS2V5RG93bk1vdmUoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJfb25LZXlkb3duVGFiXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfb25LZXlkb3duVGFiKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2lzQWN0aXZlKCkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgZ3JpZCA9IHRoaXMuX2FjdGl2ZURhdGEuZ3JpZDtcblxuICAgICAgICAgICAgICAgIGlmICghKChfYSA9IGdyaWQua2V5Ym9hcmRPcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubW92ZUNlbGxPblRhYikpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmRvQ2hhbmdlVmFsdWUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRldGFjaCh0cnVlKTtcbiAgICAgICAgICAgICAgICBncmlkLm9uS2V5RG93bk1vdmUoZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwic2V0SW5wdXRBdHRyc1wiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0SW5wdXRBdHRycyhlZGl0b3IsIGdyaWQsIGlucHV0KSB7XG4gICAgICAgICAgICAgICAgX3NldElucHV0QXR0cnMoZWRpdG9yLCBncmlkLCBpbnB1dCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIElubGluZUlucHV0RWxlbWVudDtcbiAgICAgICAgICB9KCk7XG5cbiAgICAgICAgICBleHBvcnRzLklubGluZUlucHV0RWxlbWVudCA9IElubGluZUlucHV0RWxlbWVudDtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9jb2x1bW5zL2FjdGlvbi9pbnRlcm5hbC9JbmxpbmVNZW51RWxlbWVudC5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2NvbHVtbnMvYWN0aW9uL2ludGVybmFsL0lubGluZU1lbnVFbGVtZW50LmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gY29sdW1uc0FjdGlvbkludGVybmFsSW5saW5lTWVudUVsZW1lbnRKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLklubGluZU1lbnVFbGVtZW50ID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIGRvbV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vLi4vaW50ZXJuYWwvZG9tICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL2RvbS5qc1wiKTtcblxuICAgICAgICAgIHZhciBFdmVudEhhbmRsZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uLy4uL2ludGVybmFsL0V2ZW50SGFuZGxlciAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC9FdmVudEhhbmRsZXIuanNcIik7XG5cbiAgICAgICAgICB2YXIgdXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uLy4uL2ludGVybmFsL3V0aWxzICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL3V0aWxzLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIEtFWV9UQUIgPSA5O1xuICAgICAgICAgIHZhciBLRVlfRU5URVIgPSAxMztcbiAgICAgICAgICB2YXIgS0VZX1VQID0gMzg7XG4gICAgICAgICAgdmFyIEtFWV9ET1dOID0gNDA7XG4gICAgICAgICAgdmFyIEtFWV9FU0MgPSAyNztcbiAgICAgICAgICB2YXIgQ0xBU1NOQU1FID0gXCJjaGVldGFoLWdyaWRfX2lubGluZS1tZW51XCI7XG4gICAgICAgICAgdmFyIElURU1fQ0xBU1NOQU1FID0gXCJcIi5jb25jYXQoQ0xBU1NOQU1FLCBcIl9fbWVudS1pdGVtXCIpO1xuICAgICAgICAgIHZhciBISURERU5fQ0xBU1NOQU1FID0gXCJcIi5jb25jYXQoQ0xBU1NOQU1FLCBcIi0taGlkZGVuXCIpO1xuICAgICAgICAgIHZhciBTSE9XTl9DTEFTU05BTUUgPSBcIlwiLmNvbmNhdChDTEFTU05BTUUsIFwiLS1zaG93blwiKTtcbiAgICAgICAgICB2YXIgRU1QVFlfSVRFTV9DTEFTU05BTUUgPSBcIlwiLmNvbmNhdChJVEVNX0NMQVNTTkFNRSwgXCItLWVtcHR5XCIpO1xuXG4gICAgICAgICAgZnVuY3Rpb24gZmluZEl0ZW1QYXJlbnRzKHRhcmdldCkge1xuICAgICAgICAgICAgdmFyIGVsID0gdGFyZ2V0O1xuXG4gICAgICAgICAgICB3aGlsZSAoZWwgJiYgIWVsLmNsYXNzTGlzdC5jb250YWlucyhJVEVNX0NMQVNTTkFNRSkpIHtcbiAgICAgICAgICAgICAgZWwgPSBlbC5wYXJlbnRFbGVtZW50O1xuXG4gICAgICAgICAgICAgIGlmICghZWwgfHwgZWwuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTTkFNRSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gY3JlYXRlTWVudUVsZW1lbnQoKSB7XG4gICAgICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIEAvY29sdW1ucy9hY3Rpb24vaW50ZXJuYWwvSW5saW5lTWVudUVsZW1lbnQuY3NzICovXG4gICAgICAgICAgICBcIi4uL3NyYy9qcy9jb2x1bW5zL2FjdGlvbi9pbnRlcm5hbC9JbmxpbmVNZW51RWxlbWVudC5jc3NcIik7XG5cbiAgICAgICAgICAgIHJldHVybiAoMCwgZG9tXzEuY3JlYXRlRWxlbWVudCkoXCJ1bFwiLCB7XG4gICAgICAgICAgICAgIGNsYXNzTGlzdDogQ0xBU1NOQU1FXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBhdHRhY2hFbGVtZW50KGVsZW1lbnQsIHJlY3QsIG1lbnUpIHtcbiAgICAgICAgICAgIG1lbnUuc3R5bGUudG9wID0gXCJcIi5jb25jYXQocmVjdC50b3AudG9GaXhlZCgpLCBcInB4XCIpO1xuICAgICAgICAgICAgbWVudS5zdHlsZS5sZWZ0ID0gXCJcIi5jb25jYXQocmVjdC5sZWZ0LnRvRml4ZWQoKSwgXCJweFwiKTtcbiAgICAgICAgICAgIG1lbnUuc3R5bGUud2lkdGggPSBcIlwiLmNvbmNhdChyZWN0LndpZHRoLnRvRml4ZWQoKSwgXCJweFwiKTtcbiAgICAgICAgICAgIG1lbnUuc3R5bGUubGluZUhlaWdodCA9IFwiXCIuY29uY2F0KHJlY3QuaGVpZ2h0LnRvRml4ZWQoKSwgXCJweFwiKTtcbiAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQobWVudSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gb3B0aW9uVG9MaShfcmVmMjUsIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgY2xhc3NMaXN0ID0gX3JlZjI1LmNsYXNzTGlzdCxcbiAgICAgICAgICAgICAgICBsYWJlbCA9IF9yZWYyNS5sYWJlbCxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IF9yZWYyNS52YWx1ZSxcbiAgICAgICAgICAgICAgICBodG1sID0gX3JlZjI1Lmh0bWw7XG4gICAgICAgICAgICB2YXIgaXRlbSA9ICgwLCBkb21fMS5jcmVhdGVFbGVtZW50KShcImxpXCIsIHtcbiAgICAgICAgICAgICAgY2xhc3NMaXN0OiBJVEVNX0NMQVNTTkFNRVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpdGVtLnRhYkluZGV4ID0gMDtcbiAgICAgICAgICAgIGl0ZW0uZGF0YXNldC52YWx1ZWluZGV4ID0gXCJcIi5jb25jYXQoaW5kZXgpO1xuXG4gICAgICAgICAgICBpZiAoY2xhc3NMaXN0KSB7XG4gICAgICAgICAgICAgIHZhciBfaXRlbSRjbGFzc0xpc3Q7XG5cbiAgICAgICAgICAgICAgKF9pdGVtJGNsYXNzTGlzdCA9IGl0ZW0uY2xhc3NMaXN0KS5hZGQuYXBwbHkoX2l0ZW0kY2xhc3NMaXN0LCBfdG9Db25zdW1hYmxlQXJyYXkoQXJyYXkuaXNBcnJheShjbGFzc0xpc3QpID8gY2xhc3NMaXN0IDogW2NsYXNzTGlzdF0pKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxhYmVsKSB7XG4gICAgICAgICAgICAgIHZhciBzcGFuID0gKDAsIGRvbV8xLmNyZWF0ZUVsZW1lbnQpKFwic3BhblwiLCB7XG4gICAgICAgICAgICAgICAgdGV4dDogbGFiZWxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGl0ZW0uYXBwZW5kQ2hpbGQoc3Bhbik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGh0bWwpIHtcbiAgICAgICAgICAgICAgKDAsIGRvbV8xLmFwcGVuZEh0bWwpKGl0ZW0sIGh0bWwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IFwiXCIgfHwgdmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICBpdGVtLmNsYXNzTGlzdC5hZGQoRU1QVFlfSVRFTV9DTEFTU05BTUUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBvcGVuTWVudShncmlkLCBlZGl0b3IsIGNvbCwgcm93LCB2YWx1ZSwgb3B0aW9ucywgbWVudSkge1xuICAgICAgICAgICAgdmFyIGNsYXNzTGlzdCA9IGVkaXRvci5jbGFzc0xpc3Q7XG4gICAgICAgICAgICBtZW51LmNsYXNzTGlzdC5yZW1vdmUoU0hPV05fQ0xBU1NOQU1FKTtcbiAgICAgICAgICAgIG1lbnUuY2xhc3NMaXN0LmFkZChISURERU5fQ0xBU1NOQU1FKTtcbiAgICAgICAgICAgICgwLCBkb21fMS5lbXB0eSkobWVudSk7XG4gICAgICAgICAgICBtZW51LnN0eWxlLmZvbnQgPSBncmlkLmZvbnQgfHwgXCIxNnB4IHNhbnMtc2VyaWZcIjtcbiAgICAgICAgICAgIHZhciBlbXB0eUl0ZW1FbCA9IG51bGw7XG4gICAgICAgICAgICB2YXIgdmFsdWVJdGVtRWwgPSBudWxsO1xuICAgICAgICAgICAgb3B0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChvcHRpb24sIGkpIHtcbiAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBvcHRpb25Ub0xpKG9wdGlvbiwgaSk7XG4gICAgICAgICAgICAgIG1lbnUuYXBwZW5kQ2hpbGQoaXRlbSk7XG5cbiAgICAgICAgICAgICAgaWYgKG9wdGlvbi52YWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZUl0ZW1FbCA9IGl0ZW07XG4gICAgICAgICAgICAgICAgaXRlbS5kYXRhc2V0LnNlbGVjdCA9IFwic2VsZWN0XCI7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoaXRlbS5jbGFzc0xpc3QuY29udGFpbnMoRU1QVFlfSVRFTV9DTEFTU05BTUUpKSB7XG4gICAgICAgICAgICAgICAgZW1wdHlJdGVtRWwgPSBpdGVtO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBmb2N1c0VsID0gdmFsdWVJdGVtRWwgfHwgZW1wdHlJdGVtRWwgfHwgbWVudS5jaGlsZHJlblswXTtcblxuICAgICAgICAgICAgaWYgKGNsYXNzTGlzdCkge1xuICAgICAgICAgICAgICB2YXIgX21lbnUkY2xhc3NMaXN0O1xuXG4gICAgICAgICAgICAgIChfbWVudSRjbGFzc0xpc3QgPSBtZW51LmNsYXNzTGlzdCkuYWRkLmFwcGx5KF9tZW51JGNsYXNzTGlzdCwgX3RvQ29uc3VtYWJsZUFycmF5KGNsYXNzTGlzdCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChtZW51LmNoaWxkcmVuLCAwKTtcbiAgICAgICAgICAgIHZhciBmb2N1c0luZGV4ID0gY2hpbGRyZW4uaW5kZXhPZihmb2N1c0VsKTtcblxuICAgICAgICAgICAgdmFyIF9ncmlkJGdldEF0dGFjaENlbGxzQTIgPSBncmlkLmdldEF0dGFjaENlbGxzQXJlYShncmlkLmdldENlbGxSYW5nZShjb2wsIHJvdykpLFxuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBfZ3JpZCRnZXRBdHRhY2hDZWxsc0EyLmVsZW1lbnQsXG4gICAgICAgICAgICAgICAgcmVjdCA9IF9ncmlkJGdldEF0dGFjaENlbGxzQTIucmVjdDsgLy8gQ292ZXIgdGhlIHJpZ2h0IGxpbmVcblxuXG4gICAgICAgICAgICByZWN0LndpZHRoKys7IC8vIGFwcGVuZCBmb3IgY2FsY3VsYXRpb25cblxuICAgICAgICAgICAgYXR0YWNoRWxlbWVudChlbGVtZW50LCByZWN0LCBtZW51KTsgLy8gTWFrZSB0aGUgc2VsZWN0aW9uIGl0ZW0gYXQgdGhlIG1pZGRsZVxuXG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb2N1c0luZGV4OyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIG9mZnNldEhlaWdodCA9IGNoaWxkcmVuW2ldLm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgICAgb2Zmc2V0ICs9IG9mZnNldEhlaWdodDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVjdC5vZmZzZXRUb3AoLW9mZnNldCk7XG4gICAgICAgICAgICBtZW51LnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9IFwiY2VudGVyIFwiLmNvbmNhdChvZmZzZXQgKyBNYXRoLmNlaWwoY2hpbGRyZW5bZm9jdXNJbmRleF0ub2Zmc2V0SGVpZ2h0IC8gMiksIFwicHggMHB4XCIpO1xuICAgICAgICAgICAgYXR0YWNoRWxlbWVudChlbGVtZW50LCByZWN0LCBtZW51KTsgLy8gQ29udHJvbCBub3QgdG8gb3ZlcmZsb3cgdGhlIHNjcmVlbiByYW5nZVxuXG4gICAgICAgICAgICB2YXIgYmtUcmFuc2Zvcm0gPSBtZW51LnN0eWxlLnRyYW5zZm9ybTtcbiAgICAgICAgICAgIHZhciBtZW51Q2xpZW50UmVjdDtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgLy8gVG8gY2FsY3VsYXRlIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiwgc2V0IGB0cmFuc2Zvcm1gIHRvIGBub25lYC5cbiAgICAgICAgICAgICAgbWVudS5zdHlsZS50cmFuc2Zvcm0gPSBcIm5vbmVcIjtcbiAgICAgICAgICAgICAgbWVudUNsaWVudFJlY3QgPSBtZW51LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgbWVudS5zdHlsZS50cmFuc2Zvcm0gPSBia1RyYW5zZm9ybTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG9yZ01lbnVUb3AgPSBtZW51Q2xpZW50UmVjdC50b3A7XG4gICAgICAgICAgICB2YXIgbWVudVRvcCA9IG9yZ01lbnVUb3A7XG4gICAgICAgICAgICB2YXIgd2luQm90dG9tID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgICAgICAgICAgdmFyIHdpbk1hcmdpbiA9IDIwO1xuXG4gICAgICAgICAgICBpZiAobWVudUNsaWVudFJlY3QuYm90dG9tID4gd2luQm90dG9tIC0gd2luTWFyZ2luKSB7XG4gICAgICAgICAgICAgIHZhciBkaWZmID0gbWVudUNsaWVudFJlY3QuYm90dG9tIC0gd2luQm90dG9tICsgd2luTWFyZ2luO1xuICAgICAgICAgICAgICBtZW51VG9wIC09IGRpZmY7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtZW51VG9wIDwgMFxuICAgICAgICAgICAgLyp3aW5Ub3AqL1xuICAgICAgICAgICAgKyB3aW5NYXJnaW4pIHtcbiAgICAgICAgICAgICAgbWVudVRvcCA9IHdpbk1hcmdpbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1lbnVUb3AgIT09IG9yZ01lbnVUb3ApIHtcbiAgICAgICAgICAgICAgcmVjdC5vZmZzZXRUb3AoLShvcmdNZW51VG9wIC0gbWVudVRvcCkpOyAvLyBTZXRzIHRoZSBjZW50ZXIgb2YgdGhlIG1lbnUgc2luY2UgaXQgaXMgbm90IHBvc3NpYmxlIHRvIGRldGVybWluZSB0aGUgZXhhY3QgY2VudGVyIG9mIHRoZSBzZWxlY3RlZCBlbGVtZW50LlxuXG4gICAgICAgICAgICAgIG1lbnUuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gXCJjZW50ZXJcIjsgLy8gcmUgdXBkYXRlXG5cbiAgICAgICAgICAgICAgYXR0YWNoRWxlbWVudChlbGVtZW50LCByZWN0LCBtZW51KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGZvY3VzRWwpIHtcbiAgICAgICAgICAgICAgZm9jdXNFbC5mb2N1cygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZW51LmNsYXNzTGlzdC5yZW1vdmUoSElEREVOX0NMQVNTTkFNRSk7XG4gICAgICAgICAgICBtZW51LmNsYXNzTGlzdC5hZGQoU0hPV05fQ0xBU1NOQU1FKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBjbG9zZU1lbnUoX2dyaWQsIF9jb2wsIF9yb3csIG1lbnUpIHtcbiAgICAgICAgICAgIG1lbnUuY2xhc3NMaXN0LnJlbW92ZShTSE9XTl9DTEFTU05BTUUpO1xuICAgICAgICAgICAgbWVudS5jbGFzc0xpc3QuYWRkKEhJRERFTl9DTEFTU05BTUUpO1xuICAgICAgICAgICAgKDAsIGRvbV8xLmRpc2FibGVGb2N1cykobWVudSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIElubGluZU1lbnVFbGVtZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIElubGluZU1lbnVFbGVtZW50KCkge1xuICAgICAgICAgICAgICB2YXIgX3RoaXMzMiA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIElubGluZU1lbnVFbGVtZW50KTtcblxuICAgICAgICAgICAgICB2YXIgaGFuZGxlciA9IHRoaXMuX2hhbmRsZXIgPSBuZXcgRXZlbnRIYW5kbGVyXzEuRXZlbnRIYW5kbGVyKCk7XG4gICAgICAgICAgICAgIHRoaXMuX21lbnUgPSBjcmVhdGVNZW51RWxlbWVudCgpO1xuXG4gICAgICAgICAgICAgIHRoaXMuX2JpbmRNZW51RXZlbnRzKCk7XG5cbiAgICAgICAgICAgICAgdmFyIGJvZHlDbGlja0xpc3RlbmVySWQ7XG5cbiAgICAgICAgICAgICAgdmFyIGRlcmVnaXN0ZXJCb2R5Q2xpY2tMaXN0ZW5lciA9IHRoaXMuX2RlcmVnaXN0ZXJCb2R5Q2xpY2tMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlci5vZmYoYm9keUNsaWNrTGlzdGVuZXJJZCk7XG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgdGhpcy5fcmVnaXN0ZXJCb2R5Q2xpY2tMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBkZXJlZ2lzdGVyQm9keUNsaWNrTGlzdGVuZXIoKTtcbiAgICAgICAgICAgICAgICBib2R5Q2xpY2tMaXN0ZW5lcklkID0gaGFuZGxlci5vbihkb2N1bWVudC5ib2R5LCBcImNsaWNrXCIsIF90aGlzMzIuX29uQm9keUNsaWNrLmJpbmQoX3RoaXMzMiksIHtcbiAgICAgICAgICAgICAgICAgIGNhcHR1cmU6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKElubGluZU1lbnVFbGVtZW50LCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiZGlzcG9zZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG5cbiAgICAgICAgICAgICAgICB2YXIgbWVudSA9IHRoaXMuX21lbnU7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXRhY2goKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZXIuZGlzcG9zZSgpOyAvLyBAdHMtZXhwZWN0LWVycm9yIC0tIGlnbm9yZVxuXG5cbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fbWVudTtcbiAgICAgICAgICAgICAgICB0aGlzLl9iZWZvcmVQcm9wRWRpdG9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICAoX2EgPSBtZW51LnBhcmVudEVsZW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZW1vdmVDaGlsZChtZW51KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiYXR0YWNoXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRhY2goZ3JpZCwgZWRpdG9yLCBjb2wsIHJvdywgdmFsdWUsIHJlY29yZCkge1xuICAgICAgICAgICAgICAgIHZhciBtZW51ID0gdGhpcy5fbWVudTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9iZWZvcmVQcm9wRWRpdG9yKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY2xhc3NMaXN0ID0gdGhpcy5fYmVmb3JlUHJvcEVkaXRvci5jbGFzc0xpc3Q7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChjbGFzc0xpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9tZW51JGNsYXNzTGlzdDI7XG5cbiAgICAgICAgICAgICAgICAgICAgKF9tZW51JGNsYXNzTGlzdDIgPSBtZW51LmNsYXNzTGlzdCkucmVtb3ZlLmFwcGx5KF9tZW51JGNsYXNzTGlzdDIsIF90b0NvbnN1bWFibGVBcnJheShjbGFzc0xpc3QpKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IGVkaXRvci5vcHRpb25zKHJlY29yZCk7XG4gICAgICAgICAgICAgICAgb3Blbk1lbnUoZ3JpZCwgZWRpdG9yLCBjb2wsIHJvdywgdmFsdWUsIG9wdGlvbnMsIG1lbnUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZURhdGEgPSB7XG4gICAgICAgICAgICAgICAgICBncmlkOiBncmlkLFxuICAgICAgICAgICAgICAgICAgY29sOiBjb2wsXG4gICAgICAgICAgICAgICAgICByb3c6IHJvdyxcbiAgICAgICAgICAgICAgICAgIGVkaXRvcjogZWRpdG9yLFxuICAgICAgICAgICAgICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5fYmVmb3JlUHJvcEVkaXRvciA9IGVkaXRvcjtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3JlZ2lzdGVyQm9keUNsaWNrTGlzdGVuZXIoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZGV0YWNoXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXRhY2goZ3JpZEZvY3VzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzQWN0aXZlKCkpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyRfYWN0aXZlRGF0YTMgPSB0aGlzLl9hY3RpdmVEYXRhLFxuICAgICAgICAgICAgICAgICAgICAgIGdyaWQgPSBfdGhpcyRfYWN0aXZlRGF0YTMuZ3JpZCxcbiAgICAgICAgICAgICAgICAgICAgICBjb2wgPSBfdGhpcyRfYWN0aXZlRGF0YTMuY29sLFxuICAgICAgICAgICAgICAgICAgICAgIHJvdyA9IF90aGlzJF9hY3RpdmVEYXRhMy5yb3c7XG4gICAgICAgICAgICAgICAgICB2YXIgbWVudSA9IHRoaXMuX21lbnU7XG4gICAgICAgICAgICAgICAgICBjbG9zZU1lbnUoZ3JpZCwgY29sLCByb3csIG1lbnUpO1xuICAgICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gZ3JpZC5nZXRDZWxsUmFuZ2UoY29sLCByb3cpO1xuICAgICAgICAgICAgICAgICAgZ3JpZC5pbnZhbGlkYXRlQ2VsbFJhbmdlKHJhbmdlKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKGdyaWRGb2N1cykge1xuICAgICAgICAgICAgICAgICAgICBncmlkLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlRGF0YSA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9kZXJlZ2lzdGVyQm9keUNsaWNrTGlzdGVuZXIoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiX2RvQ2hhbmdlVmFsdWVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9kb0NoYW5nZVZhbHVlKHZhbHVlaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2lzQWN0aXZlKCkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMkX2FjdGl2ZURhdGE0ID0gdGhpcy5fYWN0aXZlRGF0YSxcbiAgICAgICAgICAgICAgICAgICAgZ3JpZCA9IF90aGlzJF9hY3RpdmVEYXRhNC5ncmlkLFxuICAgICAgICAgICAgICAgICAgICBjb2wgPSBfdGhpcyRfYWN0aXZlRGF0YTQuY29sLFxuICAgICAgICAgICAgICAgICAgICByb3cgPSBfdGhpcyRfYWN0aXZlRGF0YTQucm93LFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gX3RoaXMkX2FjdGl2ZURhdGE0Lm9wdGlvbnM7XG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbiA9IG9wdGlvbnNbTnVtYmVyKHZhbHVlaW5kZXgpXTtcblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IG9wdGlvbi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgIGdyaWQuZG9DaGFuZ2VWYWx1ZShjb2wsIHJvdywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIl9pc0FjdGl2ZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2lzQWN0aXZlKCkge1xuICAgICAgICAgICAgICAgIHZhciBtZW51ID0gdGhpcy5fbWVudTtcblxuICAgICAgICAgICAgICAgIGlmICghbWVudSB8fCAhbWVudS5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9hY3RpdmVEYXRhKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIl9iaW5kTWVudUV2ZW50c1wiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2JpbmRNZW51RXZlbnRzKCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpczMzID0gdGhpcztcblxuICAgICAgICAgICAgICAgIHZhciBoYW5kbGVyID0gdGhpcy5faGFuZGxlcjtcbiAgICAgICAgICAgICAgICB2YXIgbWVudSA9IHRoaXMuX21lbnU7XG5cbiAgICAgICAgICAgICAgICB2YXIgc3RvcFByb3BhZ2F0aW9uT25seSA9IGZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbk9ubHkoZSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgfTsgLy8gZ3JpZOOBq+OCpOODmeODs+ODiOOBjOS8neaSreOBl+OBquOBhOOCiOOBhuOBq1xuXG5cbiAgICAgICAgICAgICAgICBoYW5kbGVyLm9uKG1lbnUsIFwibW91c2Vkb3duXCIsIHN0b3BQcm9wYWdhdGlvbk9ubHkpO1xuICAgICAgICAgICAgICAgIGhhbmRsZXIub24obWVudSwgXCJ0b3VjaHN0YXJ0XCIsIHN0b3BQcm9wYWdhdGlvbk9ubHkpO1xuICAgICAgICAgICAgICAgIGhhbmRsZXIub24obWVudSwgXCJkYmxjbGlja1wiLCBzdG9wUHJvcGFnYXRpb25Pbmx5KTtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLm9uKG1lbnUsIFwiY2xpY2tcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IGZpbmRJdGVtUGFyZW50cyhlLnRhcmdldCk7XG5cbiAgICAgICAgICAgICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZWluZGV4ID0gaXRlbS5kYXRhc2V0LnZhbHVlaW5kZXg7XG5cbiAgICAgICAgICAgICAgICAgIF90aGlzMzMuX2RvQ2hhbmdlVmFsdWUodmFsdWVpbmRleCB8fCBcIlwiKTtcblxuICAgICAgICAgICAgICAgICAgX3RoaXMzMy5kZXRhY2godHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5vbihtZW51LCBcImtleWRvd25cIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gZmluZEl0ZW1QYXJlbnRzKGUudGFyZ2V0KTtcblxuICAgICAgICAgICAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgdmFyIGtleUNvZGUgPSB1dGlsc18xLmV2ZW50LmdldEtleUNvZGUoZSk7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChrZXlDb2RlID09PSBLRVlfRU5URVIpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMzMy5fb25LZXlkb3duRW50ZXIobWVudSwgaXRlbSwgZSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtleUNvZGUgPT09IEtFWV9FU0MpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMzMy5kZXRhY2godHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdXRpbHNfMS5ldmVudC5jYW5jZWwoZSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtleUNvZGUgPT09IEtFWV9VUCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9ICgwLCBkb21fMS5maW5kUHJldlNpYmxpbmdGb2N1c2FibGUpKGl0ZW0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgbi5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICAgIHV0aWxzXzEuZXZlbnQuY2FuY2VsKGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtleUNvZGUgPT09IEtFWV9ET1dOKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfbiA9ICgwLCBkb21fMS5maW5kTmV4dFNpYmxpbmdGb2N1c2FibGUpKGl0ZW0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChfbikge1xuICAgICAgICAgICAgICAgICAgICAgIF9uLmZvY3VzKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICB1dGlsc18xLmV2ZW50LmNhbmNlbChlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChrZXlDb2RlID09PSBLRVlfVEFCKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzMzMuX29uS2V5ZG93blRhYihtZW51LCBpdGVtLCBlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiX29uQm9keUNsaWNrXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfb25Cb2R5Q2xpY2soZSkge1xuICAgICAgICAgICAgICAgIHZhciBlbCA9IGUudGFyZ2V0O1xuXG4gICAgICAgICAgICAgICAgaWYgKCFlbCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tZW51LmNvbnRhaW5zKGVsKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc0FjdGl2ZSgpKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZ3JpZCA9IHRoaXMuX2FjdGl2ZURhdGEuZ3JpZDtcblxuICAgICAgICAgICAgICAgICAgaWYgKGdyaWQuZ2V0RWxlbWVudCgpLmNvbnRhaW5zKGVsKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5kZXRhY2goKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiX29uS2V5ZG93bkVudGVyXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfb25LZXlkb3duRW50ZXIoX21lbnUsIGl0ZW0sIGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG5cbiAgICAgICAgICAgICAgICB2YXIgZ3JpZCA9IHRoaXMuX2lzQWN0aXZlKCkgPyB0aGlzLl9hY3RpdmVEYXRhLmdyaWQgOiBudWxsO1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZWluZGV4ID0gaXRlbS5kYXRhc2V0LnZhbHVlaW5kZXg7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9kb0NoYW5nZVZhbHVlKHZhbHVlaW5kZXggfHwgXCJcIik7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmRldGFjaCh0cnVlKTtcbiAgICAgICAgICAgICAgICB1dGlsc18xLmV2ZW50LmNhbmNlbChlKTtcblxuICAgICAgICAgICAgICAgIGlmIChncmlkKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoKF9hID0gZ3JpZC5rZXlib2FyZE9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tb3ZlQ2VsbE9uRW50ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JpZC5vbktleURvd25Nb3ZlKGUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiX29uS2V5ZG93blRhYlwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX29uS2V5ZG93blRhYihtZW51LCBpdGVtLCBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzQWN0aXZlKCkpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBncmlkID0gdGhpcy5fYWN0aXZlRGF0YS5ncmlkO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoKF9hID0gZ3JpZC5rZXlib2FyZE9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tb3ZlQ2VsbE9uVGFiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZWluZGV4ID0gaXRlbS5kYXRhc2V0LnZhbHVlaW5kZXg7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZG9DaGFuZ2VWYWx1ZSh2YWx1ZWluZGV4IHx8IFwiXCIpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGV0YWNoKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBncmlkLm9uS2V5RG93bk1vdmUoZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWUuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICAgIGlmICghKDAsIGRvbV8xLmZpbmROZXh0U2libGluZ0ZvY3VzYWJsZSkoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBtZW51LnF1ZXJ5U2VsZWN0b3IoXCIuXCIuY29uY2F0KElURU1fQ0xBU1NOQU1FKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoMCwgZG9tXzEuaXNGb2N1c2FibGUpKG4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgbiA9ICgwLCBkb21fMS5maW5kTmV4dFNpYmxpbmdGb2N1c2FibGUpKG4pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICBuLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgdXRpbHNfMS5ldmVudC5jYW5jZWwoZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYgKCEoMCwgZG9tXzEuZmluZFByZXZTaWJsaW5nRm9jdXNhYmxlKShpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbXMgPSBtZW51LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuXCIuY29uY2F0KElURU1fQ0xBU1NOQU1FKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfbjIgPSBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoISgwLCBkb21fMS5pc0ZvY3VzYWJsZSkoX24yKSkge1xuICAgICAgICAgICAgICAgICAgICAgIF9uMiA9ICgwLCBkb21fMS5maW5kUHJldlNpYmxpbmdGb2N1c2FibGUpKF9uMik7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoX24yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgX24yLmZvY3VzKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICB1dGlsc18xLmV2ZW50LmNhbmNlbChlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gSW5saW5lTWVudUVsZW1lbnQ7XG4gICAgICAgICAgfSgpO1xuXG4gICAgICAgICAgZXhwb3J0cy5JbmxpbmVNZW51RWxlbWVudCA9IElubGluZU1lbnVFbGVtZW50O1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2NvbHVtbnMvYWN0aW9uL2ludGVybmFsL1NtYWxsRGlhbG9nSW5wdXRFbGVtZW50LmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vY29sdW1ucy9hY3Rpb24vaW50ZXJuYWwvU21hbGxEaWFsb2dJbnB1dEVsZW1lbnQuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBjb2x1bW5zQWN0aW9uSW50ZXJuYWxTbWFsbERpYWxvZ0lucHV0RWxlbWVudEpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuU21hbGxEaWFsb2dJbnB1dEVsZW1lbnQgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgdXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uLy4uL2ludGVybmFsL3V0aWxzICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL3V0aWxzLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIEV2ZW50SGFuZGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vLi4vaW50ZXJuYWwvRXZlbnRIYW5kbGVyICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL0V2ZW50SGFuZGxlci5qc1wiKTtcblxuICAgICAgICAgIHZhciBkb21fMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uLy4uL2ludGVybmFsL2RvbSAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC9kb20uanNcIik7XG5cbiAgICAgICAgICB2YXIgaW5wdXRfdmFsdWVfaGFuZGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9pbnB1dC12YWx1ZS1oYW5kbGVyICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvYWN0aW9uL2ludGVybmFsL2lucHV0LXZhbHVlLWhhbmRsZXIuanNcIik7XG5cbiAgICAgICAgICB2YXIgQ0xBU1NOQU1FID0gXCJjaGVldGFoLWdyaWRfX3NtYWxsLWRpYWxvZy1pbnB1dFwiO1xuICAgICAgICAgIHZhciBJTlBVVF9DTEFTU05BTUUgPSBcIlwiLmNvbmNhdChDTEFTU05BTUUsIFwiX19pbnB1dFwiKTtcbiAgICAgICAgICB2YXIgSElEREVOX0NMQVNTTkFNRSA9IFwiXCIuY29uY2F0KENMQVNTTkFNRSwgXCItLWhpZGRlblwiKTtcbiAgICAgICAgICB2YXIgU0hPV05fQ0xBU1NOQU1FID0gXCJcIi5jb25jYXQoQ0xBU1NOQU1FLCBcIi0tc2hvd25cIik7XG4gICAgICAgICAgdmFyIEtFWV9FTlRFUiA9IDEzO1xuICAgICAgICAgIHZhciBLRVlfRVNDID0gMjc7XG5cbiAgICAgICAgICBmdW5jdGlvbiBfZm9jdXMoaW5wdXQsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgIHZhciBmb2N1cyA9IGZ1bmN0aW9uIGZvY3VzKCkge1xuICAgICAgICAgICAgICBpbnB1dC5mb2N1cygpO1xuICAgICAgICAgICAgICB2YXIgZW5kID0gaW5wdXQudmFsdWUubGVuZ3RoO1xuXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dC5zZWxlY3Rpb25TdGFydCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgaW5wdXQuc2VsZWN0aW9uU3RhcnQgPSBlbmQ7XG4gICAgICAgICAgICAgICAgICBpbnB1dC5zZWxlY3Rpb25FbmQgPSBlbmQ7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7Ly9pZ25vcmVcbiAgICAgICAgICAgICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXG5cbiAgICAgICAgICAgICAgaWYgKGRvY3VtZW50LnNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gaW5wdXQuY3JlYXRlVGV4dFJhbmdlKCk7XG4gICAgICAgICAgICAgICAgcmFuZ2UuY29sbGFwc2UoKTtcbiAgICAgICAgICAgICAgICByYW5nZS5tb3ZlRW5kKFwiY2hhcmFjdGVyXCIsIGVuZCk7XG4gICAgICAgICAgICAgICAgcmFuZ2UubW92ZVN0YXJ0KFwiY2hhcmFjdGVyXCIsIGVuZCk7XG4gICAgICAgICAgICAgICAgcmFuZ2Uuc2VsZWN0KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGhhbmRsZXIudHJ5V2l0aE9mZkV2ZW50cyhpbnB1dCwgXCJibHVyXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgZm9jdXMoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZURpYWxvZ0VsZW1lbnQoKSB7XG4gICAgICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIEAvY29sdW1ucy9hY3Rpb24vaW50ZXJuYWwvU21hbGxEaWFsb2dJbnB1dEVsZW1lbnQuY3NzICovXG4gICAgICAgICAgICBcIi4uL3NyYy9qcy9jb2x1bW5zL2FjdGlvbi9pbnRlcm5hbC9TbWFsbERpYWxvZ0lucHV0RWxlbWVudC5jc3NcIik7XG5cbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gKDAsIGRvbV8xLmNyZWF0ZUVsZW1lbnQpKFwiZGl2XCIsIHtcbiAgICAgICAgICAgICAgY2xhc3NMaXN0OiBbQ0xBU1NOQU1FLCBISURERU5fQ0xBU1NOQU1FXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgaW5wdXQgPSAoMCwgZG9tXzEuY3JlYXRlRWxlbWVudCkoXCJpbnB1dFwiLCB7XG4gICAgICAgICAgICAgIGNsYXNzTGlzdDogSU5QVVRfQ0xBU1NOQU1FXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlucHV0LnJlYWRPbmx5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGlucHV0LnRhYkluZGV4ID0gLTE7XG4gICAgICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKGlucHV0KTtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGJpbmRQcm9wcyhncmlkLCBkaWFsb2csIGlucHV0LCBlZGl0b3IpIHtcbiAgICAgICAgICAgIHZhciBjbGFzc0xpc3QgPSBlZGl0b3IuY2xhc3NMaXN0LFxuICAgICAgICAgICAgICAgIGhlbHBlclRleHQgPSBlZGl0b3IuaGVscGVyVGV4dDtcblxuICAgICAgICAgICAgaWYgKGNsYXNzTGlzdCkge1xuICAgICAgICAgICAgICB2YXIgX2RpYWxvZyRjbGFzc0xpc3Q7XG5cbiAgICAgICAgICAgICAgKF9kaWFsb2ckY2xhc3NMaXN0ID0gZGlhbG9nLmNsYXNzTGlzdCkuYWRkLmFwcGx5KF9kaWFsb2ckY2xhc3NMaXN0LCBfdG9Db25zdW1hYmxlQXJyYXkoY2xhc3NMaXN0KSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChoZWxwZXJUZXh0ICYmIHR5cGVvZiBoZWxwZXJUZXh0ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgZGlhbG9nLmRhdGFzZXQuaGVscGVyVGV4dCA9IGhlbHBlclRleHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9zZXRJbnB1dEF0dHJzMihlZGl0b3IsIGdyaWQsIGlucHV0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiB1bmJpbmRQcm9wcyhfZ3JpZCwgZGlhbG9nLCBpbnB1dCwgZWRpdG9yKSB7XG4gICAgICAgICAgICB2YXIgY2xhc3NMaXN0ID0gZWRpdG9yLmNsYXNzTGlzdDtcblxuICAgICAgICAgICAgaWYgKGNsYXNzTGlzdCkge1xuICAgICAgICAgICAgICB2YXIgX2RpYWxvZyRjbGFzc0xpc3QyO1xuXG4gICAgICAgICAgICAgIChfZGlhbG9nJGNsYXNzTGlzdDIgPSBkaWFsb2cuY2xhc3NMaXN0KS5yZW1vdmUuYXBwbHkoX2RpYWxvZyRjbGFzc0xpc3QyLCBfdG9Db25zdW1hYmxlQXJyYXkoY2xhc3NMaXN0KSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlbGV0ZSBkaWFsb2cuZGF0YXNldC5oZWxwZXJUZXh0O1xuICAgICAgICAgICAgaW5wdXQudHlwZSA9IFwiXCI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gX3NldElucHV0QXR0cnMyKGVkaXRvciwgX2dyaWQsIGlucHV0KSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IGVkaXRvci50eXBlO1xuICAgICAgICAgICAgaW5wdXQudHlwZSA9IHR5cGUgfHwgXCJcIjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgU21hbGxEaWFsb2dJbnB1dEVsZW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gU21hbGxEaWFsb2dJbnB1dEVsZW1lbnQoKSB7XG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTbWFsbERpYWxvZ0lucHV0RWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgdGhpcy5faGFuZGxlciA9IG5ldyBFdmVudEhhbmRsZXJfMS5FdmVudEhhbmRsZXIoKTtcbiAgICAgICAgICAgICAgdGhpcy5fZGlhbG9nID0gY3JlYXRlRGlhbG9nRWxlbWVudCgpO1xuICAgICAgICAgICAgICB0aGlzLl9pbnB1dCA9IHRoaXMuX2RpYWxvZy5xdWVyeVNlbGVjdG9yKFwiLlwiLmNvbmNhdChJTlBVVF9DTEFTU05BTUUpKTtcblxuICAgICAgICAgICAgICB0aGlzLl9iaW5kRGlhbG9nRXZlbnRzKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhTbWFsbERpYWxvZ0lucHV0RWxlbWVudCwgW3tcbiAgICAgICAgICAgICAga2V5OiBcImRpc3Bvc2VcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpYWxvZyA9IHRoaXMuX2RpYWxvZztcbiAgICAgICAgICAgICAgICB0aGlzLmRldGFjaCgpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlci5kaXNwb3NlKCk7IC8vIEB0cy1leHBlY3QtZXJyb3IgLS0gaWdub3JlXG5cblxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9kaWFsb2c7IC8vIEB0cy1leHBlY3QtZXJyb3IgLS0gaWdub3JlXG5cbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5faW5wdXQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmVmb3JlUHJvcEVkaXRvciA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICBpZiAoZGlhbG9nLnBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgIGRpYWxvZy5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKGRpYWxvZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJhdHRhY2hcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGF0dGFjaChncmlkLCBlZGl0b3IsIGNvbCwgcm93LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpczM0ID0gdGhpcztcblxuICAgICAgICAgICAgICAgIHZhciBoYW5kbGVyID0gdGhpcy5faGFuZGxlcjtcbiAgICAgICAgICAgICAgICB2YXIgZGlhbG9nID0gdGhpcy5fZGlhbG9nO1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dCA9IHRoaXMuX2lucHV0O1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2JlZm9yZVByb3BFZGl0b3IpIHtcbiAgICAgICAgICAgICAgICAgIHVuYmluZFByb3BzKGdyaWQsIGRpYWxvZywgaW5wdXQsIHRoaXMuX2JlZm9yZVByb3BFZGl0b3IpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRlbGV0ZSBkaWFsb2cuZGF0YXNldC5lcnJvck1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgZGlhbG9nLmNsYXNzTGlzdC5yZW1vdmUoU0hPV05fQ0xBU1NOQU1FKTtcbiAgICAgICAgICAgICAgICBkaWFsb2cuY2xhc3NMaXN0LmFkZChISURERU5fQ0xBU1NOQU1FKTtcbiAgICAgICAgICAgICAgICBpbnB1dC5yZWFkT25seSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaW5wdXQudGFiSW5kZXggPSAwO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9ncmlkJGdldEF0dGFjaENlbGxzQTMgPSBncmlkLmdldEF0dGFjaENlbGxzQXJlYShncmlkLmdldENlbGxSYW5nZShjb2wsIHJvdykpLFxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gX2dyaWQkZ2V0QXR0YWNoQ2VsbHNBMy5lbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICByZWN0ID0gX2dyaWQkZ2V0QXR0YWNoQ2VsbHNBMy5yZWN0O1xuXG4gICAgICAgICAgICAgICAgZGlhbG9nLnN0eWxlLnRvcCA9IFwiXCIuY29uY2F0KHJlY3QudG9wLnRvRml4ZWQoKSwgXCJweFwiKTtcbiAgICAgICAgICAgICAgICBkaWFsb2cuc3R5bGUubGVmdCA9IFwiXCIuY29uY2F0KHJlY3QubGVmdC50b0ZpeGVkKCksIFwicHhcIik7XG4gICAgICAgICAgICAgICAgZGlhbG9nLnN0eWxlLndpZHRoID0gXCJcIi5jb25jYXQocmVjdC53aWR0aC50b0ZpeGVkKCksIFwicHhcIik7XG4gICAgICAgICAgICAgICAgaW5wdXQuc3R5bGUuaGVpZ2h0ID0gXCJcIi5jb25jYXQocmVjdC5oZWlnaHQudG9GaXhlZCgpLCBcInB4XCIpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoZGlhbG9nKTtcbiAgICAgICAgICAgICAgICAoMCwgaW5wdXRfdmFsdWVfaGFuZGxlcl8xLnNldElucHV0VmFsdWUpKGlucHV0LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaW5wdXQuc3R5bGUuZm9udCA9IGdyaWQuZm9udCB8fCBcIjE2cHggc2Fucy1zZXJpZlwiO1xuICAgICAgICAgICAgICAgIHZhciBhY3RpdmVEYXRhID0ge1xuICAgICAgICAgICAgICAgICAgZ3JpZDogZ3JpZCxcbiAgICAgICAgICAgICAgICAgIGNvbDogY29sLFxuICAgICAgICAgICAgICAgICAgcm93OiByb3csXG4gICAgICAgICAgICAgICAgICBlZGl0b3I6IGVkaXRvclxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9vbklucHV0VmFsdWUoaW5wdXQsIGFjdGl2ZURhdGEpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCF1dGlsc18xLmJyb3dzZXIuSUUpIHtcbiAgICAgICAgICAgICAgICAgIF9mb2N1cyhpbnB1dCwgaGFuZGxlcik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIE9uIHRoZSBwYXN0ZS1ldmVudCBvbiBJRSwgc2luY2UgaXQgbWF5IG5vdCBiZSBmb2N1c2VkLCBpdCB3aWxsIGJlIGRlbGF5ZWQgYW5kIGZvY3VzZWQuXG4gICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9mb2N1cyhpbnB1dCwgaGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkaWFsb2cuY2xhc3NMaXN0LmFkZChTSE9XTl9DTEFTU05BTUUpO1xuICAgICAgICAgICAgICAgIGRpYWxvZy5jbGFzc0xpc3QucmVtb3ZlKEhJRERFTl9DTEFTU05BTUUpO1xuICAgICAgICAgICAgICAgIGlucHV0LnJlYWRPbmx5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYmluZFByb3BzKGdyaWQsIGRpYWxvZywgaW5wdXQsIGVkaXRvcik7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlRGF0YSA9IGFjdGl2ZURhdGE7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmVmb3JlUHJvcEVkaXRvciA9IGVkaXRvcjtcbiAgICAgICAgICAgICAgICB0aGlzLl9hdHRhY2hpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgZGVsZXRlIF90aGlzMzQuX2F0dGFjaGluZztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZGV0YWNoXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXRhY2goZ3JpZEZvY3VzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzQWN0aXZlKCkpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBkaWFsb2cgPSB0aGlzLl9kaWFsb2c7XG4gICAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLl9pbnB1dDtcbiAgICAgICAgICAgICAgICAgIGRpYWxvZy5jbGFzc0xpc3QucmVtb3ZlKFNIT1dOX0NMQVNTTkFNRSk7XG4gICAgICAgICAgICAgICAgICBkaWFsb2cuY2xhc3NMaXN0LmFkZChISURERU5fQ0xBU1NOQU1FKTtcbiAgICAgICAgICAgICAgICAgIGlucHV0LnJlYWRPbmx5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGlucHV0LnRhYkluZGV4ID0gLTE7XG4gICAgICAgICAgICAgICAgICB2YXIgX3RoaXMkX2FjdGl2ZURhdGE1ID0gdGhpcy5fYWN0aXZlRGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICBncmlkID0gX3RoaXMkX2FjdGl2ZURhdGE1LmdyaWQsXG4gICAgICAgICAgICAgICAgICAgICAgY29sID0gX3RoaXMkX2FjdGl2ZURhdGE1LmNvbCxcbiAgICAgICAgICAgICAgICAgICAgICByb3cgPSBfdGhpcyRfYWN0aXZlRGF0YTUucm93O1xuICAgICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gZ3JpZC5nZXRDZWxsUmFuZ2UoY29sLCByb3cpO1xuICAgICAgICAgICAgICAgICAgZ3JpZC5pbnZhbGlkYXRlQ2VsbFJhbmdlKHJhbmdlKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKGdyaWRGb2N1cykge1xuICAgICAgICAgICAgICAgICAgICBncmlkLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlRGF0YSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmVmb3JlVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJfZG9DaGFuZ2VWYWx1ZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2RvQ2hhbmdlVmFsdWUoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzMzUgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pc0FjdGl2ZSgpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5faW5wdXQ7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gaW5wdXQudmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLnRoZW4pKHRoaXMuX3ZhbGlkYXRlKHZhbHVlKSwgZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgICAgICAgICAgaWYgKHJlcyAmJiB2YWx1ZSA9PT0gaW5wdXQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzMzUkX2FjdGl2ZURhdGEgPSBfdGhpczM1Ll9hY3RpdmVEYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JpZCA9IF90aGlzMzUkX2FjdGl2ZURhdGEuZ3JpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbCA9IF90aGlzMzUkX2FjdGl2ZURhdGEuY29sLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm93ID0gX3RoaXMzNSRfYWN0aXZlRGF0YS5yb3c7XG4gICAgICAgICAgICAgICAgICAgIGdyaWQuZG9DaGFuZ2VWYWx1ZShjb2wsIHJvdywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIl9pc0FjdGl2ZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2lzQWN0aXZlKCkge1xuICAgICAgICAgICAgICAgIHZhciBkaWFsb2cgPSB0aGlzLl9kaWFsb2c7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWRpYWxvZyB8fCAhZGlhbG9nLnBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2FjdGl2ZURhdGEpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiX2JpbmREaWFsb2dFdmVudHNcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9iaW5kRGlhbG9nRXZlbnRzKCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpczM2ID0gdGhpcztcblxuICAgICAgICAgICAgICAgIHZhciBoYW5kbGVyID0gdGhpcy5faGFuZGxlcjtcbiAgICAgICAgICAgICAgICB2YXIgZGlhbG9nID0gdGhpcy5fZGlhbG9nO1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dCA9IHRoaXMuX2lucHV0O1xuXG4gICAgICAgICAgICAgICAgdmFyIHN0b3BQcm9wYWdhdGlvbk9ubHkgPSBmdW5jdGlvbiBzdG9wUHJvcGFnYXRpb25Pbmx5KGUpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIH07IC8vIGdyaWTjgavjgqTjg5njg7Pjg4jjgYzkvJ3mkq3jgZfjgarjgYTjgojjgYbjgatcblxuXG4gICAgICAgICAgICAgICAgaGFuZGxlci5vbihkaWFsb2csIFwiY2xpY2tcIiwgc3RvcFByb3BhZ2F0aW9uT25seSk7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5vbihkaWFsb2csIFwiZGJsY2xpY2tcIiwgc3RvcFByb3BhZ2F0aW9uT25seSk7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5vbihkaWFsb2csIFwibW91c2Vkb3duXCIsIHN0b3BQcm9wYWdhdGlvbk9ubHkpO1xuICAgICAgICAgICAgICAgIGhhbmRsZXIub24oZGlhbG9nLCBcInRvdWNoc3RhcnRcIiwgc3RvcFByb3BhZ2F0aW9uT25seSk7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5vbihpbnB1dCwgXCJjb21wb3NpdGlvbnN0YXJ0XCIsIGZ1bmN0aW9uIChfZSkge1xuICAgICAgICAgICAgICAgICAgaW5wdXQuY2xhc3NMaXN0LmFkZChcImNvbXBvc2l0aW9uXCIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGhhbmRsZXIub24oaW5wdXQsIFwiY29tcG9zaXRpb25lbmRcIiwgZnVuY3Rpb24gKF9lKSB7XG4gICAgICAgICAgICAgICAgICBpbnB1dC5jbGFzc0xpc3QucmVtb3ZlKFwiY29tcG9zaXRpb25cIik7XG5cbiAgICAgICAgICAgICAgICAgIF90aGlzMzYuX29uSW5wdXRWYWx1ZShpbnB1dCk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgb25LZXl1cEFuZFByZXNzID0gZnVuY3Rpb24gb25LZXl1cEFuZFByZXNzKF9lKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiY29tcG9zaXRpb25cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBfdGhpczM2Ll9vbklucHV0VmFsdWUoaW5wdXQpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBoYW5kbGVyLm9uKGlucHV0LCBcImtleXVwXCIsIG9uS2V5dXBBbmRQcmVzcyk7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5vbihpbnB1dCwgXCJrZXlwcmVzc1wiLCBvbktleXVwQW5kUHJlc3MpO1xuICAgICAgICAgICAgICAgIGhhbmRsZXIub24oaW5wdXQsIFwia2V5ZG93blwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LmNsYXNzTGlzdC5jb250YWlucyhcImNvbXBvc2l0aW9uXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgdmFyIGtleUNvZGUgPSB1dGlsc18xLmV2ZW50LmdldEtleUNvZGUoZSk7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChrZXlDb2RlID09PSBLRVlfRVNDKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzMzYuZGV0YWNoKHRydWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIHV0aWxzXzEuZXZlbnQuY2FuY2VsKGUpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChrZXlDb2RlID09PSBLRVlfRU5URVIpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMzNi5fb25LZXlkb3duRW50ZXIoZSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfdGhpczM2Ll9vbklucHV0VmFsdWUoaW5wdXQpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJfb25LZXlkb3duRW50ZXJcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9vbktleWRvd25FbnRlcihlKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzMzcgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2F0dGFjaGluZykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBpbnB1dCA9IHRoaXMuX2lucHV0O1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGlucHV0LnZhbHVlO1xuICAgICAgICAgICAgICAgICgwLCB1dGlsc18xLnRoZW4pKHRoaXMuX2RvQ2hhbmdlVmFsdWUoKSwgZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBfYTtcblxuICAgICAgICAgICAgICAgICAgaWYgKHIgJiYgdmFsdWUgPT09IGlucHV0LnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBncmlkID0gX3RoaXMzNy5faXNBY3RpdmUoKSA/IF90aGlzMzcuX2FjdGl2ZURhdGEuZ3JpZCA6IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMzNy5kZXRhY2godHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKChfYSA9IGdyaWQgPT09IG51bGwgfHwgZ3JpZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ3JpZC5rZXlib2FyZE9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tb3ZlQ2VsbE9uRW50ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICBncmlkLm9uS2V5RG93bk1vdmUoZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB1dGlsc18xLmV2ZW50LmNhbmNlbChlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiX29uSW5wdXRWYWx1ZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX29uSW5wdXRWYWx1ZShpbnB1dCwgYWN0aXZlRGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciBiZWZvcmUgPSB0aGlzLl9iZWZvcmVWYWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBpbnB1dC52YWx1ZTtcblxuICAgICAgICAgICAgICAgIGlmIChiZWZvcmUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9vbklucHV0VmFsdWVDaGFuZ2UodmFsdWUsIGFjdGl2ZURhdGEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX2JlZm9yZVZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIl9vbklucHV0VmFsdWVDaGFuZ2VcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9vbklucHV0VmFsdWVDaGFuZ2UoYWZ0ZXIsIGFjdGl2ZURhdGEpIHtcbiAgICAgICAgICAgICAgICBhY3RpdmVEYXRhID0gYWN0aXZlRGF0YSB8fCB0aGlzLl9hY3RpdmVEYXRhO1xuICAgICAgICAgICAgICAgIHZhciBkaWFsb2cgPSB0aGlzLl9kaWFsb2c7XG4gICAgICAgICAgICAgICAgdmFyIF9hY3RpdmVEYXRhID0gYWN0aXZlRGF0YSxcbiAgICAgICAgICAgICAgICAgICAgZ3JpZCA9IF9hY3RpdmVEYXRhLmdyaWQsXG4gICAgICAgICAgICAgICAgICAgIGNvbCA9IF9hY3RpdmVEYXRhLmNvbCxcbiAgICAgICAgICAgICAgICAgICAgcm93ID0gX2FjdGl2ZURhdGEucm93LFxuICAgICAgICAgICAgICAgICAgICBlZGl0b3IgPSBfYWN0aXZlRGF0YS5lZGl0b3I7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVkaXRvci5oZWxwZXJUZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBoZWxwZXJUZXh0ID0gZWRpdG9yLmhlbHBlclRleHQoYWZ0ZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JpZDogZ3JpZCxcbiAgICAgICAgICAgICAgICAgICAgY29sOiBjb2wsXG4gICAgICAgICAgICAgICAgICAgIHJvdzogcm93XG4gICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgaWYgKGhlbHBlclRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlhbG9nLmRhdGFzZXQuaGVscGVyVGV4dCA9IGhlbHBlclRleHQ7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgZGlhbG9nLmRhdGFzZXQuaGVscGVyVGV4dDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoXCJlcnJvck1lc3NhZ2VcIiBpbiBkaWFsb2cuZGF0YXNldCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsaWRhdGUoYWZ0ZXIsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiX3ZhbGlkYXRlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdmFsaWRhdGUodmFsdWUsIGlucHV0T25seSkge1xuICAgICAgICAgICAgICAgIHZhciBkaWFsb2cgPSB0aGlzLl9kaWFsb2c7XG4gICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5faW5wdXQ7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzJF9hY3RpdmVEYXRhNiA9IHRoaXMuX2FjdGl2ZURhdGEsXG4gICAgICAgICAgICAgICAgICAgIGdyaWQgPSBfdGhpcyRfYWN0aXZlRGF0YTYuZ3JpZCxcbiAgICAgICAgICAgICAgICAgICAgY29sID0gX3RoaXMkX2FjdGl2ZURhdGE2LmNvbCxcbiAgICAgICAgICAgICAgICAgICAgcm93ID0gX3RoaXMkX2FjdGl2ZURhdGE2LnJvdyxcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yID0gX3RoaXMkX2FjdGl2ZURhdGE2LmVkaXRvcjtcbiAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IFwiXCI7XG5cbiAgICAgICAgICAgICAgICBpZiAoZWRpdG9yLmlucHV0VmFsaWRhdG9yKSB7XG4gICAgICAgICAgICAgICAgICBtZXNzYWdlID0gZWRpdG9yLmlucHV0VmFsaWRhdG9yKHZhbHVlLCB7XG4gICAgICAgICAgICAgICAgICAgIGdyaWQ6IGdyaWQsXG4gICAgICAgICAgICAgICAgICAgIGNvbDogY29sLFxuICAgICAgICAgICAgICAgICAgICByb3c6IHJvd1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLnRoZW4pKG1lc3NhZ2UsIGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIW1lc3NhZ2UgJiYgZWRpdG9yLnZhbGlkYXRvciAmJiAhaW5wdXRPbmx5KSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBlZGl0b3IudmFsaWRhdG9yKHZhbHVlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgZ3JpZDogZ3JpZCxcbiAgICAgICAgICAgICAgICAgICAgICBjb2w6IGNvbCxcbiAgICAgICAgICAgICAgICAgICAgICByb3c6IHJvd1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLnRoZW4pKG1lc3NhZ2UsIGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlICYmIHZhbHVlID09PSBpbnB1dC52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGRpYWxvZy5kYXRhc2V0LmVycm9yTWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGRpYWxvZy5kYXRhc2V0LmVycm9yTWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhbWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSwgW3tcbiAgICAgICAgICAgICAga2V5OiBcInNldElucHV0QXR0cnNcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldElucHV0QXR0cnMoZWRpdG9yLCBncmlkLCBpbnB1dCkge1xuICAgICAgICAgICAgICAgIF9zZXRJbnB1dEF0dHJzMihlZGl0b3IsIGdyaWQsIGlucHV0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gU21hbGxEaWFsb2dJbnB1dEVsZW1lbnQ7XG4gICAgICAgICAgfSgpO1xuXG4gICAgICAgICAgZXhwb3J0cy5TbWFsbERpYWxvZ0lucHV0RWxlbWVudCA9IFNtYWxsRGlhbG9nSW5wdXRFbGVtZW50O1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2NvbHVtbnMvYWN0aW9uL2ludGVybmFsL2lucHV0LXZhbHVlLWhhbmRsZXIuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2NvbHVtbnMvYWN0aW9uL2ludGVybmFsL2lucHV0LXZhbHVlLWhhbmRsZXIuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGNvbHVtbnNBY3Rpb25JbnRlcm5hbElucHV0VmFsdWVIYW5kbGVySnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5zZXRJbnB1dFZhbHVlID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIEV2ZW50SGFuZGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vLi4vaW50ZXJuYWwvRXZlbnRIYW5kbGVyICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL0V2ZW50SGFuZGxlci5qc1wiKTtcblxuICAgICAgICAgIGZ1bmN0aW9uIHNldElucHV0VmFsdWUoaW5wdXQsIHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgc2lnbiA9IGlucHV0LnR5cGUgPT09IFwibnVtYmVyXCIgJiYgdmFsdWUgPT09IFwiLVwiO1xuXG4gICAgICAgICAgICBpZiAoc2lnbikge1xuICAgICAgICAgICAgICAvLyBXaGVuIGB0eXBlPVwibnVtYmVyXCJgLCB0aGUgbWludXMgc2lnbiBpcyBub3QgYWNjZXB0ZWQsIHNvIGNoYW5nZSBpdCB0byBgdHlwZT1cInRleHRcImAgb25jZS5cbiAgICAgICAgICAgICAgaW5wdXQudHlwZSA9IFwiXCI7XG4gICAgICAgICAgICAgIHZhciBoYW5kbGVyID0gbmV3IEV2ZW50SGFuZGxlcl8xLkV2ZW50SGFuZGxlcigpO1xuXG4gICAgICAgICAgICAgIHZhciBkaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgaGFuZGxlci5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgICBoYW5kbGVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgaGFuZGxlci5vbmNlKGlucHV0LCBcImlucHV0XCIsIGZ1bmN0aW9uIChfZSkge1xuICAgICAgICAgICAgICAgIGlucHV0LnR5cGUgPSBcIm51bWJlclwiO1xuICAgICAgICAgICAgICAgIGRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGhhbmRsZXIub25jZShpbnB1dCwgXCJibHVyXCIsIGZ1bmN0aW9uIChfZSkge1xuICAgICAgICAgICAgICAgIGRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlucHV0LnZhbHVlID0gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHZvaWQgMCA/IHZhbHVlIDogXCJcIjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRzLnNldElucHV0VmFsdWUgPSBzZXRJbnB1dFZhbHVlO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2NvbHVtbnMvaW5kaWNhdG9yL2hhbmRsZXJzLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vY29sdW1ucy9pbmRpY2F0b3IvaGFuZGxlcnMuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBjb2x1bW5zSW5kaWNhdG9ySGFuZGxlcnNKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLmdldERyYXdJbmRpY2F0b3IgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgdHJpYW5nbGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vdHJpYW5nbGUgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9pbmRpY2F0b3IvdHJpYW5nbGUuanNcIik7XG5cbiAgICAgICAgICBmdW5jdGlvbiBnZXREcmF3SW5kaWNhdG9yKGluZGljYXRvclN0eWxlKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSBpbmRpY2F0b3JTdHlsZS5zdHlsZTtcblxuICAgICAgICAgICAgaWYgKHN0eWxlID09PSBcInRyaWFuZ2xlXCIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRyaWFuZ2xlXzEuZHJhd1RyaWFuZ2xlSW5kaWNhdG9yO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRzLmdldERyYXdJbmRpY2F0b3IgPSBnZXREcmF3SW5kaWNhdG9yO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2NvbHVtbnMvaW5kaWNhdG9yL3RyaWFuZ2xlLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vY29sdW1ucy9pbmRpY2F0b3IvdHJpYW5nbGUuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBjb2x1bW5zSW5kaWNhdG9yVHJpYW5nbGVKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIHZhciBfS0lORF9QUk9DRVNTX01BUDtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLmRyYXdUcmlhbmdsZUluZGljYXRvciA9IHZvaWQgMDtcbiAgICAgICAgICB2YXIgS0lORF9QUk9DRVNTX01BUCA9IChfS0lORF9QUk9DRVNTX01BUCA9IHt9LCBfZGVmaW5lUHJvcGVydHkoX0tJTkRfUFJPQ0VTU19NQVAsIDBcbiAgICAgICAgICAvKiBEcmF3SW5kaWNhdG9yS2luZC50b3BMZWZ0ICovXG4gICAgICAgICAgLCB7XG4gICAgICAgICAgICB0aGVtZUNvbG9yOiBmdW5jdGlvbiB0aGVtZUNvbG9yKGhlbHBlcikge1xuICAgICAgICAgICAgICByZXR1cm4gaGVscGVyLnRoZW1lLmluZGljYXRvcnMudG9wTGVmdENvbG9yO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRoZW1lU2l6ZTogZnVuY3Rpb24gdGhlbWVTaXplKGhlbHBlcikge1xuICAgICAgICAgICAgICByZXR1cm4gaGVscGVyLnRoZW1lLmluZGljYXRvcnMudG9wTGVmdFNpemU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHJhd1BhdGg6IGZ1bmN0aW9uIGRyYXdQYXRoKGN0eCwgcmVjdCwgc2l6ZSkge1xuICAgICAgICAgICAgICB2YXIgYmFzZUxlZnQgPSByZWN0LmxlZnQgKyAxO1xuICAgICAgICAgICAgICB2YXIgYmFzZVRvcCA9IHJlY3QudG9wICsgMTtcbiAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhiYXNlTGVmdCwgYmFzZVRvcCk7XG4gICAgICAgICAgICAgIGN0eC5saW5lVG8oYmFzZUxlZnQgKyBzaXplLCBiYXNlVG9wKTtcbiAgICAgICAgICAgICAgY3R4LmxpbmVUbyhiYXNlTGVmdCwgYmFzZVRvcCArIHNpemUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLCBfZGVmaW5lUHJvcGVydHkoX0tJTkRfUFJPQ0VTU19NQVAsIDFcbiAgICAgICAgICAvKiBEcmF3SW5kaWNhdG9yS2luZC50b3BSaWdodCAqL1xuICAgICAgICAgICwge1xuICAgICAgICAgICAgdGhlbWVDb2xvcjogZnVuY3Rpb24gdGhlbWVDb2xvcihoZWxwZXIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlci50aGVtZS5pbmRpY2F0b3JzLnRvcFJpZ2h0Q29sb3I7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGhlbWVTaXplOiBmdW5jdGlvbiB0aGVtZVNpemUoaGVscGVyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoZWxwZXIudGhlbWUuaW5kaWNhdG9ycy50b3BSaWdodFNpemU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHJhd1BhdGg6IGZ1bmN0aW9uIGRyYXdQYXRoKGN0eCwgcmVjdCwgc2l6ZSkge1xuICAgICAgICAgICAgICB2YXIgYmFzZVJpZ2h0ID0gcmVjdC5yaWdodCAtIDI7XG4gICAgICAgICAgICAgIHZhciBiYXNlVG9wID0gcmVjdC50b3AgKyAxO1xuICAgICAgICAgICAgICBjdHgubW92ZVRvKGJhc2VSaWdodCwgYmFzZVRvcCk7XG4gICAgICAgICAgICAgIGN0eC5saW5lVG8oYmFzZVJpZ2h0IC0gc2l6ZSwgYmFzZVRvcCk7XG4gICAgICAgICAgICAgIGN0eC5saW5lVG8oYmFzZVJpZ2h0LCBiYXNlVG9wICsgc2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksIF9kZWZpbmVQcm9wZXJ0eShfS0lORF9QUk9DRVNTX01BUCwgMlxuICAgICAgICAgIC8qIERyYXdJbmRpY2F0b3JLaW5kLmJvdHRvbVJpZ2h0ICovXG4gICAgICAgICAgLCB7XG4gICAgICAgICAgICB0aGVtZUNvbG9yOiBmdW5jdGlvbiB0aGVtZUNvbG9yKGhlbHBlcikge1xuICAgICAgICAgICAgICByZXR1cm4gaGVscGVyLnRoZW1lLmluZGljYXRvcnMuYm90dG9tUmlnaHRDb2xvcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0aGVtZVNpemU6IGZ1bmN0aW9uIHRoZW1lU2l6ZShoZWxwZXIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlci50aGVtZS5pbmRpY2F0b3JzLmJvdHRvbVJpZ2h0U2l6ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkcmF3UGF0aDogZnVuY3Rpb24gZHJhd1BhdGgoY3R4LCByZWN0LCBzaXplKSB7XG4gICAgICAgICAgICAgIHZhciBiYXNlUmlnaHQgPSByZWN0LnJpZ2h0IC0gMjtcbiAgICAgICAgICAgICAgdmFyIGJhc2VCb3R0b20gPSByZWN0LmJvdHRvbSAtIDI7XG4gICAgICAgICAgICAgIGN0eC5tb3ZlVG8oYmFzZVJpZ2h0LCBiYXNlQm90dG9tKTtcbiAgICAgICAgICAgICAgY3R4LmxpbmVUbyhiYXNlUmlnaHQgLSBzaXplLCBiYXNlQm90dG9tKTtcbiAgICAgICAgICAgICAgY3R4LmxpbmVUbyhiYXNlUmlnaHQsIGJhc2VCb3R0b20gLSBzaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSwgX2RlZmluZVByb3BlcnR5KF9LSU5EX1BST0NFU1NfTUFQLCAzXG4gICAgICAgICAgLyogRHJhd0luZGljYXRvcktpbmQuYm90dG9tTGVmdCAqL1xuICAgICAgICAgICwge1xuICAgICAgICAgICAgdGhlbWVDb2xvcjogZnVuY3Rpb24gdGhlbWVDb2xvcihoZWxwZXIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlci50aGVtZS5pbmRpY2F0b3JzLmJvdHRvbUxlZnRDb2xvcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0aGVtZVNpemU6IGZ1bmN0aW9uIHRoZW1lU2l6ZShoZWxwZXIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlci50aGVtZS5pbmRpY2F0b3JzLmJvdHRvbUxlZnRTaXplO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRyYXdQYXRoOiBmdW5jdGlvbiBkcmF3UGF0aChjdHgsIHJlY3QsIHNpemUpIHtcbiAgICAgICAgICAgICAgdmFyIGJhc2VMZWZ0ID0gcmVjdC5sZWZ0ICsgMTtcbiAgICAgICAgICAgICAgdmFyIGJhc2VCb3R0b20gPSByZWN0LmJvdHRvbSAtIDI7XG4gICAgICAgICAgICAgIGN0eC5tb3ZlVG8oYmFzZUxlZnQsIGJhc2VCb3R0b20pO1xuICAgICAgICAgICAgICBjdHgubGluZVRvKGJhc2VMZWZ0ICsgc2l6ZSwgYmFzZUJvdHRvbSk7XG4gICAgICAgICAgICAgIGN0eC5saW5lVG8oYmFzZUxlZnQsIGJhc2VCb3R0b20gLSBzaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSwgX0tJTkRfUFJPQ0VTU19NQVApO1xuXG4gICAgICAgICAgZnVuY3Rpb24gZHJhd1RyaWFuZ2xlSW5kaWNhdG9yKGNvbnRleHQsIHN0eWxlLCBraW5kLCBoZWxwZXIpIHtcbiAgICAgICAgICAgIHZhciBwcm9jZXNzID0gS0lORF9QUk9DRVNTX01BUFtraW5kXTtcblxuICAgICAgICAgICAgaWYgKCFwcm9jZXNzKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaGVscGVyLmRyYXdCb3JkZXJXaXRoQ2xpcChjb250ZXh0LCBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICAgIHZhciByZWN0ID0gY29udGV4dC5nZXRSZWN0KCk7XG4gICAgICAgICAgICAgIHZhciBjb2xvciA9IHN0eWxlLmNvbG9yIHx8IGhlbHBlci5nZXRDb2xvcihwcm9jZXNzLnRoZW1lQ29sb3IoaGVscGVyKSwgY29udGV4dC5jb2wsIGNvbnRleHQucm93LCBjdHgpO1xuICAgICAgICAgICAgICB2YXIgc2l6ZSA9IHN0eWxlLnNpemUgJiYgTnVtYmVyKHN0eWxlLnNpemUpIHx8IHByb2Nlc3MudGhlbWVTaXplKGhlbHBlcikgfHwgcmVjdC5oZWlnaHQgLyA2OyAvLyBkcmF3IHRyaWFuZ2xlXG5cbiAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgIHByb2Nlc3MuZHJhd1BhdGgoY3R4LCByZWN0LCBzaXplKTtcbiAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5kcmF3VHJpYW5nbGVJbmRpY2F0b3IgPSBkcmF3VHJpYW5nbGVJbmRpY2F0b3I7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vY29sdW1ucy9tZXNzYWdlL0Jhc2VNZXNzYWdlLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2NvbHVtbnMvbWVzc2FnZS9CYXNlTWVzc2FnZS5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBjb2x1bW5zTWVzc2FnZUJhc2VNZXNzYWdlSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5CYXNlTWVzc2FnZSA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBCYXNlTWVzc2FnZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBCYXNlTWVzc2FnZShncmlkKSB7XG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCYXNlTWVzc2FnZSk7XG5cbiAgICAgICAgICAgICAgdGhpcy5fbWVzc2FnZUVsZW1lbnQgPSBudWxsO1xuICAgICAgICAgICAgICB0aGlzLl9ncmlkID0gZ3JpZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKEJhc2VNZXNzYWdlLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiZGlzcG9zZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRldGFjaE1lc3NhZ2VFbGVtZW50KCk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbWVzc2FnZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX21lc3NhZ2VFbGVtZW50LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9tZXNzYWdlRWxlbWVudCA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIl9nZXRNZXNzYWdlRWxlbWVudFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldE1lc3NhZ2VFbGVtZW50KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tZXNzYWdlRWxlbWVudCB8fCAodGhpcy5fbWVzc2FnZUVsZW1lbnQgPSB0aGlzLmNyZWF0ZU1lc3NhZ2VFbGVtZW50SW50ZXJuYWwoKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImF0dGFjaE1lc3NhZ2VFbGVtZW50XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRhY2hNZXNzYWdlRWxlbWVudChjb2wsIHJvdywgbWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlRWxlbWVudCA9IHRoaXMuX2dldE1lc3NhZ2VFbGVtZW50KCk7XG5cbiAgICAgICAgICAgICAgICBtZXNzYWdlRWxlbWVudC5hdHRhY2godGhpcy5fZ3JpZCwgY29sLCByb3csIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJtb3ZlTWVzc2FnZUVsZW1lbnRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1vdmVNZXNzYWdlRWxlbWVudChjb2wsIHJvdykge1xuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlRWxlbWVudCA9IHRoaXMuX2dldE1lc3NhZ2VFbGVtZW50KCk7XG5cbiAgICAgICAgICAgICAgICBtZXNzYWdlRWxlbWVudC5tb3ZlKHRoaXMuX2dyaWQsIGNvbCwgcm93KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZGV0YWNoTWVzc2FnZUVsZW1lbnRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRldGFjaE1lc3NhZ2VFbGVtZW50KCkge1xuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlRWxlbWVudCA9IHRoaXMuX2dldE1lc3NhZ2VFbGVtZW50KCk7XG5cbiAgICAgICAgICAgICAgICBtZXNzYWdlRWxlbWVudC5fZGV0YWNoKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImRyYXdDZWxsTWVzc2FnZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0NlbGxNZXNzYWdlKG1lc3NhZ2UsIGNvbnRleHQsIHN0eWxlLCBoZWxwZXIsIGdyaWQsIGluZm8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdDZWxsTWVzc2FnZUludGVybmFsKG1lc3NhZ2UsIGNvbnRleHQsIHN0eWxlLCBoZWxwZXIsIGdyaWQsIGluZm8pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBCYXNlTWVzc2FnZTtcbiAgICAgICAgICB9KCk7XG5cbiAgICAgICAgICBleHBvcnRzLkJhc2VNZXNzYWdlID0gQmFzZU1lc3NhZ2U7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vY29sdW1ucy9tZXNzYWdlL0Vycm9yTWVzc2FnZS5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vY29sdW1ucy9tZXNzYWdlL0Vycm9yTWVzc2FnZS5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gY29sdW1uc01lc3NhZ2VFcnJvck1lc3NhZ2VKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIHZhciBfX2NyZWF0ZUJpbmRpbmcgPSB0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nIHx8IChPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24gKG8sIG0sIGssIGsyKSB7XG4gICAgICAgICAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgICAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuXG4gICAgICAgICAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgICAgICAgICBkZXNjID0ge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbVtrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG4gICAgICAgICAgfSA6IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICAgICAgICAgICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICAgICAgICAgIG9bazJdID0gbVtrXTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBfX3NldE1vZHVsZURlZmF1bHQgPSB0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0IHx8IChPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24gKG8sIHYpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwge1xuICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICB2YWx1ZTogdlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSA6IGZ1bmN0aW9uIChvLCB2KSB7XG4gICAgICAgICAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgX19pbXBvcnRTdGFyID0gdGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhciB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgICAgICAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICAgICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkge1xuICAgICAgICAgICAgICBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLkVycm9yTWVzc2FnZSA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBtZXNzYWdlVXRpbHMgPSBfX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9tZXNzYWdlVXRpbHMgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9tZXNzYWdlL21lc3NhZ2VVdGlscy5qc1wiKSk7XG5cbiAgICAgICAgICB2YXIgQmFzZU1lc3NhZ2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vQmFzZU1lc3NhZ2UgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9tZXNzYWdlL0Jhc2VNZXNzYWdlLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIEVycm9yTWVzc2FnZUVsZW1lbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vaW50ZXJuYWwvRXJyb3JNZXNzYWdlRWxlbWVudCAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL21lc3NhZ2UvaW50ZXJuYWwvRXJyb3JNZXNzYWdlRWxlbWVudC5qc1wiKTtcblxuICAgICAgICAgIHZhciB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vaW50ZXJuYWwvdXRpbHMgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvdXRpbHMuanNcIik7XG5cbiAgICAgICAgICB2YXIgUkVEX0ExMDAgPSBcIiNmZjhhODBcIjtcblxuICAgICAgICAgIHZhciBFcnJvck1lc3NhZ2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXNlTWVzc2FnZV8xJEJhc2VNZSkge1xuICAgICAgICAgICAgX2luaGVyaXRzKEVycm9yTWVzc2FnZSwgX0Jhc2VNZXNzYWdlXzEkQmFzZU1lKTtcblxuICAgICAgICAgICAgdmFyIF9zdXBlcjE1ID0gX2NyZWF0ZVN1cGVyKEVycm9yTWVzc2FnZSk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIEVycm9yTWVzc2FnZSgpIHtcbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVycm9yTWVzc2FnZSk7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlcjE1LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhFcnJvck1lc3NhZ2UsIFt7XG4gICAgICAgICAgICAgIGtleTogXCJjcmVhdGVNZXNzYWdlRWxlbWVudEludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVNZXNzYWdlRWxlbWVudEludGVybmFsKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3JNZXNzYWdlRWxlbWVudF8xLkVycm9yTWVzc2FnZUVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZHJhd0NlbGxNZXNzYWdlSW50ZXJuYWxcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdDZWxsTWVzc2FnZUludGVybmFsKF9tZXNzYWdlLCBjb250ZXh0LCBzdHlsZSwgaGVscGVyLCBncmlkLCBfaW5mbykge1xuICAgICAgICAgICAgICAgIHZhciBiZ0NvbG9yID0gc3R5bGUuYmdDb2xvcjtcblxuICAgICAgICAgICAgICAgIHZhciBfY29udGV4dCRnZXRTZWxlY3Rpb24gPSBjb250ZXh0LmdldFNlbGVjdGlvbigpLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3QgPSBfY29udGV4dCRnZXRTZWxlY3Rpb24uc2VsZWN0O1xuXG4gICAgICAgICAgICAgICAgaWYgKCEoMCwgdXRpbHNfMS5jZWxsSW5SYW5nZSkoZ3JpZC5nZXRDZWxsUmFuZ2UoY29udGV4dC5jb2wsIGNvbnRleHQucm93KSwgc2VsZWN0LmNvbCwgc2VsZWN0LnJvdykgfHwgIWdyaWQuaGFzRm9jdXNHcmlkKCkpIHtcbiAgICAgICAgICAgICAgICAgIGhlbHBlci5kcmF3Qm9yZGVyV2l0aENsaXAoY29udGV4dCwgZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlVXRpbHMuZHJhd0V4Y2xhbWF0aW9uTWFya0JveChjb250ZXh0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgYmdDb2xvcjogaGVscGVyLmdldENvbG9yKGhlbHBlci50aGVtZS5tZXNzYWdlcy5lcnJvckJnQ29sb3IsIGNvbnRleHQuY29sLCBjb250ZXh0LnJvdywgY3R4KSB8fCBSRURfQTEwMCxcbiAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogYmdDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICBib3hXaWR0aDogaGVscGVyLnRoZW1lLm1lc3NhZ2VzLmJveFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgIG1hcmtIZWlnaHQ6IGhlbHBlci50aGVtZS5tZXNzYWdlcy5tYXJrSGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgIH0sIGhlbHBlcik7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIEVycm9yTWVzc2FnZTtcbiAgICAgICAgICB9KEJhc2VNZXNzYWdlXzEuQmFzZU1lc3NhZ2UpO1xuXG4gICAgICAgICAgZXhwb3J0cy5FcnJvck1lc3NhZ2UgPSBFcnJvck1lc3NhZ2U7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vY29sdW1ucy9tZXNzYWdlL0luZm9NZXNzYWdlLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2NvbHVtbnMvbWVzc2FnZS9JbmZvTWVzc2FnZS5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBjb2x1bW5zTWVzc2FnZUluZm9NZXNzYWdlSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICB2YXIgX19jcmVhdGVCaW5kaW5nID0gdGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZyB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICAgICAgICAgICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcblxuICAgICAgICAgICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgICAgICAgICAgZGVzYyA9IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ba107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xuICAgICAgICAgIH0gOiBmdW5jdGlvbiAobywgbSwgaywgazIpIHtcbiAgICAgICAgICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgICAgICAgICBvW2syXSA9IG1ba107XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gdGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCB2KSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHtcbiAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gOiBmdW5jdGlvbiAobywgdikge1xuICAgICAgICAgICAgb1tcImRlZmF1bHRcIl0gPSB2O1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIF9faW1wb3J0U3RhciA9IHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgICAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIHtcbiAgICAgICAgICAgICAgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5JbmZvTWVzc2FnZSA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBtZXNzYWdlVXRpbHMgPSBfX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9tZXNzYWdlVXRpbHMgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9tZXNzYWdlL21lc3NhZ2VVdGlscy5qc1wiKSk7XG5cbiAgICAgICAgICB2YXIgQmFzZU1lc3NhZ2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vQmFzZU1lc3NhZ2UgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9tZXNzYWdlL0Jhc2VNZXNzYWdlLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIE1lc3NhZ2VFbGVtZW50XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL2ludGVybmFsL01lc3NhZ2VFbGVtZW50ICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvbWVzc2FnZS9pbnRlcm5hbC9NZXNzYWdlRWxlbWVudC5qc1wiKTtcblxuICAgICAgICAgIHZhciB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vaW50ZXJuYWwvdXRpbHMgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvdXRpbHMuanNcIik7XG5cbiAgICAgICAgICB2YXIgR1JFWV9MMiA9IFwiI2UwZTBlMFwiO1xuXG4gICAgICAgICAgdmFyIEluZm9NZXNzYWdlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZU1lc3NhZ2VfMSRCYXNlTWUyKSB7XG4gICAgICAgICAgICBfaW5oZXJpdHMoSW5mb01lc3NhZ2UsIF9CYXNlTWVzc2FnZV8xJEJhc2VNZTIpO1xuXG4gICAgICAgICAgICB2YXIgX3N1cGVyMTYgPSBfY3JlYXRlU3VwZXIoSW5mb01lc3NhZ2UpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBJbmZvTWVzc2FnZSgpIHtcbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEluZm9NZXNzYWdlKTtcblxuICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyMTYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKEluZm9NZXNzYWdlLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiY3JlYXRlTWVzc2FnZUVsZW1lbnRJbnRlcm5hbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlTWVzc2FnZUVsZW1lbnRJbnRlcm5hbCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE1lc3NhZ2VFbGVtZW50XzEuTWVzc2FnZUVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZHJhd0NlbGxNZXNzYWdlSW50ZXJuYWxcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdDZWxsTWVzc2FnZUludGVybmFsKF9tZXNzYWdlLCBjb250ZXh0LCBzdHlsZSwgaGVscGVyLCBncmlkLCBfaW5mbykge1xuICAgICAgICAgICAgICAgIHZhciBiZ0NvbG9yID0gc3R5bGUuYmdDb2xvcjtcblxuICAgICAgICAgICAgICAgIHZhciBfY29udGV4dCRnZXRTZWxlY3Rpb24yID0gY29udGV4dC5nZXRTZWxlY3Rpb24oKSxcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ID0gX2NvbnRleHQkZ2V0U2VsZWN0aW9uMi5zZWxlY3Q7XG5cbiAgICAgICAgICAgICAgICBpZiAoISgwLCB1dGlsc18xLmNlbGxJblJhbmdlKShncmlkLmdldENlbGxSYW5nZShjb250ZXh0LmNvbCwgY29udGV4dC5yb3cpLCBzZWxlY3QuY29sLCBzZWxlY3Qucm93KSB8fCAhZ3JpZC5oYXNGb2N1c0dyaWQoKSkge1xuICAgICAgICAgICAgICAgICAgaGVscGVyLmRyYXdCb3JkZXJXaXRoQ2xpcChjb250ZXh0LCBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VVdGlscy5kcmF3SW5mb3JtYXRpb25NYXJrQm94KGNvbnRleHQsIHtcbiAgICAgICAgICAgICAgICAgICAgICBiZ0NvbG9yOiBoZWxwZXIuZ2V0Q29sb3IoaGVscGVyLnRoZW1lLm1lc3NhZ2VzLmluZm9CZ0NvbG9yLCBjb250ZXh0LmNvbCwgY29udGV4dC5yb3csIGN0eCkgfHwgR1JFWV9MMixcbiAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogYmdDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICBib3hXaWR0aDogaGVscGVyLnRoZW1lLm1lc3NhZ2VzLmJveFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgIG1hcmtIZWlnaHQ6IGhlbHBlci50aGVtZS5tZXNzYWdlcy5tYXJrSGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgIH0sIGhlbHBlcik7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIEluZm9NZXNzYWdlO1xuICAgICAgICAgIH0oQmFzZU1lc3NhZ2VfMS5CYXNlTWVzc2FnZSk7XG5cbiAgICAgICAgICBleHBvcnRzLkluZm9NZXNzYWdlID0gSW5mb01lc3NhZ2U7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vY29sdW1ucy9tZXNzYWdlL01lc3NhZ2VIYW5kbGVyLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2NvbHVtbnMvbWVzc2FnZS9NZXNzYWdlSGFuZGxlci5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBjb2x1bW5zTWVzc2FnZU1lc3NhZ2VIYW5kbGVySnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5NZXNzYWdlSGFuZGxlciA9IGV4cG9ydHMuaGFzTWVzc2FnZSA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBFcnJvck1lc3NhZ2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vRXJyb3JNZXNzYWdlICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvbWVzc2FnZS9FcnJvck1lc3NhZ2UuanNcIik7XG5cbiAgICAgICAgICB2YXIgSW5mb01lc3NhZ2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vSW5mb01lc3NhZ2UgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9tZXNzYWdlL0luZm9NZXNzYWdlLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIExHX0VWRU5UX1RZUEVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uL2xpc3QtZ3JpZC9MR19FVkVOVF9UWVBFICovXG4gICAgICAgICAgXCIuL2xpc3QtZ3JpZC9MR19FVkVOVF9UWVBFLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIFdhcm5pbmdNZXNzYWdlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL1dhcm5pbmdNZXNzYWdlICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvbWVzc2FnZS9XYXJuaW5nTWVzc2FnZS5qc1wiKTtcblxuICAgICAgICAgIHZhciB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vaW50ZXJuYWwvdXRpbHMgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvdXRpbHMuanNcIik7XG5cbiAgICAgICAgICB2YXIgRU1QVFlfTUVTU0FHRSA9IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IG51bGxcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciBNRVNTQUdFX0lOU1RBTkNFX0ZBQ1RPUlkgPSB7XG4gICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24gZXJyb3IoZ3JpZCkge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yTWVzc2FnZV8xLkVycm9yTWVzc2FnZShncmlkKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbmZvOiBmdW5jdGlvbiBpbmZvKGdyaWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbmZvTWVzc2FnZV8xLkluZm9NZXNzYWdlKGdyaWQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHdhcm5pbmc6IGZ1bmN0aW9uIHdhcm5pbmcoZ3JpZCkge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IFdhcm5pbmdNZXNzYWdlXzEuV2FybmluZ01lc3NhZ2UoZ3JpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKCFtZXNzYWdlIHx8ICgwLCB1dGlsc18xLmlzUHJvbWlzZSkobWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIEVNUFRZX01FU1NBR0U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICAgICAgICAgIG9yaWdpbmFsOiBtZXNzYWdlXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0eXBlID0gbWVzc2FnZS50eXBlIHx8IFwiZXJyb3JcIjtcblxuICAgICAgICAgICAgaWYgKHR5cGUgJiYgdHlwZSBpbiBNRVNTQUdFX0lOU1RBTkNFX0ZBQ1RPUlkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZS5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIG9yaWdpbmFsOiBtZXNzYWdlXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC10ZW1wbGF0ZS1leHByZXNzaW9uc1xuICAgICAgICAgICAgICBtZXNzYWdlOiBcIlwiLmNvbmNhdChtZXNzYWdlKSxcbiAgICAgICAgICAgICAgb3JpZ2luYWw6IG1lc3NhZ2VcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gaGFzTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gISFub3JtYWxpemVNZXNzYWdlKG1lc3NhZ2UpLm1lc3NhZ2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5oYXNNZXNzYWdlID0gaGFzTWVzc2FnZTtcblxuICAgICAgICAgIHZhciBNZXNzYWdlSGFuZGxlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBNZXNzYWdlSGFuZGxlcihncmlkLCBnZXRNZXNzYWdlKSB7XG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNZXNzYWdlSGFuZGxlcik7XG5cbiAgICAgICAgICAgICAgdGhpcy5fYXR0YWNoSW5mbyA9IG51bGw7XG4gICAgICAgICAgICAgIHRoaXMuX2dyaWQgPSBncmlkO1xuICAgICAgICAgICAgICB0aGlzLl9tZXNzYWdlSW5zdGFuY2VzID0ge307XG5cbiAgICAgICAgICAgICAgdGhpcy5fYmluZEdyaWRFdmVudChncmlkLCBnZXRNZXNzYWdlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKE1lc3NhZ2VIYW5kbGVyLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiZGlzcG9zZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG5cbiAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZUluc3RhbmNlcyA9IHRoaXMuX21lc3NhZ2VJbnN0YW5jZXM7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrIGluIG1lc3NhZ2VJbnN0YW5jZXMpIHtcbiAgICAgICAgICAgICAgICAgIChfYSA9IG1lc3NhZ2VJbnN0YW5jZXNba10pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgfSAvLyBAdHMtZXhwZWN0LWVycm9yIC0tIGlnbm9yZVxuXG5cbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fbWVzc2FnZUluc3RhbmNlczsgLy8gQHRzLWV4cGVjdC1lcnJvciAtLSBpZ25vcmVcblxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9hdHRhY2hJbmZvO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJkcmF3Q2VsbE1lc3NhZ2VcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdDZWxsTWVzc2FnZShtZXNzYWdlLCBjb250ZXh0LCBzdHlsZSwgaGVscGVyLCBncmlkLCBpbmZvKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNNZXNzYWdlKG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gdGhpcy5fZ2V0TWVzc2FnZUluc3RhbmNlT2ZNZXNzYWdlKG1lc3NhZ2UpO1xuXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuZHJhd0NlbGxNZXNzYWdlKG5vcm1hbGl6ZU1lc3NhZ2UobWVzc2FnZSksIGNvbnRleHQsIHN0eWxlLCBoZWxwZXIsIGdyaWQsIGluZm8pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJfYXR0YWNoXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfYXR0YWNoKGNvbCwgcm93LCBtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZm8gPSB0aGlzLl9hdHRhY2hJbmZvO1xuXG4gICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gdGhpcy5fZ2V0TWVzc2FnZUluc3RhbmNlT2ZNZXNzYWdlKG1lc3NhZ2UpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGluZm8gJiYgaW5mby5pbnN0YW5jZSAhPT0gaW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgIGluZm8uaW5zdGFuY2UuZGV0YWNoTWVzc2FnZUVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5hdHRhY2hNZXNzYWdlRWxlbWVudChjb2wsIHJvdywgbm9ybWFsaXplTWVzc2FnZShtZXNzYWdlKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXR0YWNoSW5mbyA9IHtcbiAgICAgICAgICAgICAgICAgIGNvbDogY29sLFxuICAgICAgICAgICAgICAgICAgcm93OiByb3csXG4gICAgICAgICAgICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2VcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJfbW92ZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX21vdmUoY29sLCByb3cpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5mbyA9IHRoaXMuX2F0dGFjaEluZm87XG5cbiAgICAgICAgICAgICAgICBpZiAoIWluZm8gfHwgaW5mby5jb2wgIT09IGNvbCB8fCBpbmZvLnJvdyAhPT0gcm93KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gaW5mby5pbnN0YW5jZTtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5tb3ZlTWVzc2FnZUVsZW1lbnQoY29sLCByb3cpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJfZGV0YWNoXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZGV0YWNoKCkge1xuICAgICAgICAgICAgICAgIHZhciBpbmZvID0gdGhpcy5fYXR0YWNoSW5mbztcblxuICAgICAgICAgICAgICAgIGlmICghaW5mbykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGluZm8uaW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuZGV0YWNoTWVzc2FnZUVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hdHRhY2hJbmZvID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiX2JpbmRHcmlkRXZlbnRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9iaW5kR3JpZEV2ZW50KGdyaWQsIGdldE1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMzOCA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICB2YXIgb25TZWxlY3RNZXNzYWdlID0gZnVuY3Rpb24gb25TZWxlY3RNZXNzYWdlKHNlbCkge1xuICAgICAgICAgICAgICAgICAgdmFyIHNldE1lc3NhZ2VEYXRhID0gZnVuY3Rpb24gc2V0TWVzc2FnZURhdGEobXNnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaGFzTWVzc2FnZShtc2cpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgX3RoaXMzOC5fZGV0YWNoKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgX3RoaXMzOC5fYXR0YWNoKHNlbC5jb2wsIHNlbC5yb3csIG1zZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gZ2V0TWVzc2FnZShzZWwuY29sLCBzZWwucm93KTtcblxuICAgICAgICAgICAgICAgICAgaWYgKCgwLCB1dGlsc18xLmlzUHJvbWlzZSkobWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMzOC5fZGV0YWNoKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50aGVuKGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3U2VsID0gZ3JpZC5zZWxlY3Rpb24uc2VsZWN0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1NlbC5jb2wgIT09IHNlbC5jb2wgfHwgbmV3U2VsLnJvdyAhPT0gc2VsLnJvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgIHNldE1lc3NhZ2VEYXRhKG1zZyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHNldE1lc3NhZ2VEYXRhKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBncmlkLmxpc3RlbihMR19FVkVOVF9UWVBFXzEuTEdfRVZFTlRfVFlQRS5TRUxFQ1RFRF9DRUxMLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKCFlLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgaWYgKGUuYmVmb3JlLmNvbCA9PT0gZS5jb2wgJiYgZS5iZWZvcmUucm93ID09PSBlLnJvdykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIG9uU2VsZWN0TWVzc2FnZShlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBncmlkLmxpc3RlbihMR19FVkVOVF9UWVBFXzEuTEdfRVZFTlRfVFlQRS5TQ1JPTEwsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBzZWwgPSBncmlkLnNlbGVjdGlvbi5zZWxlY3Q7XG5cbiAgICAgICAgICAgICAgICAgIF90aGlzMzguX21vdmUoc2VsLmNvbCwgc2VsLnJvdyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZ3JpZC5saXN0ZW4oTEdfRVZFTlRfVFlQRV8xLkxHX0VWRU5UX1RZUEUuQ0hBTkdFRF9WQUxVRSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICghZ3JpZC5oYXNGb2N1c0dyaWQoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHZhciBzZWwgPSBncmlkLnNlbGVjdGlvbi5zZWxlY3Q7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChzZWwuY29sICE9PSBlLmNvbCB8fCBzZWwucm93ICE9PSBlLnJvdykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIG9uU2VsZWN0TWVzc2FnZShlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBncmlkLmxpc3RlbihMR19FVkVOVF9UWVBFXzEuTEdfRVZFTlRfVFlQRS5GT0NVU19HUklELCBmdW5jdGlvbiAoX2UpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBzZWwgPSBncmlkLnNlbGVjdGlvbi5zZWxlY3Q7XG4gICAgICAgICAgICAgICAgICBvblNlbGVjdE1lc3NhZ2Uoc2VsKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBncmlkLmxpc3RlbihMR19FVkVOVF9UWVBFXzEuTEdfRVZFTlRfVFlQRS5CTFVSX0dSSUQsIGZ1bmN0aW9uIChfZSkge1xuICAgICAgICAgICAgICAgICAgX3RoaXMzOC5fZGV0YWNoKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIl9nZXRNZXNzYWdlSW5zdGFuY2VPZk1lc3NhZ2VcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRNZXNzYWdlSW5zdGFuY2VPZk1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlSW5zdGFuY2VzID0gdGhpcy5fbWVzc2FnZUluc3RhbmNlcztcblxuICAgICAgICAgICAgICAgIHZhciBfbm9ybWFsaXplTWVzc2FnZSA9IG5vcm1hbGl6ZU1lc3NhZ2UobWVzc2FnZSksXG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSBfbm9ybWFsaXplTWVzc2FnZS50eXBlO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2VJbnN0YW5jZXNbdHlwZV0gfHwgKG1lc3NhZ2VJbnN0YW5jZXNbdHlwZV0gPSBNRVNTQUdFX0lOU1RBTkNFX0ZBQ1RPUllbdHlwZV0odGhpcy5fZ3JpZCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBNZXNzYWdlSGFuZGxlcjtcbiAgICAgICAgICB9KCk7XG5cbiAgICAgICAgICBleHBvcnRzLk1lc3NhZ2VIYW5kbGVyID0gTWVzc2FnZUhhbmRsZXI7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vY29sdW1ucy9tZXNzYWdlL1dhcm5pbmdNZXNzYWdlLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2NvbHVtbnMvbWVzc2FnZS9XYXJuaW5nTWVzc2FnZS5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBjb2x1bW5zTWVzc2FnZVdhcm5pbmdNZXNzYWdlSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICB2YXIgX19jcmVhdGVCaW5kaW5nID0gdGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZyB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICAgICAgICAgICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcblxuICAgICAgICAgICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgICAgICAgICAgZGVzYyA9IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ba107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xuICAgICAgICAgIH0gOiBmdW5jdGlvbiAobywgbSwgaywgazIpIHtcbiAgICAgICAgICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgICAgICAgICBvW2syXSA9IG1ba107XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gdGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCB2KSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHtcbiAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gOiBmdW5jdGlvbiAobywgdikge1xuICAgICAgICAgICAgb1tcImRlZmF1bHRcIl0gPSB2O1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIF9faW1wb3J0U3RhciA9IHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgICAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIHtcbiAgICAgICAgICAgICAgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5XYXJuaW5nTWVzc2FnZSA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBtZXNzYWdlVXRpbHMgPSBfX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9tZXNzYWdlVXRpbHMgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9tZXNzYWdlL21lc3NhZ2VVdGlscy5qc1wiKSk7XG5cbiAgICAgICAgICB2YXIgQmFzZU1lc3NhZ2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vQmFzZU1lc3NhZ2UgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9tZXNzYWdlL0Jhc2VNZXNzYWdlLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIFdhcm5pbmdNZXNzYWdlRWxlbWVudF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9pbnRlcm5hbC9XYXJuaW5nTWVzc2FnZUVsZW1lbnQgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9tZXNzYWdlL2ludGVybmFsL1dhcm5pbmdNZXNzYWdlRWxlbWVudC5qc1wiKTtcblxuICAgICAgICAgIHZhciB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vaW50ZXJuYWwvdXRpbHMgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvdXRpbHMuanNcIik7XG5cbiAgICAgICAgICB2YXIgREVFUF9PUkFOR0VfQTEwMCA9IFwiI2ZmOWU4MFwiO1xuXG4gICAgICAgICAgdmFyIFdhcm5pbmdNZXNzYWdlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZU1lc3NhZ2VfMSRCYXNlTWUzKSB7XG4gICAgICAgICAgICBfaW5oZXJpdHMoV2FybmluZ01lc3NhZ2UsIF9CYXNlTWVzc2FnZV8xJEJhc2VNZTMpO1xuXG4gICAgICAgICAgICB2YXIgX3N1cGVyMTcgPSBfY3JlYXRlU3VwZXIoV2FybmluZ01lc3NhZ2UpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBXYXJuaW5nTWVzc2FnZSgpIHtcbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFdhcm5pbmdNZXNzYWdlKTtcblxuICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyMTcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKFdhcm5pbmdNZXNzYWdlLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiY3JlYXRlTWVzc2FnZUVsZW1lbnRJbnRlcm5hbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlTWVzc2FnZUVsZW1lbnRJbnRlcm5hbCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFdhcm5pbmdNZXNzYWdlRWxlbWVudF8xLldhcm5pbmdNZXNzYWdlRWxlbWVudCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJkcmF3Q2VsbE1lc3NhZ2VJbnRlcm5hbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0NlbGxNZXNzYWdlSW50ZXJuYWwoX21lc3NhZ2UsIGNvbnRleHQsIHN0eWxlLCBoZWxwZXIsIGdyaWQsIF9pbmZvKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJnQ29sb3IgPSBzdHlsZS5iZ0NvbG9yO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9jb250ZXh0JGdldFNlbGVjdGlvbjMgPSBjb250ZXh0LmdldFNlbGVjdGlvbigpLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3QgPSBfY29udGV4dCRnZXRTZWxlY3Rpb24zLnNlbGVjdDtcblxuICAgICAgICAgICAgICAgIGlmICghKDAsIHV0aWxzXzEuY2VsbEluUmFuZ2UpKGdyaWQuZ2V0Q2VsbFJhbmdlKGNvbnRleHQuY29sLCBjb250ZXh0LnJvdyksIHNlbGVjdC5jb2wsIHNlbGVjdC5yb3cpIHx8ICFncmlkLmhhc0ZvY3VzR3JpZCgpKSB7XG4gICAgICAgICAgICAgICAgICBoZWxwZXIuZHJhd0JvcmRlcldpdGhDbGlwKGNvbnRleHQsIGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVV0aWxzLmRyYXdFeGNsYW1hdGlvbk1hcmtCb3goY29udGV4dCwge1xuICAgICAgICAgICAgICAgICAgICAgIGJnQ29sb3I6IGhlbHBlci5nZXRDb2xvcihoZWxwZXIudGhlbWUubWVzc2FnZXMud2FybkJnQ29sb3IsIGNvbnRleHQuY29sLCBjb250ZXh0LnJvdywgY3R4KSB8fCBERUVQX09SQU5HRV9BMTAwLFxuICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBiZ0NvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgIGJveFdpZHRoOiBoZWxwZXIudGhlbWUubWVzc2FnZXMuYm94V2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgbWFya0hlaWdodDogaGVscGVyLnRoZW1lLm1lc3NhZ2VzLm1hcmtIZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgfSwgaGVscGVyKTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gV2FybmluZ01lc3NhZ2U7XG4gICAgICAgICAgfShCYXNlTWVzc2FnZV8xLkJhc2VNZXNzYWdlKTtcblxuICAgICAgICAgIGV4cG9ydHMuV2FybmluZ01lc3NhZ2UgPSBXYXJuaW5nTWVzc2FnZTtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9jb2x1bW5zL21lc3NhZ2UvaW50ZXJuYWwvRXJyb3JNZXNzYWdlRWxlbWVudC5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2NvbHVtbnMvbWVzc2FnZS9pbnRlcm5hbC9FcnJvck1lc3NhZ2VFbGVtZW50LmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gY29sdW1uc01lc3NhZ2VJbnRlcm5hbEVycm9yTWVzc2FnZUVsZW1lbnRKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLkVycm9yTWVzc2FnZUVsZW1lbnQgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgTWVzc2FnZUVsZW1lbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vTWVzc2FnZUVsZW1lbnQgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9tZXNzYWdlL2ludGVybmFsL01lc3NhZ2VFbGVtZW50LmpzXCIpO1xuXG4gICAgICAgICAgdmFyIENMQVNTTkFNRSA9IFwiY2hlZXRhaC1ncmlkX19lcnJvci1tZXNzYWdlLWVsZW1lbnRcIjtcbiAgICAgICAgICB2YXIgTUVTU0FHRV9DTEFTU05BTUUgPSBcIlwiLmNvbmNhdChDTEFTU05BTUUsIFwiX19tZXNzYWdlXCIpO1xuXG4gICAgICAgICAgdmFyIEVycm9yTWVzc2FnZUVsZW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9NZXNzYWdlRWxlbWVudF8xJE1lcykge1xuICAgICAgICAgICAgX2luaGVyaXRzKEVycm9yTWVzc2FnZUVsZW1lbnQsIF9NZXNzYWdlRWxlbWVudF8xJE1lcyk7XG5cbiAgICAgICAgICAgIHZhciBfc3VwZXIxOCA9IF9jcmVhdGVTdXBlcihFcnJvck1lc3NhZ2VFbGVtZW50KTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gRXJyb3JNZXNzYWdlRWxlbWVudCgpIHtcbiAgICAgICAgICAgICAgdmFyIF90aGlzMzk7XG5cbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVycm9yTWVzc2FnZUVsZW1lbnQpO1xuXG4gICAgICAgICAgICAgIF90aGlzMzkgPSBfc3VwZXIxOC5jYWxsKHRoaXMpO1xuXG4gICAgICAgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAgIC8qISBAL2NvbHVtbnMvbWVzc2FnZS9pbnRlcm5hbC9FcnJvck1lc3NhZ2VFbGVtZW50LmNzcyAqL1xuICAgICAgICAgICAgICBcIi4uL3NyYy9qcy9jb2x1bW5zL21lc3NhZ2UvaW50ZXJuYWwvRXJyb3JNZXNzYWdlRWxlbWVudC5jc3NcIik7XG5cbiAgICAgICAgICAgICAgX3RoaXMzOS5fcm9vdEVsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU05BTUUpO1xuXG4gICAgICAgICAgICAgIF90aGlzMzkuX21lc3NhZ2VFbGVtZW50LmNsYXNzTGlzdC5hZGQoTUVTU0FHRV9DTEFTU05BTUUpO1xuXG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczM5O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gRXJyb3JNZXNzYWdlRWxlbWVudDtcbiAgICAgICAgICB9KE1lc3NhZ2VFbGVtZW50XzEuTWVzc2FnZUVsZW1lbnQpO1xuXG4gICAgICAgICAgZXhwb3J0cy5FcnJvck1lc3NhZ2VFbGVtZW50ID0gRXJyb3JNZXNzYWdlRWxlbWVudDtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9jb2x1bW5zL21lc3NhZ2UvaW50ZXJuYWwvTWVzc2FnZUVsZW1lbnQuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vY29sdW1ucy9tZXNzYWdlL2ludGVybmFsL01lc3NhZ2VFbGVtZW50LmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGNvbHVtbnNNZXNzYWdlSW50ZXJuYWxNZXNzYWdlRWxlbWVudEpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuTWVzc2FnZUVsZW1lbnQgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgRXZlbnRIYW5kbGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi8uLi9pbnRlcm5hbC9FdmVudEhhbmRsZXIgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvRXZlbnRIYW5kbGVyLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIGRvbV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vLi4vaW50ZXJuYWwvZG9tICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL2RvbS5qc1wiKTtcblxuICAgICAgICAgIHZhciBDTEFTU05BTUUgPSBcImNoZWV0YWgtZ3JpZF9fbWVzc2FnZS1lbGVtZW50XCI7XG4gICAgICAgICAgdmFyIE1FU1NBR0VfQ0xBU1NOQU1FID0gXCJcIi5jb25jYXQoQ0xBU1NOQU1FLCBcIl9fbWVzc2FnZVwiKTtcbiAgICAgICAgICB2YXIgSElEREVOX0NMQVNTTkFNRSA9IFwiXCIuY29uY2F0KENMQVNTTkFNRSwgXCItLWhpZGRlblwiKTtcbiAgICAgICAgICB2YXIgU0hPV05fQ0xBU1NOQU1FID0gXCJcIi5jb25jYXQoQ0xBU1NOQU1FLCBcIi0tc2hvd25cIik7XG4gICAgICAgICAgdmFyIExFRlRfRElGRl9DU1NfUFJPUF9OQU1FID0gXCItLWNoZWV0YWgtZ3JpZC1tZXNzYWdlLWVsZW1lbnQtbGVmdC1kaWZmXCI7XG5cbiAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVNZXNzYWdlRG9tRWxlbWVudCgpIHtcbiAgICAgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgQC9jb2x1bW5zL21lc3NhZ2UvaW50ZXJuYWwvTWVzc2FnZUVsZW1lbnQuY3NzICovXG4gICAgICAgICAgICBcIi4uL3NyYy9qcy9jb2x1bW5zL21lc3NhZ2UvaW50ZXJuYWwvTWVzc2FnZUVsZW1lbnQuY3NzXCIpO1xuXG4gICAgICAgICAgICB2YXIgcm9vdEVsZW1lbnQgPSAoMCwgZG9tXzEuY3JlYXRlRWxlbWVudCkoXCJkaXZcIiwge1xuICAgICAgICAgICAgICBjbGFzc0xpc3Q6IFtDTEFTU05BTUUsIEhJRERFTl9DTEFTU05BTUVdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlRWxlbWVudCA9ICgwLCBkb21fMS5jcmVhdGVFbGVtZW50KShcInNwYW5cIiwge1xuICAgICAgICAgICAgICBjbGFzc0xpc3Q6IFtNRVNTQUdFX0NMQVNTTkFNRV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcm9vdEVsZW1lbnQuYXBwZW5kQ2hpbGQobWVzc2FnZUVsZW1lbnQpO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3RFbGVtZW50O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBNZXNzYWdlRWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBNZXNzYWdlRWxlbWVudCgpIHtcbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1lc3NhZ2VFbGVtZW50KTtcblxuICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyID0gbmV3IEV2ZW50SGFuZGxlcl8xLkV2ZW50SGFuZGxlcigpO1xuICAgICAgICAgICAgICB2YXIgcm9vdEVsZW1lbnQgPSB0aGlzLl9yb290RWxlbWVudCA9IGNyZWF0ZU1lc3NhZ2VEb21FbGVtZW50KCk7XG4gICAgICAgICAgICAgIHRoaXMuX21lc3NhZ2VFbGVtZW50ID0gcm9vdEVsZW1lbnQucXVlcnlTZWxlY3RvcihcIi5cIi5jb25jYXQoTUVTU0FHRV9DTEFTU05BTUUpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKE1lc3NhZ2VFbGVtZW50LCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiZGlzcG9zZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRldGFjaCgpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlci5kaXNwb3NlKCk7IC8vIEB0cy1leHBlY3QtZXJyb3IgLS0gaWdub3JlXG5cblxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9yb290RWxlbWVudDsgLy8gQHRzLWV4cGVjdC1lcnJvciAtLSBpZ25vcmVcblxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9tZXNzYWdlRWxlbWVudDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiYXR0YWNoXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRhY2goZ3JpZCwgY29sLCByb3csIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgcm9vdEVsZW1lbnQgPSB0aGlzLl9yb290RWxlbWVudDtcbiAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZUVsZW1lbnQgPSB0aGlzLl9tZXNzYWdlRWxlbWVudDtcbiAgICAgICAgICAgICAgICByb290RWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFNIT1dOX0NMQVNTTkFNRSk7XG4gICAgICAgICAgICAgICAgcm9vdEVsZW1lbnQuY2xhc3NMaXN0LmFkZChISURERU5fQ0xBU1NOQU1FKTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hdHRhY2hDZWxsKGdyaWQsIGNvbCwgcm93KSkge1xuICAgICAgICAgICAgICAgICAgcm9vdEVsZW1lbnQuY2xhc3NMaXN0LmFkZChTSE9XTl9DTEFTU05BTUUpO1xuICAgICAgICAgICAgICAgICAgcm9vdEVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShISURERU5fQ0xBU1NOQU1FKTtcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2VFbGVtZW50LnRleHRDb250ZW50ID0gbWVzc2FnZS5tZXNzYWdlO1xuXG4gICAgICAgICAgICAgICAgICB0aGlzLl9hZGp1c3RTdHlsZShncmlkLCBjb2wsIHJvdyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2RldGFjaCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwibW92ZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZShncmlkLCBjb2wsIHJvdykge1xuICAgICAgICAgICAgICAgIHZhciByb290RWxlbWVudCA9IHRoaXMuX3Jvb3RFbGVtZW50O1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2F0dGFjaENlbGwoZ3JpZCwgY29sLCByb3cpKSB7XG4gICAgICAgICAgICAgICAgICByb290RWxlbWVudC5jbGFzc0xpc3QuYWRkKFNIT1dOX0NMQVNTTkFNRSk7XG4gICAgICAgICAgICAgICAgICByb290RWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKEhJRERFTl9DTEFTU05BTUUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9kZXRhY2goKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImRldGFjaFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGV0YWNoKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RldGFjaCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJfZGV0YWNoXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZGV0YWNoKCkge1xuICAgICAgICAgICAgICAgIHZhciByb290RWxlbWVudCA9IHRoaXMuX3Jvb3RFbGVtZW50O1xuXG4gICAgICAgICAgICAgICAgaWYgKHJvb3RFbGVtZW50LnBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgIHJvb3RFbGVtZW50LnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQocm9vdEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgcm9vdEVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShTSE9XTl9DTEFTU05BTUUpO1xuICAgICAgICAgICAgICAgICAgcm9vdEVsZW1lbnQuY2xhc3NMaXN0LmFkZChISURERU5fQ0xBU1NOQU1FKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIl9hdHRhY2hDZWxsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfYXR0YWNoQ2VsbChncmlkLCBjb2wsIHJvdykge1xuICAgICAgICAgICAgICAgIHZhciByb290RWxlbWVudCA9IHRoaXMuX3Jvb3RFbGVtZW50O1xuXG4gICAgICAgICAgICAgICAgdmFyIF9ncmlkJGdldEF0dGFjaENlbGxzQTQgPSBncmlkLmdldEF0dGFjaENlbGxzQXJlYShncmlkLmdldENlbGxSYW5nZShjb2wsIHJvdykpLFxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gX2dyaWQkZ2V0QXR0YWNoQ2VsbHNBNC5lbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICByZWN0ID0gX2dyaWQkZ2V0QXR0YWNoQ2VsbHNBNC5yZWN0O1xuXG4gICAgICAgICAgICAgICAgdmFyIHRvcCA9IHJlY3QuYm90dG9tLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gcmVjdC5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IHJlY3Qud2lkdGg7XG4gICAgICAgICAgICAgICAgdmFyIGZyb3plblJvd0NvdW50ID0gZ3JpZC5mcm96ZW5Sb3dDb3VudCxcbiAgICAgICAgICAgICAgICAgICAgZnJvemVuQ29sQ291bnQgPSBncmlkLmZyb3plbkNvbENvdW50O1xuXG4gICAgICAgICAgICAgICAgaWYgKHJvdyA+PSBmcm96ZW5Sb3dDb3VudCAmJiBmcm96ZW5Sb3dDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIHZhciBfZ3JpZCRnZXRBdHRhY2hDZWxsc0E1ID0gZ3JpZC5nZXRBdHRhY2hDZWxsc0FyZWEoZ3JpZC5nZXRDZWxsUmFuZ2UoY29sLCBmcm96ZW5Sb3dDb3VudCAtIDEpKSxcbiAgICAgICAgICAgICAgICAgICAgICBmcm96ZW5SZWN0ID0gX2dyaWQkZ2V0QXR0YWNoQ2VsbHNBNS5yZWN0O1xuXG4gICAgICAgICAgICAgICAgICBpZiAodG9wIDwgZnJvemVuUmVjdC5ib3R0b20pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBPdXRzaWRlIHRoZSByZWN0YW5nbGUuXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0b3AgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gT3V0c2lkZSB0aGUgcmVjdGFuZ2xlLlxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjb2wgPj0gZnJvemVuQ29sQ291bnQgJiYgZnJvemVuQ29sQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgX2dyaWQkZ2V0QXR0YWNoQ2VsbHNBNiA9IGdyaWQuZ2V0QXR0YWNoQ2VsbHNBcmVhKGdyaWQuZ2V0Q2VsbFJhbmdlKGZyb3plbkNvbENvdW50IC0gMSwgcm93KSksXG4gICAgICAgICAgICAgICAgICAgICAgX2Zyb3plblJlY3QgPSBfZ3JpZCRnZXRBdHRhY2hDZWxsc0E2LnJlY3Q7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChsZWZ0IDwgX2Zyb3plblJlY3QucmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBPdXRzaWRlIHRoZSByZWN0YW5nbGUuXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlmIChsZWZ0IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIE91dHNpZGUgdGhlIHJlY3RhbmdsZS5cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0SGVpZ2h0ID0gZWxlbWVudC5vZmZzZXRIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFdpZHRoID0gZWxlbWVudC5vZmZzZXRXaWR0aDtcblxuICAgICAgICAgICAgICAgIGlmIChvZmZzZXRIZWlnaHQgPCB0b3ApIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gT3V0c2lkZSB0aGUgcmVjdGFuZ2xlLlxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChvZmZzZXRXaWR0aCA8IGxlZnQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gT3V0c2lkZSB0aGUgcmVjdGFuZ2xlLlxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJvb3RFbGVtZW50LnN0eWxlLnRvcCA9IFwiXCIuY29uY2F0KHRvcC50b0ZpeGVkKCksIFwicHhcIik7XG4gICAgICAgICAgICAgICAgcm9vdEVsZW1lbnQuc3R5bGUubGVmdCA9IFwiXCIuY29uY2F0KGxlZnQudG9GaXhlZCgpLCBcInB4XCIpO1xuICAgICAgICAgICAgICAgIHJvb3RFbGVtZW50LnN0eWxlLndpZHRoID0gXCJcIi5jb25jYXQod2lkdGgudG9GaXhlZCgpLCBcInB4XCIpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJvb3RFbGVtZW50LnBhcmVudEVsZW1lbnQgIT09IGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQocm9vdEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBJZiB0aGUgbWVzc2FnZSBpcyBwbGFjZWQgb3V0c2lkZSB0aGUgR3JpZCwgYWRqdXN0IGl0cyBwb3NpdGlvbi5cbiAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIl9hZGp1c3RTdHlsZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2FkanVzdFN0eWxlKGdyaWQsIGNvbCwgcm93KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJvb3RFbGVtZW50ID0gdGhpcy5fcm9vdEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBncmlkLmdldEVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZVJlY3QgPSByb290RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudFJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlTGVmdCA9IG1lc3NhZ2VSZWN0LmxlZnQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudFJlY3QucmlnaHQgPCBtZXNzYWdlUmVjdC5yaWdodCkge1xuICAgICAgICAgICAgICAgICAgdmFyIG92ZXJmbG93ID0gbWVzc2FnZVJlY3QucmlnaHQgLSBlbGVtZW50UmVjdC5yaWdodDtcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2VMZWZ0IC09IG92ZXJmbG93O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlTGVmdCA8IGVsZW1lbnRSZWN0LmxlZnQpIHtcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2VMZWZ0ID0gZWxlbWVudFJlY3QubGVmdDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZUxlZnQgIT09IG1lc3NhZ2VSZWN0LmxlZnQpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBkaWZmID0gbWVzc2FnZVJlY3QubGVmdCAtIG1lc3NhZ2VMZWZ0O1xuXG4gICAgICAgICAgICAgICAgICB2YXIgX2dyaWQkZ2V0QXR0YWNoQ2VsbHNBNyA9IGdyaWQuZ2V0QXR0YWNoQ2VsbHNBcmVhKGdyaWQuZ2V0Q2VsbFJhbmdlKGNvbCwgcm93KSksXG4gICAgICAgICAgICAgICAgICAgICAgcmVjdCA9IF9ncmlkJGdldEF0dGFjaENlbGxzQTcucmVjdDtcblxuICAgICAgICAgICAgICAgICAgcm9vdEVsZW1lbnQuc3R5bGUubGVmdCA9IFwiXCIuY29uY2F0KChyZWN0LmxlZnQgLSBkaWZmKS50b0ZpeGVkKCksIFwicHhcIik7XG4gICAgICAgICAgICAgICAgICB2YXIgZGlmZkNzcyA9IFwiXCIuY29uY2F0KGRpZmYudG9GaXhlZCgpLCBcInB4XCIpO1xuICAgICAgICAgICAgICAgICAgcm9vdEVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoTEVGVF9ESUZGX0NTU19QUk9QX05BTUUsIGRpZmZDc3MpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByb290RWxlbWVudC5zdHlsZS5yZW1vdmVQcm9wZXJ0eShMRUZUX0RJRkZfQ1NTX1BST1BfTkFNRSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBNZXNzYWdlRWxlbWVudDtcbiAgICAgICAgICB9KCk7XG5cbiAgICAgICAgICBleHBvcnRzLk1lc3NhZ2VFbGVtZW50ID0gTWVzc2FnZUVsZW1lbnQ7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vY29sdW1ucy9tZXNzYWdlL2ludGVybmFsL1dhcm5pbmdNZXNzYWdlRWxlbWVudC5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vY29sdW1ucy9tZXNzYWdlL2ludGVybmFsL1dhcm5pbmdNZXNzYWdlRWxlbWVudC5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gY29sdW1uc01lc3NhZ2VJbnRlcm5hbFdhcm5pbmdNZXNzYWdlRWxlbWVudEpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuV2FybmluZ01lc3NhZ2VFbGVtZW50ID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIE1lc3NhZ2VFbGVtZW50XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL01lc3NhZ2VFbGVtZW50ICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvbWVzc2FnZS9pbnRlcm5hbC9NZXNzYWdlRWxlbWVudC5qc1wiKTtcblxuICAgICAgICAgIHZhciBDTEFTU05BTUUgPSBcImNoZWV0YWgtZ3JpZF9fd2FybmluZy1tZXNzYWdlLWVsZW1lbnRcIjtcbiAgICAgICAgICB2YXIgTUVTU0FHRV9DTEFTU05BTUUgPSBcIlwiLmNvbmNhdChDTEFTU05BTUUsIFwiX19tZXNzYWdlXCIpO1xuXG4gICAgICAgICAgdmFyIFdhcm5pbmdNZXNzYWdlRWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX01lc3NhZ2VFbGVtZW50XzEkTWVzMikge1xuICAgICAgICAgICAgX2luaGVyaXRzKFdhcm5pbmdNZXNzYWdlRWxlbWVudCwgX01lc3NhZ2VFbGVtZW50XzEkTWVzMik7XG5cbiAgICAgICAgICAgIHZhciBfc3VwZXIxOSA9IF9jcmVhdGVTdXBlcihXYXJuaW5nTWVzc2FnZUVsZW1lbnQpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBXYXJuaW5nTWVzc2FnZUVsZW1lbnQoKSB7XG4gICAgICAgICAgICAgIHZhciBfdGhpczQwO1xuXG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBXYXJuaW5nTWVzc2FnZUVsZW1lbnQpO1xuXG4gICAgICAgICAgICAgIF90aGlzNDAgPSBfc3VwZXIxOS5jYWxsKHRoaXMpO1xuXG4gICAgICAgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAgIC8qISBAL2NvbHVtbnMvbWVzc2FnZS9pbnRlcm5hbC9XYXJuaW5nTWVzc2FnZUVsZW1lbnQuY3NzICovXG4gICAgICAgICAgICAgIFwiLi4vc3JjL2pzL2NvbHVtbnMvbWVzc2FnZS9pbnRlcm5hbC9XYXJuaW5nTWVzc2FnZUVsZW1lbnQuY3NzXCIpO1xuXG4gICAgICAgICAgICAgIF90aGlzNDAuX3Jvb3RFbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NOQU1FKTtcblxuICAgICAgICAgICAgICBfdGhpczQwLl9tZXNzYWdlRWxlbWVudC5jbGFzc0xpc3QuYWRkKE1FU1NBR0VfQ0xBU1NOQU1FKTtcblxuICAgICAgICAgICAgICByZXR1cm4gX3RoaXM0MDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIFdhcm5pbmdNZXNzYWdlRWxlbWVudDtcbiAgICAgICAgICB9KE1lc3NhZ2VFbGVtZW50XzEuTWVzc2FnZUVsZW1lbnQpO1xuXG4gICAgICAgICAgZXhwb3J0cy5XYXJuaW5nTWVzc2FnZUVsZW1lbnQgPSBXYXJuaW5nTWVzc2FnZUVsZW1lbnQ7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vY29sdW1ucy9tZXNzYWdlL21lc3NhZ2VVdGlscy5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vY29sdW1ucy9tZXNzYWdlL21lc3NhZ2VVdGlscy5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gY29sdW1uc01lc3NhZ2VNZXNzYWdlVXRpbHNKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLmRyYXdJbmZvcm1hdGlvbk1hcmtCb3ggPSBleHBvcnRzLmRyYXdFeGNsYW1hdGlvbk1hcmtCb3ggPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgUmVjdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vaW50ZXJuYWwvUmVjdCAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC9SZWN0LmpzXCIpO1xuXG4gICAgICAgICAgZnVuY3Rpb24gZHJhd0V4Y2xhbWF0aW9uTWFya0JveChjb250ZXh0LCBzdHlsZSwgaGVscGVyKSB7XG4gICAgICAgICAgICB2YXIgYmdDb2xvciA9IHN0eWxlLmJnQ29sb3IsXG4gICAgICAgICAgICAgICAgY29sb3IgPSBzdHlsZS5jb2xvcixcbiAgICAgICAgICAgICAgICBib3hXaWR0aCA9IHN0eWxlLmJveFdpZHRoLFxuICAgICAgICAgICAgICAgIG1hcmtIZWlnaHQgPSBzdHlsZS5tYXJrSGVpZ2h0O1xuICAgICAgICAgICAgdmFyIGN0eCA9IGNvbnRleHQuZ2V0Q29udGV4dCgpO1xuICAgICAgICAgICAgdmFyIHJlY3QgPSBjb250ZXh0LmdldFJlY3QoKTsgLy8gZHJhdyBib3hcblxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGJnQ29sb3I7XG4gICAgICAgICAgICB2YXIgYm94UmVjdCA9IHJlY3QuY29weSgpO1xuICAgICAgICAgICAgYm94UmVjdC5sZWZ0ID0gYm94UmVjdC5yaWdodCAtIChOdW1iZXIoYm94V2lkdGgpIHx8IDI0KTtcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdChib3hSZWN0LmxlZnQsIGJveFJlY3QudG9wLCBib3hSZWN0LndpZHRoLCBib3hSZWN0LmhlaWdodCAtIDEpOyAvLyBkcmF3IGV4Y2xhbWF0aW9uIG1hcmtcblxuICAgICAgICAgICAgdmFyIGZpbGxDb2xvciA9IGNvbG9yO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IE51bWJlcihtYXJrSGVpZ2h0KSB8fCAyMDtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IGhlaWdodCAvIDU7XG4gICAgICAgICAgICB2YXIgbGVmdCA9IGJveFJlY3QubGVmdCArIChib3hSZWN0LndpZHRoIC0gd2lkdGgpIC8gMjtcbiAgICAgICAgICAgIHZhciB0b3AgPSBib3hSZWN0LnRvcCArIChib3hSZWN0LmhlaWdodCAtIGhlaWdodCkgLyAyO1xuICAgICAgICAgICAgaGVscGVyLmZpbGxSZWN0V2l0aFN0YXRlKG5ldyBSZWN0XzEuUmVjdChsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQgLyA1ICogMyksIGNvbnRleHQsIHtcbiAgICAgICAgICAgICAgZmlsbENvbG9yOiBmaWxsQ29sb3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaGVscGVyLmZpbGxSZWN0V2l0aFN0YXRlKG5ldyBSZWN0XzEuUmVjdChsZWZ0LCB0b3AgKyBoZWlnaHQgLyA1ICogNCwgd2lkdGgsIGhlaWdodCAvIDUpLCBjb250ZXh0LCB7XG4gICAgICAgICAgICAgIGZpbGxDb2xvcjogZmlsbENvbG9yXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRzLmRyYXdFeGNsYW1hdGlvbk1hcmtCb3ggPSBkcmF3RXhjbGFtYXRpb25NYXJrQm94O1xuXG4gICAgICAgICAgZnVuY3Rpb24gZHJhd0luZm9ybWF0aW9uTWFya0JveChjb250ZXh0LCBzdHlsZSwgaGVscGVyKSB7XG4gICAgICAgICAgICB2YXIgYmdDb2xvciA9IHN0eWxlLmJnQ29sb3IsXG4gICAgICAgICAgICAgICAgY29sb3IgPSBzdHlsZS5jb2xvcixcbiAgICAgICAgICAgICAgICBib3hXaWR0aCA9IHN0eWxlLmJveFdpZHRoLFxuICAgICAgICAgICAgICAgIG1hcmtIZWlnaHQgPSBzdHlsZS5tYXJrSGVpZ2h0O1xuICAgICAgICAgICAgdmFyIGN0eCA9IGNvbnRleHQuZ2V0Q29udGV4dCgpO1xuICAgICAgICAgICAgdmFyIHJlY3QgPSBjb250ZXh0LmdldFJlY3QoKTsgLy8gZHJhdyBib3hcblxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGJnQ29sb3I7XG4gICAgICAgICAgICB2YXIgYm94UmVjdCA9IHJlY3QuY29weSgpO1xuICAgICAgICAgICAgYm94UmVjdC5sZWZ0ID0gYm94UmVjdC5yaWdodCAtIChOdW1iZXIoYm94V2lkdGgpIHx8IDI0KTtcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdChib3hSZWN0LmxlZnQsIGJveFJlY3QudG9wLCBib3hSZWN0LndpZHRoLCBib3hSZWN0LmhlaWdodCAtIDEpOyAvLyBkcmF3IGkgbWFya1xuXG4gICAgICAgICAgICB2YXIgZmlsbENvbG9yID0gY29sb3I7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gTnVtYmVyKG1hcmtIZWlnaHQpIHx8IDIwO1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gaGVpZ2h0IC8gNTtcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gYm94UmVjdC5sZWZ0ICsgKGJveFJlY3Qud2lkdGggLSB3aWR0aCkgLyAyO1xuICAgICAgICAgICAgdmFyIHRvcCA9IGJveFJlY3QudG9wICsgKGJveFJlY3QuaGVpZ2h0IC0gaGVpZ2h0KSAvIDI7XG4gICAgICAgICAgICBoZWxwZXIuZmlsbFJlY3RXaXRoU3RhdGUobmV3IFJlY3RfMS5SZWN0KGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCAvIDUpLCBjb250ZXh0LCB7XG4gICAgICAgICAgICAgIGZpbGxDb2xvcjogZmlsbENvbG9yXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGhlbHBlci5maWxsUmVjdFdpdGhTdGF0ZShuZXcgUmVjdF8xLlJlY3QobGVmdCwgdG9wICsgaGVpZ2h0IC8gNSAqIDIsIHdpZHRoLCBoZWlnaHQgLyA1ICogMyksIGNvbnRleHQsIHtcbiAgICAgICAgICAgICAgZmlsbENvbG9yOiBmaWxsQ29sb3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMuZHJhd0luZm9ybWF0aW9uTWFya0JveCA9IGRyYXdJbmZvcm1hdGlvbk1hcmtCb3g7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vY29sdW1ucy9zdHlsZS5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vY29sdW1ucy9zdHlsZS5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gY29sdW1uc1N0eWxlSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5vZiA9IGV4cG9ydHMuVHJlZVN0eWxlID0gZXhwb3J0cy5NZW51U3R5bGUgPSBleHBvcnRzLk11bHRpbGluZVRleHRTdHlsZSA9IGV4cG9ydHMuUGVyY2VudENvbXBsZXRlQmFyU3R5bGUgPSBleHBvcnRzLkljb25TdHlsZSA9IGV4cG9ydHMuSW1hZ2VTdHlsZSA9IGV4cG9ydHMuQnV0dG9uU3R5bGUgPSBleHBvcnRzLlJhZGlvU3R5bGUgPSBleHBvcnRzLkNoZWNrU3R5bGUgPSBleHBvcnRzLk51bWJlclN0eWxlID0gZXhwb3J0cy5TdHlsZSA9IGV4cG9ydHMuQmFzZVN0eWxlID0gZXhwb3J0cy5FVkVOVF9UWVBFID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIEJhc2VTdHlsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9zdHlsZS9CYXNlU3R5bGUgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9zdHlsZS9CYXNlU3R5bGUuanNcIik7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCYXNlU3R5bGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICByZXR1cm4gQmFzZVN0eWxlXzEuQmFzZVN0eWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIEJ1dHRvblN0eWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL3N0eWxlL0J1dHRvblN0eWxlICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvc3R5bGUvQnV0dG9uU3R5bGUuanNcIik7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCdXR0b25TdHlsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBCdXR0b25TdHlsZV8xLkJ1dHRvblN0eWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIENoZWNrU3R5bGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vc3R5bGUvQ2hlY2tTdHlsZSAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3N0eWxlL0NoZWNrU3R5bGUuanNcIik7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDaGVja1N0eWxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIENoZWNrU3R5bGVfMS5DaGVja1N0eWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIEljb25TdHlsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9zdHlsZS9JY29uU3R5bGUgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9zdHlsZS9JY29uU3R5bGUuanNcIik7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJY29uU3R5bGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICByZXR1cm4gSWNvblN0eWxlXzEuSWNvblN0eWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIEltYWdlU3R5bGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vc3R5bGUvSW1hZ2VTdHlsZSAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3N0eWxlL0ltYWdlU3R5bGUuanNcIik7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbWFnZVN0eWxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIEltYWdlU3R5bGVfMS5JbWFnZVN0eWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIE1lbnVTdHlsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9zdHlsZS9NZW51U3R5bGUgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9zdHlsZS9NZW51U3R5bGUuanNcIik7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNZW51U3R5bGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICByZXR1cm4gTWVudVN0eWxlXzEuTWVudVN0eWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIE11bHRpbGluZVRleHRTdHlsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9zdHlsZS9NdWx0aWxpbmVUZXh0U3R5bGUgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9zdHlsZS9NdWx0aWxpbmVUZXh0U3R5bGUuanNcIik7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNdWx0aWxpbmVUZXh0U3R5bGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICByZXR1cm4gTXVsdGlsaW5lVGV4dFN0eWxlXzEuTXVsdGlsaW5lVGV4dFN0eWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIE51bWJlclN0eWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL3N0eWxlL051bWJlclN0eWxlICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvc3R5bGUvTnVtYmVyU3R5bGUuanNcIik7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOdW1iZXJTdHlsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBOdW1iZXJTdHlsZV8xLk51bWJlclN0eWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIFBlcmNlbnRDb21wbGV0ZUJhclN0eWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL3N0eWxlL1BlcmNlbnRDb21wbGV0ZUJhclN0eWxlICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvc3R5bGUvUGVyY2VudENvbXBsZXRlQmFyU3R5bGUuanNcIik7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQZXJjZW50Q29tcGxldGVCYXJTdHlsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBQZXJjZW50Q29tcGxldGVCYXJTdHlsZV8xLlBlcmNlbnRDb21wbGV0ZUJhclN0eWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIFJhZGlvU3R5bGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vc3R5bGUvUmFkaW9TdHlsZSAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3N0eWxlL1JhZGlvU3R5bGUuanNcIik7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSYWRpb1N0eWxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFJhZGlvU3R5bGVfMS5SYWRpb1N0eWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIFN0eWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL3N0eWxlL1N0eWxlICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvc3R5bGUvU3R5bGUuanNcIik7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTdHlsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBTdHlsZV8xLlN0eWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIFRyZWVTdHlsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9zdHlsZS9UcmVlU3R5bGUgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9zdHlsZS9UcmVlU3R5bGUuanNcIik7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUcmVlU3R5bGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICByZXR1cm4gVHJlZVN0eWxlXzEuVHJlZVN0eWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBFVkVOVF9UWVBFID0gQmFzZVN0eWxlXzEuQmFzZVN0eWxlLkVWRU5UX1RZUEU7XG4gICAgICAgICAgZXhwb3J0cy5FVkVOVF9UWVBFID0gRVZFTlRfVFlQRTtcblxuICAgICAgICAgIGZ1bmN0aW9uIG9mKGNvbHVtblN0eWxlLCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgIHJlY29yZCkge1xuICAgICAgICAgICAgdmFyIFN0eWxlQ2xhc3NEZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IFN0eWxlXzEuU3R5bGU7XG5cbiAgICAgICAgICAgIGlmIChjb2x1bW5TdHlsZSkge1xuICAgICAgICAgICAgICBpZiAoY29sdW1uU3R5bGUgaW5zdGFuY2VvZiBCYXNlU3R5bGVfMS5CYXNlU3R5bGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sdW1uU3R5bGU7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbHVtblN0eWxlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2YoY29sdW1uU3R5bGUocmVjb3JkKSwgcmVjb3JkLCBTdHlsZUNsYXNzRGVmKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQgJiYgY29sdW1uU3R5bGUgaW4gcmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9mKHJlY29yZFtjb2x1bW5TdHlsZV0sIHJlY29yZCwgU3R5bGVDbGFzc0RlZik7XG4gICAgICAgICAgICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcblxuXG4gICAgICAgICAgICAgIHJldHVybiBuZXcgU3R5bGVDbGFzc0RlZihjb2x1bW5TdHlsZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gU3R5bGVDbGFzc0RlZi5ERUZBVUxUO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMub2YgPSBvZjtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9jb2x1bW5zL3N0eWxlL0Jhc2VTdHlsZS5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2NvbHVtbnMvc3R5bGUvQmFzZVN0eWxlLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gY29sdW1uc1N0eWxlQmFzZVN0eWxlSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5CYXNlU3R5bGUgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgRXZlbnRUYXJnZXRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uL2NvcmUvRXZlbnRUYXJnZXQgKi9cbiAgICAgICAgICBcIi4vY29yZS9FdmVudFRhcmdldC5qc1wiKTtcblxuICAgICAgICAgIHZhciBTVFlMRV9FVkVOVF9UWVBFID0ge1xuICAgICAgICAgICAgQ0hBTkdFX1NUWUxFOiBcImNoYW5nZV9zdHlsZVwiXG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgZGVmYXVsdFN0eWxlO1xuXG4gICAgICAgICAgdmFyIEJhc2VTdHlsZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0V2ZW50VGFyZ2V0XzEkRXZlbnRUKSB7XG4gICAgICAgICAgICBfaW5oZXJpdHMoQmFzZVN0eWxlLCBfRXZlbnRUYXJnZXRfMSRFdmVudFQpO1xuXG4gICAgICAgICAgICB2YXIgX3N1cGVyMjAgPSBfY3JlYXRlU3VwZXIoQmFzZVN0eWxlKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gQmFzZVN0eWxlKCkge1xuICAgICAgICAgICAgICB2YXIgX3RoaXM0MTtcblxuICAgICAgICAgICAgICB2YXIgX3JlZjI2ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgICAgICAgICAgIGJnQ29sb3IgPSBfcmVmMjYuYmdDb2xvcixcbiAgICAgICAgICAgICAgICAgIHZpc2liaWxpdHkgPSBfcmVmMjYudmlzaWJpbGl0eSxcbiAgICAgICAgICAgICAgICAgIGluZGljYXRvclRvcExlZnQgPSBfcmVmMjYuaW5kaWNhdG9yVG9wTGVmdCxcbiAgICAgICAgICAgICAgICAgIGluZGljYXRvclRvcFJpZ2h0ID0gX3JlZjI2LmluZGljYXRvclRvcFJpZ2h0LFxuICAgICAgICAgICAgICAgICAgaW5kaWNhdG9yQm90dG9tUmlnaHQgPSBfcmVmMjYuaW5kaWNhdG9yQm90dG9tUmlnaHQsXG4gICAgICAgICAgICAgICAgICBpbmRpY2F0b3JCb3R0b21MZWZ0ID0gX3JlZjI2LmluZGljYXRvckJvdHRvbUxlZnQ7XG5cbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJhc2VTdHlsZSk7XG5cbiAgICAgICAgICAgICAgX3RoaXM0MSA9IF9zdXBlcjIwLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgIF90aGlzNDEuX2JnQ29sb3IgPSBiZ0NvbG9yO1xuICAgICAgICAgICAgICBfdGhpczQxLl92aXNpYmlsaXR5ID0gbm9ybWFsaXplVmlzaWJpbGl0eSh2aXNpYmlsaXR5LCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICBfdGhpczQxLl9pbmRpY2F0b3JUb3BMZWZ0ID0gbm9ybWFsaXplSW5kaWNhdG9yKGluZGljYXRvclRvcExlZnQpO1xuICAgICAgICAgICAgICBfdGhpczQxLl9pbmRpY2F0b3JUb3BSaWdodCA9IG5vcm1hbGl6ZUluZGljYXRvcihpbmRpY2F0b3JUb3BSaWdodCk7XG4gICAgICAgICAgICAgIF90aGlzNDEuX2luZGljYXRvckJvdHRvbVJpZ2h0ID0gbm9ybWFsaXplSW5kaWNhdG9yKGluZGljYXRvckJvdHRvbVJpZ2h0KTtcbiAgICAgICAgICAgICAgX3RoaXM0MS5faW5kaWNhdG9yQm90dG9tTGVmdCA9IG5vcm1hbGl6ZUluZGljYXRvcihpbmRpY2F0b3JCb3R0b21MZWZ0KTtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzNDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhCYXNlU3R5bGUsIFt7XG4gICAgICAgICAgICAgIGtleTogXCJiZ0NvbG9yXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9iZ0NvbG9yO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChiZ0NvbG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmdDb2xvciA9IGJnQ29sb3I7XG4gICAgICAgICAgICAgICAgdGhpcy5kb0NoYW5nZVN0eWxlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInZpc2liaWxpdHlcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2liaWxpdHk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZpc2liaWxpdHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZVZpc2liaWxpdHkodmlzaWJpbGl0eSwgdGhpcy5fdmlzaWJpbGl0eSk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdmlzaWJpbGl0eSA9PT0gbm9ybWFsaXplZCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX3Zpc2liaWxpdHkgPSBub3JtYWxpemVkO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9DaGFuZ2VTdHlsZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJpbmRpY2F0b3JUb3BMZWZ0XCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbmRpY2F0b3JUb3BMZWZ0O1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChpbmRpY2F0b3JUb3BMZWZ0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5kaWNhdG9yVG9wTGVmdCA9IG5vcm1hbGl6ZUluZGljYXRvcihpbmRpY2F0b3JUb3BMZWZ0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmRvQ2hhbmdlU3R5bGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiaW5kaWNhdG9yVG9wUmlnaHRcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2luZGljYXRvclRvcFJpZ2h0O1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChpbmRpY2F0b3JUb3BSaWdodCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2luZGljYXRvclRvcFJpZ2h0ID0gbm9ybWFsaXplSW5kaWNhdG9yKGluZGljYXRvclRvcFJpZ2h0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmRvQ2hhbmdlU3R5bGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiaW5kaWNhdG9yQm90dG9tUmlnaHRcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2luZGljYXRvckJvdHRvbVJpZ2h0O1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChpbmRpY2F0b3JCb3R0b21SaWdodCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2luZGljYXRvckJvdHRvbVJpZ2h0ID0gbm9ybWFsaXplSW5kaWNhdG9yKGluZGljYXRvckJvdHRvbVJpZ2h0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmRvQ2hhbmdlU3R5bGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiaW5kaWNhdG9yQm90dG9tTGVmdFwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faW5kaWNhdG9yQm90dG9tTGVmdDtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoaW5kaWNhdG9yQm90dG9tTGVmdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2luZGljYXRvckJvdHRvbUxlZnQgPSBub3JtYWxpemVJbmRpY2F0b3IoaW5kaWNhdG9yQm90dG9tTGVmdCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kb0NoYW5nZVN0eWxlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImRvQ2hhbmdlU3R5bGVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRvQ2hhbmdlU3R5bGUoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlTGlzdGVuZXJzKFNUWUxFX0VWRU5UX1RZUEUuQ0hBTkdFX1NUWUxFKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY2xvbmVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmFzZVN0eWxlKHRoaXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSwgW3tcbiAgICAgICAgICAgICAga2V5OiBcIkVWRU5UX1RZUEVcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFNUWUxFX0VWRU5UX1RZUEU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIkRFRkFVTFRcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRTdHlsZSA/IGRlZmF1bHRTdHlsZSA6IGRlZmF1bHRTdHlsZSA9IG5ldyBCYXNlU3R5bGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gQmFzZVN0eWxlO1xuICAgICAgICAgIH0oRXZlbnRUYXJnZXRfMS5FdmVudFRhcmdldCk7XG5cbiAgICAgICAgICBleHBvcnRzLkJhc2VTdHlsZSA9IEJhc2VTdHlsZTtcblxuICAgICAgICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZUluZGljYXRvcihpbmRpY2F0b3IpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5kaWNhdG9yID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3R5bGU6IGluZGljYXRvclxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaW5kaWNhdG9yO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVZpc2liaWxpdHkodmlzaWJpbGl0eSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmlzaWJpbGl0eSAmJiB2aXNpYmlsaXR5ICE9PSBcInZpc2libGVcIiAmJiB2aXNpYmlsaXR5ICE9PSBcImhpZGRlblwiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB2aXNpYmlsaXR5O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKioqL1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2NvbHVtbnMvc3R5bGUvQnJhbmNoR3JhcGhTdHlsZS5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9jb2x1bW5zL3N0eWxlL0JyYW5jaEdyYXBoU3R5bGUuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gY29sdW1uc1N0eWxlQnJhbmNoR3JhcGhTdHlsZUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuQnJhbmNoR3JhcGhTdHlsZSA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBCYXNlU3R5bGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vQmFzZVN0eWxlICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvc3R5bGUvQmFzZVN0eWxlLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIGRlZmF1bHRTdHlsZTtcblxuICAgICAgICAgIHZhciBERUZBVUxUX0JSQU5DSF9DT0xPUlMgPSBmdW5jdGlvbiBERUZBVUxUX0JSQU5DSF9DT0xPUlMoX25hbWUsIGluZGV4KSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGluZGV4ICUgMykge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiIzk3OTc5N1wiO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCIjMDA4ZmI1XCI7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiBcIiNmMWMxMDlcIjtcblxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gXCIjOTc5Nzk3XCI7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHZhciBCcmFuY2hHcmFwaFN0eWxlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZVN0eWxlXzEkQmFzZVN0eWwpIHtcbiAgICAgICAgICAgIF9pbmhlcml0cyhCcmFuY2hHcmFwaFN0eWxlLCBfQmFzZVN0eWxlXzEkQmFzZVN0eWwpO1xuXG4gICAgICAgICAgICB2YXIgX3N1cGVyMjEgPSBfY3JlYXRlU3VwZXIoQnJhbmNoR3JhcGhTdHlsZSk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIEJyYW5jaEdyYXBoU3R5bGUoKSB7XG4gICAgICAgICAgICAgIHZhciBfdGhpczQyO1xuXG4gICAgICAgICAgICAgIHZhciBzdHlsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJyYW5jaEdyYXBoU3R5bGUpO1xuXG4gICAgICAgICAgICAgIF90aGlzNDIgPSBfc3VwZXIyMS5jYWxsKHRoaXMsIHN0eWxlKTtcbiAgICAgICAgICAgICAgX3RoaXM0Mi5fYnJhbmNoQ29sb3JzID0gc3R5bGUuYnJhbmNoQ29sb3JzIHx8IERFRkFVTFRfQlJBTkNIX0NPTE9SUztcbiAgICAgICAgICAgICAgX3RoaXM0Mi5fbWFyZ2luID0gc3R5bGUubWFyZ2luIHx8IDQ7XG4gICAgICAgICAgICAgIF90aGlzNDIuX2NpcmNsZVNpemUgPSBzdHlsZS5jaXJjbGVTaXplIHx8IDE2O1xuICAgICAgICAgICAgICBfdGhpczQyLl9icmFuY2hMaW5lV2lkdGggPSBzdHlsZS5icmFuY2hMaW5lV2lkdGggfHwgNDtcbiAgICAgICAgICAgICAgX3RoaXM0Mi5fbWVyZ2VTdHlsZSA9IHN0eWxlLm1lcmdlU3R5bGUgPT09IFwic3RyYWlnaHRcIiA/IFwic3RyYWlnaHRcIiA6IFwiYmV6aWVyXCI7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczQyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoQnJhbmNoR3JhcGhTdHlsZSwgW3tcbiAgICAgICAgICAgICAga2V5OiBcImJyYW5jaENvbG9yc1wiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYnJhbmNoQ29sb3JzO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChicmFuY2hDb2xvcnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9icmFuY2hDb2xvcnMgPSBicmFuY2hDb2xvcnM7XG4gICAgICAgICAgICAgICAgdGhpcy5kb0NoYW5nZVN0eWxlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIm1hcmdpblwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbWFyZ2luO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChtYXJnaW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXJnaW4gPSBtYXJnaW47XG4gICAgICAgICAgICAgICAgdGhpcy5kb0NoYW5nZVN0eWxlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNpcmNsZVNpemVcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NpcmNsZVNpemU7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGNpcmNsZVNpemUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaXJjbGVTaXplID0gY2lyY2xlU2l6ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmRvQ2hhbmdlU3R5bGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiYnJhbmNoTGluZVdpZHRoXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9icmFuY2hMaW5lV2lkdGg7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGJyYW5jaExpbmVXaWR0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2JyYW5jaExpbmVXaWR0aCA9IGJyYW5jaExpbmVXaWR0aDtcbiAgICAgICAgICAgICAgICB0aGlzLmRvQ2hhbmdlU3R5bGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwibWVyZ2VTdHlsZVwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbWVyZ2VTdHlsZTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQobWVyZ2VTdHlsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21lcmdlU3R5bGUgPSBtZXJnZVN0eWxlO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9DaGFuZ2VTdHlsZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjbG9uZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCcmFuY2hHcmFwaFN0eWxlKHRoaXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSwgW3tcbiAgICAgICAgICAgICAga2V5OiBcIkRFRkFVTFRcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRTdHlsZSA/IGRlZmF1bHRTdHlsZSA6IGRlZmF1bHRTdHlsZSA9IG5ldyBCcmFuY2hHcmFwaFN0eWxlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIEJyYW5jaEdyYXBoU3R5bGU7XG4gICAgICAgICAgfShCYXNlU3R5bGVfMS5CYXNlU3R5bGUpO1xuXG4gICAgICAgICAgZXhwb3J0cy5CcmFuY2hHcmFwaFN0eWxlID0gQnJhbmNoR3JhcGhTdHlsZTtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9jb2x1bW5zL3N0eWxlL0J1dHRvblN0eWxlLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9jb2x1bW5zL3N0eWxlL0J1dHRvblN0eWxlLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBjb2x1bW5zU3R5bGVCdXR0b25TdHlsZUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuQnV0dG9uU3R5bGUgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgU3R5bGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vU3R5bGUgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9zdHlsZS9TdHlsZS5qc1wiKTtcblxuICAgICAgICAgIHZhciB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vaW50ZXJuYWwvdXRpbHMgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvdXRpbHMuanNcIik7XG5cbiAgICAgICAgICB2YXIgZGVmYXVsdFN0eWxlO1xuXG4gICAgICAgICAgdmFyIEJ1dHRvblN0eWxlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfU3R5bGVfMSRTdHlsZSkge1xuICAgICAgICAgICAgX2luaGVyaXRzKEJ1dHRvblN0eWxlLCBfU3R5bGVfMSRTdHlsZSk7XG5cbiAgICAgICAgICAgIHZhciBfc3VwZXIyMiA9IF9jcmVhdGVTdXBlcihCdXR0b25TdHlsZSk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIEJ1dHRvblN0eWxlKCkge1xuICAgICAgICAgICAgICB2YXIgX3RoaXM0MztcblxuICAgICAgICAgICAgICB2YXIgc3R5bGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCdXR0b25TdHlsZSk7XG5cbiAgICAgICAgICAgICAgX3RoaXM0MyA9IF9zdXBlcjIyLmNhbGwodGhpcywgKDAsIHV0aWxzXzEuZGVmYXVsdHMpKHN0eWxlLCB7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduOiBcImNlbnRlclwiXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgdmFyIGJ1dHRvbkJnQ29sb3IgPSBzdHlsZS5idXR0b25CZ0NvbG9yO1xuICAgICAgICAgICAgICBfdGhpczQzLl9idXR0b25CZ0NvbG9yID0gYnV0dG9uQmdDb2xvcjtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzNDM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhCdXR0b25TdHlsZSwgW3tcbiAgICAgICAgICAgICAga2V5OiBcImJ1dHRvbkJnQ29sb3JcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2J1dHRvbkJnQ29sb3I7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGJ1dHRvbkJnQ29sb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9idXR0b25CZ0NvbG9yID0gYnV0dG9uQmdDb2xvcjtcbiAgICAgICAgICAgICAgICB0aGlzLmRvQ2hhbmdlU3R5bGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY2xvbmVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQnV0dG9uU3R5bGUodGhpcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiREVGQVVMVFwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdFN0eWxlID8gZGVmYXVsdFN0eWxlIDogZGVmYXVsdFN0eWxlID0gbmV3IEJ1dHRvblN0eWxlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIEJ1dHRvblN0eWxlO1xuICAgICAgICAgIH0oU3R5bGVfMS5TdHlsZSk7XG5cbiAgICAgICAgICBleHBvcnRzLkJ1dHRvblN0eWxlID0gQnV0dG9uU3R5bGU7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vY29sdW1ucy9zdHlsZS9DaGVja1N0eWxlLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2NvbHVtbnMvc3R5bGUvQ2hlY2tTdHlsZS5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBjb2x1bW5zU3R5bGVDaGVja1N0eWxlSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5DaGVja1N0eWxlID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIFN0ZEJhc2VTdHlsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9TdGRCYXNlU3R5bGUgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9zdHlsZS9TdGRCYXNlU3R5bGUuanNcIik7XG5cbiAgICAgICAgICB2YXIgdXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uL2ludGVybmFsL3V0aWxzICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL3V0aWxzLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIGRlZmF1bHRTdHlsZTtcblxuICAgICAgICAgIHZhciBDaGVja1N0eWxlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfU3RkQmFzZVN0eWxlXzEkU3RkQmEpIHtcbiAgICAgICAgICAgIF9pbmhlcml0cyhDaGVja1N0eWxlLCBfU3RkQmFzZVN0eWxlXzEkU3RkQmEpO1xuXG4gICAgICAgICAgICB2YXIgX3N1cGVyMjMgPSBfY3JlYXRlU3VwZXIoQ2hlY2tTdHlsZSk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIENoZWNrU3R5bGUoKSB7XG4gICAgICAgICAgICAgIHZhciBfdGhpczQ0O1xuXG4gICAgICAgICAgICAgIHZhciBzdHlsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENoZWNrU3R5bGUpO1xuXG4gICAgICAgICAgICAgIF90aGlzNDQgPSBfc3VwZXIyMy5jYWxsKHRoaXMsICgwLCB1dGlsc18xLmRlZmF1bHRzKShzdHlsZSwge1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbjogXCJjZW50ZXJcIlxuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgIHZhciB1bmNoZWNrQmdDb2xvciA9IHN0eWxlLnVuY2hlY2tCZ0NvbG9yLFxuICAgICAgICAgICAgICAgICAgY2hlY2tCZ0NvbG9yID0gc3R5bGUuY2hlY2tCZ0NvbG9yLFxuICAgICAgICAgICAgICAgICAgYm9yZGVyQ29sb3IgPSBzdHlsZS5ib3JkZXJDb2xvcjtcbiAgICAgICAgICAgICAgX3RoaXM0NC5fdW5jaGVja0JnQ29sb3IgPSB1bmNoZWNrQmdDb2xvcjtcbiAgICAgICAgICAgICAgX3RoaXM0NC5fY2hlY2tCZ0NvbG9yID0gY2hlY2tCZ0NvbG9yO1xuICAgICAgICAgICAgICBfdGhpczQ0Ll9ib3JkZXJDb2xvciA9IGJvcmRlckNvbG9yO1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXM0NDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKENoZWNrU3R5bGUsIFt7XG4gICAgICAgICAgICAgIGtleTogXCJ1bmNoZWNrQmdDb2xvclwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdW5jaGVja0JnQ29sb3I7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHVuY2hlY2tCZ0NvbG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdW5jaGVja0JnQ29sb3IgPSB1bmNoZWNrQmdDb2xvcjtcbiAgICAgICAgICAgICAgICB0aGlzLmRvQ2hhbmdlU3R5bGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY2hlY2tCZ0NvbG9yXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jaGVja0JnQ29sb3I7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGNoZWNrQmdDb2xvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrQmdDb2xvciA9IGNoZWNrQmdDb2xvcjtcbiAgICAgICAgICAgICAgICB0aGlzLmRvQ2hhbmdlU3R5bGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiYm9yZGVyQ29sb3JcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JvcmRlckNvbG9yO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChib3JkZXJDb2xvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2JvcmRlckNvbG9yID0gYm9yZGVyQ29sb3I7XG4gICAgICAgICAgICAgICAgdGhpcy5kb0NoYW5nZVN0eWxlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNsb25lXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENoZWNrU3R5bGUodGhpcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiREVGQVVMVFwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdFN0eWxlID8gZGVmYXVsdFN0eWxlIDogZGVmYXVsdFN0eWxlID0gbmV3IENoZWNrU3R5bGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gQ2hlY2tTdHlsZTtcbiAgICAgICAgICB9KFN0ZEJhc2VTdHlsZV8xLlN0ZEJhc2VTdHlsZSk7XG5cbiAgICAgICAgICBleHBvcnRzLkNoZWNrU3R5bGUgPSBDaGVja1N0eWxlO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2NvbHVtbnMvc3R5bGUvSWNvblN0eWxlLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vY29sdW1ucy9zdHlsZS9JY29uU3R5bGUuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBjb2x1bW5zU3R5bGVJY29uU3R5bGVKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLkljb25TdHlsZSA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBTdHlsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9TdHlsZSAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3N0eWxlL1N0eWxlLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIHV0aWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi9pbnRlcm5hbC91dGlscyAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC91dGlscy5qc1wiKTtcblxuICAgICAgICAgIHZhciBkZWZhdWx0U3R5bGU7XG5cbiAgICAgICAgICB2YXIgSWNvblN0eWxlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfU3R5bGVfMSRTdHlsZTIpIHtcbiAgICAgICAgICAgIF9pbmhlcml0cyhJY29uU3R5bGUsIF9TdHlsZV8xJFN0eWxlMik7XG5cbiAgICAgICAgICAgIHZhciBfc3VwZXIyNCA9IF9jcmVhdGVTdXBlcihJY29uU3R5bGUpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBJY29uU3R5bGUoKSB7XG4gICAgICAgICAgICAgIHZhciBzdHlsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEljb25TdHlsZSk7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlcjI0LmNhbGwodGhpcywgKDAsIHV0aWxzXzEuZGVmYXVsdHMpKHN0eWxlLCB7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduOiBcImNlbnRlclwiXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKEljb25TdHlsZSwgW3tcbiAgICAgICAgICAgICAga2V5OiBcImNsb25lXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEljb25TdHlsZSh0aGlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0sIFt7XG4gICAgICAgICAgICAgIGtleTogXCJERUZBVUxUXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0U3R5bGUgPyBkZWZhdWx0U3R5bGUgOiBkZWZhdWx0U3R5bGUgPSBuZXcgSWNvblN0eWxlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIEljb25TdHlsZTtcbiAgICAgICAgICB9KFN0eWxlXzEuU3R5bGUpO1xuXG4gICAgICAgICAgZXhwb3J0cy5JY29uU3R5bGUgPSBJY29uU3R5bGU7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vY29sdW1ucy9zdHlsZS9JbWFnZVN0eWxlLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2NvbHVtbnMvc3R5bGUvSW1hZ2VTdHlsZS5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBjb2x1bW5zU3R5bGVJbWFnZVN0eWxlSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5JbWFnZVN0eWxlID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIFN0ZEJhc2VTdHlsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9TdGRCYXNlU3R5bGUgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9zdHlsZS9TdGRCYXNlU3R5bGUuanNcIik7XG5cbiAgICAgICAgICB2YXIgdXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uL2ludGVybmFsL3V0aWxzICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL3V0aWxzLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIGRlZmF1bHRTdHlsZTtcblxuICAgICAgICAgIHZhciBJbWFnZVN0eWxlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfU3RkQmFzZVN0eWxlXzEkU3RkQmEyKSB7XG4gICAgICAgICAgICBfaW5oZXJpdHMoSW1hZ2VTdHlsZSwgX1N0ZEJhc2VTdHlsZV8xJFN0ZEJhMik7XG5cbiAgICAgICAgICAgIHZhciBfc3VwZXIyNSA9IF9jcmVhdGVTdXBlcihJbWFnZVN0eWxlKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gSW1hZ2VTdHlsZSgpIHtcbiAgICAgICAgICAgICAgdmFyIF90aGlzNDU7XG5cbiAgICAgICAgICAgICAgdmFyIHN0eWxlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW1hZ2VTdHlsZSk7XG5cbiAgICAgICAgICAgICAgX3RoaXM0NSA9IF9zdXBlcjI1LmNhbGwodGhpcywgKDAsIHV0aWxzXzEuZGVmYXVsdHMpKHN0eWxlLCB7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduOiBcImNlbnRlclwiXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgX3RoaXM0NS5faW1hZ2VTaXppbmcgPSBzdHlsZS5pbWFnZVNpemluZztcbiAgICAgICAgICAgICAgX3RoaXM0NS5fbWFyZ2luID0gc3R5bGUubWFyZ2luIHx8IDQ7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczQ1O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoSW1hZ2VTdHlsZSwgW3tcbiAgICAgICAgICAgICAga2V5OiBcImltYWdlU2l6aW5nXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbWFnZVNpemluZztcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoaW1hZ2VTaXppbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbWFnZVNpemluZyA9IGltYWdlU2l6aW5nO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9DaGFuZ2VTdHlsZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJtYXJnaW5cIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21hcmdpbjtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQobWFyZ2luKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFyZ2luID0gbWFyZ2luO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9DaGFuZ2VTdHlsZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjbG9uZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbWFnZVN0eWxlKHRoaXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSwgW3tcbiAgICAgICAgICAgICAga2V5OiBcIkRFRkFVTFRcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRTdHlsZSA/IGRlZmF1bHRTdHlsZSA6IGRlZmF1bHRTdHlsZSA9IG5ldyBJbWFnZVN0eWxlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIEltYWdlU3R5bGU7XG4gICAgICAgICAgfShTdGRCYXNlU3R5bGVfMS5TdGRCYXNlU3R5bGUpO1xuXG4gICAgICAgICAgZXhwb3J0cy5JbWFnZVN0eWxlID0gSW1hZ2VTdHlsZTtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9jb2x1bW5zL3N0eWxlL01lbnVTdHlsZS5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2NvbHVtbnMvc3R5bGUvTWVudVN0eWxlLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gY29sdW1uc1N0eWxlTWVudVN0eWxlSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5NZW51U3R5bGUgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgU3R5bGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vU3R5bGUgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9zdHlsZS9TdHlsZS5qc1wiKTtcblxuICAgICAgICAgIHZhciBkZWZhdWx0U3R5bGU7XG5cbiAgICAgICAgICB2YXIgTWVudVN0eWxlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfU3R5bGVfMSRTdHlsZTMpIHtcbiAgICAgICAgICAgIF9pbmhlcml0cyhNZW51U3R5bGUsIF9TdHlsZV8xJFN0eWxlMyk7XG5cbiAgICAgICAgICAgIHZhciBfc3VwZXIyNiA9IF9jcmVhdGVTdXBlcihNZW51U3R5bGUpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBNZW51U3R5bGUoKSB7XG4gICAgICAgICAgICAgIHZhciBfdGhpczQ2O1xuXG4gICAgICAgICAgICAgIHZhciBzdHlsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1lbnVTdHlsZSk7XG5cbiAgICAgICAgICAgICAgX3RoaXM0NiA9IF9zdXBlcjI2LmNhbGwodGhpcywgc3R5bGUpO1xuICAgICAgICAgICAgICB2YXIgYXBwZWFyYW5jZSA9IHN0eWxlLmFwcGVhcmFuY2U7XG4gICAgICAgICAgICAgIF90aGlzNDYuX2FwcGVhcmFuY2UgPSBhcHBlYXJhbmNlO1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXM0NjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKE1lbnVTdHlsZSwgW3tcbiAgICAgICAgICAgICAga2V5OiBcImFwcGVhcmFuY2VcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGVhcmFuY2UgfHwgXCJtZW51bGlzdC1idXR0b25cIjtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoYXBwZWFyYW5jZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FwcGVhcmFuY2UgPSBhcHBlYXJhbmNlO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9DaGFuZ2VTdHlsZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjbG9uZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNZW51U3R5bGUodGhpcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiREVGQVVMVFwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdFN0eWxlID8gZGVmYXVsdFN0eWxlIDogZGVmYXVsdFN0eWxlID0gbmV3IE1lbnVTdHlsZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBNZW51U3R5bGU7XG4gICAgICAgICAgfShTdHlsZV8xLlN0eWxlKTtcblxuICAgICAgICAgIGV4cG9ydHMuTWVudVN0eWxlID0gTWVudVN0eWxlO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2NvbHVtbnMvc3R5bGUvTXVsdGlsaW5lVGV4dFN0eWxlLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vY29sdW1ucy9zdHlsZS9NdWx0aWxpbmVUZXh0U3R5bGUuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBjb2x1bW5zU3R5bGVNdWx0aWxpbmVUZXh0U3R5bGVKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLk11bHRpbGluZVRleHRTdHlsZSA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBTdHlsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9TdHlsZSAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3N0eWxlL1N0eWxlLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIHV0aWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi9pbnRlcm5hbC91dGlscyAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC91dGlscy5qc1wiKTtcblxuICAgICAgICAgIHZhciBkZWZhdWx0U3R5bGU7XG5cbiAgICAgICAgICB2YXIgTXVsdGlsaW5lVGV4dFN0eWxlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfU3R5bGVfMSRTdHlsZTQpIHtcbiAgICAgICAgICAgIF9pbmhlcml0cyhNdWx0aWxpbmVUZXh0U3R5bGUsIF9TdHlsZV8xJFN0eWxlNCk7XG5cbiAgICAgICAgICAgIHZhciBfc3VwZXIyNyA9IF9jcmVhdGVTdXBlcihNdWx0aWxpbmVUZXh0U3R5bGUpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBNdWx0aWxpbmVUZXh0U3R5bGUoKSB7XG4gICAgICAgICAgICAgIHZhciBfdGhpczQ3O1xuXG4gICAgICAgICAgICAgIHZhciBzdHlsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE11bHRpbGluZVRleHRTdHlsZSk7XG5cbiAgICAgICAgICAgICAgX3RoaXM0NyA9IF9zdXBlcjI3LmNhbGwodGhpcywgKDAsIHV0aWxzXzEuZGVmYXVsdHMpKHN0eWxlLCB7XG4gICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lOiBcInRvcFwiXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgX3RoaXM0Ny5fbGluZUhlaWdodCA9IHN0eWxlLmxpbmVIZWlnaHQgfHwgXCIxZW1cIjtcbiAgICAgICAgICAgICAgX3RoaXM0Ny5fYXV0b1dyYXBUZXh0ID0gc3R5bGUuYXV0b1dyYXBUZXh0IHx8IGZhbHNlO1xuICAgICAgICAgICAgICBfdGhpczQ3Ll9saW5lQ2xhbXAgPSBzdHlsZS5saW5lQ2xhbXA7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczQ3O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoTXVsdGlsaW5lVGV4dFN0eWxlLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiY2xvbmVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTXVsdGlsaW5lVGV4dFN0eWxlKHRoaXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJsaW5lSGVpZ2h0XCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9saW5lSGVpZ2h0O1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChsaW5lSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGluZUhlaWdodCA9IGxpbmVIZWlnaHQ7XG4gICAgICAgICAgICAgICAgdGhpcy5kb0NoYW5nZVN0eWxlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImxpbmVDbGFtcFwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbGluZUNsYW1wO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChsaW5lQ2xhbXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9saW5lQ2xhbXAgPSBsaW5lQ2xhbXA7XG4gICAgICAgICAgICAgICAgdGhpcy5kb0NoYW5nZVN0eWxlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImF1dG9XcmFwVGV4dFwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYXV0b1dyYXBUZXh0O1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChhdXRvV3JhcFRleHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hdXRvV3JhcFRleHQgPSBhdXRvV3JhcFRleHQ7XG4gICAgICAgICAgICAgICAgdGhpcy5kb0NoYW5nZVN0eWxlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiREVGQVVMVFwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdFN0eWxlID8gZGVmYXVsdFN0eWxlIDogZGVmYXVsdFN0eWxlID0gbmV3IE11bHRpbGluZVRleHRTdHlsZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBNdWx0aWxpbmVUZXh0U3R5bGU7XG4gICAgICAgICAgfShTdHlsZV8xLlN0eWxlKTtcblxuICAgICAgICAgIGV4cG9ydHMuTXVsdGlsaW5lVGV4dFN0eWxlID0gTXVsdGlsaW5lVGV4dFN0eWxlO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2NvbHVtbnMvc3R5bGUvTnVtYmVyU3R5bGUuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2NvbHVtbnMvc3R5bGUvTnVtYmVyU3R5bGUuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGNvbHVtbnNTdHlsZU51bWJlclN0eWxlSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5OdW1iZXJTdHlsZSA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBTdHlsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9TdHlsZSAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3N0eWxlL1N0eWxlLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIHV0aWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi9pbnRlcm5hbC91dGlscyAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC91dGlscy5qc1wiKTtcblxuICAgICAgICAgIHZhciBkZWZhdWx0U3R5bGU7XG5cbiAgICAgICAgICB2YXIgTnVtYmVyU3R5bGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9TdHlsZV8xJFN0eWxlNSkge1xuICAgICAgICAgICAgX2luaGVyaXRzKE51bWJlclN0eWxlLCBfU3R5bGVfMSRTdHlsZTUpO1xuXG4gICAgICAgICAgICB2YXIgX3N1cGVyMjggPSBfY3JlYXRlU3VwZXIoTnVtYmVyU3R5bGUpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBOdW1iZXJTdHlsZSgpIHtcbiAgICAgICAgICAgICAgdmFyIHN0eWxlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTnVtYmVyU3R5bGUpO1xuXG4gICAgICAgICAgICAgIHJldHVybiBfc3VwZXIyOC5jYWxsKHRoaXMsICgwLCB1dGlsc18xLmRlZmF1bHRzKShzdHlsZSwge1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbjogXCJyaWdodFwiXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKE51bWJlclN0eWxlLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiY2xvbmVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTnVtYmVyU3R5bGUodGhpcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiREVGQVVMVFwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdFN0eWxlID8gZGVmYXVsdFN0eWxlIDogZGVmYXVsdFN0eWxlID0gbmV3IE51bWJlclN0eWxlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIE51bWJlclN0eWxlO1xuICAgICAgICAgIH0oU3R5bGVfMS5TdHlsZSk7XG5cbiAgICAgICAgICBleHBvcnRzLk51bWJlclN0eWxlID0gTnVtYmVyU3R5bGU7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vY29sdW1ucy9zdHlsZS9QZXJjZW50Q29tcGxldGVCYXJTdHlsZS5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vY29sdW1ucy9zdHlsZS9QZXJjZW50Q29tcGxldGVCYXJTdHlsZS5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gY29sdW1uc1N0eWxlUGVyY2VudENvbXBsZXRlQmFyU3R5bGVKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLlBlcmNlbnRDb21wbGV0ZUJhclN0eWxlID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIFN0eWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL1N0eWxlICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvc3R5bGUvU3R5bGUuanNcIik7XG5cbiAgICAgICAgICB2YXIgZGVmYXVsdFN0eWxlO1xuXG4gICAgICAgICAgdmFyIERFRkFVTFRfQkFSX0NPTE9SID0gZnVuY3Rpb24gREVGQVVMVF9CQVJfQ09MT1IobnVtKSB7XG4gICAgICAgICAgICBpZiAobnVtID4gODApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFwiIzIwYThkOFwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobnVtID4gNTApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFwiIzRkYmQ3NFwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobnVtID4gMjApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFwiI2ZmYzEwN1wiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gXCIjZjg2YzZiXCI7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHZhciBQZXJjZW50Q29tcGxldGVCYXJTdHlsZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1N0eWxlXzEkU3R5bGU2KSB7XG4gICAgICAgICAgICBfaW5oZXJpdHMoUGVyY2VudENvbXBsZXRlQmFyU3R5bGUsIF9TdHlsZV8xJFN0eWxlNik7XG5cbiAgICAgICAgICAgIHZhciBfc3VwZXIyOSA9IF9jcmVhdGVTdXBlcihQZXJjZW50Q29tcGxldGVCYXJTdHlsZSk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIFBlcmNlbnRDb21wbGV0ZUJhclN0eWxlKCkge1xuICAgICAgICAgICAgICB2YXIgX3RoaXM0ODtcblxuICAgICAgICAgICAgICB2YXIgc3R5bGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQZXJjZW50Q29tcGxldGVCYXJTdHlsZSk7XG5cbiAgICAgICAgICAgICAgX3RoaXM0OCA9IF9zdXBlcjI5LmNhbGwodGhpcywgc3R5bGUpO1xuICAgICAgICAgICAgICBfdGhpczQ4Ll9iYXJDb2xvciA9IHN0eWxlLmJhckNvbG9yIHx8IERFRkFVTFRfQkFSX0NPTE9SO1xuICAgICAgICAgICAgICBfdGhpczQ4Ll9iYXJCZ0NvbG9yID0gc3R5bGUuYmFyQmdDb2xvciB8fCBcIiNmMGYzZjVcIjtcbiAgICAgICAgICAgICAgX3RoaXM0OC5fYmFySGVpZ2h0ID0gc3R5bGUuYmFySGVpZ2h0IHx8IDM7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczQ4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoUGVyY2VudENvbXBsZXRlQmFyU3R5bGUsIFt7XG4gICAgICAgICAgICAgIGtleTogXCJiYXJDb2xvclwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYmFyQ29sb3I7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGJhckNvbG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmFyQ29sb3IgPSBiYXJDb2xvcjtcbiAgICAgICAgICAgICAgICB0aGlzLmRvQ2hhbmdlU3R5bGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiYmFyQmdDb2xvclwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYmFyQmdDb2xvcjtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoYmFyQmdDb2xvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2JhckJnQ29sb3IgPSBiYXJCZ0NvbG9yO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9DaGFuZ2VTdHlsZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJiYXJIZWlnaHRcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JhckhlaWdodDtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoYmFySGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmFySGVpZ2h0ID0gYmFySGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRoaXMuZG9DaGFuZ2VTdHlsZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjbG9uZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQZXJjZW50Q29tcGxldGVCYXJTdHlsZSh0aGlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0sIFt7XG4gICAgICAgICAgICAgIGtleTogXCJERUZBVUxUXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0U3R5bGUgPyBkZWZhdWx0U3R5bGUgOiBkZWZhdWx0U3R5bGUgPSBuZXcgUGVyY2VudENvbXBsZXRlQmFyU3R5bGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gUGVyY2VudENvbXBsZXRlQmFyU3R5bGU7XG4gICAgICAgICAgfShTdHlsZV8xLlN0eWxlKTtcblxuICAgICAgICAgIGV4cG9ydHMuUGVyY2VudENvbXBsZXRlQmFyU3R5bGUgPSBQZXJjZW50Q29tcGxldGVCYXJTdHlsZTtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9jb2x1bW5zL3N0eWxlL1JhZGlvU3R5bGUuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vY29sdW1ucy9zdHlsZS9SYWRpb1N0eWxlLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGNvbHVtbnNTdHlsZVJhZGlvU3R5bGVKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLlJhZGlvU3R5bGUgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgU3RkQmFzZVN0eWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL1N0ZEJhc2VTdHlsZSAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3N0eWxlL1N0ZEJhc2VTdHlsZS5qc1wiKTtcblxuICAgICAgICAgIHZhciB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vaW50ZXJuYWwvdXRpbHMgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvdXRpbHMuanNcIik7XG5cbiAgICAgICAgICB2YXIgZGVmYXVsdFN0eWxlO1xuXG4gICAgICAgICAgdmFyIFJhZGlvU3R5bGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9TdGRCYXNlU3R5bGVfMSRTdGRCYTMpIHtcbiAgICAgICAgICAgIF9pbmhlcml0cyhSYWRpb1N0eWxlLCBfU3RkQmFzZVN0eWxlXzEkU3RkQmEzKTtcblxuICAgICAgICAgICAgdmFyIF9zdXBlcjMwID0gX2NyZWF0ZVN1cGVyKFJhZGlvU3R5bGUpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBSYWRpb1N0eWxlKCkge1xuICAgICAgICAgICAgICB2YXIgX3RoaXM0OTtcblxuICAgICAgICAgICAgICB2YXIgc3R5bGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSYWRpb1N0eWxlKTtcblxuICAgICAgICAgICAgICBfdGhpczQ5ID0gX3N1cGVyMzAuY2FsbCh0aGlzLCAoMCwgdXRpbHNfMS5kZWZhdWx0cykoc3R5bGUsIHtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ246IFwiY2VudGVyXCJcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICB2YXIgY2hlY2tDb2xvciA9IHN0eWxlLmNoZWNrQ29sb3IsXG4gICAgICAgICAgICAgICAgICB1bmNoZWNrQm9yZGVyQ29sb3IgPSBzdHlsZS51bmNoZWNrQm9yZGVyQ29sb3IsXG4gICAgICAgICAgICAgICAgICBjaGVja0JvcmRlckNvbG9yID0gc3R5bGUuY2hlY2tCb3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgICAgIHVuY2hlY2tCZ0NvbG9yID0gc3R5bGUudW5jaGVja0JnQ29sb3IsXG4gICAgICAgICAgICAgICAgICBjaGVja0JnQ29sb3IgPSBzdHlsZS5jaGVja0JnQ29sb3I7XG4gICAgICAgICAgICAgIF90aGlzNDkuX2NoZWNrQ29sb3IgPSBjaGVja0NvbG9yO1xuICAgICAgICAgICAgICBfdGhpczQ5Ll91bmNoZWNrQm9yZGVyQ29sb3IgPSB1bmNoZWNrQm9yZGVyQ29sb3I7XG4gICAgICAgICAgICAgIF90aGlzNDkuX2NoZWNrQm9yZGVyQ29sb3IgPSBjaGVja0JvcmRlckNvbG9yO1xuICAgICAgICAgICAgICBfdGhpczQ5Ll91bmNoZWNrQmdDb2xvciA9IHVuY2hlY2tCZ0NvbG9yO1xuICAgICAgICAgICAgICBfdGhpczQ5Ll9jaGVja0JnQ29sb3IgPSBjaGVja0JnQ29sb3I7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczQ5O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoUmFkaW9TdHlsZSwgW3tcbiAgICAgICAgICAgICAga2V5OiBcImNoZWNrQ29sb3JcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrQ29sb3I7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGNoZWNrQ29sb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGVja0NvbG9yID0gY2hlY2tDb2xvcjtcbiAgICAgICAgICAgICAgICB0aGlzLmRvQ2hhbmdlU3R5bGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwidW5jaGVja0JvcmRlckNvbG9yXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl91bmNoZWNrQm9yZGVyQ29sb3I7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHVuY2hlY2tCb3JkZXJDb2xvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VuY2hlY2tCb3JkZXJDb2xvciA9IHVuY2hlY2tCb3JkZXJDb2xvcjtcbiAgICAgICAgICAgICAgICB0aGlzLmRvQ2hhbmdlU3R5bGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY2hlY2tCb3JkZXJDb2xvclwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tCb3JkZXJDb2xvcjtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoY2hlY2tCb3JkZXJDb2xvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrQm9yZGVyQ29sb3IgPSBjaGVja0JvcmRlckNvbG9yO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9DaGFuZ2VTdHlsZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJ1bmNoZWNrQmdDb2xvclwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdW5jaGVja0JnQ29sb3I7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHVuY2hlY2tCZ0NvbG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdW5jaGVja0JnQ29sb3IgPSB1bmNoZWNrQmdDb2xvcjtcbiAgICAgICAgICAgICAgICB0aGlzLmRvQ2hhbmdlU3R5bGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY2hlY2tCZ0NvbG9yXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jaGVja0JnQ29sb3I7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGNoZWNrQmdDb2xvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrQmdDb2xvciA9IGNoZWNrQmdDb2xvcjtcbiAgICAgICAgICAgICAgICB0aGlzLmRvQ2hhbmdlU3R5bGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY2xvbmVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmFkaW9TdHlsZSh0aGlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0sIFt7XG4gICAgICAgICAgICAgIGtleTogXCJERUZBVUxUXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0U3R5bGUgPyBkZWZhdWx0U3R5bGUgOiBkZWZhdWx0U3R5bGUgPSBuZXcgUmFkaW9TdHlsZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBSYWRpb1N0eWxlO1xuICAgICAgICAgIH0oU3RkQmFzZVN0eWxlXzEuU3RkQmFzZVN0eWxlKTtcblxuICAgICAgICAgIGV4cG9ydHMuUmFkaW9TdHlsZSA9IFJhZGlvU3R5bGU7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vY29sdW1ucy9zdHlsZS9TdGRCYXNlU3R5bGUuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9jb2x1bW5zL3N0eWxlL1N0ZEJhc2VTdHlsZS5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGNvbHVtbnNTdHlsZVN0ZEJhc2VTdHlsZUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuU3RkQmFzZVN0eWxlID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIEJhc2VTdHlsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9CYXNlU3R5bGUgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9zdHlsZS9CYXNlU3R5bGUuanNcIik7XG5cbiAgICAgICAgICB2YXIgZGVmYXVsdFN0eWxlO1xuXG4gICAgICAgICAgdmFyIFN0ZEJhc2VTdHlsZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Jhc2VTdHlsZV8xJEJhc2VTdHlsMikge1xuICAgICAgICAgICAgX2luaGVyaXRzKFN0ZEJhc2VTdHlsZSwgX0Jhc2VTdHlsZV8xJEJhc2VTdHlsMik7XG5cbiAgICAgICAgICAgIHZhciBfc3VwZXIzMSA9IF9jcmVhdGVTdXBlcihTdGRCYXNlU3R5bGUpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBTdGRCYXNlU3R5bGUoKSB7XG4gICAgICAgICAgICAgIHZhciBfdGhpczUwO1xuXG4gICAgICAgICAgICAgIHZhciBzdHlsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN0ZEJhc2VTdHlsZSk7XG5cbiAgICAgICAgICAgICAgX3RoaXM1MCA9IF9zdXBlcjMxLmNhbGwodGhpcywgc3R5bGUpO1xuICAgICAgICAgICAgICBfdGhpczUwLl90ZXh0QWxpZ24gPSBzdHlsZS50ZXh0QWxpZ24gfHwgXCJsZWZ0XCI7XG4gICAgICAgICAgICAgIF90aGlzNTAuX3RleHRCYXNlbGluZSA9IHN0eWxlLnRleHRCYXNlbGluZSB8fCBcIm1pZGRsZVwiO1xuICAgICAgICAgICAgICBfdGhpczUwLl9wYWRkaW5nID0gc3R5bGUucGFkZGluZztcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzNTA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhTdGRCYXNlU3R5bGUsIFt7XG4gICAgICAgICAgICAgIGtleTogXCJ0ZXh0QWxpZ25cIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RleHRBbGlnbjtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodGV4dEFsaWduKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4dEFsaWduID0gdGV4dEFsaWduO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9DaGFuZ2VTdHlsZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJ0ZXh0QmFzZWxpbmVcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RleHRCYXNlbGluZTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodGV4dEJhc2VsaW5lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4dEJhc2VsaW5lID0gdGV4dEJhc2VsaW5lO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9DaGFuZ2VTdHlsZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJwYWRkaW5nXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYWRkaW5nO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChwYWRkaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFkZGluZyA9IHBhZGRpbmc7XG4gICAgICAgICAgICAgICAgdGhpcy5kb0NoYW5nZVN0eWxlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNsb25lXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN0ZEJhc2VTdHlsZSh0aGlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0sIFt7XG4gICAgICAgICAgICAgIGtleTogXCJERUZBVUxUXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0U3R5bGUgPyBkZWZhdWx0U3R5bGUgOiBkZWZhdWx0U3R5bGUgPSBuZXcgU3RkQmFzZVN0eWxlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIFN0ZEJhc2VTdHlsZTtcbiAgICAgICAgICB9KEJhc2VTdHlsZV8xLkJhc2VTdHlsZSk7XG5cbiAgICAgICAgICBleHBvcnRzLlN0ZEJhc2VTdHlsZSA9IFN0ZEJhc2VTdHlsZTtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9jb2x1bW5zL3N0eWxlL1N0eWxlLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9jb2x1bW5zL3N0eWxlL1N0eWxlLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBjb2x1bW5zU3R5bGVTdHlsZUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuU3R5bGUgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgU3RkQmFzZVN0eWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL1N0ZEJhc2VTdHlsZSAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3N0eWxlL1N0ZEJhc2VTdHlsZS5qc1wiKTtcblxuICAgICAgICAgIHZhciBkZWZhdWx0U3R5bGU7XG5cbiAgICAgICAgICB2YXIgU3R5bGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9TdGRCYXNlU3R5bGVfMSRTdGRCYTQpIHtcbiAgICAgICAgICAgIF9pbmhlcml0cyhTdHlsZSwgX1N0ZEJhc2VTdHlsZV8xJFN0ZEJhNCk7XG5cbiAgICAgICAgICAgIHZhciBfc3VwZXIzMiA9IF9jcmVhdGVTdXBlcihTdHlsZSk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIFN0eWxlKCkge1xuICAgICAgICAgICAgICB2YXIgX3RoaXM1MTtcblxuICAgICAgICAgICAgICB2YXIgc3R5bGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdHlsZSk7XG5cbiAgICAgICAgICAgICAgX3RoaXM1MSA9IF9zdXBlcjMyLmNhbGwodGhpcywgc3R5bGUpO1xuICAgICAgICAgICAgICBfdGhpczUxLl9jb2xvciA9IHN0eWxlLmNvbG9yO1xuICAgICAgICAgICAgICBfdGhpczUxLl9mb250ID0gc3R5bGUuZm9udDtcbiAgICAgICAgICAgICAgX3RoaXM1MS5fdGV4dE92ZXJmbG93ID0gc3R5bGUudGV4dE92ZXJmbG93IHx8IFwiY2xpcFwiO1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXM1MTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKFN0eWxlLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiY29sb3JcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbG9yO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChjb2xvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbG9yID0gY29sb3I7XG4gICAgICAgICAgICAgICAgdGhpcy5kb0NoYW5nZVN0eWxlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImZvbnRcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZvbnQ7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGZvbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mb250ID0gZm9udDtcbiAgICAgICAgICAgICAgICB0aGlzLmRvQ2hhbmdlU3R5bGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwidGV4dE92ZXJmbG93XCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90ZXh0T3ZlcmZsb3c7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHRleHRPdmVyZmxvdykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RleHRPdmVyZmxvdyA9IHRleHRPdmVyZmxvdztcbiAgICAgICAgICAgICAgICB0aGlzLmRvQ2hhbmdlU3R5bGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY2xvbmVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3R5bGUodGhpcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiREVGQVVMVFwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdFN0eWxlID8gZGVmYXVsdFN0eWxlIDogZGVmYXVsdFN0eWxlID0gbmV3IFN0eWxlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIFN0eWxlO1xuICAgICAgICAgIH0oU3RkQmFzZVN0eWxlXzEuU3RkQmFzZVN0eWxlKTtcblxuICAgICAgICAgIGV4cG9ydHMuU3R5bGUgPSBTdHlsZTtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9jb2x1bW5zL3N0eWxlL1RyZWVTdHlsZS5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2NvbHVtbnMvc3R5bGUvVHJlZVN0eWxlLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gY29sdW1uc1N0eWxlVHJlZVN0eWxlSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5UcmVlU3R5bGUgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgU3R5bGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vU3R5bGUgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9zdHlsZS9TdHlsZS5qc1wiKTtcblxuICAgICAgICAgIHZhciBkZWZhdWx0U3R5bGU7XG5cbiAgICAgICAgICB2YXIgVHJlZVN0eWxlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfU3R5bGVfMSRTdHlsZTcpIHtcbiAgICAgICAgICAgIF9pbmhlcml0cyhUcmVlU3R5bGUsIF9TdHlsZV8xJFN0eWxlNyk7XG5cbiAgICAgICAgICAgIHZhciBfc3VwZXIzMyA9IF9jcmVhdGVTdXBlcihUcmVlU3R5bGUpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBUcmVlU3R5bGUoKSB7XG4gICAgICAgICAgICAgIHZhciBfdGhpczUyO1xuXG4gICAgICAgICAgICAgIHZhciBzdHlsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRyZWVTdHlsZSk7XG5cbiAgICAgICAgICAgICAgX3RoaXM1MiA9IF9zdXBlcjMzLmNhbGwodGhpcywgc3R5bGUpO1xuICAgICAgICAgICAgICBfdGhpczUyLl9saW5lU3R5bGUgPSBzdHlsZS5saW5lU3R5bGU7XG4gICAgICAgICAgICAgIF90aGlzNTIuX2xpbmVDb2xvciA9IHN0eWxlLmxpbmVDb2xvcjtcbiAgICAgICAgICAgICAgX3RoaXM1Mi5fbGluZVdpZHRoID0gc3R5bGUubGluZVdpZHRoO1xuICAgICAgICAgICAgICBfdGhpczUyLl90cmVlSWNvbiA9IHN0eWxlLnRyZWVJY29uO1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXM1MjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKFRyZWVTdHlsZSwgW3tcbiAgICAgICAgICAgICAga2V5OiBcImNsb25lXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRyZWVTdHlsZSh0aGlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwibGluZVN0eWxlXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9saW5lU3R5bGU7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGxpbmVTdHlsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xpbmVTdHlsZSA9IGxpbmVTdHlsZTtcbiAgICAgICAgICAgICAgICB0aGlzLmRvQ2hhbmdlU3R5bGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwibGluZUNvbG9yXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9saW5lQ29sb3I7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGxpbmVDb2xvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xpbmVDb2xvciA9IGxpbmVDb2xvcjtcbiAgICAgICAgICAgICAgICB0aGlzLmRvQ2hhbmdlU3R5bGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwibGluZVdpZHRoXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9saW5lV2lkdGg7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGxpbmVXaWR0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICAgICAgICAgICAgICB0aGlzLmRvQ2hhbmdlU3R5bGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwidHJlZUljb25cIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyZWVJY29uO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh0cmVlSWNvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RyZWVJY29uID0gdHJlZUljb247XG4gICAgICAgICAgICAgICAgdGhpcy5kb0NoYW5nZVN0eWxlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiREVGQVVMVFwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdFN0eWxlID8gZGVmYXVsdFN0eWxlIDogZGVmYXVsdFN0eWxlID0gbmV3IFRyZWVTdHlsZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBUcmVlU3R5bGU7XG4gICAgICAgICAgfShTdHlsZV8xLlN0eWxlKTtcblxuICAgICAgICAgIGV4cG9ydHMuVHJlZVN0eWxlID0gVHJlZVN0eWxlO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2NvbHVtbnMvdHlwZS5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9jb2x1bW5zL3R5cGUuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gY29sdW1uc1R5cGVKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLm9mID0gZXhwb3J0cy5UcmVlQ29sdW1uID0gZXhwb3J0cy5NdWx0aWxpbmVUZXh0Q29sdW1uID0gZXhwb3J0cy5NZW51Q29sdW1uID0gZXhwb3J0cy5CcmFuY2hHcmFwaENvbHVtbiA9IGV4cG9ydHMuSWNvbkNvbHVtbiA9IGV4cG9ydHMuUGVyY2VudENvbXBsZXRlQmFyQ29sdW1uID0gZXhwb3J0cy5JbWFnZUNvbHVtbiA9IGV4cG9ydHMuQnV0dG9uQ29sdW1uID0gZXhwb3J0cy5SYWRpb0NvbHVtbiA9IGV4cG9ydHMuQ2hlY2tDb2x1bW4gPSBleHBvcnRzLk51bWJlckNvbHVtbiA9IGV4cG9ydHMuQ29sdW1uID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIEJyYW5jaEdyYXBoQ29sdW1uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL3R5cGUvQnJhbmNoR3JhcGhDb2x1bW4gKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy90eXBlL0JyYW5jaEdyYXBoQ29sdW1uLmpzXCIpO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQnJhbmNoR3JhcGhDb2x1bW5cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICByZXR1cm4gQnJhbmNoR3JhcGhDb2x1bW5fMS5CcmFuY2hHcmFwaENvbHVtbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBCdXR0b25Db2x1bW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vdHlwZS9CdXR0b25Db2x1bW4gKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy90eXBlL0J1dHRvbkNvbHVtbi5qc1wiKTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJ1dHRvbkNvbHVtblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBCdXR0b25Db2x1bW5fMS5CdXR0b25Db2x1bW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgQ2hlY2tDb2x1bW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vdHlwZS9DaGVja0NvbHVtbiAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3R5cGUvQ2hlY2tDb2x1bW4uanNcIik7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDaGVja0NvbHVtblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBDaGVja0NvbHVtbl8xLkNoZWNrQ29sdW1uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIENvbHVtbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi90eXBlL0NvbHVtbiAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3R5cGUvQ29sdW1uLmpzXCIpO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29sdW1uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIENvbHVtbl8xLkNvbHVtbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBJY29uQ29sdW1uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL3R5cGUvSWNvbkNvbHVtbiAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3R5cGUvSWNvbkNvbHVtbi5qc1wiKTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkljb25Db2x1bW5cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICByZXR1cm4gSWNvbkNvbHVtbl8xLkljb25Db2x1bW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgSW1hZ2VDb2x1bW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vdHlwZS9JbWFnZUNvbHVtbiAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3R5cGUvSW1hZ2VDb2x1bW4uanNcIik7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbWFnZUNvbHVtblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBJbWFnZUNvbHVtbl8xLkltYWdlQ29sdW1uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIE1lbnVDb2x1bW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vdHlwZS9NZW51Q29sdW1uICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvdHlwZS9NZW51Q29sdW1uLmpzXCIpO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTWVudUNvbHVtblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBNZW51Q29sdW1uXzEuTWVudUNvbHVtbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBNdWx0aWxpbmVUZXh0Q29sdW1uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL3R5cGUvTXVsdGlsaW5lVGV4dENvbHVtbiAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3R5cGUvTXVsdGlsaW5lVGV4dENvbHVtbi5qc1wiKTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk11bHRpbGluZVRleHRDb2x1bW5cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICByZXR1cm4gTXVsdGlsaW5lVGV4dENvbHVtbl8xLk11bHRpbGluZVRleHRDb2x1bW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgTnVtYmVyQ29sdW1uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL3R5cGUvTnVtYmVyQ29sdW1uICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvdHlwZS9OdW1iZXJDb2x1bW4uanNcIik7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOdW1iZXJDb2x1bW5cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyQ29sdW1uXzEuTnVtYmVyQ29sdW1uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIFBlcmNlbnRDb21wbGV0ZUJhckNvbHVtbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi90eXBlL1BlcmNlbnRDb21wbGV0ZUJhckNvbHVtbiAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3R5cGUvUGVyY2VudENvbXBsZXRlQmFyQ29sdW1uLmpzXCIpO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUGVyY2VudENvbXBsZXRlQmFyQ29sdW1uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFBlcmNlbnRDb21wbGV0ZUJhckNvbHVtbl8xLlBlcmNlbnRDb21wbGV0ZUJhckNvbHVtbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBSYWRpb0NvbHVtbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi90eXBlL1JhZGlvQ29sdW1uICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvdHlwZS9SYWRpb0NvbHVtbi5qc1wiKTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJhZGlvQ29sdW1uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFJhZGlvQ29sdW1uXzEuUmFkaW9Db2x1bW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgVHJlZUNvbHVtbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi90eXBlL1RyZWVDb2x1bW4gKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy90eXBlL1RyZWVDb2x1bW4uanNcIik7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUcmVlQ29sdW1uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFRyZWVDb2x1bW5fMS5UcmVlQ29sdW1uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBUWVBFUyA9IHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBERUZBVUxUOiBuZXcgQ29sdW1uXzEuQ29sdW1uKCksXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgTlVNQkVSOiBuZXcgTnVtYmVyQ29sdW1uXzEuTnVtYmVyQ29sdW1uKCksXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgQ0hFQ0s6IG5ldyBDaGVja0NvbHVtbl8xLkNoZWNrQ29sdW1uKCksXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgUkFESU86IG5ldyBSYWRpb0NvbHVtbl8xLlJhZGlvQ29sdW1uKCksXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgQlVUVE9OOiBuZXcgQnV0dG9uQ29sdW1uXzEuQnV0dG9uQ29sdW1uKCksXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgSU1BR0U6IG5ldyBJbWFnZUNvbHVtbl8xLkltYWdlQ29sdW1uKCksXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgTVVMVElMSU5FVEVYVDogbmV3IE11bHRpbGluZVRleHRDb2x1bW5fMS5NdWx0aWxpbmVUZXh0Q29sdW1uKClcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgZnVuY3Rpb24gb2YoY29sdW1uVHlwZSkge1xuICAgICAgICAgICAgaWYgKCFjb2x1bW5UeXBlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBUWVBFUy5ERUZBVUxUO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY29sdW1uVHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICB2YXIga2V5ID0gY29sdW1uVHlwZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICByZXR1cm4gVFlQRVNba2V5XSB8fCBvZihudWxsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBjb2x1bW5UeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMub2YgPSBvZjtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9jb2x1bW5zL3R5cGUvQmFzZUNvbHVtbi5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2NvbHVtbnMvdHlwZS9CYXNlQ29sdW1uLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gY29sdW1uc1R5cGVCYXNlQ29sdW1uSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICB2YXIgX19jcmVhdGVCaW5kaW5nID0gdGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZyB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICAgICAgICAgICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcblxuICAgICAgICAgICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgICAgICAgICAgZGVzYyA9IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ba107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xuICAgICAgICAgIH0gOiBmdW5jdGlvbiAobywgbSwgaywgazIpIHtcbiAgICAgICAgICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgICAgICAgICBvW2syXSA9IG1ba107XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gdGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCB2KSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHtcbiAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gOiBmdW5jdGlvbiAobywgdikge1xuICAgICAgICAgICAgb1tcImRlZmF1bHRcIl0gPSB2O1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIF9faW1wb3J0U3RhciA9IHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgICAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIHtcbiAgICAgICAgICAgICAgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5CYXNlQ29sdW1uID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIHN0eWxlQ29udGVudHMgPSBfX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vc3R5bGUgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9zdHlsZS5qc1wiKSk7XG5cbiAgICAgICAgICB2YXIgdXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uL2ludGVybmFsL3V0aWxzICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL3V0aWxzLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIEJhc2VTdHlsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vc3R5bGUvQmFzZVN0eWxlICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvc3R5bGUvQmFzZVN0eWxlLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIGFuaW1hdGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uL2ludGVybmFsL2FuaW1hdGUgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvYW5pbWF0ZS5qc1wiKTtcblxuICAgICAgICAgIHZhciBzeW1ib2xNYW5hZ2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi9pbnRlcm5hbC9zeW1ib2xNYW5hZ2VyICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL3N5bWJvbE1hbmFnZXIuanNcIik7XG5cbiAgICAgICAgICB2YXIgaGFuZGxlcnNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uL2luZGljYXRvci9oYW5kbGVycyAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL2luZGljYXRvci9oYW5kbGVycy5qc1wiKTtcblxuICAgICAgICAgIHZhciBzZXRSZWFkb25seSA9IHV0aWxzXzEub2JqLnNldFJlYWRvbmx5O1xuICAgICAgICAgIHZhciBDT0xVTU5fRkFERUlOX1NUQVRFX0lEID0gKDAsIHN5bWJvbE1hbmFnZXJfMS5nZXRDb2x1bW5GYWRlaW5TdGF0ZUlkKSgpO1xuXG4gICAgICAgICAgZnVuY3Rpb24gaXNGYWRlaW5XaGVuQ2FsbGJhY2tJblByb21pc2UoY29sdW1uLCBncmlkKSB7XG4gICAgICAgICAgICBpZiAoY29sdW1uLmZhZGVpbldoZW5DYWxsYmFja0luUHJvbWlzZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjb2x1bW4uZmFkZWluV2hlbkNhbGxiYWNrSW5Qcm9taXNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gISFncmlkLmNvbmZpZ3VyZShcImZhZGVpbldoZW5DYWxsYmFja0luUHJvbWlzZVwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBnZXRGYWRlaW5TdGF0ZShncmlkKSB7XG4gICAgICAgICAgICB2YXIgc3RhdGUgPSBncmlkW0NPTFVNTl9GQURFSU5fU1RBVEVfSURdO1xuXG4gICAgICAgICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgICAgICAgIHN0YXRlID0ge1xuICAgICAgICAgICAgICAgIGNlbGxzOiB7fVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBzZXRSZWFkb25seShncmlkLCBDT0xVTU5fRkFERUlOX1NUQVRFX0lELCBzdGF0ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBfZ2VuZXJhdGVGYWRlaW5Qb2ludEFjdGlvbihncmlkLCBjb2wsIHJvdywgY29udGV4dCwgZHJhd0ludGVybmFsLCBkcmF3Q2VsbEJhc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgICAgICAgdmFyIHN0YXRlID0gZ2V0RmFkZWluU3RhdGUoZ3JpZCk7XG4gICAgICAgICAgICAgIHZhciBzdGF0ZUtleSA9IFwiXCIuY29uY2F0KHJvdywgXCI6XCIpLmNvbmNhdChjb2wpO1xuXG4gICAgICAgICAgICAgIGlmIChwb2ludCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzdGF0ZS5jZWxsc1tzdGF0ZUtleV07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuY2VsbHNbc3RhdGVLZXldID0ge1xuICAgICAgICAgICAgICAgICAgb3BhY2l0eTogcG9pbnRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZHJhd0NlbGxCYXNlKCk7XG4gICAgICAgICAgICAgIGRyYXdJbnRlcm5hbCgpO1xuICAgICAgICAgICAgICB2YXIgY2VsbFN0YXRlID0gc3RhdGUuY2VsbHNbc3RhdGVLZXldO1xuXG4gICAgICAgICAgICAgIGlmIChjZWxsU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAvL+mAj+mBjuOBmeOCi+OBn+OCgeiDjOaZr+OCkumAj+mBjuOBp+S4iuabuOOBjVxuICAgICAgICAgICAgICAgIHZhciBjdHggPSBjb250ZXh0LmdldENvbnRleHQoKTtcbiAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxIC0gY2VsbFN0YXRlLm9wYWNpdHk7XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgZHJhd0NlbGxCYXNlKCk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBmYWRlaW5NZ3IgPSB7XG4gICAgICAgICAgICBhbmltYXRlOiBmdW5jdGlvbiBhbmltYXRlKGdyaWQsIGNvbCwgcm93LCBjb250ZXh0LCBkcmF3SW50ZXJuYWwsIGRyYXdDZWxsQmFzZSkge1xuICAgICAgICAgICAgICAvLyBmYWRlaW4gYW5pbWF0aW9uXG4gICAgICAgICAgICAgIHZhciBzdGF0ZSA9IGdldEZhZGVpblN0YXRlKGdyaWQpO1xuICAgICAgICAgICAgICB2YXIgYWN0aXZlRmFkZWlucyA9IFtfZ2VuZXJhdGVGYWRlaW5Qb2ludEFjdGlvbihncmlkLCBjb2wsIHJvdywgY29udGV4dCwgZHJhd0ludGVybmFsLCBkcmF3Q2VsbEJhc2UpXTtcbiAgICAgICAgICAgICAgc3RhdGUuYWN0aXZlRmFkZWlucyA9IGFjdGl2ZUZhZGVpbnM7XG4gICAgICAgICAgICAgICgwLCBhbmltYXRlXzEuYW5pbWF0ZSkoNTAwLCBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgICAgICAgICBhY3RpdmVGYWRlaW5zLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmKHBvaW50KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmIChwb2ludCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgZGVsZXRlIHN0YXRlLmFjdGl2ZUZhZGVpbnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtYXJnZUFuaW1hdGU6IGZ1bmN0aW9uIG1hcmdlQW5pbWF0ZShncmlkLCBjb2wsIHJvdywgY29udGV4dCwgZHJhd0ludGVybmFsLCBkcmF3Q2VsbEJhc2UpIHtcbiAgICAgICAgICAgICAgdmFyIHN0YXRlID0gZ2V0RmFkZWluU3RhdGUoZ3JpZCk7XG5cbiAgICAgICAgICAgICAgaWYgKHN0YXRlLmFjdGl2ZUZhZGVpbnMpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5hY3RpdmVGYWRlaW5zLnB1c2goX2dlbmVyYXRlRmFkZWluUG9pbnRBY3Rpb24oZ3JpZCwgY29sLCByb3csIGNvbnRleHQsIGRyYXdJbnRlcm5hbCwgZHJhd0NlbGxCYXNlKSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZHJhd0ludGVybmFsKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdmFyIEJhc2VDb2x1bW4gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gQmFzZUNvbHVtbihvcHRpb24pIHtcbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJhc2VDb2x1bW4pO1xuXG4gICAgICAgICAgICAgIHRoaXMub25EcmF3Q2VsbCA9IHRoaXMub25EcmF3Q2VsbC5iaW5kKHRoaXMpOyAvL+OCueOCs+ODvOODl+OCkuWbuuWumuOBleOBm+OCi1xuICAgICAgICAgICAgICAvL1Byb21pc2Xjga5jYWxsYmFja+OBp+ODleOCp+ODvOODieOCpOODs+ihqOekuuOBmeOCi1xuXG4gICAgICAgICAgICAgIHRoaXMuX2ZhZGVpbldoZW5DYWxsYmFja0luUHJvbWlzZSA9IG9wdGlvbiA9PT0gbnVsbCB8fCBvcHRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbi5mYWRlaW5XaGVuQ2FsbGJhY2tJblByb21pc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhCYXNlQ29sdW1uLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiZmFkZWluV2hlbkNhbGxiYWNrSW5Qcm9taXNlXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9mYWRlaW5XaGVuQ2FsbGJhY2tJblByb21pc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIlN0eWxlQ2xhc3NcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJhc2VTdHlsZV8xLkJhc2VTdHlsZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwib25EcmF3Q2VsbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25EcmF3Q2VsbChjZWxsVmFsdWUsIGluZm8sIGNvbnRleHQsIGdyaWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXM1MyA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICB2YXIgX2E7XG5cbiAgICAgICAgICAgICAgICB2YXIgc3R5bGUgPSBpbmZvLnN0eWxlLFxuICAgICAgICAgICAgICAgICAgICBnZXRSZWNvcmQgPSBpbmZvLmdldFJlY29yZCxcbiAgICAgICAgICAgICAgICAgICAgZHJhd0NlbGxCYXNlID0gaW5mby5kcmF3Q2VsbEJhc2U7XG4gICAgICAgICAgICAgICAgdmFyIGhlbHBlciA9IGdyaWQuZ2V0R3JpZENhbnZhc0hlbHBlcigpO1xuICAgICAgICAgICAgICAgIGRyYXdDZWxsQmFzZSgpO1xuICAgICAgICAgICAgICAgIHZhciByZWNvcmQgPSBnZXRSZWNvcmQoKTtcbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZTtcblxuICAgICAgICAgICAgICAgIGlmICgoMCwgdXRpbHNfMS5pc1Byb21pc2UpKHJlY29yZCkpIHtcbiAgICAgICAgICAgICAgICAgIHByb21pc2UgPSByZWNvcmQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICgoMCwgdXRpbHNfMS5pc1Byb21pc2UpKGNlbGxWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgIHByb21pc2UgPSBjZWxsVmFsdWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhciBtc2cgPSBpbmZvLmdldE1lc3NhZ2UoKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKCgwLCB1dGlsc18xLmlzUHJvbWlzZSkobXNnKSkge1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlID0gbXNnO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy/mloflrZfmj4/nlLtcblxuXG4gICAgICAgICAgICAgICAgaWYgKHByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW3JlY29yZCwgY2VsbFZhbHVlLCBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2VsbFZhbHVlO1xuICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbmZvLmdldE1lc3NhZ2UoKTtcbiAgICAgICAgICAgICAgICAgIH0pXSkudGhlbihmdW5jdGlvbiAoX3JlZjI3KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWNvcmQgPSBfcmVmMjdbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBfcmVmMjdbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gX3JlZjI3WzJdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudENvbnRleHQgPSBjb250ZXh0LnRvQ3VycmVudENvbnRleHQoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRyYXdSZWN0ID0gY3VycmVudENvbnRleHQuZ2V0RHJhd1JlY3QoKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWRyYXdSZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWUgPSBEYXRlLm5vdygpIC0gc3RhcnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRyYXdJbnRlcm5hbCA9IGZ1bmN0aW9uIGRyYXdJbnRlcm5hbCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudENvbnRleHQgPSBjb250ZXh0LnRvQ3VycmVudENvbnRleHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgZHJhd1JlY3QgPSBjdXJyZW50Q29udGV4dC5nZXREcmF3UmVjdCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCFkcmF3UmVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgIHZhciBhY3RTdHlsZSA9IHN0eWxlQ29udGVudHMub2Yoc3R5bGUsIHJlY29yZCwgX3RoaXM1My5TdHlsZUNsYXNzKTtcblxuICAgICAgICAgICAgICAgICAgICAgIF90aGlzNTMuZHJhd0ludGVybmFsKF90aGlzNTMuY29udmVydEludGVybmFsKHZhbCksIGN1cnJlbnRDb250ZXh0LCBhY3RTdHlsZSwgaGVscGVyLCBncmlkLCBpbmZvKTtcblxuICAgICAgICAgICAgICAgICAgICAgIF90aGlzNTMuZHJhd01lc3NhZ2VJbnRlcm5hbChtZXNzYWdlLCBjdXJyZW50Q29udGV4dCwgYWN0U3R5bGUsIGhlbHBlciwgZ3JpZCwgaW5mbyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICBfdGhpczUzLmRyYXdJbmRpY2F0b3JzSW50ZXJuYWwoY3VycmVudENvbnRleHQsIGFjdFN0eWxlLCBoZWxwZXIsIGdyaWQsIGluZm8pO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNGYWRlaW5XaGVuQ2FsbGJhY2tJblByb21pc2UoX3RoaXM1MywgZ3JpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBkcmF3SW50ZXJuYWwoKTsgLy/ljZjntJTjgarmj4/nlLtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sID0gY29udGV4dC5jb2wsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJvdyA9IGNvbnRleHQucm93O1xuXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWUgPCA4MCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy84MG1z5Lul5YaF44GuUHJvbWlzZUNhbGxiYWNr44Gv5YmN44Ki44OL44Oh44O844K344On44Oz44Gr57Wx5ZCIXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWRlaW5NZ3IubWFyZ2VBbmltYXRlKGdyaWQsIGNvbCwgcm93LCBjb250ZXh0LCBkcmF3SW50ZXJuYWwsIGRyYXdDZWxsQmFzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8v44Ki44OL44Oh44O844K344On44OzXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWRlaW5NZ3IuYW5pbWF0ZShncmlkLCBjb2wsIHJvdywgY29udGV4dCwgZHJhd0ludGVybmFsLCBkcmF3Q2VsbEJhc2UpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhciBhY3RTdHlsZSA9IHN0eWxlQ29udGVudHMub2Yoc3R5bGUsIHJlY29yZCwgdGhpcy5TdHlsZUNsYXNzKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd0ludGVybmFsKHRoaXMuY29udmVydEludGVybmFsKGNlbGxWYWx1ZSksIGNvbnRleHQsIGFjdFN0eWxlLCBoZWxwZXIsIGdyaWQsIGluZm8pO1xuICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3TWVzc2FnZUludGVybmFsKGluZm8uZ2V0TWVzc2FnZSgpLCBjb250ZXh0LCBhY3RTdHlsZSwgaGVscGVyLCBncmlkLCBpbmZvKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd0luZGljYXRvcnNJbnRlcm5hbChjb250ZXh0LCBhY3RTdHlsZSwgaGVscGVyLCBncmlkLCBpbmZvKTsgLy/jg5Xjgqfjg7zjg4njgqTjg7Pjga7loLTlkIjpgI/pgY7jgZnjgovjgZ/jgoHog4zmma/jgpLpgI/pgY7jgafkuIrmm7jjgY1cblxuICAgICAgICAgICAgICAgICAgdmFyIGNvbCA9IGNvbnRleHQuY29sLFxuICAgICAgICAgICAgICAgICAgICAgIHJvdyA9IGNvbnRleHQucm93O1xuICAgICAgICAgICAgICAgICAgdmFyIHN0YXRlS2V5ID0gXCJcIi5jb25jYXQoY29sLCBcIjpcIikuY29uY2F0KHJvdyk7XG4gICAgICAgICAgICAgICAgICB2YXIgY2VsbFN0YXRlID0gKF9hID0gZ3JpZFtDT0xVTU5fRkFERUlOX1NUQVRFX0lEXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNlbGxzW3N0YXRlS2V5XTtcblxuICAgICAgICAgICAgICAgICAgaWYgKGNlbGxTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3R4ID0gY29udGV4dC5nZXRDb250ZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDEgLSBjZWxsU3RhdGUub3BhY2l0eTtcblxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIGRyYXdDZWxsQmFzZSgpO1xuICAgICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNvbnZlcnRJbnRlcm5hbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY29udmVydEludGVybmFsKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IFwiXCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImRyYXdNZXNzYWdlSW50ZXJuYWxcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdNZXNzYWdlSW50ZXJuYWwobWVzc2FnZSwgY29udGV4dCwgc3R5bGUsIGhlbHBlciwgZ3JpZCwgaW5mbykge1xuICAgICAgICAgICAgICAgIGluZm8ubWVzc2FnZUhhbmRsZXIuZHJhd0NlbGxNZXNzYWdlKG1lc3NhZ2UsIGNvbnRleHQsIHN0eWxlLCBoZWxwZXIsIGdyaWQsIGluZm8pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJkcmF3SW5kaWNhdG9yc0ludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3SW5kaWNhdG9yc0ludGVybmFsKGNvbnRleHQsIHN0eWxlLCBoZWxwZXIsIGdyaWQsIGluZm8pIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG5cbiAgICAgICAgICAgICAgICB2YXIgaW5kaWNhdG9yVG9wTGVmdCA9IHN0eWxlLmluZGljYXRvclRvcExlZnQsXG4gICAgICAgICAgICAgICAgICAgIGluZGljYXRvclRvcFJpZ2h0ID0gc3R5bGUuaW5kaWNhdG9yVG9wUmlnaHQsXG4gICAgICAgICAgICAgICAgICAgIGluZGljYXRvckJvdHRvbVJpZ2h0ID0gc3R5bGUuaW5kaWNhdG9yQm90dG9tUmlnaHQsXG4gICAgICAgICAgICAgICAgICAgIGluZGljYXRvckJvdHRvbUxlZnQgPSBzdHlsZS5pbmRpY2F0b3JCb3R0b21MZWZ0O1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kyID0gMCwgX2FyciA9IFtbaW5kaWNhdG9yVG9wTGVmdCwgMFxuICAgICAgICAgICAgICAgIC8qIERyYXdJbmRpY2F0b3JLaW5kLnRvcExlZnQgKi9cbiAgICAgICAgICAgICAgICBdLCBbaW5kaWNhdG9yVG9wUmlnaHQsIDFcbiAgICAgICAgICAgICAgICAvKiBEcmF3SW5kaWNhdG9yS2luZC50b3BSaWdodCAqL1xuICAgICAgICAgICAgICAgIF0sIFtpbmRpY2F0b3JCb3R0b21SaWdodCwgMlxuICAgICAgICAgICAgICAgIC8qIERyYXdJbmRpY2F0b3JLaW5kLmJvdHRvbVJpZ2h0ICovXG4gICAgICAgICAgICAgICAgXSwgW2luZGljYXRvckJvdHRvbUxlZnQsIDNcbiAgICAgICAgICAgICAgICAvKiBEcmF3SW5kaWNhdG9yS2luZC5ib3R0b21MZWZ0ICovXG4gICAgICAgICAgICAgICAgXV07IF9pMiA8IF9hcnIubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICAgICAgICAgICAgdmFyIF9hcnIkX2kgPSBfYXJyW19pMl0sXG4gICAgICAgICAgICAgICAgICAgICAgaW5kaWNhdG9yU3R5bGUgPSBfYXJyJF9pWzBdLFxuICAgICAgICAgICAgICAgICAgICAgIGtpbmQgPSBfYXJyJF9pWzFdO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoaW5kaWNhdG9yU3R5bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gKDAsIGhhbmRsZXJzXzEuZ2V0RHJhd0luZGljYXRvcikoaW5kaWNhdG9yU3R5bGUpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EoY29udGV4dCwgaW5kaWNhdG9yU3R5bGUsIGtpbmQsIGhlbHBlciwgZ3JpZCwgaW5mbyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJiaW5kR3JpZEV2ZW50XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kR3JpZEV2ZW50KF9ncmlkLCBfY2VsbElkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJnZXRDb3B5Q2VsbFZhbHVlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb3B5Q2VsbFZhbHVlKHZhbHVlLCBfZ3JpZCwgX2NlbGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIEJhc2VDb2x1bW47XG4gICAgICAgICAgfSgpO1xuXG4gICAgICAgICAgZXhwb3J0cy5CYXNlQ29sdW1uID0gQmFzZUNvbHVtbjtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9jb2x1bW5zL3R5cGUvQnJhbmNoR3JhcGhDb2x1bW4uanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vY29sdW1ucy90eXBlL0JyYW5jaEdyYXBoQ29sdW1uLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGNvbHVtbnNUeXBlQnJhbmNoR3JhcGhDb2x1bW5Kcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLkJyYW5jaEdyYXBoQ29sdW1uID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIHV0aWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi9pbnRlcm5hbC91dGlscyAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC91dGlscy5qc1wiKTtcblxuICAgICAgICAgIHZhciBCYXNlQ29sdW1uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL0Jhc2VDb2x1bW4gKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy90eXBlL0Jhc2VDb2x1bW4uanNcIik7XG5cbiAgICAgICAgICB2YXIgQnJhbmNoR3JhcGhTdHlsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vc3R5bGUvQnJhbmNoR3JhcGhTdHlsZSAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3N0eWxlL0JyYW5jaEdyYXBoU3R5bGUuanNcIik7XG5cbiAgICAgICAgICB2YXIgc3ltYm9sTWFuYWdlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vaW50ZXJuYWwvc3ltYm9sTWFuYWdlciAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC9zeW1ib2xNYW5hZ2VyLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIF8gPSAoMCwgc3ltYm9sTWFuYWdlcl8xLmdldEJyYW5jaEdyYXBoQ29sdW1uU3RhdGVJZCkoKTtcblxuICAgICAgICAgIGZ1bmN0aW9uIGdldEFsbENvbHVtbkRhdGEoZ3JpZCwgZmllbGQsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgZGF0YVNvdXJjZSA9IGdyaWQuZGF0YVNvdXJjZTtcbiAgICAgICAgICAgIHZhciBhbGxEYXRhID0gW107XG4gICAgICAgICAgICB2YXIgcHJvbWlzZTtcblxuICAgICAgICAgICAgdmFyIF9sb29wNCA9IGZ1bmN0aW9uIF9sb29wNChpbmRleCkge1xuICAgICAgICAgICAgICB2YXIgZGF0YSA9IGRhdGFTb3VyY2UuZ2V0RmllbGQoaW5kZXgsIGZpZWxkKTtcblxuICAgICAgICAgICAgICBpZiAoKDAsIHV0aWxzXzEuaXNQcm9taXNlKShkYXRhKSkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhSW5kZXggPSBhbGxEYXRhLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBhbGxEYXRhLnB1c2godW5kZWZpbmVkKTtcblxuICAgICAgICAgICAgICAgIGlmICghcHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgcHJvbWlzZSA9IGRhdGEudGhlbihmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgICAgICBhbGxEYXRhW2RhdGFJbmRleF0gPSBkO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsRGF0YVtkYXRhSW5kZXhdID0gZDtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhbGxEYXRhLnB1c2goZGF0YSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBkYXRhU291cmNlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICBfbG9vcDQoaW5kZXgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocHJvbWlzZSkge1xuICAgICAgICAgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhhbGxEYXRhKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjYWxsYmFjayhhbGxEYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgQnJhbmNoTGluZSA9IGZ1bmN0aW9uIEJyYW5jaExpbmUoX3JlZjI4KSB7XG4gICAgICAgICAgICB2YXIgZnJvbUluZGV4ID0gX3JlZjI4LmZyb21JbmRleCxcbiAgICAgICAgICAgICAgICB0b0luZGV4ID0gX3JlZjI4LnRvSW5kZXgsXG4gICAgICAgICAgICAgICAgY29sb3JJbmRleCA9IF9yZWYyOC5jb2xvckluZGV4LFxuICAgICAgICAgICAgICAgIHBvaW50ID0gX3JlZjI4LnBvaW50O1xuXG4gICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnJhbmNoTGluZSk7XG5cbiAgICAgICAgICAgIHRoaXMuZnJvbUluZGV4ID0gZnJvbUluZGV4O1xuICAgICAgICAgICAgdGhpcy50b0luZGV4ID0gdG9JbmRleDtcbiAgICAgICAgICAgIHRoaXMuY29sb3JJbmRleCA9IGNvbG9ySW5kZXg7XG4gICAgICAgICAgICB0aGlzLnBvaW50ID0gcG9pbnQ7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHZhciBCcmFuY2hQb2ludCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBCcmFuY2hQb2ludChfcmVmMjkpIHtcbiAgICAgICAgICAgICAgdmFyIGluZGV4ID0gX3JlZjI5LmluZGV4LFxuICAgICAgICAgICAgICAgICAgX3JlZjI5JGNvbW1pdCA9IF9yZWYyOS5jb21taXQsXG4gICAgICAgICAgICAgICAgICBjb21taXQgPSBfcmVmMjkkY29tbWl0ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYyOSRjb21taXQsXG4gICAgICAgICAgICAgICAgICBfcmVmMjkkbGluZXMgPSBfcmVmMjkubGluZXMsXG4gICAgICAgICAgICAgICAgICBsaW5lcyA9IF9yZWYyOSRsaW5lcyA9PT0gdm9pZCAwID8gW10gOiBfcmVmMjkkbGluZXMsXG4gICAgICAgICAgICAgICAgICB0YWcgPSBfcmVmMjkudGFnO1xuXG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCcmFuY2hQb2ludCk7XG5cbiAgICAgICAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgICB0aGlzLmNvbW1pdCA9IGNvbW1pdDtcbiAgICAgICAgICAgICAgdGhpcy5saW5lcyA9IGxpbmVzO1xuICAgICAgICAgICAgICB0aGlzLnRhZyA9IHRhZztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKEJyYW5jaFBvaW50LCBudWxsLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwibWVyZ2VMaW5lc1wiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbWVyZ2VMaW5lcyhsaW5lcykge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBsaW5lcy5maWx0ZXIoZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBsLmZyb21JbmRleCAhPSBudWxsICYmIGwudG9JbmRleCAhPSBudWxsO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhciBmcm9tTGlzdCA9IGxpbmVzLmZpbHRlcihmdW5jdGlvbiAobCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGwuZnJvbUluZGV4ICE9IG51bGwgJiYgbC50b0luZGV4ID09IG51bGw7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIHRvTGlzdCA9IGxpbmVzLmZpbHRlcihmdW5jdGlvbiAobCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGwuZnJvbUluZGV4ID09IG51bGwgJiYgbC50b0luZGV4ICE9IG51bGw7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZnJvbUxpc3QuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b0xpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSB0b0xpc3RbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQucG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChmLmNvbG9ySW5kZXggPT09IHQuY29sb3JJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgIGYudG9JbmRleCA9IHQudG9JbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICB0b0xpc3Quc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGYpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQuY29uY2F0KHRvTGlzdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIm1lcmdlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBtZXJnZShhLCBiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFhKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJyYW5jaFBvaW50KHtcbiAgICAgICAgICAgICAgICAgIGluZGV4OiBhLmluZGV4LFxuICAgICAgICAgICAgICAgICAgY29tbWl0OiBhLmNvbW1pdCB8fCBiLmNvbW1pdCxcbiAgICAgICAgICAgICAgICAgIGxpbmVzOiBCcmFuY2hQb2ludC5tZXJnZUxpbmVzKGEubGluZXMuY29uY2F0KGIubGluZXMpKSxcbiAgICAgICAgICAgICAgICAgIHRhZzogYS50YWcgfHwgYi50YWdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gQnJhbmNoUG9pbnQ7XG4gICAgICAgICAgfSgpO1xuXG4gICAgICAgICAgZnVuY3Rpb24gam9pbkxpbmUodGltZWxpbmUsIGJyYW5jaEluZGV4KSB7XG4gICAgICAgICAgICB2YXIgcmV2ZXJzZSA9IF90b0NvbnN1bWFibGVBcnJheSh0aW1lbGluZSkucmV2ZXJzZSgpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJldmVyc2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIGYgPSByZXZlcnNlW2ldW2JyYW5jaEluZGV4XTtcblxuICAgICAgICAgICAgICBpZiAoZikge1xuICAgICAgICAgICAgICAgIGYubGluZXMgPSBCcmFuY2hQb2ludC5tZXJnZUxpbmVzKGYubGluZXMuY29uY2F0KFtuZXcgQnJhbmNoTGluZSh7XG4gICAgICAgICAgICAgICAgICB0b0luZGV4OiBicmFuY2hJbmRleCxcbiAgICAgICAgICAgICAgICAgIGNvbG9ySW5kZXg6IGJyYW5jaEluZGV4XG4gICAgICAgICAgICAgICAgfSldKSk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGk7IGorKykge1xuICAgICAgICAgICAgICAgICAgdmFyIHRsID0gcmV2ZXJzZVtqXTtcbiAgICAgICAgICAgICAgICAgIHRsW2JyYW5jaEluZGV4XSA9IG5ldyBCcmFuY2hQb2ludCh7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBicmFuY2hJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgbGluZXM6IFtuZXcgQnJhbmNoTGluZSh7XG4gICAgICAgICAgICAgICAgICAgICAgZnJvbUluZGV4OiBicmFuY2hJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICB0b0luZGV4OiBicmFuY2hJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICBjb2xvckluZGV4OiBicmFuY2hJbmRleFxuICAgICAgICAgICAgICAgICAgICB9KV1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBicmFuY2goX3JlZjMwLCBmcm9tLCB0bykge1xuICAgICAgICAgICAgdmFyIHRpbWVsaW5lID0gX3JlZjMwLnRpbWVsaW5lLFxuICAgICAgICAgICAgICAgIGJyYW5jaGVzID0gX3JlZjMwLmJyYW5jaGVzO1xuICAgICAgICAgICAgdmFyIGZyb21JbmRleCA9IGZyb20gIT0gbnVsbCA/IGJyYW5jaGVzLmluZGV4T2YoZnJvbSkgOiAtMTtcbiAgICAgICAgICAgIHZhciB0b0luZGV4ID0gYnJhbmNoZXMuaW5kZXhPZih0byk7XG5cbiAgICAgICAgICAgIGlmICh0b0luZGV4IDwgMCkge1xuICAgICAgICAgICAgICB0b0luZGV4ID0gYnJhbmNoZXMubGVuZ3RoO1xuICAgICAgICAgICAgICBicmFuY2hlcy5wdXNoKHRvKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gZmluZEJyYW5jaFJvb3RJbmRleCgpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSB0aW1lbGluZS5sZW5ndGggLSAxOyBpbmRleCA+PSAwOyBpbmRleC0tKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRsID0gdGltZWxpbmVbaW5kZXhdO1xuICAgICAgICAgICAgICAgIHZhciBfZnJvbSA9IHRsW2Zyb21JbmRleF07XG5cbiAgICAgICAgICAgICAgICBpZiAoX2Zyb20gJiYgX2Zyb20uY29tbWl0KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZnJvbUluZGV4IDwgMCkge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IEJyYW5jaFBvaW50KHtcbiAgICAgICAgICAgICAgICBpbmRleDogdG9JbmRleFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBmcm9tVGFyZ2V0SW5kZXggPSBmaW5kQnJhbmNoUm9vdEluZGV4KCk7XG5cbiAgICAgICAgICAgICAgaWYgKGZyb21UYXJnZXRJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBicmFuY2hUYXJnZXRGcm9tSW5kZXggPSBmcm9tVGFyZ2V0SW5kZXggKyAxO1xuICAgICAgICAgICAgICB2YXIgYnJhbmNoUG9pbnQgPSBuZXcgQnJhbmNoUG9pbnQoe1xuICAgICAgICAgICAgICAgIGluZGV4OiB0b0luZGV4LFxuICAgICAgICAgICAgICAgIGxpbmVzOiBbbmV3IEJyYW5jaExpbmUoe1xuICAgICAgICAgICAgICAgICAgZnJvbUluZGV4OiBmcm9tSW5kZXgsXG4gICAgICAgICAgICAgICAgICBjb2xvckluZGV4OiB0b0luZGV4XG4gICAgICAgICAgICAgICAgfSldXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB2YXIgcG9pbnQ7XG4gICAgICAgICAgICAgIHZhciByZXN1bHQgPSBudWxsO1xuXG4gICAgICAgICAgICAgIGlmIChicmFuY2hUYXJnZXRGcm9tSW5kZXggPCB0aW1lbGluZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0TGluZSA9IHRpbWVsaW5lW2JyYW5jaFRhcmdldEZyb21JbmRleF07XG4gICAgICAgICAgICAgICAgcG9pbnQgPSB0YXJnZXRMaW5lW3RvSW5kZXhdID0gQnJhbmNoUG9pbnQubWVyZ2UodGFyZ2V0TGluZVt0b0luZGV4XSwgYnJhbmNoUG9pbnQpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBvaW50ID0gYnJhbmNoUG9pbnQ7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gYnJhbmNoUG9pbnQ7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgX2Zyb20yID0gdGltZWxpbmVbZnJvbVRhcmdldEluZGV4XVtmcm9tSW5kZXhdO1xuICAgICAgICAgICAgICBfZnJvbTIubGluZXMgPSBCcmFuY2hQb2ludC5tZXJnZUxpbmVzKF9mcm9tMi5saW5lcy5jb25jYXQoW25ldyBCcmFuY2hMaW5lKHtcbiAgICAgICAgICAgICAgICB0b0luZGV4OiB0b0luZGV4LFxuICAgICAgICAgICAgICAgIGNvbG9ySW5kZXg6IHRvSW5kZXgsXG4gICAgICAgICAgICAgICAgcG9pbnQ6IHBvaW50XG4gICAgICAgICAgICAgIH0pXSkpO1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGNvbW1pdChfcmVmMzEsIG5hbWUpIHtcbiAgICAgICAgICAgIHZhciB0aW1lbGluZSA9IF9yZWYzMS50aW1lbGluZSxcbiAgICAgICAgICAgICAgICBicmFuY2hlcyA9IF9yZWYzMS5icmFuY2hlcztcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGJyYW5jaGVzLmluZGV4T2YobmFtZSk7XG5cbiAgICAgICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgQnJhbmNoUG9pbnQoe1xuICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgIGNvbW1pdDogdHJ1ZVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChqb2luTGluZSh0aW1lbGluZSwgaW5kZXgpKSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5saW5lcyA9IEJyYW5jaFBvaW50Lm1lcmdlTGluZXMocmVzdWx0LmxpbmVzLmNvbmNhdChbbmV3IEJyYW5jaExpbmUoe1xuICAgICAgICAgICAgICAgIGZyb21JbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgICAgY29sb3JJbmRleDogaW5kZXhcbiAgICAgICAgICAgICAgfSldKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gY29tbWl0VGFnKF9yZWYzMiwgbmFtZSwgdGFnKSB7XG4gICAgICAgICAgICB2YXIgYnJhbmNoZXMgPSBfcmVmMzIuYnJhbmNoZXM7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBicmFuY2hlcy5pbmRleE9mKG5hbWUpO1xuXG4gICAgICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgIGluZGV4ID0gYnJhbmNoZXMubGVuZ3RoO1xuICAgICAgICAgICAgICBicmFuY2hlcy5wdXNoKG5hbWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3IEJyYW5jaFBvaW50KHtcbiAgICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgICB0YWc6IHRhZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gY29tbWl0TWVyZ2UoX3JlZjMzLCBmcm9tLCB0bykge1xuICAgICAgICAgICAgdmFyIHRpbWVsaW5lID0gX3JlZjMzLnRpbWVsaW5lLFxuICAgICAgICAgICAgICAgIGJyYW5jaGVzID0gX3JlZjMzLmJyYW5jaGVzO1xuICAgICAgICAgICAgdmFyIGZyb21JbmRleCA9IGJyYW5jaGVzLmluZGV4T2YoZnJvbSk7XG4gICAgICAgICAgICB2YXIgdG9JbmRleCA9IGJyYW5jaGVzLmluZGV4T2YodG8pO1xuXG4gICAgICAgICAgICBpZiAodG9JbmRleCA8IDAgfHwgZnJvbUluZGV4IDwgMCkge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IEJyYW5jaFBvaW50KHtcbiAgICAgICAgICAgICAgICBpbmRleDogdG9JbmRleCxcbiAgICAgICAgICAgICAgICBjb21taXQ6IHRydWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgQnJhbmNoUG9pbnQoe1xuICAgICAgICAgICAgICBpbmRleDogdG9JbmRleCxcbiAgICAgICAgICAgICAgY29tbWl0OiB0cnVlLFxuICAgICAgICAgICAgICBsaW5lczogW25ldyBCcmFuY2hMaW5lKHtcbiAgICAgICAgICAgICAgICBmcm9tSW5kZXg6IGZyb21JbmRleCxcbiAgICAgICAgICAgICAgICBjb2xvckluZGV4OiBmcm9tSW5kZXhcbiAgICAgICAgICAgICAgfSksIG5ldyBCcmFuY2hMaW5lKHtcbiAgICAgICAgICAgICAgICBmcm9tSW5kZXg6IHRvSW5kZXgsXG4gICAgICAgICAgICAgICAgY29sb3JJbmRleDogdG9JbmRleFxuICAgICAgICAgICAgICB9KV1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgZnJvbUxpc3QgPSBfdG9Db25zdW1hYmxlQXJyYXkodGltZWxpbmUpO1xuXG4gICAgICAgICAgICB2YXIgZnJvbVRhcmdldExpbmUgPSBmcm9tTGlzdC5wb3AoKTtcblxuICAgICAgICAgICAgaWYgKGZyb21UYXJnZXRMaW5lKSB7XG4gICAgICAgICAgICAgIGZyb21UYXJnZXRMaW5lW2Zyb21JbmRleF0gPSBCcmFuY2hQb2ludC5tZXJnZShmcm9tVGFyZ2V0TGluZVtmcm9tSW5kZXhdLCBuZXcgQnJhbmNoUG9pbnQoe1xuICAgICAgICAgICAgICAgIGluZGV4OiB0b0luZGV4LFxuICAgICAgICAgICAgICAgIGxpbmVzOiBbbmV3IEJyYW5jaExpbmUoe1xuICAgICAgICAgICAgICAgICAgdG9JbmRleDogdG9JbmRleCxcbiAgICAgICAgICAgICAgICAgIGNvbG9ySW5kZXg6IGZyb21JbmRleFxuICAgICAgICAgICAgICAgIH0pXVxuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChqb2luTGluZShmcm9tTGlzdCwgZnJvbUluZGV4KSAmJiBmcm9tVGFyZ2V0TGluZSkge1xuICAgICAgICAgICAgICBmcm9tVGFyZ2V0TGluZVtmcm9tSW5kZXhdLmxpbmVzID0gQnJhbmNoUG9pbnQubWVyZ2VMaW5lcyhmcm9tVGFyZ2V0TGluZVtmcm9tSW5kZXhdLmxpbmVzLmNvbmNhdChbbmV3IEJyYW5jaExpbmUoe1xuICAgICAgICAgICAgICAgIGZyb21JbmRleDogZnJvbUluZGV4LFxuICAgICAgICAgICAgICAgIGNvbG9ySW5kZXg6IGZyb21JbmRleFxuICAgICAgICAgICAgICB9KV0pKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgam9pbkxpbmUodGltZWxpbmUsIHRvSW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBjYWxjQ29tbWFuZChpbmZvLCBjb21tYW5kKSB7XG4gICAgICAgICAgICB2YXIgdGltZWxpbmUgPSBpbmZvLnRpbWVsaW5lO1xuICAgICAgICAgICAgdmFyIHRpbWVsaW5lRGF0YSA9IFtdOyAvLyBjb25zdCBsYXN0ID0gdGltZWxpbmUubGVuZ3RoID4gMCA/IHRpbWVsaW5lW3RpbWVsaW5lLmxlbmd0aCAtIDFdIDogbnVsbDtcblxuICAgICAgICAgICAgdmFyIGNvbW1hbmRzID0gQXJyYXkuaXNBcnJheShjb21tYW5kKSA/IGNvbW1hbmQgOiBbY29tbWFuZF07XG4gICAgICAgICAgICBjb21tYW5kcy5mb3JFYWNoKGZ1bmN0aW9uIChjbWQpIHtcbiAgICAgICAgICAgICAgaWYgKCFjbWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgcG9pbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKGNtZC5jb21tYW5kID09PSBcImJyYW5jaFwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZyb20gPSB1dGlsc18xLm9iai5pc09iamVjdChjbWQuYnJhbmNoKSA/IGNtZC5icmFuY2guZnJvbSA6IG51bGw7XG4gICAgICAgICAgICAgICAgdmFyIHRvID0gdXRpbHNfMS5vYmouaXNPYmplY3QoY21kLmJyYW5jaCkgPyBjbWQuYnJhbmNoLnRvIDogY21kLmJyYW5jaDtcbiAgICAgICAgICAgICAgICBwb2ludCA9IGJyYW5jaChpbmZvLCBmcm9tLCB0byk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoY21kLmNvbW1hbmQgPT09IFwiY29tbWl0XCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2JyYW5jaCA9IGNtZC5icmFuY2g7XG4gICAgICAgICAgICAgICAgcG9pbnQgPSBjb21taXQoaW5mbywgX2JyYW5jaCk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoY21kLmNvbW1hbmQgPT09IFwibWVyZ2VcIikge1xuICAgICAgICAgICAgICAgIHZhciBfY21kJGJyYW5jaCA9IGNtZC5icmFuY2gsXG4gICAgICAgICAgICAgICAgICAgIF9mcm9tMyA9IF9jbWQkYnJhbmNoLmZyb20sXG4gICAgICAgICAgICAgICAgICAgIF90byA9IF9jbWQkYnJhbmNoLnRvO1xuICAgICAgICAgICAgICAgIHBvaW50ID0gY29tbWl0TWVyZ2UoaW5mbywgX2Zyb20zLCBfdG8pO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNtZC5jb21tYW5kID09PSBcInRhZ1wiKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9icmFuY2gyID0gY21kLmJyYW5jaCxcbiAgICAgICAgICAgICAgICAgICAgdGFnID0gY21kLnRhZztcbiAgICAgICAgICAgICAgICBwb2ludCA9IGNvbW1pdFRhZyhpbmZvLCBfYnJhbmNoMiwgdGFnKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChwb2ludCAmJiBwb2ludC5pbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgdGltZWxpbmVEYXRhW3BvaW50LmluZGV4XSA9IEJyYW5jaFBvaW50Lm1lcmdlKHRpbWVsaW5lRGF0YVtwb2ludC5pbmRleF0sIHBvaW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aW1lbGluZS5wdXNoKHRpbWVsaW5lRGF0YSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gY2FsY0JyYW5jaGVzSW5mbyhzdGFydCwgZ3JpZCwgZmllbGQpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICAgIGJyYW5jaGVzOiBbXSxcbiAgICAgICAgICAgICAgdGltZWxpbmU6IFtdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ2V0QWxsQ29sdW1uRGF0YShncmlkLCBmaWVsZCwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgaWYgKHN0YXJ0ICE9PSBcInRvcFwiKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IF90b0NvbnN1bWFibGVBcnJheShkYXRhKS5yZXZlcnNlKCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24gKGNvbW1hbmQpIHtcbiAgICAgICAgICAgICAgICBjYWxjQ29tbWFuZChyZXN1bHQsIGNvbW1hbmQpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBjYWxjQnJhbmNoWFBvaW50cyhjdHgsIGxlZnQsIHdpZHRoLCByYWRpdXMsIGJyYW5jaGVzLCB0aW1lbGluZSkge1xuICAgICAgICAgICAgdmFyIHcgPSBNYXRoLm1heCh3aWR0aCAvIGJyYW5jaGVzLmxlbmd0aCArIDEsIDUpO1xuICAgICAgICAgICAgdGltZWxpbmUuZm9yRWFjaChmdW5jdGlvbiAodGwpIHtcbiAgICAgICAgICAgICAgdGwuZm9yRWFjaChmdW5jdGlvbiAocCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPD0gMCkge1xuICAgICAgICAgICAgICAgICAgLy8g6KiI566X44Gu5oSP5ZGz44GM54Sh44GEXG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHAudGFnKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgdGV4dFdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KHAudGFnKS53aWR0aDtcblxuICAgICAgICAgICAgICAgICAgaWYgKHcgKiBpbmRleCArIHJhZGl1cyAqIDIgKyA0ICsgdGV4dFdpZHRoID4gd2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdyA9IE1hdGgubWF4KCh3aWR0aCAtIHJhZGl1cyAqIDIgLSA0IC0gdGV4dFdpZHRoKSAvIGluZGV4LCA1KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICB2YXIgeCA9IGxlZnQ7XG4gICAgICAgICAgICBicmFuY2hlcy5mb3JFYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmVzdWx0LnB1c2goTWF0aC5jZWlsKHggKyByYWRpdXMpKTtcbiAgICAgICAgICAgICAgeCArPSB3O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHJlbmRlck1lcmdlKGdyaWQsIGN0eCwgeCwgeSwgdXBMaW5lSW5kZXgsIGRvd25MaW5lSW5kZXgsIGNvbG9ySW5kZXgsIF9yZWYzNCwgX3JlZjM1KSB7XG4gICAgICAgICAgICB2YXIgYnJhbmNoWFBvaW50cyA9IF9yZWYzNC5icmFuY2hYUG9pbnRzLFxuICAgICAgICAgICAgICAgIGJyYW5jaENvbG9ycyA9IF9yZWYzNC5icmFuY2hDb2xvcnMsXG4gICAgICAgICAgICAgICAgYnJhbmNoTGluZVdpZHRoID0gX3JlZjM0LmJyYW5jaExpbmVXaWR0aCxcbiAgICAgICAgICAgICAgICBtZXJnZVN0eWxlID0gX3JlZjM0Lm1lcmdlU3R5bGU7XG4gICAgICAgICAgICB2YXIgY29sID0gX3JlZjM1LmNvbCxcbiAgICAgICAgICAgICAgICByb3cgPSBfcmVmMzUucm93LFxuICAgICAgICAgICAgICAgIGJyYW5jaGVzID0gX3JlZjM1LmJyYW5jaGVzO1xuXG4gICAgICAgICAgICBpZiAodXBMaW5lSW5kZXggIT0gbnVsbCB8fCBkb3duTGluZUluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gKDAsIHV0aWxzXzEuZ2V0T3JBcHBseSkoYnJhbmNoQ29sb3JzLCBicmFuY2hlc1tjb2xvckluZGV4XSwgY29sb3JJbmRleCk7XG4gICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSBicmFuY2hMaW5lV2lkdGg7XG4gICAgICAgICAgICAgIGN0eC5saW5lQ2FwID0gXCJyb3VuZFwiO1xuICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgICAgICAgaWYgKHVwTGluZUluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgdXBYID0gYnJhbmNoWFBvaW50c1t1cExpbmVJbmRleF07XG4gICAgICAgICAgICAgICAgdmFyIHVwUmVjdCA9IGdyaWQuZ2V0Q2VsbFJlbGF0aXZlUmVjdChjb2wsIHJvdyAtIDEpO1xuICAgICAgICAgICAgICAgIHZhciB1cFkgPSB1cFJlY3QudG9wICsgdXBSZWN0LmhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh1cFgsIHVwWSk7XG5cbiAgICAgICAgICAgICAgICBpZiAobWVyZ2VTdHlsZSA9PT0gXCJiZXppZXJcIikge1xuICAgICAgICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8odXBYLCAoeSArIHVwWSkgLyAyLCB4LCAoeSArIHVwWSkgLyAyLCB4LCB5KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChkb3duTGluZUluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgZG93blggPSBicmFuY2hYUG9pbnRzW2Rvd25MaW5lSW5kZXhdO1xuICAgICAgICAgICAgICAgIHZhciBkb3duUmVjdCA9IGdyaWQuZ2V0Q2VsbFJlbGF0aXZlUmVjdChjb2wsIHJvdyArIDEpO1xuICAgICAgICAgICAgICAgIHZhciBkb3duWSA9IGRvd25SZWN0LnRvcCArIGRvd25SZWN0LmhlaWdodCAvIDI7XG5cbiAgICAgICAgICAgICAgICBpZiAobWVyZ2VTdHlsZSA9PT0gXCJiZXppZXJcIikge1xuICAgICAgICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oeCwgKHkgKyBkb3duWSkgLyAyLCBkb3duWCwgKHkgKyBkb3duWSkgLyAyLCBkb3duWCwgZG93blkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjdHgubGluZVRvKGRvd25YLCBkb3duWSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBCcmFuY2hHcmFwaENvbHVtblxuICAgICAgICAgICAqXG4gICAgICAgICAgICogRGF0YSBjb21tYW5kc1xuICAgICAgICAgICAqIC0gbWFzdGVyIGJyYW5jaCBvciBvcnBoYW4gYnJhbmNoXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBgYGBqc1xuICAgICAgICAgICAqIHtcbiAgICAgICAgICAgKiBcdGNvbW1hbmQ6ICdicmFuY2gnLFxuICAgICAgICAgICAqIFx0YnJhbmNoOiAnYnJhbmNoIG5hbWUgQScsXG4gICAgICAgICAgICogfVxuICAgICAgICAgICAqIGBgYFxuICAgICAgICAgICAqXG4gICAgICAgICAgICogLSBjb21taXRcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIGBgYGpzXG4gICAgICAgICAgICoge1xuICAgICAgICAgICAqIFx0Y29tbWFuZDogJ2NvbW1pdCcsXG4gICAgICAgICAgICogXHRicmFuY2g6ICdicmFuY2ggbmFtZSBBJ1xuICAgICAgICAgICAqIH1cbiAgICAgICAgICAgKiBgYGBcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIC0gYnJhbmNoXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBgYGBqc1xuICAgICAgICAgICAqIHtcbiAgICAgICAgICAgKiBcdGNvbW1hbmQ6ICdicmFuY2gnLFxuICAgICAgICAgICAqIFx0YnJhbmNoOiB7XG4gICAgICAgICAgICogXHRcdGZyb206ICdicmFuY2ggbmFtZSBBJyxcbiAgICAgICAgICAgKiBcdFx0dG86ICdicmFuY2ggbmFtZSBCJ1xuICAgICAgICAgICAqIFx0fVxuICAgICAgICAgICAqIH1cbiAgICAgICAgICAgKiBgYGBcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIC0gbWVyZ2VcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIGBgYGpzXG4gICAgICAgICAgICoge1xuICAgICAgICAgICAqIFx0Y29tbWFuZDogJ21lcmdlJyxcbiAgICAgICAgICAgKiBcdGJyYW5jaDoge1xuICAgICAgICAgICAqIFx0XHRmcm9tOiAnYnJhbmNoIG5hbWUgQicsXG4gICAgICAgICAgICogXHRcdHRvOiAnYnJhbmNoIG5hbWUgQSdcbiAgICAgICAgICAgKiBcdH1cbiAgICAgICAgICAgKiB9XG4gICAgICAgICAgICogYGBgXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiAtIHRhZ1xuICAgICAgICAgICAqXG4gICAgICAgICAgICogYGBganNcbiAgICAgICAgICAgKiB7XG4gICAgICAgICAgICogXHRjb21tYW5kOiAndGFnJyxcbiAgICAgICAgICAgKiBcdGJyYW5jaDogJ2JyYW5jaCBuYW1lIEEnLFxuICAgICAgICAgICAqIFx0dGFnOiAndGFnIG5hbWUnXG4gICAgICAgICAgICogfVxuICAgICAgICAgICAqIGBgYFxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQG1lbWJlcm9mIGNoZWV0YWhHcmlkLmNvbHVtbnMudHlwZVxuICAgICAgICAgICAqL1xuXG5cbiAgICAgICAgICB2YXIgQnJhbmNoR3JhcGhDb2x1bW4gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXNlQ29sdW1uXzEkQmFzZUNvbCkge1xuICAgICAgICAgICAgX2luaGVyaXRzKEJyYW5jaEdyYXBoQ29sdW1uLCBfQmFzZUNvbHVtbl8xJEJhc2VDb2wpO1xuXG4gICAgICAgICAgICB2YXIgX3N1cGVyMzQgPSBfY3JlYXRlU3VwZXIoQnJhbmNoR3JhcGhDb2x1bW4pO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBCcmFuY2hHcmFwaENvbHVtbigpIHtcbiAgICAgICAgICAgICAgdmFyIF90aGlzNTQ7XG5cbiAgICAgICAgICAgICAgdmFyIG9wdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJyYW5jaEdyYXBoQ29sdW1uKTtcblxuICAgICAgICAgICAgICBfdGhpczU0ID0gX3N1cGVyMzQuY2FsbCh0aGlzLCBvcHRpb24pO1xuICAgICAgICAgICAgICBfdGhpczU0Ll9zdGFydCA9IG9wdGlvbi5zdGFydCB8fCBcImJvdHRvbVwiO1xuICAgICAgICAgICAgICBfdGhpczU0Ll9jYWNoZSA9IG9wdGlvbi5jYWNoZSAhPSBudWxsID8gb3B0aW9uLmNhY2hlIDogZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczU0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoQnJhbmNoR3JhcGhDb2x1bW4sIFt7XG4gICAgICAgICAgICAgIGtleTogXCJTdHlsZUNsYXNzXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBCcmFuY2hHcmFwaFN0eWxlXzEuQnJhbmNoR3JhcGhTdHlsZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY2xlYXJDYWNoZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXJDYWNoZShncmlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGludGVybmFsID0gZ3JpZDtcbiAgICAgICAgICAgICAgICBkZWxldGUgaW50ZXJuYWxbX107XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIm9uRHJhd0NlbGxcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uRHJhd0NlbGwoY2VsbFZhbHVlLCBpbmZvLCBjb250ZXh0LCBncmlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NhY2hlKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgc3RhdGUgPSBncmlkW19dIHx8IChncmlkW19dID0gbmV3IE1hcCgpKTtcbiAgICAgICAgICAgICAgICAgIHZhciBjb2wgPSBjb250ZXh0LmNvbCxcbiAgICAgICAgICAgICAgICAgICAgICByb3cgPSBjb250ZXh0LnJvdztcbiAgICAgICAgICAgICAgICAgIHZhciBmaWVsZCA9IGdyaWQuZ2V0RmllbGQoY29sLCByb3cpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoIXN0YXRlLmhhcyhmaWVsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuc2V0KGZpZWxkLCBjYWxjQnJhbmNoZXNJbmZvKHRoaXMuX3N0YXJ0LCBncmlkLCBmaWVsZCkpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZ2V0KF9nZXRQcm90b3R5cGVPZihCcmFuY2hHcmFwaENvbHVtbi5wcm90b3R5cGUpLCBcIm9uRHJhd0NlbGxcIiwgdGhpcykuY2FsbCh0aGlzLCBjZWxsVmFsdWUsIGluZm8sIGNvbnRleHQsIGdyaWQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjbG9uZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCcmFuY2hHcmFwaENvbHVtbih0aGlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwic3RhcnRcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXJ0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjYWNoZVwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImRyYXdJbnRlcm5hbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0ludGVybmFsKF92YWx1ZSwgY29udGV4dCwgc3R5bGUsIGhlbHBlciwgZ3JpZCwgX3JlZjM2KSB7XG4gICAgICAgICAgICAgICAgdmFyIGRyYXdDZWxsQmFzZSA9IF9yZWYzNi5kcmF3Q2VsbEJhc2U7XG5cbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuXG4gICAgICAgICAgICAgICAgdmFyIGNvbCA9IGNvbnRleHQuY29sLFxuICAgICAgICAgICAgICAgICAgICByb3cgPSBjb250ZXh0LnJvdztcbiAgICAgICAgICAgICAgICB2YXIgZmllbGQgPSBncmlkLmdldEZpZWxkKGNvbCwgcm93KTtcblxuICAgICAgICAgICAgICAgIHZhciBfcmVmMzcgPSAoX2IgPSB0aGlzLl9jYWNoZSA/IChfYSA9IGdyaWRbX10pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXQoZmllbGQpIDogbnVsbCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogY2FsY0JyYW5jaGVzSW5mbyh0aGlzLl9zdGFydCwgZ3JpZCwgZmllbGQpLFxuICAgICAgICAgICAgICAgICAgICB0aW1lbGluZSA9IF9yZWYzNy50aW1lbGluZSxcbiAgICAgICAgICAgICAgICAgICAgYnJhbmNoZXMgPSBfcmVmMzcuYnJhbmNoZXM7XG5cbiAgICAgICAgICAgICAgICB2YXIgX3JlZjM4ID0gdGhpcy5fc3RhcnQgIT09IFwidG9wXCIgPyB7XG4gICAgICAgICAgICAgICAgICB1cExpbmVJbmRleEtleTogXCJ0b0luZGV4XCIsXG4gICAgICAgICAgICAgICAgICBkb3duTGluZUluZGV4S2V5OiBcImZyb21JbmRleFwiXG4gICAgICAgICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgICAgICAgIHVwTGluZUluZGV4S2V5OiBcImZyb21JbmRleFwiLFxuICAgICAgICAgICAgICAgICAgZG93bkxpbmVJbmRleEtleTogXCJ0b0luZGV4XCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB1cExpbmVJbmRleEtleSA9IF9yZWYzOC51cExpbmVJbmRleEtleSxcbiAgICAgICAgICAgICAgICAgICAgZG93bkxpbmVJbmRleEtleSA9IF9yZWYzOC5kb3duTGluZUluZGV4S2V5O1xuXG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9zdGFydCAhPT0gXCJ0b3BcIiA/IHRpbWVsaW5lW3RpbWVsaW5lLmxlbmd0aCAtIChyb3cgLSBncmlkLmZyb3plblJvd0NvdW50KSAtIDFdIDogdGltZWxpbmVbcm93IC0gZ3JpZC5mcm96ZW5Sb3dDb3VudF07XG4gICAgICAgICAgICAgICAgdmFyIGJyYW5jaENvbG9ycyA9IHN0eWxlLmJyYW5jaENvbG9ycyxcbiAgICAgICAgICAgICAgICAgICAgYnJhbmNoTGluZVdpZHRoID0gc3R5bGUuYnJhbmNoTGluZVdpZHRoLFxuICAgICAgICAgICAgICAgICAgICBjaXJjbGVTaXplID0gc3R5bGUuY2lyY2xlU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VTdHlsZSA9IHN0eWxlLm1lcmdlU3R5bGUsXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbiA9IHN0eWxlLm1hcmdpbixcbiAgICAgICAgICAgICAgICAgICAgYmdDb2xvciA9IHN0eWxlLmJnQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIHZpc2liaWxpdHkgPSBzdHlsZS52aXNpYmlsaXR5O1xuXG4gICAgICAgICAgICAgICAgaWYgKGJnQ29sb3IpIHtcbiAgICAgICAgICAgICAgICAgIGRyYXdDZWxsQmFzZSh7XG4gICAgICAgICAgICAgICAgICAgIGJnQ29sb3I6IGJnQ29sb3JcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh2aXNpYmlsaXR5ID09PSBcImhpZGRlblwiKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHJlY3QgPSBjb250ZXh0LmdldFJlY3QoKTtcbiAgICAgICAgICAgICAgICB2YXIgcmFkaXVzID0gY2lyY2xlU2l6ZSAvIDI7XG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gcmVjdC53aWR0aCAtIG1hcmdpbiAqIDI7XG4gICAgICAgICAgICAgICAgaGVscGVyLmRyYXdXaXRoQ2xpcChjb250ZXh0LCBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICAgICAgICBjdHgudGV4dEFsaWduID0gXCJsZWZ0XCI7XG4gICAgICAgICAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIjtcbiAgICAgICAgICAgICAgICAgIHZhciBicmFuY2hYUG9pbnRzID0gY2FsY0JyYW5jaFhQb2ludHMoY3R4LCByZWN0LmxlZnQgKyBtYXJnaW4sIHdpZHRoLCByYWRpdXMsIGJyYW5jaGVzLCB0aW1lbGluZSk7XG4gICAgICAgICAgICAgICAgICB2YXIgeSA9IHJlY3QudG9wICsgcmVjdC5oZWlnaHQgLyAyOyAvLyBkcmF3IGpvaW4gbGluZXNcblxuICAgICAgICAgICAgICAgICAgZGF0YS5tYXAoZnVuY3Rpb24gKHBvaW50LCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9pbnQgPyBwb2ludC5saW5lcy5tYXAoZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JJbmRleDogbGluZS5jb2xvckluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgdXBMaW5lSW5kZXg6IGxpbmVbdXBMaW5lSW5kZXhLZXldLFxuICAgICAgICAgICAgICAgICAgICAgICAgZG93bkxpbmVJbmRleDogbGluZVtkb3duTGluZUluZGV4S2V5XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50SW5kZXg6IGluZGV4XG4gICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSkgOiBbXTtcbiAgICAgICAgICAgICAgICAgIH0pLnJlZHVjZShmdW5jdGlvbiAocCwgYykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcC5jb25jYXQoYyk7XG4gICAgICAgICAgICAgICAgICB9LCBbXSkgLy8gZmxhdE1hcFxuICAgICAgICAgICAgICAgICAgLy8gb3JkZXIgb2Ygb3ZlcmxhcFxuICAgICAgICAgICAgICAgICAgLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGIuY29sb3JJbmRleCAtIGEuY29sb3JJbmRleDtcbiAgICAgICAgICAgICAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBicmFuY2hYUG9pbnRzW2xpbmUucG9pbnRJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlck1lcmdlKGdyaWQsIGN0eCwgeCwgeSwgbGluZS51cExpbmVJbmRleCwgbGluZS5kb3duTGluZUluZGV4LCBsaW5lLmNvbG9ySW5kZXgsIHtcbiAgICAgICAgICAgICAgICAgICAgICBtYXJnaW46IG1hcmdpbixcbiAgICAgICAgICAgICAgICAgICAgICBicmFuY2hYUG9pbnRzOiBicmFuY2hYUG9pbnRzLFxuICAgICAgICAgICAgICAgICAgICAgIGJyYW5jaExpbmVXaWR0aDogYnJhbmNoTGluZVdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgIGJyYW5jaENvbG9yczogYnJhbmNoQ29sb3JzLFxuICAgICAgICAgICAgICAgICAgICAgIG1lcmdlU3R5bGU6IG1lcmdlU3R5bGVcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICBjb2w6IGNvbCxcbiAgICAgICAgICAgICAgICAgICAgICByb3c6IHJvdyxcbiAgICAgICAgICAgICAgICAgICAgICBicmFuY2hlczogYnJhbmNoZXNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9KTsgLy8gZHJhdyBjb21taXQgcG9pbnRzXG5cbiAgICAgICAgICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbiAocCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHAgJiYgcC5jb21taXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IGJyYW5jaFhQb2ludHNbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAoMCwgdXRpbHNfMS5nZXRPckFwcGx5KShicmFuY2hDb2xvcnMsIGJyYW5jaGVzW2luZGV4XSwgaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICBjdHguYXJjKHgsIHksIHJhZGl1cywgMCwgTWF0aC5QSSAqIDIsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KTsgLy8gZHJhdyB0YWdzXG5cbiAgICAgICAgICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbiAocCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHAgJiYgcC50YWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gKDAsIHV0aWxzXzEuZ2V0T3JBcHBseSkoYnJhbmNoQ29sb3JzLCBicmFuY2hlc1tpbmRleF0sIGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQocC50YWcsIGJyYW5jaFhQb2ludHNbaW5kZXhdICsgcmFkaXVzICsgNCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBCcmFuY2hHcmFwaENvbHVtbjtcbiAgICAgICAgICB9KEJhc2VDb2x1bW5fMS5CYXNlQ29sdW1uKTtcblxuICAgICAgICAgIGV4cG9ydHMuQnJhbmNoR3JhcGhDb2x1bW4gPSBCcmFuY2hHcmFwaENvbHVtbjtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9jb2x1bW5zL3R5cGUvQnV0dG9uQ29sdW1uLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9jb2x1bW5zL3R5cGUvQnV0dG9uQ29sdW1uLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBjb2x1bW5zVHlwZUJ1dHRvbkNvbHVtbkpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgdmFyIF9fY3JlYXRlQmluZGluZyA9IHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcgfHwgKE9iamVjdC5jcmVhdGUgPyBmdW5jdGlvbiAobywgbSwgaywgazIpIHtcbiAgICAgICAgICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG5cbiAgICAgICAgICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICAgICAgICAgIGRlc2MgPSB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBtW2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbiAgICAgICAgICB9IDogZnVuY3Rpb24gKG8sIG0sIGssIGsyKSB7XG4gICAgICAgICAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgICAgICAgICAgb1trMl0gPSBtW2tdO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQgfHwgKE9iamVjdC5jcmVhdGUgPyBmdW5jdGlvbiAobywgdikge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7XG4gICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgIHZhbHVlOiB2XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IDogZnVuY3Rpb24gKG8sIHYpIHtcbiAgICAgICAgICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBfX2ltcG9ydFN0YXIgPSB0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgICAgICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgICAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSB7XG4gICAgICAgICAgICAgIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuQnV0dG9uQ29sdW1uID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIHV0aWxzID0gX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vY29sdW1uVXRpbHMgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy90eXBlL2NvbHVtblV0aWxzLmpzXCIpKTtcblxuICAgICAgICAgIHZhciBCdXR0b25TdHlsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vc3R5bGUvQnV0dG9uU3R5bGUgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9zdHlsZS9CdXR0b25TdHlsZS5qc1wiKTtcblxuICAgICAgICAgIHZhciBDb2x1bW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vQ29sdW1uICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvdHlwZS9Db2x1bW4uanNcIik7XG5cbiAgICAgICAgICB2YXIgdXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uL2ludGVybmFsL3V0aWxzICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL3V0aWxzLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIHN5bWJvbE1hbmFnZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uL2ludGVybmFsL3N5bWJvbE1hbmFnZXIgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvc3ltYm9sTWFuYWdlci5qc1wiKTtcblxuICAgICAgICAgIHZhciBCVVRUT05fQ09MVU1OX1NUQVRFX0lEID0gKDAsIHN5bWJvbE1hbmFnZXJfMS5nZXRCdXR0b25Db2x1bW5TdGF0ZUlkKSgpO1xuXG4gICAgICAgICAgdmFyIEJ1dHRvbkNvbHVtbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0NvbHVtbl8xJENvbHVtbikge1xuICAgICAgICAgICAgX2luaGVyaXRzKEJ1dHRvbkNvbHVtbiwgX0NvbHVtbl8xJENvbHVtbik7XG5cbiAgICAgICAgICAgIHZhciBfc3VwZXIzNSA9IF9jcmVhdGVTdXBlcihCdXR0b25Db2x1bW4pO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBCdXR0b25Db2x1bW4oKSB7XG4gICAgICAgICAgICAgIHZhciBfdGhpczU1O1xuXG4gICAgICAgICAgICAgIHZhciBvcHRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCdXR0b25Db2x1bW4pO1xuXG4gICAgICAgICAgICAgIF90aGlzNTUgPSBfc3VwZXIzNS5jYWxsKHRoaXMsIG9wdGlvbik7XG4gICAgICAgICAgICAgIF90aGlzNTUuX2NhcHRpb24gPSBvcHRpb24uY2FwdGlvbjtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzNTU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhCdXR0b25Db2x1bW4sIFt7XG4gICAgICAgICAgICAgIGtleTogXCJTdHlsZUNsYXNzXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBCdXR0b25TdHlsZV8xLkJ1dHRvblN0eWxlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjYXB0aW9uXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYXB0aW9uO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJ3aXRoQ2FwdGlvblwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gd2l0aENhcHRpb24oY2FwdGlvbikge1xuICAgICAgICAgICAgICAgIHZhciBjID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIGMuX2NhcHRpb24gPSBjYXB0aW9uO1xuICAgICAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjbG9uZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCdXR0b25Db2x1bW4odGhpcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNvbnZlcnRJbnRlcm5hbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY29udmVydEludGVybmFsKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhcHRpb24gfHwgX2dldChfZ2V0UHJvdG90eXBlT2YoQnV0dG9uQ29sdW1uLnByb3RvdHlwZSksIFwiY29udmVydEludGVybmFsXCIsIHRoaXMpLmNhbGwodGhpcywgdmFsdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJnZXRDb3B5Q2VsbFZhbHVlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb3B5Q2VsbFZhbHVlKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhcHRpb24gfHwgdmFsdWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImRyYXdJbnRlcm5hbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0ludGVybmFsKHZhbHVlLCBjb250ZXh0LCBzdHlsZSwgaGVscGVyLCBncmlkLCBfcmVmMzkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZHJhd0NlbGxCYXNlID0gX3JlZjM5LmRyYXdDZWxsQmFzZSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0SWNvbiA9IF9yZWYzOS5nZXRJY29uO1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0QWxpZ24gPSBzdHlsZS50ZXh0QWxpZ24sXG4gICAgICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZSA9IHN0eWxlLnRleHRCYXNlbGluZSxcbiAgICAgICAgICAgICAgICAgICAgYmdDb2xvciA9IHN0eWxlLmJnQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yID0gc3R5bGUuY29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbkJnQ29sb3IgPSBzdHlsZS5idXR0b25CZ0NvbG9yLFxuICAgICAgICAgICAgICAgICAgICBmb250ID0gc3R5bGUuZm9udCxcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZyA9IHN0eWxlLnBhZGRpbmcsXG4gICAgICAgICAgICAgICAgICAgIHRleHRPdmVyZmxvdyA9IHN0eWxlLnRleHRPdmVyZmxvdyxcbiAgICAgICAgICAgICAgICAgICAgdmlzaWJpbGl0eSA9IHN0eWxlLnZpc2liaWxpdHk7XG5cbiAgICAgICAgICAgICAgICBpZiAoYmdDb2xvcikge1xuICAgICAgICAgICAgICAgICAgZHJhd0NlbGxCYXNlKHtcbiAgICAgICAgICAgICAgICAgICAgYmdDb2xvcjogYmdDb2xvclxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHZpc2liaWxpdHkgPT09IFwiaGlkZGVuXCIpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgdGV4dFZhbHVlID0gdmFsdWUgIT0gbnVsbCA/IFN0cmluZyh2YWx1ZSkgOiBcIlwiO1xuICAgICAgICAgICAgICAgIGhlbHBlci50ZXN0Rm9udExvYWQoZm9udCwgdGV4dFZhbHVlLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICB2YXIgY29sID0gY29udGV4dC5jb2wsXG4gICAgICAgICAgICAgICAgICAgIHJvdyA9IGNvbnRleHQucm93O1xuICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IGdyaWQuZ2V0Q2VsbFJhbmdlKGNvbCwgcm93KTtcbiAgICAgICAgICAgICAgICB2YXIgYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXRlID0gZ3JpZFtCVVRUT05fQ09MVU1OX1NUQVRFX0lEXTtcblxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLm1vdXNlQWN0aXZlQ2VsbCAmJiAoMCwgdXRpbHNfMS5jZWxsSW5SYW5nZSkocmFuZ2UsIHN0YXRlLm1vdXNlQWN0aXZlQ2VsbC5jb2wsIHN0YXRlLm1vdXNlQWN0aXZlQ2VsbC5yb3cpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2NvbnRleHQkZ2V0U2VsZWN0aW9uNCA9IGNvbnRleHQuZ2V0U2VsZWN0aW9uKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3QgPSBfY29udGV4dCRnZXRTZWxlY3Rpb240LnNlbGVjdDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoKDAsIHV0aWxzXzEuY2VsbEluUmFuZ2UpKHJhbmdlLCBzZWxlY3QuY29sLCBzZWxlY3Qucm93KSkge1xuICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB1dGlscy5sb2FkSWNvbnMoZ2V0SWNvbigpLCBjb250ZXh0LCBoZWxwZXIsIGZ1bmN0aW9uIChpY29ucywgY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgaGVscGVyLmJ1dHRvbih0ZXh0VmFsdWUsIGNvbnRleHQsIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24sXG4gICAgICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZTogdGV4dEJhc2VsaW5lLFxuICAgICAgICAgICAgICAgICAgICBiZ0NvbG9yOiBidXR0b25CZ0NvbG9yLFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGZvbnQ6IGZvbnQsXG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IHBhZGRpbmcsXG4gICAgICAgICAgICAgICAgICAgIHNoYWRvdzogYWN0aXZlID8ge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBcInJnYmEoMCwgMCwgMCwgMC40OClcIixcbiAgICAgICAgICAgICAgICAgICAgICBibHVyOiA2LFxuICAgICAgICAgICAgICAgICAgICAgIG9mZnNldFk6IDNcbiAgICAgICAgICAgICAgICAgICAgfSA6IHt9LFxuICAgICAgICAgICAgICAgICAgICB0ZXh0T3ZlcmZsb3c6IHRleHRPdmVyZmxvdyxcbiAgICAgICAgICAgICAgICAgICAgaWNvbnM6IGljb25zXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gQnV0dG9uQ29sdW1uO1xuICAgICAgICAgIH0oQ29sdW1uXzEuQ29sdW1uKTtcblxuICAgICAgICAgIGV4cG9ydHMuQnV0dG9uQ29sdW1uID0gQnV0dG9uQ29sdW1uO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2NvbHVtbnMvdHlwZS9DaGVja0NvbHVtbi5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9jb2x1bW5zL3R5cGUvQ2hlY2tDb2x1bW4uanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gY29sdW1uc1R5cGVDaGVja0NvbHVtbkpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuQ2hlY2tDb2x1bW4gPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgQmFzZUNvbHVtbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9CYXNlQ29sdW1uICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvdHlwZS9CYXNlQ29sdW1uLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIENoZWNrU3R5bGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uL3N0eWxlL0NoZWNrU3R5bGUgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9zdHlsZS9DaGVja1N0eWxlLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIHN5bWJvbE1hbmFnZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uL2ludGVybmFsL3N5bWJvbE1hbmFnZXIgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvc3ltYm9sTWFuYWdlci5qc1wiKTtcblxuICAgICAgICAgIHZhciB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vdXRpbHMgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy91dGlscy9pbmRleC5qc1wiKTtcblxuICAgICAgICAgIHZhciBDSEVDS19DT0xVTU5fU1RBVEVfSUQgPSAoMCwgc3ltYm9sTWFuYWdlcl8xLmdldENoZWNrQ29sdW1uU3RhdGVJZCkoKTtcblxuICAgICAgICAgIHZhciBDaGVja0NvbHVtbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Jhc2VDb2x1bW5fMSRCYXNlQ29sMikge1xuICAgICAgICAgICAgX2luaGVyaXRzKENoZWNrQ29sdW1uLCBfQmFzZUNvbHVtbl8xJEJhc2VDb2wyKTtcblxuICAgICAgICAgICAgdmFyIF9zdXBlcjM2ID0gX2NyZWF0ZVN1cGVyKENoZWNrQ29sdW1uKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gQ2hlY2tDb2x1bW4oKSB7XG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDaGVja0NvbHVtbik7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlcjM2LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhDaGVja0NvbHVtbiwgW3tcbiAgICAgICAgICAgICAga2V5OiBcIlN0eWxlQ2xhc3NcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIENoZWNrU3R5bGVfMS5DaGVja1N0eWxlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjbG9uZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGVja0NvbHVtbih0aGlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY29udmVydEludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb252ZXJ0SW50ZXJuYWwodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEudG9Cb29sZWFuKSh2YWx1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImRyYXdJbnRlcm5hbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0ludGVybmFsKHZhbHVlLCBjb250ZXh0LCBzdHlsZSwgaGVscGVyLCBncmlkLCBfcmVmNDApIHtcbiAgICAgICAgICAgICAgICB2YXIgZHJhd0NlbGxCYXNlID0gX3JlZjQwLmRyYXdDZWxsQmFzZTtcblxuICAgICAgICAgICAgICAgIHZhciBfYTtcblxuICAgICAgICAgICAgICAgIHZhciB0ZXh0QWxpZ24gPSBzdHlsZS50ZXh0QWxpZ24sXG4gICAgICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZSA9IHN0eWxlLnRleHRCYXNlbGluZSxcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZyA9IHN0eWxlLnBhZGRpbmcsXG4gICAgICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yID0gc3R5bGUuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrQmdDb2xvciA9IHN0eWxlLmNoZWNrQmdDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgdW5jaGVja0JnQ29sb3IgPSBzdHlsZS51bmNoZWNrQmdDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgYmdDb2xvciA9IHN0eWxlLmJnQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIHZpc2liaWxpdHkgPSBzdHlsZS52aXNpYmlsaXR5O1xuXG4gICAgICAgICAgICAgICAgaWYgKGJnQ29sb3IpIHtcbiAgICAgICAgICAgICAgICAgIGRyYXdDZWxsQmFzZSh7XG4gICAgICAgICAgICAgICAgICAgIGJnQ29sb3I6IGJnQ29sb3JcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh2aXNpYmlsaXR5ID09PSBcImhpZGRlblwiKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGNvbCA9IGNvbnRleHQuY29sLFxuICAgICAgICAgICAgICAgICAgICByb3cgPSBjb250ZXh0LnJvdztcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBncmlkLmdldENlbGxSYW5nZShjb2wsIHJvdyk7XG4gICAgICAgICAgICAgICAgdmFyIGNlbGxLZXkgPSBcIlwiLmNvbmNhdChyYW5nZS5zdGFydC5jb2wsIFwiOlwiKS5jb25jYXQocmFuZ2Uuc3RhcnQucm93KTtcbiAgICAgICAgICAgICAgICB2YXIgZWxhcHNlZCA9IChfYSA9IGdyaWRbQ0hFQ0tfQ09MVU1OX1NUQVRFX0lEXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVsYXBzZWRbY2VsbEtleV07XG4gICAgICAgICAgICAgICAgdmFyIG9wdCA9IHtcbiAgICAgICAgICAgICAgICAgIHRleHRBbGlnbjogdGV4dEFsaWduLFxuICAgICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lOiB0ZXh0QmFzZWxpbmUsXG4gICAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICAgICAgICBjaGVja0JnQ29sb3I6IGNoZWNrQmdDb2xvcixcbiAgICAgICAgICAgICAgICAgIHVuY2hlY2tCZ0NvbG9yOiB1bmNoZWNrQmdDb2xvcixcbiAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IHBhZGRpbmdcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgaWYgKGVsYXBzZWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgb3B0LmFuaW1FbGFwc2VkVGltZSA9IGVsYXBzZWQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaGVscGVyLmNoZWNrYm94KHZhbHVlLCBjb250ZXh0LCBvcHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBDaGVja0NvbHVtbjtcbiAgICAgICAgICB9KEJhc2VDb2x1bW5fMS5CYXNlQ29sdW1uKTtcblxuICAgICAgICAgIGV4cG9ydHMuQ2hlY2tDb2x1bW4gPSBDaGVja0NvbHVtbjtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9jb2x1bW5zL3R5cGUvQ29sdW1uLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9jb2x1bW5zL3R5cGUvQ29sdW1uLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBjb2x1bW5zVHlwZUNvbHVtbkpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgdmFyIF9fY3JlYXRlQmluZGluZyA9IHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcgfHwgKE9iamVjdC5jcmVhdGUgPyBmdW5jdGlvbiAobywgbSwgaywgazIpIHtcbiAgICAgICAgICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG5cbiAgICAgICAgICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICAgICAgICAgIGRlc2MgPSB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBtW2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbiAgICAgICAgICB9IDogZnVuY3Rpb24gKG8sIG0sIGssIGsyKSB7XG4gICAgICAgICAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgICAgICAgICAgb1trMl0gPSBtW2tdO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQgfHwgKE9iamVjdC5jcmVhdGUgPyBmdW5jdGlvbiAobywgdikge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7XG4gICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgIHZhbHVlOiB2XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IDogZnVuY3Rpb24gKG8sIHYpIHtcbiAgICAgICAgICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBfX2ltcG9ydFN0YXIgPSB0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgICAgICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgICAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSB7XG4gICAgICAgICAgICAgIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuQ29sdW1uID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIHV0aWxzID0gX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vY29sdW1uVXRpbHMgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy90eXBlL2NvbHVtblV0aWxzLmpzXCIpKTtcblxuICAgICAgICAgIHZhciBCYXNlQ29sdW1uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL0Jhc2VDb2x1bW4gKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy90eXBlL0Jhc2VDb2x1bW4uanNcIik7XG5cbiAgICAgICAgICB2YXIgU3R5bGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uL3N0eWxlL1N0eWxlICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvc3R5bGUvU3R5bGUuanNcIik7XG5cbiAgICAgICAgICB2YXIgQ29sdW1uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZUNvbHVtbl8xJEJhc2VDb2wzKSB7XG4gICAgICAgICAgICBfaW5oZXJpdHMoQ29sdW1uLCBfQmFzZUNvbHVtbl8xJEJhc2VDb2wzKTtcblxuICAgICAgICAgICAgdmFyIF9zdXBlcjM3ID0gX2NyZWF0ZVN1cGVyKENvbHVtbik7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIENvbHVtbigpIHtcbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbHVtbik7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlcjM3LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhDb2x1bW4sIFt7XG4gICAgICAgICAgICAgIGtleTogXCJTdHlsZUNsYXNzXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBTdHlsZV8xLlN0eWxlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjbG9uZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2x1bW4odGhpcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImRyYXdJbnRlcm5hbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0ludGVybmFsKHZhbHVlLCBjb250ZXh0LCBzdHlsZSwgaGVscGVyLCBfZ3JpZCwgX3JlZjQxKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRyYXdDZWxsQmFzZSA9IF9yZWY0MS5kcmF3Q2VsbEJhc2UsXG4gICAgICAgICAgICAgICAgICAgIGdldEljb24gPSBfcmVmNDEuZ2V0SWNvbjtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dEFsaWduID0gc3R5bGUudGV4dEFsaWduLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmUgPSBzdHlsZS50ZXh0QmFzZWxpbmUsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yID0gc3R5bGUuY29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGZvbnQgPSBzdHlsZS5mb250LFxuICAgICAgICAgICAgICAgICAgICBiZ0NvbG9yID0gc3R5bGUuYmdDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZyA9IHN0eWxlLnBhZGRpbmcsXG4gICAgICAgICAgICAgICAgICAgIHRleHRPdmVyZmxvdyA9IHN0eWxlLnRleHRPdmVyZmxvdyxcbiAgICAgICAgICAgICAgICAgICAgdmlzaWJpbGl0eSA9IHN0eWxlLnZpc2liaWxpdHk7XG5cbiAgICAgICAgICAgICAgICBpZiAoYmdDb2xvcikge1xuICAgICAgICAgICAgICAgICAgZHJhd0NlbGxCYXNlKHtcbiAgICAgICAgICAgICAgICAgICAgYmdDb2xvcjogYmdDb2xvclxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHZpc2liaWxpdHkgPT09IFwiaGlkZGVuXCIpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgdGV4dFZhbHVlID0gdmFsdWUgIT0gbnVsbCA/IFN0cmluZyh2YWx1ZSkgOiBcIlwiO1xuICAgICAgICAgICAgICAgIGhlbHBlci50ZXN0Rm9udExvYWQoZm9udCwgdGV4dFZhbHVlLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICB1dGlscy5sb2FkSWNvbnMoZ2V0SWNvbigpLCBjb250ZXh0LCBoZWxwZXIsIGZ1bmN0aW9uIChpY29ucywgY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgaGVscGVyLnRleHQodGV4dFZhbHVlLCBjb250ZXh0LCB7XG4gICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbjogdGV4dEFsaWduLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmU6IHRleHRCYXNlbGluZSxcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgICAgICAgICBmb250OiBmb250LFxuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiBwYWRkaW5nLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0T3ZlcmZsb3c6IHRleHRPdmVyZmxvdyxcbiAgICAgICAgICAgICAgICAgICAgaWNvbnM6IGljb25zXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gQ29sdW1uO1xuICAgICAgICAgIH0oQmFzZUNvbHVtbl8xLkJhc2VDb2x1bW4pO1xuXG4gICAgICAgICAgZXhwb3J0cy5Db2x1bW4gPSBDb2x1bW47XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vY29sdW1ucy90eXBlL0ljb25Db2x1bW4uanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9jb2x1bW5zL3R5cGUvSWNvbkNvbHVtbi5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGNvbHVtbnNUeXBlSWNvbkNvbHVtbkpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgdmFyIF9fY3JlYXRlQmluZGluZyA9IHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcgfHwgKE9iamVjdC5jcmVhdGUgPyBmdW5jdGlvbiAobywgbSwgaywgazIpIHtcbiAgICAgICAgICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG5cbiAgICAgICAgICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICAgICAgICAgIGRlc2MgPSB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBtW2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbiAgICAgICAgICB9IDogZnVuY3Rpb24gKG8sIG0sIGssIGsyKSB7XG4gICAgICAgICAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgICAgICAgICAgb1trMl0gPSBtW2tdO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQgfHwgKE9iamVjdC5jcmVhdGUgPyBmdW5jdGlvbiAobywgdikge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7XG4gICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgIHZhbHVlOiB2XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IDogZnVuY3Rpb24gKG8sIHYpIHtcbiAgICAgICAgICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBfX2ltcG9ydFN0YXIgPSB0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgICAgICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgICAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSB7XG4gICAgICAgICAgICAgIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuSWNvbkNvbHVtbiA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBpY29ucyA9IF9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi9pbnRlcm5hbC9pY29ucyAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC9pY29ucy5qc1wiKSk7XG5cbiAgICAgICAgICB2YXIgQ29sdW1uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL0NvbHVtbiAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3R5cGUvQ29sdW1uLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIEljb25TdHlsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vc3R5bGUvSWNvblN0eWxlICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvc3R5bGUvSWNvblN0eWxlLmpzXCIpO1xuXG4gICAgICAgICAgZnVuY3Rpb24gcmVwZWF0QXJyYXkodmFsLCBjb3VudCkge1xuICAgICAgICAgICAgaWYgKGNvdW50ID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgICBjb3VudCA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBhID0gW107XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgICBhLnB1c2godmFsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIEljb25Db2x1bW4gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Db2x1bW5fMSRDb2x1bW4yKSB7XG4gICAgICAgICAgICBfaW5oZXJpdHMoSWNvbkNvbHVtbiwgX0NvbHVtbl8xJENvbHVtbjIpO1xuXG4gICAgICAgICAgICB2YXIgX3N1cGVyMzggPSBfY3JlYXRlU3VwZXIoSWNvbkNvbHVtbik7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIEljb25Db2x1bW4oKSB7XG4gICAgICAgICAgICAgIHZhciBfdGhpczU2O1xuXG4gICAgICAgICAgICAgIHZhciBvcHRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJY29uQ29sdW1uKTtcblxuICAgICAgICAgICAgICBfdGhpczU2ID0gX3N1cGVyMzguY2FsbCh0aGlzLCBvcHRpb24pO1xuICAgICAgICAgICAgICBfdGhpczU2Ll90YWdOYW1lID0gb3B0aW9uLnRhZ05hbWUgfHwgXCJpXCI7XG4gICAgICAgICAgICAgIF90aGlzNTYuX2NsYXNzTmFtZSA9IG9wdGlvbi5jbGFzc05hbWU7XG4gICAgICAgICAgICAgIF90aGlzNTYuX2NvbnRlbnQgPSBvcHRpb24uY29udGVudDtcbiAgICAgICAgICAgICAgX3RoaXM1Ni5fbmFtZSA9IG9wdGlvbi5uYW1lO1xuICAgICAgICAgICAgICBfdGhpczU2Ll9pY29uV2lkdGggPSBvcHRpb24uaWNvbldpZHRoO1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXM1NjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKEljb25Db2x1bW4sIFt7XG4gICAgICAgICAgICAgIGtleTogXCJTdHlsZUNsYXNzXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBJY29uU3R5bGVfMS5JY29uU3R5bGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNsb25lXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEljb25Db2x1bW4odGhpcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInRhZ05hbWVcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RhZ05hbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNsYXNzTmFtZVwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2xhc3NOYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjb250ZW50XCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250ZW50O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJuYW1lXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJpY29uV2lkdGhcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ljb25XaWR0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZHJhd0ludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3SW50ZXJuYWwodmFsdWUsIGNvbnRleHQsIHN0eWxlLCBoZWxwZXIsIGdyaWQsIGluZm8pIHtcbiAgICAgICAgICAgICAgICB2YXIgbnVtID0gTnVtYmVyKHZhbHVlKTtcblxuICAgICAgICAgICAgICAgIGlmICghaXNOYU4obnVtKSkge1xuICAgICAgICAgICAgICAgICAgdmFyIGljb24gPSB7fTtcbiAgICAgICAgICAgICAgICAgIGljb25zLmljb25Qcm9wS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgIGljb25ba10gPSBzdHlsZVtrXTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgaWNvbi5jbGFzc05hbWUgPSB0aGlzLl9jbGFzc05hbWU7XG4gICAgICAgICAgICAgICAgICBpY29uLnRhZ05hbWUgPSB0aGlzLl90YWdOYW1lO1xuXG4gICAgICAgICAgICAgICAgICBpZiAodGhpcy5fY29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICBpY29uLmNvbnRlbnQgPSB0aGlzLl9jb250ZW50O1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBpY29uLm5hbWUgPSB0aGlzLl9uYW1lO1xuXG4gICAgICAgICAgICAgICAgICBpZiAodGhpcy5faWNvbldpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGljb24ud2lkdGggPSB0aGlzLl9pY29uV2lkdGg7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGluZm8uZ2V0SWNvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcGVhdEFycmF5KGljb24sIG51bSk7XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpbmZvLmdldEljb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihJY29uQ29sdW1uLnByb3RvdHlwZSksIFwiZHJhd0ludGVybmFsXCIsIHRoaXMpLmNhbGwodGhpcywgXCJcIiwgY29udGV4dCwgc3R5bGUsIGhlbHBlciwgZ3JpZCwgaW5mbyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIEljb25Db2x1bW47XG4gICAgICAgICAgfShDb2x1bW5fMS5Db2x1bW4pO1xuXG4gICAgICAgICAgZXhwb3J0cy5JY29uQ29sdW1uID0gSWNvbkNvbHVtbjtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9jb2x1bW5zL3R5cGUvSW1hZ2VDb2x1bW4uanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vY29sdW1ucy90eXBlL0ltYWdlQ29sdW1uLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGNvbHVtbnNUeXBlSW1hZ2VDb2x1bW5Kcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLkltYWdlQ29sdW1uID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIEJhc2VDb2x1bW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vQmFzZUNvbHVtbiAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3R5cGUvQmFzZUNvbHVtbi5qc1wiKTtcblxuICAgICAgICAgIHZhciBJbWFnZVN0eWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi9zdHlsZS9JbWFnZVN0eWxlICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvc3R5bGUvSW1hZ2VTdHlsZS5qc1wiKTtcblxuICAgICAgICAgIHZhciBSZWN0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi9pbnRlcm5hbC9SZWN0ICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL1JlY3QuanNcIik7XG5cbiAgICAgICAgICB2YXIgY2FudmFzZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uL2ludGVybmFsL2NhbnZhc2VzICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL2NhbnZhc2VzLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIGltZ3NfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uL2ludGVybmFsL2ltZ3MgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvaW1ncy5qc1wiKTtcblxuICAgICAgICAgIHZhciBNQVhfTFJVX0NBQ0hFX1NJWkUgPSA1MDtcblxuICAgICAgICAgIGZ1bmN0aW9uIGdldEltYWdlKHVybCkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBpbWdzXzEuZ2V0Q2FjaGVPckxvYWQpKFwiSW1hZ2VDb2x1bW5cIiwgTUFYX0xSVV9DQUNIRV9TSVpFLCB1cmwpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGNhbGNLZWVwQXNwZWN0UmF0aW9TaXplKHdpZHRoLCBoZWlnaHQsIG1heFdpZHRoLCBtYXhIZWlnaHQpIHtcbiAgICAgICAgICAgIHZhciBuZXdXaWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgdmFyIG5ld0hlaWdodCA9IGhlaWdodDtcblxuICAgICAgICAgICAgaWYgKG5ld1dpZHRoID4gbWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgbmV3V2lkdGggPSBtYXhXaWR0aDtcbiAgICAgICAgICAgICAgbmV3SGVpZ2h0ID0gbmV3V2lkdGggKiBoZWlnaHQgLyB3aWR0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5ld0hlaWdodCA+IG1heEhlaWdodCkge1xuICAgICAgICAgICAgICBuZXdIZWlnaHQgPSBtYXhIZWlnaHQ7XG4gICAgICAgICAgICAgIG5ld1dpZHRoID0gbmV3SGVpZ2h0ICogd2lkdGggLyBoZWlnaHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHdpZHRoOiBuZXdXaWR0aCxcbiAgICAgICAgICAgICAgaGVpZ2h0OiBuZXdIZWlnaHRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIEltYWdlQ29sdW1uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZUNvbHVtbl8xJEJhc2VDb2w0KSB7XG4gICAgICAgICAgICBfaW5oZXJpdHMoSW1hZ2VDb2x1bW4sIF9CYXNlQ29sdW1uXzEkQmFzZUNvbDQpO1xuXG4gICAgICAgICAgICB2YXIgX3N1cGVyMzkgPSBfY3JlYXRlU3VwZXIoSW1hZ2VDb2x1bW4pO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBJbWFnZUNvbHVtbigpIHtcbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEltYWdlQ29sdW1uKTtcblxuICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyMzkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKEltYWdlQ29sdW1uLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiU3R5bGVDbGFzc1wiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gSW1hZ2VTdHlsZV8xLkltYWdlU3R5bGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIm9uRHJhd0NlbGxcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uRHJhd0NlbGwoY2VsbFZhbHVlLCBpbmZvLCBjb250ZXh0LCBncmlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9nZXQoX2dldFByb3RvdHlwZU9mKEltYWdlQ29sdW1uLnByb3RvdHlwZSksIFwib25EcmF3Q2VsbFwiLCB0aGlzKS5jYWxsKHRoaXMsIGdldEltYWdlKGNlbGxWYWx1ZSksIGluZm8sIGNvbnRleHQsIGdyaWQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjbG9uZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbWFnZUNvbHVtbih0aGlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZHJhd0ludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3SW50ZXJuYWwodmFsdWUsIGNvbnRleHQsIHN0eWxlLCBoZWxwZXIsIF9ncmlkLCBfcmVmNDIpIHtcbiAgICAgICAgICAgICAgICB2YXIgZHJhd0NlbGxCYXNlID0gX3JlZjQyLmRyYXdDZWxsQmFzZTtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dEFsaWduID0gc3R5bGUudGV4dEFsaWduLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmUgPSBzdHlsZS50ZXh0QmFzZWxpbmUsXG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmcgPSBzdHlsZS5wYWRkaW5nLFxuICAgICAgICAgICAgICAgICAgICBtYXJnaW4gPSBzdHlsZS5tYXJnaW4sXG4gICAgICAgICAgICAgICAgICAgIGJnQ29sb3IgPSBzdHlsZS5iZ0NvbG9yLFxuICAgICAgICAgICAgICAgICAgICB2aXNpYmlsaXR5ID0gc3R5bGUudmlzaWJpbGl0eTtcblxuICAgICAgICAgICAgICAgIGlmIChiZ0NvbG9yKSB7XG4gICAgICAgICAgICAgICAgICBkcmF3Q2VsbEJhc2Uoe1xuICAgICAgICAgICAgICAgICAgICBiZ0NvbG9yOiBiZ0NvbG9yXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodmlzaWJpbGl0eSA9PT0gXCJoaWRkZW5cIikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgaGVscGVyLmRyYXdXaXRoQ2xpcChjb250ZXh0LCBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSB0ZXh0QWxpZ247XG4gICAgICAgICAgICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSB0ZXh0QmFzZWxpbmU7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWN0ID0gY29udGV4dC5nZXRSZWN0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhZGRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFkZGluZ051bXMgPSBoZWxwZXIudG9Cb3hQaXhlbEFycmF5KHBhZGRpbmcsIGNvbnRleHQsIHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgIC8qIGZvbnQgKi9cbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBsZWZ0ID0gcmVjdC5sZWZ0ICsgcGFkZGluZ051bXNbM107XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHRvcCA9IHJlY3QudG9wICsgcGFkZGluZ051bXNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gcmVjdC53aWR0aCAtIHBhZGRpbmdOdW1zWzFdIC0gcGFkZGluZ051bXNbM107XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IHJlY3QuaGVpZ2h0IC0gcGFkZGluZ051bXNbMF0gLSBwYWRkaW5nTnVtc1syXTtcbiAgICAgICAgICAgICAgICAgICAgICByZWN0ID0gbmV3IFJlY3RfMS5SZWN0KGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoc3R5bGUuaW1hZ2VTaXppbmcgPT09IFwia2VlcC1hc3BlY3QtcmF0aW9cIikge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBfY2FsY0tlZXBBc3BlY3RSYXRpb1MgPSBjYWxjS2VlcEFzcGVjdFJhdGlvU2l6ZSh2YWx1ZS53aWR0aCwgdmFsdWUuaGVpZ2h0LCByZWN0LndpZHRoIC0gbWFyZ2luICogMiwgcmVjdC5oZWlnaHQgLSBtYXJnaW4gKiAyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX3dpZHRoID0gX2NhbGNLZWVwQXNwZWN0UmF0aW9TLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBfaGVpZ2h0ID0gX2NhbGNLZWVwQXNwZWN0UmF0aW9TLmhlaWdodDtcblxuICAgICAgICAgICAgICAgICAgICAgIHZhciBwb3MgPSAoMCwgY2FudmFzZXNfMS5jYWxjU3RhcnRQb3NpdGlvbikoY3R4LCByZWN0LCBfd2lkdGgsIF9oZWlnaHQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogbWFyZ2luXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZSh2YWx1ZSwgMCwgMCwgdmFsdWUud2lkdGgsIHZhbHVlLmhlaWdodCwgcG9zLngsIHBvcy55LCBfd2lkdGgsIF9oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UodmFsdWUsIDAsIDAsIHZhbHVlLndpZHRoLCB2YWx1ZS5oZWlnaHQsIHJlY3QubGVmdCArIG1hcmdpbiwgcmVjdC50b3AgKyBtYXJnaW4sIHJlY3Qud2lkdGggLSBtYXJnaW4gKiAyLCByZWN0LmhlaWdodCAtIG1hcmdpbiAqIDIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIEltYWdlQ29sdW1uO1xuICAgICAgICAgIH0oQmFzZUNvbHVtbl8xLkJhc2VDb2x1bW4pO1xuXG4gICAgICAgICAgZXhwb3J0cy5JbWFnZUNvbHVtbiA9IEltYWdlQ29sdW1uO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2NvbHVtbnMvdHlwZS9NZW51Q29sdW1uLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vY29sdW1ucy90eXBlL01lbnVDb2x1bW4uanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBjb2x1bW5zVHlwZU1lbnVDb2x1bW5Kcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIHZhciBfX2NyZWF0ZUJpbmRpbmcgPSB0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nIHx8IChPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24gKG8sIG0sIGssIGsyKSB7XG4gICAgICAgICAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgICAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuXG4gICAgICAgICAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgICAgICAgICBkZXNjID0ge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbVtrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG4gICAgICAgICAgfSA6IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICAgICAgICAgICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICAgICAgICAgIG9bazJdID0gbVtrXTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBfX3NldE1vZHVsZURlZmF1bHQgPSB0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0IHx8IChPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24gKG8sIHYpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwge1xuICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICB2YWx1ZTogdlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSA6IGZ1bmN0aW9uIChvLCB2KSB7XG4gICAgICAgICAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgX19pbXBvcnRTdGFyID0gdGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhciB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgICAgICAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICAgICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkge1xuICAgICAgICAgICAgICBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLk1lbnVDb2x1bW4gPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgdXRpbHMgPSBfX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9jb2x1bW5VdGlscyAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3R5cGUvY29sdW1uVXRpbHMuanNcIikpO1xuXG4gICAgICAgICAgdmFyIEJhc2VDb2x1bW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vQmFzZUNvbHVtbiAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3R5cGUvQmFzZUNvbHVtbi5qc1wiKTtcblxuICAgICAgICAgIHZhciBNZW51U3R5bGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uL3N0eWxlL01lbnVTdHlsZSAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3N0eWxlL01lbnVTdHlsZS5qc1wiKTtcblxuICAgICAgICAgIHZhciBtZW51X2l0ZW1zXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi9pbnRlcm5hbC9tZW51LWl0ZW1zICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL21lbnUtaXRlbXMuanNcIik7XG5cbiAgICAgICAgICB2YXIgTWVudUNvbHVtbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Jhc2VDb2x1bW5fMSRCYXNlQ29sNSkge1xuICAgICAgICAgICAgX2luaGVyaXRzKE1lbnVDb2x1bW4sIF9CYXNlQ29sdW1uXzEkQmFzZUNvbDUpO1xuXG4gICAgICAgICAgICB2YXIgX3N1cGVyNDAgPSBfY3JlYXRlU3VwZXIoTWVudUNvbHVtbik7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIE1lbnVDb2x1bW4oKSB7XG4gICAgICAgICAgICAgIHZhciBfdGhpczU3O1xuXG4gICAgICAgICAgICAgIHZhciBvcHRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNZW51Q29sdW1uKTtcblxuICAgICAgICAgICAgICBfdGhpczU3ID0gX3N1cGVyNDAuY2FsbCh0aGlzLCBvcHRpb24pO1xuICAgICAgICAgICAgICBfdGhpczU3Ll9vcHRpb25zID0gKDAsIG1lbnVfaXRlbXNfMS5ub3JtYWxpemUpKG9wdGlvbi5vcHRpb25zKTtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzNTc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhNZW51Q29sdW1uLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiU3R5bGVDbGFzc1wiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWVudVN0eWxlXzEuTWVudVN0eWxlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjbG9uZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNZW51Q29sdW1uKHRoaXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJvcHRpb25zXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcHRpb25zO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJ3aXRoT3B0aW9uc1wiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gd2l0aE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHZhciBjID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIGMuX29wdGlvbnMgPSAoMCwgbWVudV9pdGVtc18xLm5vcm1hbGl6ZSkob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImRyYXdJbnRlcm5hbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0ludGVybmFsKHZhbHVlLCBjb250ZXh0LCBzdHlsZSwgaGVscGVyLCBfZ3JpZCwgX3JlZjQzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRyYXdDZWxsQmFzZSA9IF9yZWY0My5kcmF3Q2VsbEJhc2UsXG4gICAgICAgICAgICAgICAgICAgIGdldEljb24gPSBfcmVmNDMuZ2V0SWNvbjtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dEFsaWduID0gc3R5bGUudGV4dEFsaWduLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmUgPSBzdHlsZS50ZXh0QmFzZWxpbmUsXG4gICAgICAgICAgICAgICAgICAgIGZvbnQgPSBzdHlsZS5mb250LFxuICAgICAgICAgICAgICAgICAgICBiZ0NvbG9yID0gc3R5bGUuYmdDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZyA9IHN0eWxlLnBhZGRpbmcsXG4gICAgICAgICAgICAgICAgICAgIHRleHRPdmVyZmxvdyA9IHN0eWxlLnRleHRPdmVyZmxvdyxcbiAgICAgICAgICAgICAgICAgICAgYXBwZWFyYW5jZSA9IHN0eWxlLmFwcGVhcmFuY2UsXG4gICAgICAgICAgICAgICAgICAgIHZpc2liaWxpdHkgPSBzdHlsZS52aXNpYmlsaXR5O1xuICAgICAgICAgICAgICAgIHZhciBjb2xvciA9IHN0eWxlLmNvbG9yO1xuXG4gICAgICAgICAgICAgICAgaWYgKGJnQ29sb3IpIHtcbiAgICAgICAgICAgICAgICAgIGRyYXdDZWxsQmFzZSh7XG4gICAgICAgICAgICAgICAgICAgIGJnQ29sb3I6IGJnQ29sb3JcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh2aXNpYmlsaXR5ID09PSBcImhpZGRlblwiKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGNvbnZlcnRlZFZhbHVlID0gdGhpcy5fY29udmVydEludGVybmFsKHZhbHVlKTtcblxuICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gY29udmVydGVkVmFsdWUgIT0gbnVsbCA/IFN0cmluZyhjb252ZXJ0ZWRWYWx1ZSkgOiBcIlwiO1xuICAgICAgICAgICAgICAgIGhlbHBlci50ZXN0Rm9udExvYWQoZm9udCwgdGV4dCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgdXRpbHMubG9hZEljb25zKGdldEljb24oKSwgY29udGV4dCwgaGVscGVyLCBmdW5jdGlvbiAoaWNvbnMsIGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBiYXNlUGFkZGluZyA9IGhlbHBlci50b0JveFBpeGVsQXJyYXkocGFkZGluZyB8fCAwLCBjb250ZXh0LCBmb250KTtcbiAgICAgICAgICAgICAgICAgIHZhciB0ZXh0UGFkZGluZyA9IGJhc2VQYWRkaW5nLnNsaWNlKDApO1xuICAgICAgICAgICAgICAgICAgdGV4dFBhZGRpbmdbMV0gKz0gMjY7IC8vIGljb24gcGFkZGluZ1xuXG4gICAgICAgICAgICAgICAgICB2YXIgaWNvblBhZGRpbmcgPSBiYXNlUGFkZGluZy5zbGljZSgwKTtcbiAgICAgICAgICAgICAgICAgIGljb25QYWRkaW5nWzFdICs9IDg7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChjb2xvciA9PSBudWxsICYmICh2YWx1ZSA9PSBudWxsIHx8IHZhbHVlID09PSBcIlwiKSkge1xuICAgICAgICAgICAgICAgICAgICBjb2xvciA9IFwicmdiYSgwLCAwLCAwLCAuMzgpXCI7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGhlbHBlci50ZXh0KHRleHQsIGNvbnRleHQsIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24sXG4gICAgICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZTogdGV4dEJhc2VsaW5lLFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGZvbnQ6IGZvbnQsXG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IHRleHRQYWRkaW5nLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0T3ZlcmZsb3c6IHRleHRPdmVyZmxvdyxcbiAgICAgICAgICAgICAgICAgICAgaWNvbnM6IGljb25zXG4gICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgaWYgKGFwcGVhcmFuY2UgPT09IFwibWVudWxpc3QtYnV0dG9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZHJhdyBkcm9wZG93biBhcnJvdyBpY29uXG4gICAgICAgICAgICAgICAgICAgIGhlbHBlci50ZXh0KFwiXCIsIGNvbnRleHQsIHtcbiAgICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ246IFwicmlnaHRcIixcbiAgICAgICAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmU6IHRleHRCYXNlbGluZSxcbiAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgZm9udDogZm9udCxcbiAgICAgICAgICAgICAgICAgICAgICBpY29uczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IFwiTTAgMiA1IDcgMTAgMnpcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBcInJnYmEoMCwgMCwgMCwgLjU0KVwiXG4gICAgICAgICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogaWNvblBhZGRpbmdcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFwcGVhcmFuY2UgIT09IFwibm9uZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtdGVtcGxhdGUtZXhwcmVzc2lvbnNcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwidW5zdXBwb3J0ZWQgYXBwZWFyYW5jZTpcIi5jb25jYXQoYXBwZWFyYW5jZSkpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjb252ZXJ0SW50ZXJuYWxcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnZlcnRJbnRlcm5hbCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiX2NvbnZlcnRJbnRlcm5hbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2NvbnZlcnRJbnRlcm5hbCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5fb3B0aW9ucztcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgdmFyIG9wdGlvbiA9IG9wdGlvbnNbaV07XG5cbiAgICAgICAgICAgICAgICAgIGlmIChvcHRpb24udmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gb3B0aW9uLmxhYmVsO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2dldChfZ2V0UHJvdG90eXBlT2YoTWVudUNvbHVtbi5wcm90b3R5cGUpLCBcImNvbnZlcnRJbnRlcm5hbFwiLCB0aGlzKS5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0Q29weUNlbGxWYWx1ZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29weUNlbGxWYWx1ZSh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb252ZXJ0SW50ZXJuYWwodmFsdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBNZW51Q29sdW1uO1xuICAgICAgICAgIH0oQmFzZUNvbHVtbl8xLkJhc2VDb2x1bW4pO1xuXG4gICAgICAgICAgZXhwb3J0cy5NZW51Q29sdW1uID0gTWVudUNvbHVtbjtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9jb2x1bW5zL3R5cGUvTXVsdGlsaW5lVGV4dENvbHVtbi5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2NvbHVtbnMvdHlwZS9NdWx0aWxpbmVUZXh0Q29sdW1uLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gY29sdW1uc1R5cGVNdWx0aWxpbmVUZXh0Q29sdW1uSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICB2YXIgX19jcmVhdGVCaW5kaW5nID0gdGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZyB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICAgICAgICAgICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcblxuICAgICAgICAgICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgICAgICAgICAgZGVzYyA9IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ba107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xuICAgICAgICAgIH0gOiBmdW5jdGlvbiAobywgbSwgaywgazIpIHtcbiAgICAgICAgICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgICAgICAgICBvW2syXSA9IG1ba107XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gdGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCB2KSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHtcbiAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gOiBmdW5jdGlvbiAobywgdikge1xuICAgICAgICAgICAgb1tcImRlZmF1bHRcIl0gPSB2O1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIF9faW1wb3J0U3RhciA9IHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgICAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIHtcbiAgICAgICAgICAgICAgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5NdWx0aWxpbmVUZXh0Q29sdW1uID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIHV0aWxzID0gX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vY29sdW1uVXRpbHMgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy90eXBlL2NvbHVtblV0aWxzLmpzXCIpKTtcblxuICAgICAgICAgIHZhciBCYXNlQ29sdW1uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL0Jhc2VDb2x1bW4gKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy90eXBlL0Jhc2VDb2x1bW4uanNcIik7XG5cbiAgICAgICAgICB2YXIgTXVsdGlsaW5lVGV4dFN0eWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi9zdHlsZS9NdWx0aWxpbmVUZXh0U3R5bGUgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9zdHlsZS9NdWx0aWxpbmVUZXh0U3R5bGUuanNcIik7XG5cbiAgICAgICAgICB2YXIgTXVsdGlsaW5lVGV4dENvbHVtbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Jhc2VDb2x1bW5fMSRCYXNlQ29sNikge1xuICAgICAgICAgICAgX2luaGVyaXRzKE11bHRpbGluZVRleHRDb2x1bW4sIF9CYXNlQ29sdW1uXzEkQmFzZUNvbDYpO1xuXG4gICAgICAgICAgICB2YXIgX3N1cGVyNDEgPSBfY3JlYXRlU3VwZXIoTXVsdGlsaW5lVGV4dENvbHVtbik7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIE11bHRpbGluZVRleHRDb2x1bW4oKSB7XG4gICAgICAgICAgICAgIHZhciBvcHRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNdWx0aWxpbmVUZXh0Q29sdW1uKTtcblxuICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyNDEuY2FsbCh0aGlzLCBvcHRpb24pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoTXVsdGlsaW5lVGV4dENvbHVtbiwgW3tcbiAgICAgICAgICAgICAga2V5OiBcIlN0eWxlQ2xhc3NcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE11bHRpbGluZVRleHRTdHlsZV8xLk11bHRpbGluZVRleHRTdHlsZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY2xvbmVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTXVsdGlsaW5lVGV4dENvbHVtbih0aGlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZHJhd0ludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3SW50ZXJuYWwodmFsdWUsIGNvbnRleHQsIHN0eWxlLCBoZWxwZXIsIF9ncmlkLCBfcmVmNDQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZHJhd0NlbGxCYXNlID0gX3JlZjQ0LmRyYXdDZWxsQmFzZSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0SWNvbiA9IF9yZWY0NC5nZXRJY29uO1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0QWxpZ24gPSBzdHlsZS50ZXh0QWxpZ24sXG4gICAgICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZSA9IHN0eWxlLnRleHRCYXNlbGluZSxcbiAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBzdHlsZS5jb2xvcixcbiAgICAgICAgICAgICAgICAgICAgZm9udCA9IHN0eWxlLmZvbnQsXG4gICAgICAgICAgICAgICAgICAgIGJnQ29sb3IgPSBzdHlsZS5iZ0NvbG9yLFxuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nID0gc3R5bGUucGFkZGluZyxcbiAgICAgICAgICAgICAgICAgICAgbGluZUhlaWdodCA9IHN0eWxlLmxpbmVIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIGF1dG9XcmFwVGV4dCA9IHN0eWxlLmF1dG9XcmFwVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgbGluZUNsYW1wID0gc3R5bGUubGluZUNsYW1wLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0T3ZlcmZsb3cgPSBzdHlsZS50ZXh0T3ZlcmZsb3csXG4gICAgICAgICAgICAgICAgICAgIHZpc2liaWxpdHkgPSBzdHlsZS52aXNpYmlsaXR5O1xuXG4gICAgICAgICAgICAgICAgaWYgKGJnQ29sb3IpIHtcbiAgICAgICAgICAgICAgICAgIGRyYXdDZWxsQmFzZSh7XG4gICAgICAgICAgICAgICAgICAgIGJnQ29sb3I6IGJnQ29sb3JcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh2aXNpYmlsaXR5ID09PSBcImhpZGRlblwiKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHRleHRWYWx1ZSA9IHZhbHVlICE9IG51bGwgPyBTdHJpbmcodmFsdWUpIDogXCJcIjtcbiAgICAgICAgICAgICAgICB2YXIgbGluZXMgPSB0ZXh0VmFsdWUucmVwbGFjZSgvXFxyP1xcbi9nLCBcIlxcblwiKS5yZXBsYWNlKC9cXHIvZywgXCJcXG5cIikuc3BsaXQoXCJcXG5cIik7XG4gICAgICAgICAgICAgICAgaGVscGVyLnRlc3RGb250TG9hZChmb250LCB0ZXh0VmFsdWUsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIHV0aWxzLmxvYWRJY29ucyhnZXRJY29uKCksIGNvbnRleHQsIGhlbHBlciwgZnVuY3Rpb24gKGljb25zLCBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICBoZWxwZXIubXVsdGlsaW5lVGV4dChsaW5lcywgY29udGV4dCwge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ246IHRleHRBbGlnbixcbiAgICAgICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lOiB0ZXh0QmFzZWxpbmUsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgICAgICAgICAgICAgICAgZm9udDogZm9udCxcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogcGFkZGluZyxcbiAgICAgICAgICAgICAgICAgICAgbGluZUhlaWdodDogbGluZUhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgYXV0b1dyYXBUZXh0OiBhdXRvV3JhcFRleHQsXG4gICAgICAgICAgICAgICAgICAgIGxpbmVDbGFtcDogbGluZUNsYW1wLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0T3ZlcmZsb3c6IHRleHRPdmVyZmxvdyxcbiAgICAgICAgICAgICAgICAgICAgaWNvbnM6IGljb25zXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gTXVsdGlsaW5lVGV4dENvbHVtbjtcbiAgICAgICAgICB9KEJhc2VDb2x1bW5fMS5CYXNlQ29sdW1uKTtcblxuICAgICAgICAgIGV4cG9ydHMuTXVsdGlsaW5lVGV4dENvbHVtbiA9IE11bHRpbGluZVRleHRDb2x1bW47XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vY29sdW1ucy90eXBlL051bWJlckNvbHVtbi5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vY29sdW1ucy90eXBlL051bWJlckNvbHVtbi5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gY29sdW1uc1R5cGVOdW1iZXJDb2x1bW5Kcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLk51bWJlckNvbHVtbiA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBDb2x1bW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vQ29sdW1uICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvdHlwZS9Db2x1bW4uanNcIik7XG5cbiAgICAgICAgICB2YXIgTnVtYmVyU3R5bGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uL3N0eWxlL051bWJlclN0eWxlICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvc3R5bGUvTnVtYmVyU3R5bGUuanNcIik7XG5cbiAgICAgICAgICB2YXIgZGVmYXVsdEZvcm1hdDtcblxuICAgICAgICAgIHZhciBOdW1iZXJDb2x1bW4gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Db2x1bW5fMSRDb2x1bW4zKSB7XG4gICAgICAgICAgICBfaW5oZXJpdHMoTnVtYmVyQ29sdW1uLCBfQ29sdW1uXzEkQ29sdW1uMyk7XG5cbiAgICAgICAgICAgIHZhciBfc3VwZXI0MiA9IF9jcmVhdGVTdXBlcihOdW1iZXJDb2x1bW4pO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBOdW1iZXJDb2x1bW4oKSB7XG4gICAgICAgICAgICAgIHZhciBfdGhpczU4O1xuXG4gICAgICAgICAgICAgIHZhciBvcHRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOdW1iZXJDb2x1bW4pO1xuXG4gICAgICAgICAgICAgIF90aGlzNTggPSBfc3VwZXI0Mi5jYWxsKHRoaXMsIG9wdGlvbik7XG4gICAgICAgICAgICAgIF90aGlzNTguX2Zvcm1hdCA9IG9wdGlvbi5mb3JtYXQ7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczU4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoTnVtYmVyQ29sdW1uLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiU3R5bGVDbGFzc1wiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyU3R5bGVfMS5OdW1iZXJTdHlsZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY2xvbmVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTnVtYmVyQ29sdW1uKHRoaXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJmb3JtYXRcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Zvcm1hdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwid2l0aEZvcm1hdFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gd2l0aEZvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgYyA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICBjLl9mb3JtYXQgPSBmb3JtYXQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNvbnZlcnRJbnRlcm5hbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY29udmVydEludGVybmFsKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG51bSA9IE51bWJlcih2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4obnVtKSkge1xuICAgICAgICAgICAgICAgICAgdmFyIGNvbnZlcnRlZFZhbHVlID0gX2dldChfZ2V0UHJvdG90eXBlT2YoTnVtYmVyQ29sdW1uLnByb3RvdHlwZSksIFwiY29udmVydEludGVybmFsXCIsIHRoaXMpLmNhbGwodGhpcywgdmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gY29udmVydGVkVmFsdWUgIT0gbnVsbCA/IFN0cmluZyhjb252ZXJ0ZWRWYWx1ZSkgOiBcIlwiO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBmb3JtYXQgPSB0aGlzLl9mb3JtYXQgfHwgTnVtYmVyQ29sdW1uLmRlZmF1bHRGb3JtYXQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdC5mb3JtYXQobnVtKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0sIFt7XG4gICAgICAgICAgICAgIGtleTogXCJkZWZhdWx0Rm9ybWF0XCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0Rm9ybWF0IHx8IChkZWZhdWx0Rm9ybWF0ID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KCkpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChmbXQpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0Rm9ybWF0ID0gZm10O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBAZGVwcmVjYXRlZCBVc2UgZGVmYXVsdEZvcm1hdCBpbnN0ZWFkXG4gICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJkZWZhdWx0Rm90bWF0XCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRGb3JtYXQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIEBkZXByZWNhdGVkIFVzZSBkZWZhdWx0Rm9ybWF0IGluc3RlYWRcbiAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoZm10KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWZhdWx0Rm9ybWF0ID0gZm10O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBOdW1iZXJDb2x1bW47XG4gICAgICAgICAgfShDb2x1bW5fMS5Db2x1bW4pO1xuXG4gICAgICAgICAgZXhwb3J0cy5OdW1iZXJDb2x1bW4gPSBOdW1iZXJDb2x1bW47XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vY29sdW1ucy90eXBlL1BlcmNlbnRDb21wbGV0ZUJhckNvbHVtbi5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vY29sdW1ucy90eXBlL1BlcmNlbnRDb21wbGV0ZUJhckNvbHVtbi5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gY29sdW1uc1R5cGVQZXJjZW50Q29tcGxldGVCYXJDb2x1bW5Kcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLlBlcmNlbnRDb21wbGV0ZUJhckNvbHVtbiA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vaW50ZXJuYWwvdXRpbHMgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvdXRpbHMuanNcIik7XG5cbiAgICAgICAgICB2YXIgQ29sdW1uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL0NvbHVtbiAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3R5cGUvQ29sdW1uLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIFBlcmNlbnRDb21wbGV0ZUJhclN0eWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi9zdHlsZS9QZXJjZW50Q29tcGxldGVCYXJTdHlsZSAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3N0eWxlL1BlcmNlbnRDb21wbGV0ZUJhclN0eWxlLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIE1BUkdJTiA9IDI7XG5cbiAgICAgICAgICB2YXIgUGVyY2VudENvbXBsZXRlQmFyQ29sdW1uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ29sdW1uXzEkQ29sdW1uNCkge1xuICAgICAgICAgICAgX2luaGVyaXRzKFBlcmNlbnRDb21wbGV0ZUJhckNvbHVtbiwgX0NvbHVtbl8xJENvbHVtbjQpO1xuXG4gICAgICAgICAgICB2YXIgX3N1cGVyNDMgPSBfY3JlYXRlU3VwZXIoUGVyY2VudENvbXBsZXRlQmFyQ29sdW1uKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gUGVyY2VudENvbXBsZXRlQmFyQ29sdW1uKCkge1xuICAgICAgICAgICAgICB2YXIgX3RoaXM1OTtcblxuICAgICAgICAgICAgICB2YXIgb3B0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGVyY2VudENvbXBsZXRlQmFyQ29sdW1uKTtcblxuICAgICAgICAgICAgICBfdGhpczU5ID0gX3N1cGVyNDMuY2FsbCh0aGlzLCBvcHRpb24pO1xuICAgICAgICAgICAgICBfdGhpczU5Ll9taW4gPSBvcHRpb24ubWluIHx8IDA7XG4gICAgICAgICAgICAgIF90aGlzNTkuX21heCA9IG9wdGlvbi5tYXggfHwgX3RoaXM1OS5fbWluICsgMTAwO1xuXG4gICAgICAgICAgICAgIF90aGlzNTkuX2Zvcm1hdHRlciA9IG9wdGlvbi5mb3JtYXR0ZXIgfHwgZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICByZXR1cm4gX3RoaXM1OTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKFBlcmNlbnRDb21wbGV0ZUJhckNvbHVtbiwgW3tcbiAgICAgICAgICAgICAga2V5OiBcIlN0eWxlQ2xhc3NcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBlcmNlbnRDb21wbGV0ZUJhclN0eWxlXzEuUGVyY2VudENvbXBsZXRlQmFyU3R5bGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNsb25lXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBlcmNlbnRDb21wbGV0ZUJhckNvbHVtbih0aGlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwibWluXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1pbjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwibWF4XCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1heDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZm9ybWF0dGVyXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdHRlcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZHJhd0ludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3SW50ZXJuYWwodmFsdWUsIGNvbnRleHQsIHN0eWxlLCBoZWxwZXIsIGdyaWQsIGluZm8pIHtcbiAgICAgICAgICAgICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihQZXJjZW50Q29tcGxldGVCYXJDb2x1bW4ucHJvdG90eXBlKSwgXCJkcmF3SW50ZXJuYWxcIiwgdGhpcykuY2FsbCh0aGlzLCB0aGlzLl9mb3JtYXR0ZXIodmFsdWUpLCBjb250ZXh0LCBzdHlsZSwgaGVscGVyLCBncmlkLCBpbmZvKTtcblxuICAgICAgICAgICAgICAgIHZhciBiYXJDb2xvciA9IHN0eWxlLmJhckNvbG9yLFxuICAgICAgICAgICAgICAgICAgICBiYXJCZ0NvbG9yID0gc3R5bGUuYmFyQmdDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgYmFySGVpZ2h0ID0gc3R5bGUuYmFySGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICB2aXNpYmlsaXR5ID0gc3R5bGUudmlzaWJpbGl0eTtcblxuICAgICAgICAgICAgICAgIGlmICh2aXNpYmlsaXR5ID09PSBcImhpZGRlblwiKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHRleHRWYWx1ZSA9IHZhbHVlICE9IG51bGwgPyBTdHJpbmcodmFsdWUpIDogXCJcIjtcblxuICAgICAgICAgICAgICAgIGlmICh1dGlsc18xLnN0ci5lbmRzV2l0aCh0ZXh0VmFsdWUsIFwiJVwiKSkge1xuICAgICAgICAgICAgICAgICAgdGV4dFZhbHVlID0gdGV4dFZhbHVlLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgbnVtID0gTnVtYmVyKHRleHRWYWx1ZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4obnVtKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciByYXRlID0gbnVtIDwgdGhpcy5fbWluID8gMCA6IG51bSA+IHRoaXMuX21heCA/IDEgOiAobnVtIC0gdGhpcy5fbWluKSAvICh0aGlzLl9tYXggLSB0aGlzLl9taW4pO1xuICAgICAgICAgICAgICAgIGhlbHBlci5kcmF3V2l0aENsaXAoY29udGV4dCwgZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAgICAgICAgICAgdmFyIHJlY3QgPSBjb250ZXh0LmdldFJlY3QoKTtcbiAgICAgICAgICAgICAgICAgIHZhciBiYXJNYXhXaWR0aCA9IHJlY3Qud2lkdGggLSBNQVJHSU4gKiAyIC0gMTtcbiAgICAgICAgICAgICAgICAgIC8q572r57eaKi9cblxuICAgICAgICAgICAgICAgICAgdmFyIGJhclRvcCA9IHJlY3QuYm90dG9tIC0gTUFSR0lOIC0gYmFySGVpZ2h0IC0gMTtcbiAgICAgICAgICAgICAgICAgIC8q572r57eaKi9cblxuICAgICAgICAgICAgICAgICAgdmFyIGJhckxlZnQgPSByZWN0LmxlZnQgKyBNQVJHSU47XG4gICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gKDAsIHV0aWxzXzEuZ2V0T3JBcHBseSkoYmFyQmdDb2xvciwgcmF0ZSAqIDEwMCkgfHwgXCIjZjBmM2Y1XCI7XG4gICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICBjdHgucmVjdChiYXJMZWZ0LCBiYXJUb3AsIGJhck1heFdpZHRoLCBiYXJIZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgICAgICAgIHZhciBiYXJTaXplID0gTWF0aC5taW4oYmFyTWF4V2lkdGggKiByYXRlLCBiYXJNYXhXaWR0aCk7XG4gICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gKDAsIHV0aWxzXzEuZ2V0T3JBcHBseSkoYmFyQ29sb3IsIHJhdGUgKiAxMDApIHx8IFwiIzIwYThkOFwiO1xuICAgICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgY3R4LnJlY3QoYmFyTGVmdCwgYmFyVG9wLCBiYXJTaXplLCBiYXJIZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gUGVyY2VudENvbXBsZXRlQmFyQ29sdW1uO1xuICAgICAgICAgIH0oQ29sdW1uXzEuQ29sdW1uKTtcblxuICAgICAgICAgIGV4cG9ydHMuUGVyY2VudENvbXBsZXRlQmFyQ29sdW1uID0gUGVyY2VudENvbXBsZXRlQmFyQ29sdW1uO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2NvbHVtbnMvdHlwZS9SYWRpb0NvbHVtbi5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9jb2x1bW5zL3R5cGUvUmFkaW9Db2x1bW4uanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gY29sdW1uc1R5cGVSYWRpb0NvbHVtbkpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuUmFkaW9Db2x1bW4gPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgQmFzZUNvbHVtbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9CYXNlQ29sdW1uICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvdHlwZS9CYXNlQ29sdW1uLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIFJhZGlvU3R5bGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uL3N0eWxlL1JhZGlvU3R5bGUgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9zdHlsZS9SYWRpb1N0eWxlLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIHN5bWJvbE1hbmFnZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uL2ludGVybmFsL3N5bWJvbE1hbmFnZXIgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvc3ltYm9sTWFuYWdlci5qc1wiKTtcblxuICAgICAgICAgIHZhciB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vdXRpbHMgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy91dGlscy9pbmRleC5qc1wiKTtcblxuICAgICAgICAgIHZhciBSQURJT19DT0xVTU5fU1RBVEVfSUQgPSAoMCwgc3ltYm9sTWFuYWdlcl8xLmdldFJhZGlvQ29sdW1uU3RhdGVJZCkoKTtcblxuICAgICAgICAgIHZhciBSYWRpb0NvbHVtbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Jhc2VDb2x1bW5fMSRCYXNlQ29sNykge1xuICAgICAgICAgICAgX2luaGVyaXRzKFJhZGlvQ29sdW1uLCBfQmFzZUNvbHVtbl8xJEJhc2VDb2w3KTtcblxuICAgICAgICAgICAgdmFyIF9zdXBlcjQ0ID0gX2NyZWF0ZVN1cGVyKFJhZGlvQ29sdW1uKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gUmFkaW9Db2x1bW4oKSB7XG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSYWRpb0NvbHVtbik7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlcjQ0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhSYWRpb0NvbHVtbiwgW3tcbiAgICAgICAgICAgICAga2V5OiBcIlN0eWxlQ2xhc3NcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJhZGlvU3R5bGVfMS5SYWRpb1N0eWxlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjbG9uZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSYWRpb0NvbHVtbih0aGlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY29udmVydEludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb252ZXJ0SW50ZXJuYWwodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEudG9Cb29sZWFuKSh2YWx1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImRyYXdJbnRlcm5hbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0ludGVybmFsKHZhbHVlLCBjb250ZXh0LCBzdHlsZSwgaGVscGVyLCBncmlkLCBfcmVmNDUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZHJhd0NlbGxCYXNlID0gX3JlZjQ1LmRyYXdDZWxsQmFzZTtcblxuICAgICAgICAgICAgICAgIHZhciBfYTtcblxuICAgICAgICAgICAgICAgIHZhciB0ZXh0QWxpZ24gPSBzdHlsZS50ZXh0QWxpZ24sXG4gICAgICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZSA9IHN0eWxlLnRleHRCYXNlbGluZSxcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZyA9IHN0eWxlLnBhZGRpbmcsXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrQ29sb3IgPSBzdHlsZS5jaGVja0NvbG9yLFxuICAgICAgICAgICAgICAgICAgICB1bmNoZWNrQm9yZGVyQ29sb3IgPSBzdHlsZS51bmNoZWNrQm9yZGVyQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrQm9yZGVyQ29sb3IgPSBzdHlsZS5jaGVja0JvcmRlckNvbG9yLFxuICAgICAgICAgICAgICAgICAgICB1bmNoZWNrQmdDb2xvciA9IHN0eWxlLnVuY2hlY2tCZ0NvbG9yLFxuICAgICAgICAgICAgICAgICAgICBjaGVja0JnQ29sb3IgPSBzdHlsZS5jaGVja0JnQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGJnQ29sb3IgPSBzdHlsZS5iZ0NvbG9yLFxuICAgICAgICAgICAgICAgICAgICB2aXNpYmlsaXR5ID0gc3R5bGUudmlzaWJpbGl0eTtcblxuICAgICAgICAgICAgICAgIGlmIChiZ0NvbG9yKSB7XG4gICAgICAgICAgICAgICAgICBkcmF3Q2VsbEJhc2Uoe1xuICAgICAgICAgICAgICAgICAgICBiZ0NvbG9yOiBiZ0NvbG9yXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodmlzaWJpbGl0eSA9PT0gXCJoaWRkZW5cIikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBjb2wgPSBjb250ZXh0LmNvbCxcbiAgICAgICAgICAgICAgICAgICAgcm93ID0gY29udGV4dC5yb3c7XG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gZ3JpZC5nZXRDZWxsUmFuZ2UoY29sLCByb3cpO1xuICAgICAgICAgICAgICAgIHZhciBjZWxsS2V5ID0gXCJcIi5jb25jYXQocmFuZ2Uuc3RhcnQuY29sLCBcIjpcIikuY29uY2F0KHJhbmdlLnN0YXJ0LnJvdyk7XG4gICAgICAgICAgICAgICAgdmFyIGVsYXBzZWQgPSAoX2EgPSBncmlkW1JBRElPX0NPTFVNTl9TVEFURV9JRF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5lbGFwc2VkW2NlbGxLZXldO1xuICAgICAgICAgICAgICAgIHZhciBvcHQgPSB7XG4gICAgICAgICAgICAgICAgICB0ZXh0QWxpZ246IHRleHRBbGlnbixcbiAgICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZTogdGV4dEJhc2VsaW5lLFxuICAgICAgICAgICAgICAgICAgY2hlY2tDb2xvcjogY2hlY2tDb2xvcixcbiAgICAgICAgICAgICAgICAgIHVuY2hlY2tCb3JkZXJDb2xvcjogdW5jaGVja0JvcmRlckNvbG9yLFxuICAgICAgICAgICAgICAgICAgY2hlY2tCb3JkZXJDb2xvcjogY2hlY2tCb3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgICAgIHVuY2hlY2tCZ0NvbG9yOiB1bmNoZWNrQmdDb2xvcixcbiAgICAgICAgICAgICAgICAgIGNoZWNrQmdDb2xvcjogY2hlY2tCZ0NvbG9yLFxuICAgICAgICAgICAgICAgICAgcGFkZGluZzogcGFkZGluZ1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAoZWxhcHNlZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBvcHQuYW5pbUVsYXBzZWRUaW1lID0gZWxhcHNlZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBoZWxwZXIucmFkaW9CdXR0b24odmFsdWUsIGNvbnRleHQsIG9wdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIFJhZGlvQ29sdW1uO1xuICAgICAgICAgIH0oQmFzZUNvbHVtbl8xLkJhc2VDb2x1bW4pO1xuXG4gICAgICAgICAgZXhwb3J0cy5SYWRpb0NvbHVtbiA9IFJhZGlvQ29sdW1uO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2NvbHVtbnMvdHlwZS9UcmVlQ29sdW1uLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vY29sdW1ucy90eXBlL1RyZWVDb2x1bW4uanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBjb2x1bW5zVHlwZVRyZWVDb2x1bW5Kcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIHZhciBfX2NyZWF0ZUJpbmRpbmcgPSB0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nIHx8IChPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24gKG8sIG0sIGssIGsyKSB7XG4gICAgICAgICAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgICAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuXG4gICAgICAgICAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgICAgICAgICBkZXNjID0ge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbVtrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG4gICAgICAgICAgfSA6IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICAgICAgICAgICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICAgICAgICAgIG9bazJdID0gbVtrXTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBfX3NldE1vZHVsZURlZmF1bHQgPSB0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0IHx8IChPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24gKG8sIHYpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwge1xuICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICB2YWx1ZTogdlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSA6IGZ1bmN0aW9uIChvLCB2KSB7XG4gICAgICAgICAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgX19pbXBvcnRTdGFyID0gdGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhciB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgICAgICAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICAgICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkge1xuICAgICAgICAgICAgICBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLmdldFRyZWVOb2RlSW5mb0F0ID0gZXhwb3J0cy5UcmVlQ29sdW1uID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIGlubGluZVV0aWxzID0gX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uL2VsZW1lbnQvaW5saW5lcyAqL1xuICAgICAgICAgIFwiLi9lbGVtZW50L2lubGluZXMuanNcIikpO1xuXG4gICAgICAgICAgdmFyIHV0aWxzID0gX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uL2NvbHVtbnMvdHlwZS9jb2x1bW5VdGlscyAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3R5cGUvY29sdW1uVXRpbHMuanNcIikpO1xuXG4gICAgICAgICAgdmFyIENvbHVtbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9Db2x1bW4gKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy90eXBlL0NvbHVtbi5qc1wiKTtcblxuICAgICAgICAgIHZhciBSZWN0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi9pbnRlcm5hbC9SZWN0ICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL1JlY3QuanNcIik7XG5cbiAgICAgICAgICB2YXIgVHJlZVN0eWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi9zdHlsZS9UcmVlU3R5bGUgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9zdHlsZS9UcmVlU3R5bGUuanNcIik7XG5cbiAgICAgICAgICB2YXIgY2FudmFzZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uL2ludGVybmFsL2NhbnZhc2VzICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL2NhbnZhc2VzLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIHN5bWJvbE1hbmFnZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uL2ludGVybmFsL3N5bWJvbE1hbmFnZXIgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvc3ltYm9sTWFuYWdlci5qc1wiKTtcblxuICAgICAgICAgIHZhciB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vaW50ZXJuYWwvdXRpbHMgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvdXRpbHMuanNcIik7XG5cbiAgICAgICAgICB2YXIgXyA9ICgwLCBzeW1ib2xNYW5hZ2VyXzEuZ2V0VHJlZUNvbHVtblN0YXRlSWQpKCk7XG5cbiAgICAgICAgICB2YXIgVHJlZUNvbHVtbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0NvbHVtbl8xJENvbHVtbjUpIHtcbiAgICAgICAgICAgIF9pbmhlcml0cyhUcmVlQ29sdW1uLCBfQ29sdW1uXzEkQ29sdW1uNSk7XG5cbiAgICAgICAgICAgIHZhciBfc3VwZXI0NSA9IF9jcmVhdGVTdXBlcihUcmVlQ29sdW1uKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gVHJlZUNvbHVtbigpIHtcbiAgICAgICAgICAgICAgdmFyIF90aGlzNjA7XG5cbiAgICAgICAgICAgICAgdmFyIG9wdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRyZWVDb2x1bW4pO1xuXG4gICAgICAgICAgICAgIF90aGlzNjAgPSBfc3VwZXI0NS5jYWxsKHRoaXMsIG9wdGlvbik7XG4gICAgICAgICAgICAgIF90aGlzNjAuX2NhY2hlID0gb3B0aW9uLmNhY2hlICE9IG51bGwgPyBvcHRpb24uY2FjaGUgOiBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzNjA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhUcmVlQ29sdW1uLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiU3R5bGVDbGFzc1wiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVHJlZVN0eWxlXzEuVHJlZVN0eWxlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjbGVhckNhY2hlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhckNhY2hlKGdyaWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW50ZXJuYWwgPSBncmlkO1xuICAgICAgICAgICAgICAgIGlmICghaW50ZXJuYWxbX10pIHJldHVybjtcbiAgICAgICAgICAgICAgICBkZWxldGUgaW50ZXJuYWxbX10uY2FjaGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImRyYXduSWNvbkFjdGlvbkFyZWFcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICAgICAgICAgICAgdmFyIGludGVybmFsID0gcGFyYW0uZ3JpZDtcbiAgICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IGludGVybmFsW19dO1xuICAgICAgICAgICAgICAgICAgaWYgKCEoc3RhdGUgPT09IG51bGwgfHwgc3RhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0YXRlLmRyYXduSWNvbnMpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICB2YXIgZHJhd25JY29ucyA9IHN0YXRlLmRyYXduSWNvbnM7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZHJhd25JY29ucy5hcmVhKHBhcmFtKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJvbkRyYXdDZWxsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbkRyYXdDZWxsKGNlbGxWYWx1ZSwgaW5mbywgY29udGV4dCwgZ3JpZCkge1xuICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IGdyaWRbX10gfHwgKGdyaWRbX10gPSB7fSk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2FjaGUgJiYgIXN0YXRlLmNhY2hlKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY2FjaGUgPSBzdGF0ZS5jYWNoZSB8fCAoc3RhdGUuY2FjaGUgPSBuZXcgTWFwKCkpO1xuICAgICAgICAgICAgICAgICAgdmFyIGNvbCA9IGNvbnRleHQuY29sLFxuICAgICAgICAgICAgICAgICAgICAgIHJvdyA9IGNvbnRleHQucm93O1xuICAgICAgICAgICAgICAgICAgdmFyIGZpZWxkID0gZ3JpZC5nZXRGaWVsZChjb2wsIHJvdyk7XG5cbiAgICAgICAgICAgICAgICAgIGlmICghY2FjaGUuaGFzKGZpZWxkKSkge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZS5zZXQoZmllbGQsIG5ldyBUcmVlQ29sdW1uSW5mbyhncmlkLCBmaWVsZCkpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZ2V0KF9nZXRQcm90b3R5cGVPZihUcmVlQ29sdW1uLnByb3RvdHlwZSksIFwib25EcmF3Q2VsbFwiLCB0aGlzKS5jYWxsKHRoaXMsIGNlbGxWYWx1ZSwgaW5mbywgY29udGV4dCwgZ3JpZCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNsb25lXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRyZWVDb2x1bW4odGhpcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNhY2hlXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWNoZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0Q29weUNlbGxWYWx1ZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29weUNlbGxWYWx1ZSh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciB0cmVlRGF0YSA9IGdldFRyZWVEYXRhRnJvbVZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJlZURhdGEuY2FwdGlvbjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZHJhd0ludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3SW50ZXJuYWwodmFsdWUsIGNvbnRleHQsIHN0eWxlLCBoZWxwZXIsIGdyaWQsIF9yZWY0Nikge1xuICAgICAgICAgICAgICAgIHZhciBkcmF3Q2VsbEJhc2UgPSBfcmVmNDYuZHJhd0NlbGxCYXNlLFxuICAgICAgICAgICAgICAgICAgICBnZXRJY29uID0gX3JlZjQ2LmdldEljb247XG5cbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuXG4gICAgICAgICAgICAgICAgdmFyIHRleHRBbGlnbiA9IHN0eWxlLnRleHRBbGlnbixcbiAgICAgICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lID0gc3R5bGUudGV4dEJhc2VsaW5lLFxuICAgICAgICAgICAgICAgICAgICBiZ0NvbG9yID0gc3R5bGUuYmdDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZyA9IHN0eWxlLnBhZGRpbmcsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yID0gc3R5bGUuY29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGZvbnQgPSBzdHlsZS5mb250LFxuICAgICAgICAgICAgICAgICAgICB0ZXh0T3ZlcmZsb3cgPSBzdHlsZS50ZXh0T3ZlcmZsb3c7XG5cbiAgICAgICAgICAgICAgICBpZiAoYmdDb2xvcikge1xuICAgICAgICAgICAgICAgICAgZHJhd0NlbGxCYXNlKHtcbiAgICAgICAgICAgICAgICAgICAgYmdDb2xvcjogYmdDb2xvclxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHN0YXRlID0gZ3JpZFtfXSB8fCAoZ3JpZFtfXSA9IHt9KTtcblxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5kcmF3bkljb25zKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZHJhd25JY29ucyA9IHN0YXRlLmRyYXduSWNvbnM7XG4gICAgICAgICAgICAgICAgICBkcmF3bkljb25zLmRlbGV0ZShjb250ZXh0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgY29sID0gY29udGV4dC5jb2wsXG4gICAgICAgICAgICAgICAgICAgIHJvdyA9IGNvbnRleHQucm93O1xuICAgICAgICAgICAgICAgIHZhciBmaWVsZCA9IGdyaWQuZ2V0RmllbGQoY29sLCByb3cpO1xuICAgICAgICAgICAgICAgIHZhciB0Y2kgPSAoX2IgPSB0aGlzLl9jYWNoZSA/IChfYSA9IHN0YXRlLmNhY2hlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0KGZpZWxkKSA6IG51bGwpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG5ldyBUcmVlQ29sdW1uSW5mbyhncmlkLCBmaWVsZCk7XG4gICAgICAgICAgICAgICAgdmFyIGluZm8gPSB0Y2kuZ2V0SW5mbyh2YWx1ZSwgcm93KTtcbiAgICAgICAgICAgICAgICBoZWxwZXIudGVzdEZvbnRMb2FkKGZvbnQsIGluZm8uY2FwdGlvbiwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgdXRpbHMubG9hZEljb25zKGdldEljb24oKSwgY29udGV4dCwgaGVscGVyLCBmdW5jdGlvbiAoaWNvbnMsIGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgIHZhciByZWN0ID0gY29udGV4dC5nZXRSZWN0KCk7XG4gICAgICAgICAgICAgICAgICB2YXIgYmFzZVBhZGRpbmcgPSBoZWxwZXIudG9Cb3hQaXhlbEFycmF5KHBhZGRpbmcgfHwgMCwgY29udGV4dCwgZm9udCk7XG4gICAgICAgICAgICAgICAgICB2YXIgbmVzdExldmVsID0gaW5mby5wYXRoLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgIGhlbHBlci5kcmF3V2l0aENsaXAoY29udGV4dCwgZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm9udFNpemUgPSAoMCwgY2FudmFzZXNfMS5nZXRGb250U2l6ZSkoY3R4LCBmb250KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGVudFNpemUgPSBmb250U2l6ZS53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRvcCA9IHJlY3QudG9wICsgYmFzZVBhZGRpbmdbMF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZWZ0ID0gcmVjdC5sZWZ0ICsgYmFzZVBhZGRpbmdbM107XG4gICAgICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSByZWN0LmhlaWdodCAtIGJhc2VQYWRkaW5nWzBdIC0gYmFzZVBhZGRpbmdbMl07XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5lQmFzZWxpbmUgPSB0ZXh0QmFzZWxpbmUgIT09IG51bGwgJiYgdGV4dEJhc2VsaW5lICE9PSB2b2lkIDAgPyB0ZXh0QmFzZWxpbmUgOiBjdHgudGV4dEJhc2VsaW5lIHx8IFwibWlkZGxlXCI7IC8vIENhbGN1bGF0ZSBob3Jpem9udGFsIGxpbmUgcG9zaXRpb25cblxuICAgICAgICAgICAgICAgICAgICB2YXIgaExpbmVZID0gdG9wICsgaGVpZ2h0IC8gMjtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobGluZUJhc2VsaW5lID09PSBcImJvdHRvbVwiIHx8IGxpbmVCYXNlbGluZSA9PT0gXCJhbHBoYWJldGljXCIgfHwgbGluZUJhc2VsaW5lID09PSBcImlkZW9ncmFwaGljXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBib3R0b21cbiAgICAgICAgICAgICAgICAgICAgICBoTGluZVkgPSB0b3AgKyBoZWlnaHQgLSBmb250U2l6ZS5oZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRleHRCYXNlbGluZSA9PT0gXCJtaWRkbGVcIikge1xuICAgICAgICAgICAgICAgICAgICAgIGhMaW5lWSA9IHRvcCArIGhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gdG9wXG4gICAgICAgICAgICAgICAgICAgICAgaExpbmVZID0gdG9wICsgZm9udFNpemUuaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgfSAvLyBHZXQgdGhlIHRyZWUgaWNvblxuXG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlZmluZWRUcmVlSWNvbiA9IHN0eWxlLnRyZWVJY29uIHx8IGhlbHBlci5nZXRTdHlsZVByb3BlcnR5KGhlbHBlci50aGVtZS50cmVlLnRyZWVJY29uLCBjb2wsIHJvdywgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyZWVJY29uID0gZGVmaW5lZFRyZWVJY29uID09PSBcIm5vbmVcIiA/IG51bGwgOiBkZWZpbmVkVHJlZUljb24gPT09IFwiY2hldnJvbl9yaWdodFwiIHx8IGRlZmluZWRUcmVlSWNvbiA9PT0gXCJleHBhbmRfbW9yZVwiID8ge1xuICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGRlZmluZWRUcmVlSWNvbixcbiAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogZm9udFNpemUud2lkdGhcbiAgICAgICAgICAgICAgICAgICAgfSA6IGRlZmluZWRUcmVlSWNvbjsgLy8gQ2FsY3VsYXRlIGljb24gcmVjdFxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBpY29uUmVjdCA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyZWVJY29uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcblxuICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHJlZUxpbmVMZWZ0ID0gbGVmdCArIGluZGVudFNpemUgKiAobmVzdExldmVsIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdkxpbmVYID0gdHJlZUxpbmVMZWZ0ICsgaW5kZW50U2l6ZSAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2l6ZSA9IGlubGluZVV0aWxzLmljb25PZih0cmVlSWNvbikud2lkdGgoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjdHg6IGN0eFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpY29uUmVjdCA9IG5ldyBSZWN0XzEuUmVjdCh2TGluZVggLSBzaXplIC8gMiwgaExpbmVZIC0gc2l6ZSAvIDIsIHNpemUsIHNpemUpO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgICAgICAgIH0gLy8gSXQgcHJlc2VydmVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgZHJhd24gaWNvblxuICAgICAgICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgaXQgaXMgdXNlZCBmb3IgdGhlIGBhcmVhYCBvcHRpb24gb2YgdGhlIGBBY3Rpb25gIGNsYXNzLlxuXG5cbiAgICAgICAgICAgICAgICAgICAgICB2YXIgX2RyYXduSWNvbnMgPSBzdGF0ZS5kcmF3bkljb25zIHx8IChzdGF0ZS5kcmF3bkljb25zID0gbmV3IERyYXduSWNvbnMoKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICBfZHJhd25JY29ucy5zZXQoY29udGV4dCwgaWNvblJlY3QpO1xuICAgICAgICAgICAgICAgICAgICB9IC8vIEdldCB0cmVlIGxpbmUgY29sb3JcblxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5lU3R5bGUgPSBzdHlsZS5saW5lU3R5bGUgfHwgaGVscGVyLnRoZW1lLnRyZWUubGluZVN0eWxlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lU3R5bGUgIT09IFwibm9uZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmVXaWR0aCA9IHN0eWxlLmxpbmVXaWR0aCB8fCBoZWxwZXIudGhlbWUudHJlZS5saW5lV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmVDb2xvciA9IHN0eWxlLmxpbmVDb2xvciB8fCBoZWxwZXIuZ2V0Q29sb3IoaGVscGVyLnRoZW1lLnRyZWUubGluZUNvbG9yLCBjb2wsIHJvdywgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGxpbmVDb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubGluZUNhcCA9IFwicm91bmRcIjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGljb25SZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENsaXAgaWNvbiBhcmVhXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnJlY3QoMCwgMCwgY3R4LmNhbnZhcy53aWR0aCwgY3R4LmNhbnZhcy5oZWlnaHQpOyAvLyBEcmF3IGEgc3F1YXJlIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24gdG8gaG9sbG93IG91dCB0aGUgaW5zaWRlLlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yZWN0KGljb25SZWN0LnJpZ2h0LCBpY29uUmVjdC50b3AsIC1pY29uUmVjdC53aWR0aCwgaWNvblJlY3QuaGVpZ2h0KTsgLy8gLy8gRm9yIGRlYnVnXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGN0eC5maWxsU3R5bGUgPSBcIiMwMDAyXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGN0eC5maWxsKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmNsaXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gLy8gRHJhdyB0cmVlIGxpbmVzXG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgaW5mby5nZXRMaW5lcygpLmZvckVhY2goZnVuY3Rpb24gKGxpbmUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0cmVlTGluZUxlZnQgPSBsZWZ0ICsgaW5kZW50U2l6ZSAqIGluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdkxpbmVYID0gdHJlZUxpbmVMZWZ0ICsgaW5kZW50U2l6ZSAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0cmVlTGluZVJpZ2h0ID0gdHJlZUxpbmVMZWZ0ICsgaW5kZW50U2l6ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGluZSAhPT0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBUcmVlTGluZUtpbmQubm9uZSAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmUgPT09IDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIFRyZWVMaW5lS2luZC52ZXJ0aWNhbCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh2TGluZVgsIHJlY3QudG9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHZMaW5lWCwgcmVjdC5ib3R0b20pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxpbmUgPT09IDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIFRyZWVMaW5lS2luZC5sYXN0ICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHZMaW5lWCwgcmVjdC50b3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8odkxpbmVYLCBoTGluZVkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8odHJlZUxpbmVSaWdodCwgaExpbmVZKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsaW5lID09PSAzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBUcmVlTGluZUtpbmQuc3RhcnQgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8odHJlZUxpbmVSaWdodCwgaExpbmVZKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHZMaW5lWCwgaExpbmVZKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHZMaW5lWCwgcmVjdC5ib3R0b20pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxpbmUgPT09IDRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIFRyZWVMaW5lS2luZC52ZXJ0aWNhbEJyYW5jaCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh2TGluZVgsIHJlY3QudG9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHZMaW5lWCwgcmVjdC5ib3R0b20pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8odkxpbmVYLCBoTGluZVkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8odHJlZUxpbmVSaWdodCwgaExpbmVZKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsaW5lID09PSA1XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBUcmVlTGluZUtpbmQuaG9yaXpvbnRhbCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh0cmVlTGluZUxlZnQsIGhMaW5lWSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh0cmVlTGluZVJpZ2h0LCBoTGluZVkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxpbmUgPT09IDZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIFRyZWVMaW5lS2luZC5ob3Jpem9udGFsQnJhbmNoICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHRyZWVMaW5lTGVmdCwgaExpbmVZKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHRyZWVMaW5lUmlnaHQsIGhMaW5lWSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh2TGluZVgsIGhMaW5lWSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh2TGluZVgsIHJlY3QuYm90dG9tKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsaW5lID09PSA3XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBUcmVlTGluZUtpbmQubG9uZSAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh2TGluZVgsIGhMaW5lWSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh0cmVlTGluZVJpZ2h0LCBoTGluZVkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAodHJlZUljb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBEcmF3IHRyZWUgaWNvblxuICAgICAgICAgICAgICAgICAgICAgIHZhciBpY29uTGVmdE9mZnNldCA9IGluZGVudFNpemUgKiAobmVzdExldmVsIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGljb25XaWR0aCA9IGluZGVudFNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGljb25QYWRkaW5nID0gYmFzZVBhZGRpbmcuc2xpY2UoMCk7XG4gICAgICAgICAgICAgICAgICAgICAgaWNvblBhZGRpbmdbM10gKz0gaWNvbkxlZnRPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgaWNvblBhZGRpbmdbMV0gPSByZWN0LndpZHRoIC0gaWNvbldpZHRoIC0gaWNvblBhZGRpbmdbM107IC8vIHBhZGRpbmcgcmlnaHRcblxuICAgICAgICAgICAgICAgICAgICAgIGhlbHBlci50ZXh0KFwiXCIsIGNvbnRleHQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbjogXCJjZW50ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZTogdGV4dEJhc2VsaW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9udDogZm9udCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb25zOiBbdHJlZUljb25dLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogaWNvblBhZGRpbmdcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0UGFkZGluZyA9IGJhc2VQYWRkaW5nLnNsaWNlKDApO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0UGFkZGluZ1szXSArPSBuZXN0TGV2ZWwgKiBpbmRlbnRTaXplOyAvLyBUcmVlIGluZGVudCBwYWRkaW5nXG5cbiAgICAgICAgICAgICAgICAgICAgaGVscGVyLnRleHQoaW5mby5jYXB0aW9uLCBjb250ZXh0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24sXG4gICAgICAgICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lOiB0ZXh0QmFzZWxpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgIGZvbnQ6IGZvbnQsXG4gICAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogdGV4dFBhZGRpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgdGV4dE92ZXJmbG93OiB0ZXh0T3ZlcmZsb3csXG4gICAgICAgICAgICAgICAgICAgICAgaWNvbnM6IGljb25zXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIFRyZWVDb2x1bW47XG4gICAgICAgICAgfShDb2x1bW5fMS5Db2x1bW4pO1xuXG4gICAgICAgICAgZXhwb3J0cy5UcmVlQ29sdW1uID0gVHJlZUNvbHVtbjtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBJZiB0aGUgY2VsbCBpcyBhIFRyZWVDb2x1bW4sIGdldHMgdGhlIHRyZWUgbm9kZSBpbmZvcm1hdGlvbiBmcm9tIHRoZSBnaXZlbiBjZWxsLlxuICAgICAgICAgICAqL1xuXG4gICAgICAgICAgZnVuY3Rpb24gZ2V0VHJlZU5vZGVJbmZvQXQoX3JlZjQ3KSB7XG4gICAgICAgICAgICB2YXIgZ3JpZCA9IF9yZWY0Ny5ncmlkLFxuICAgICAgICAgICAgICAgIGNvbCA9IF9yZWY0Ny5jb2wsXG4gICAgICAgICAgICAgICAgcm93ID0gX3JlZjQ3LnJvdztcbiAgICAgICAgICAgIHZhciBmaWVsZCA9IGdyaWQuZ2V0RmllbGQoY29sLCByb3cpO1xuICAgICAgICAgICAgaWYgKCFmaWVsZCkgcmV0dXJuIHtcbiAgICAgICAgICAgICAgaGFzQ2hpbGRyZW46IGZhbHNlLFxuICAgICAgICAgICAgICBub2RlVHlwZTogXCJsZWFmXCJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgZGF0YVNvdXJjZSA9IGdyaWQuZGF0YVNvdXJjZTtcbiAgICAgICAgICAgIHZhciBjdXJySW5kZXggPSBncmlkLmdldFJlY29yZEluZGV4QnlSb3cocm93KTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGRhdGFTb3VyY2UuZ2V0RmllbGQoY3VyckluZGV4LCBmaWVsZCk7XG4gICAgICAgICAgICB2YXIgdHJlZURhdGEgPSBnZXRUcmVlRGF0YUZyb21WYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICB2YXIgaGFzQ2hpbGRyZW4gPSBoYXNDaGlsZHJlbkJ5UmVjb3JkKHRyZWVEYXRhLCBkYXRhU291cmNlLCBmaWVsZCwgY3VyckluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIG5vZGVUeXBlOiBoYXNDaGlsZHJlbiA/IFwiYnJhbmNoXCIgOiB0cmVlRGF0YS5ub2RlVHlwZSB8fCBcImxlYWZcIixcbiAgICAgICAgICAgICAgaGFzQ2hpbGRyZW46IGhhc0NoaWxkcmVuXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMuZ2V0VHJlZU5vZGVJbmZvQXQgPSBnZXRUcmVlTm9kZUluZm9BdDtcblxuICAgICAgICAgIGZ1bmN0aW9uIGhhc0NoaWxkcmVuQnlSZWNvcmQodHJlZURhdGEsIGRhdGFTb3VyY2UsIGZpZWxkLCByZWNvcmRJbmRleCkge1xuICAgICAgICAgICAgdmFyIG5leHQgPSBkYXRhU291cmNlLmdldEZpZWxkKHJlY29yZEluZGV4ICsgMSwgZmllbGQpO1xuICAgICAgICAgICAgaWYgKCFuZXh0IHx8ICgwLCB1dGlsc18xLmlzUHJvbWlzZSkobmV4dCkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHZhciBuZXh0UGFyZW50UGF0aCA9IGdldFBhcmVudFBhdGgobmV4dCk7XG4gICAgICAgICAgICByZXR1cm4gdHJlZURhdGEucGF0aC5sZW5ndGggPT09IG5leHRQYXJlbnRQYXRoLmxlbmd0aCAmJiBuZXh0UGFyZW50UGF0aC5ldmVyeShmdW5jdGlvbiAocCwgaSkge1xuICAgICAgICAgICAgICByZXR1cm4gcCA9PT0gdHJlZURhdGEucGF0aFtpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBUcmVlQ29sdW1uSW5mbyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBUcmVlQ29sdW1uSW5mbyhncmlkLCBmaWVsZCkge1xuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVHJlZUNvbHVtbkluZm8pO1xuXG4gICAgICAgICAgICAgIHRoaXMuX2NhY2hlID0ge307XG4gICAgICAgICAgICAgIHRoaXMuX2dyaWQgPSBncmlkO1xuICAgICAgICAgICAgICB0aGlzLl9maWVsZCA9IGZpZWxkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoVHJlZUNvbHVtbkluZm8sIFt7XG4gICAgICAgICAgICAgIGtleTogXCJnZXRJbmZvXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbmZvKHZhbHVlLCByb3cpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmllbGQgPSB0aGlzLl9maWVsZCxcbiAgICAgICAgICAgICAgICAgICAgZ3JpZCA9IHRoaXMuX2dyaWQsXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlID0gdGhpcy5fY2FjaGU7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJJbmRleCA9IGdyaWQuZ2V0UmVjb3JkSW5kZXhCeVJvdyhyb3cpO1xuICAgICAgICAgICAgICAgIHZhciBkYXRhU291cmNlID0gZ3JpZC5kYXRhU291cmNlO1xuICAgICAgICAgICAgICAgIHZhciB0cmVlRGF0YSA9IGdldFRyZWVEYXRhRnJvbVZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB2YXIgaGFzQ2hpbGRyZW4gPSBoYXNDaGlsZHJlbkJ5UmVjb3JkKHRyZWVEYXRhLCBkYXRhU291cmNlLCBmaWVsZCwgY3VyckluZGV4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgY2FwdGlvbjogdHJlZURhdGEuY2FwdGlvbixcbiAgICAgICAgICAgICAgICAgIHBhdGg6IHRyZWVEYXRhLnBhdGgsXG4gICAgICAgICAgICAgICAgICBnZXRMaW5lczogZnVuY3Rpb24gZ2V0TGluZXMoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyUGF0aCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50UGF0aCA9IHRyZWVEYXRhLnBhdGguc2xpY2UoMCwgLTEpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50TGluZXMgPSBwYXJlbnRQYXRoLm1hcChmdW5jdGlvbiAocCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjdXJyUGF0aC5wdXNoKHApO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBpc0xhc3QgPSBpbmRleCA9PT0gcGFyZW50UGF0aC5sZW5ndGggLSAxO1xuXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc05leHRTaWJsaW5nV2l0aENhY2hlKGN1cnJQYXRoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzTGFzdCA/IDRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIFRyZWVMaW5lS2luZC52ZXJ0aWNhbEJyYW5jaCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgOiAxXG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBUcmVlTGluZUtpbmQudmVydGljYWwgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzTGFzdCA/IDJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIFRyZWVMaW5lS2luZC5sYXN0ICovXG4gICAgICAgICAgICAgICAgICAgICAgICA6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIFRyZWVMaW5lS2luZC5ub25lICovXG4gICAgICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGZMaW5lO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNDaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICAgIHNlbGZMaW5lID0gcGFyZW50UGF0aC5sZW5ndGggPiAwID8gNlxuICAgICAgICAgICAgICAgICAgICAgIC8qIFRyZWVMaW5lS2luZC5ob3Jpem9udGFsQnJhbmNoICovXG4gICAgICAgICAgICAgICAgICAgICAgOiAzXG4gICAgICAgICAgICAgICAgICAgICAgLyogVHJlZUxpbmVLaW5kLnN0YXJ0ICovXG4gICAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHNlbGZMaW5lID0gcGFyZW50UGF0aC5sZW5ndGggPiAwID8gNVxuICAgICAgICAgICAgICAgICAgICAgIC8qIFRyZWVMaW5lS2luZC5ob3Jpem9udGFsICovXG4gICAgICAgICAgICAgICAgICAgICAgOiA3XG4gICAgICAgICAgICAgICAgICAgICAgLyogVHJlZUxpbmVLaW5kLmxvbmUgKi9cbiAgICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50TGluZXMuY29uY2F0KHNlbGZMaW5lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gaGFzTmV4dFNpYmxpbmdXaXRoQ2FjaGUocGFyZW50UGF0aCkge1xuICAgICAgICAgICAgICAgICAgdmFyIGhhcyA9IGhhc05leHRTaWJsaW5nRnJvbUNhY2hlKGN1cnJJbmRleCwgcGFyZW50UGF0aC5sZW5ndGgpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoaGFzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhcztcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGhhc05leHRTaWJsaW5nKHBhcmVudFBhdGgpO1xuXG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IGN1cnJJbmRleDsgaW5kZXggPCByZXN1bHQuZW5kOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldE5leHRTaWJsaW5nVG9DYWNoZShpbmRleCwgcGFyZW50UGF0aC5sZW5ndGgsIHJlc3VsdC5oYXMpO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LmhhcztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBoYXNOZXh0U2libGluZ0Zyb21DYWNoZShpbmRleCwgbGV2ZWwpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBfcmVmNDggPSBjYWNoZVtpbmRleF0gfHwgKGNhY2hlW2luZGV4XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgaGFzTmV4dFNpYmxpbmdzOiBbXVxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgaGFzTmV4dFNpYmxpbmdzID0gX3JlZjQ4Lmhhc05leHRTaWJsaW5ncztcblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhc05leHRTaWJsaW5nc1tsZXZlbF07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gc2V0TmV4dFNpYmxpbmdUb0NhY2hlKGluZGV4LCBsZXZlbCwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBfcmVmNDkgPSBjYWNoZVtpbmRleF0gfHwgKGNhY2hlW2luZGV4XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgaGFzTmV4dFNpYmxpbmdzOiBbXVxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgaGFzTmV4dFNpYmxpbmdzID0gX3JlZjQ5Lmhhc05leHRTaWJsaW5ncztcblxuICAgICAgICAgICAgICAgICAgaGFzTmV4dFNpYmxpbmdzW2xldmVsXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGhhc05leHRTaWJsaW5nKHBhcmVudFBhdGgpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gY3VyckluZGV4ICsgMTtcblxuICAgICAgICAgICAgICAgICAgdmFyIF9sb29wNSA9IGZ1bmN0aW9uIF9sb29wNShpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IGRhdGFTb3VyY2UuZ2V0RmllbGQoaW5kZXgsIGZpZWxkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCB1dGlsc18xLmlzUHJvbWlzZSkoZGF0YSkpIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgdjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhczogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0UGF0aCA9IGdldFBhcmVudFBhdGgoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbmV4dFBhdGgubGVuZ3RoKSByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgIHY6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXM6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRQYXRoLmV2ZXJ5KGZ1bmN0aW9uIChwLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHAgPT09IG5leHRQYXRoW2ldO1xuICAgICAgICAgICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbCBtYXRjaGVzIVxuICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRQYXRoLmxlbmd0aCA8IG5leHRQYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSXQncyBhIGNoaWxkLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZS5nLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8g4pScIHRhcmdldFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8g4pSCIOKUnCBuZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGFzID0gaGFzTmV4dFNpYmxpbmdGcm9tQ2FjaGUoaW5kZXgsIHBhcmVudFBhdGgubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXMgIT0gbnVsbCkgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzOiBoYXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XG4gICAgICAgICAgICAgICAgICAgICAgfSAvLyBUaGVyZSBpcyBuZXh0IHNpYmxpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgLy8gZS5nLlxuICAgICAgICAgICAgICAgICAgICAgIC8vIOKUnCB0YXJnZXRcbiAgICAgICAgICAgICAgICAgICAgICAvLyDilIIg4pScIHhcbiAgICAgICAgICAgICAgICAgICAgICAvLyDilIIg4pSUIHhcbiAgICAgICAgICAgICAgICAgICAgICAvLyDilJQgbmV4dFxuXG5cbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBoYXM6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9IC8vIFRoZXJlIGlzIG5vIG5leHQgc2libGluZy5cbiAgICAgICAgICAgICAgICAgICAgLy8gZS5nLlxuICAgICAgICAgICAgICAgICAgICAvLyDilIIg4pSUIHRhcmdldFxuICAgICAgICAgICAgICAgICAgICAvLyDilIIgICDilJwgeFxuICAgICAgICAgICAgICAgICAgICAvLyDilIIgICDilJQgeFxuICAgICAgICAgICAgICAgICAgICAvLyDilJQgbmV4dFxuXG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICB2OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gc3RhcnRJbmRleDsgaW5kZXggPCBkYXRhU291cmNlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3JldCA9IF9sb29wNShpbmRleCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKF9yZXQgPT09IFwiY29udGludWVcIikgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdHlwZW9mKF9yZXQpID09PSBcIm9iamVjdFwiKSByZXR1cm4gX3JldC52O1xuICAgICAgICAgICAgICAgICAgfSAvLyBUaGVyZSBpcyBubyBuZXh0IHNpYmxpbmcuXG5cblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBkYXRhU291cmNlLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgaGFzOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIFRyZWVDb2x1bW5JbmZvO1xuICAgICAgICAgIH0oKTtcblxuICAgICAgICAgIGZ1bmN0aW9uIGdldFRyZWVEYXRhRnJvbVZhbHVlKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuXG4gICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0VHJlZURhdGFGcm9tVmFsdWUoe1xuICAgICAgICAgICAgICAgICAgcGF0aDogdmFsdWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZS5wYXRoKSkgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIGNhcHRpb246IFN0cmluZygoX2IgPSAoX2EgPSB2YWx1ZS5jYXB0aW9uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB2YWx1ZS5wYXRoW3ZhbHVlLnBhdGgubGVuZ3RoIC0gMV0pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFwiXCIpLFxuICAgICAgICAgICAgICAgICAgcGF0aDogdmFsdWUucGF0aCxcbiAgICAgICAgICAgICAgICAgIG5vZGVUeXBlOiB2YWx1ZS5ub2RlVHlwZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZS5wYXRoID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBnZXRUcmVlRGF0YUZyb21WYWx1ZShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHZhbHVlKSwge1xuICAgICAgICAgICAgICAgICAgcGF0aDogdmFsdWUucGF0aCgpXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGNhcHRpb246IFN0cmluZyh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdm9pZCAwID8gdmFsdWUgOiBcIlwiKSxcbiAgICAgICAgICAgICAgcGF0aDogW3ZhbHVlXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBnZXRQYXJlbnRQYXRoKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0VHJlZURhdGFGcm9tVmFsdWUodmFsdWUpLnBhdGguc2xpY2UoMCwgLTEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBEcmF3bkljb25zID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIERyYXduSWNvbnMoKSB7XG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEcmF3bkljb25zKTtcblxuICAgICAgICAgICAgICB0aGlzLl9kcmF3bkljb25zID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoRHJhd25JY29ucywgW3tcbiAgICAgICAgICAgICAga2V5OiBcInNldFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KGNlbGwsIGNsaXBSZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhd25JY29ucy5zZXQoXCJcIi5jb25jYXQoY2VsbC5jb2wsIFwiOlwiKS5jb25jYXQoY2VsbC5yb3cpLCBjbGlwUmVjdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImRlbGV0ZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2RlbGV0ZShjZWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhd25JY29ucy5kZWxldGUoXCJcIi5jb25jYXQoY2VsbC5jb2wsIFwiOlwiKS5jb25jYXQoY2VsbC5yb3cpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiYXJlYVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYXJlYShfcmVmNTApIHtcbiAgICAgICAgICAgICAgICB2YXIgY29sID0gX3JlZjUwLmNvbCxcbiAgICAgICAgICAgICAgICAgICAgcm93ID0gX3JlZjUwLnJvdyxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQgPSBfcmVmNTAucG9pbnRJbkRyYXdpbmdDYW52YXM7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IFwiXCIuY29uY2F0KGNvbCwgXCI6XCIpLmNvbmNhdChyb3cpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHJlY3QgPSB0aGlzLl9kcmF3bkljb25zLmdldChrZXkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFyZWN0KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY3QubGVmdCA8PSBwb2ludC54ICYmIHBvaW50LnggPD0gcmVjdC5yaWdodCAmJiByZWN0LnRvcCA8PSBwb2ludC55ICYmIHBvaW50LnkgPD0gcmVjdC5ib3R0b207XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIERyYXduSWNvbnM7XG4gICAgICAgICAgfSgpO1xuICAgICAgICAgIC8qKiovXG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vY29sdW1ucy90eXBlL2NvbHVtblV0aWxzLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2NvbHVtbnMvdHlwZS9jb2x1bW5VdGlscy5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBjb2x1bW5zVHlwZUNvbHVtblV0aWxzSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICB2YXIgX19jcmVhdGVCaW5kaW5nID0gdGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZyB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICAgICAgICAgICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcblxuICAgICAgICAgICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgICAgICAgICAgZGVzYyA9IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ba107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xuICAgICAgICAgIH0gOiBmdW5jdGlvbiAobywgbSwgaywgazIpIHtcbiAgICAgICAgICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgICAgICAgICBvW2syXSA9IG1ba107XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gdGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCB2KSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHtcbiAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gOiBmdW5jdGlvbiAobywgdikge1xuICAgICAgICAgICAgb1tcImRlZmF1bHRcIl0gPSB2O1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIF9faW1wb3J0U3RhciA9IHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgICAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIHtcbiAgICAgICAgICAgICAgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5sb2FkSWNvbnMgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgaWNvbnMgPSBfX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vaW50ZXJuYWwvaWNvbnMgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvaWNvbnMuanNcIikpO1xuXG4gICAgICAgICAgdmFyIHV0aWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi9pbnRlcm5hbC91dGlscyAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC91dGlscy5qc1wiKTtcblxuICAgICAgICAgIGZ1bmN0aW9uIGxvYWRJY29ucyhpY29uLCBjb250ZXh0LCBoZWxwZXIsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgYXJnSWNvbiA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgaWYgKGljb24pIHtcbiAgICAgICAgICAgICAgaWYgKCgwLCB1dGlsc18xLmlzUHJvbWlzZSkoaWNvbikpIHtcbiAgICAgICAgICAgICAgICBpY29uLnRoZW4oZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICAgIGxvYWRJY29ucyhpLCBjb250ZXh0LnRvQ3VycmVudENvbnRleHQoKSwgaGVscGVyLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGljb25MaXN0ID0gaWNvbnMudG9Ob3JtYWxpemVBcnJheShpY29uKTtcbiAgICAgICAgICAgICAgICBpY29uTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaS5mb250ICYmIGkuY29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICBoZWxwZXIudGVzdEZvbnRMb2FkKGkuZm9udCwgaS5jb250ZW50LCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhcmdJY29uID0gaWNvbkxpc3Q7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FsbGJhY2soYXJnSWNvbiwgY29udGV4dCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5sb2FkSWNvbnMgPSBsb2FkSWNvbnM7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vY29sdW1ucy91dGlscy9pbmRleC5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vY29sdW1ucy91dGlscy9pbmRleC5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gY29sdW1uc1V0aWxzSW5kZXhKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLnRvQm9vbGVhbiA9IHZvaWQgMDtcblxuICAgICAgICAgIGZ1bmN0aW9uIHRvQm9vbGVhbih2YWwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgIGlmICh2YWwgPT09IFwiZmFsc2VcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWwgPT09IFwib2ZmXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoL14wKyQvLmV4ZWModmFsKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gQm9vbGVhbih2YWwpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMudG9Cb29sZWFuID0gdG9Cb29sZWFuO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2NvcmUuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2NvcmUuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGNvcmVKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLkVWRU5UX1RZUEUgPSBleHBvcnRzLkRyYXdHcmlkID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIERyYXdHcmlkXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL2NvcmUvRHJhd0dyaWQgKi9cbiAgICAgICAgICBcIi4vY29yZS9EcmF3R3JpZC5qc1wiKTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRyYXdHcmlkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIERyYXdHcmlkXzEuRHJhd0dyaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgREdfRVZFTlRfVFlQRV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9jb3JlL0RHX0VWRU5UX1RZUEUgKi9cbiAgICAgICAgICBcIi4vY29yZS9ER19FVkVOVF9UWVBFLmpzXCIpO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRVZFTlRfVFlQRVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBER19FVkVOVF9UWVBFXzEuREdfRVZFTlRfVFlQRTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9jb3JlL0RHX0VWRU5UX1RZUEUuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vY29yZS9ER19FVkVOVF9UWVBFLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGNvcmVER19FVkVOVF9UWVBFSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5ER19FVkVOVF9UWVBFID0gdm9pZCAwO1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIERyYXdHcmlkIGV2ZW50IHR5cGVzXG4gICAgICAgICAgICogQGNsYXNzZGVzYyBjaGVldGFoR3JpZC5jb3JlLkVWRU5UX1RZUEVcbiAgICAgICAgICAgKiBAbWVtYmVyb2YgY2hlZXRhaEdyaWQuY29yZVxuICAgICAgICAgICAqL1xuXG4gICAgICAgICAgZXhwb3J0cy5ER19FVkVOVF9UWVBFID0ge1xuICAgICAgICAgICAgQ0xJQ0tfQ0VMTDogXCJjbGlja19jZWxsXCIsXG4gICAgICAgICAgICBEQkxDTElDS19DRUxMOiBcImRibGNsaWNrX2NlbGxcIixcbiAgICAgICAgICAgIERCTFRBUF9DRUxMOiBcImRibHRhcF9jZWxsXCIsXG4gICAgICAgICAgICBNT1VTRURPV05fQ0VMTDogXCJtb3VzZWRvd25fY2VsbFwiLFxuICAgICAgICAgICAgTU9VU0VVUF9DRUxMOiBcIm1vdXNldXBfY2VsbFwiLFxuICAgICAgICAgICAgU0VMRUNURURfQ0VMTDogXCJzZWxlY3RlZF9jZWxsXCIsXG4gICAgICAgICAgICBLRVlET1dOOiBcImtleWRvd25cIixcbiAgICAgICAgICAgIE1PVVNFTU9WRV9DRUxMOiBcIm1vdXNlbW92ZV9jZWxsXCIsXG4gICAgICAgICAgICBNT1VTRUVOVEVSX0NFTEw6IFwibW91c2VlbnRlcl9jZWxsXCIsXG4gICAgICAgICAgICBNT1VTRUxFQVZFX0NFTEw6IFwibW91c2VsZWF2ZV9jZWxsXCIsXG4gICAgICAgICAgICBNT1VTRU9WRVJfQ0VMTDogXCJtb3VzZW92ZXJfY2VsbFwiLFxuICAgICAgICAgICAgTU9VU0VPVVRfQ0VMTDogXCJtb3VzZW91dF9jZWxsXCIsXG4gICAgICAgICAgICBUT1VDSFNUQVJUX0NFTEw6IFwidG91Y2hzdGFydF9jZWxsXCIsXG4gICAgICAgICAgICBDT05URVhUTUVOVV9DRUxMOiBcImNvbnRleHRtZW51X2NlbGxcIixcbiAgICAgICAgICAgIElOUFVUX0NFTEw6IFwiaW5wdXRfY2VsbFwiLFxuICAgICAgICAgICAgUEFTVEVfQ0VMTDogXCJwYXN0ZV9jZWxsXCIsXG4gICAgICAgICAgICBERUxFVEVfQ0VMTDogXCJkZWxldGVfY2VsbFwiLFxuICAgICAgICAgICAgRURJVEFCTEVJTlBVVF9DRUxMOiBcImVkaXRhYmxlaW5wdXRfY2VsbFwiLFxuICAgICAgICAgICAgTU9ESUZZX1NUQVRVU19FRElUQUJMRUlOUFVUX0NFTEw6IFwibW9kaWZ5X3N0YXR1c19lZGl0YWJsZWlucHV0X2NlbGxcIixcbiAgICAgICAgICAgIFJFU0laRV9DT0xVTU46IFwicmVzaXplX2NvbHVtblwiLFxuICAgICAgICAgICAgU0NST0xMOiBcInNjcm9sbFwiLFxuICAgICAgICAgICAgRk9DVVNfR1JJRDogXCJmb2N1c19ncmlkXCIsXG4gICAgICAgICAgICBCTFVSX0dSSUQ6IFwiYmx1cl9ncmlkXCJcbiAgICAgICAgICB9O1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2NvcmUvRHJhd0dyaWQuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2NvcmUvRHJhd0dyaWQuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGNvcmVEcmF3R3JpZEpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgdmFyIF9fY3JlYXRlQmluZGluZyA9IHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcgfHwgKE9iamVjdC5jcmVhdGUgPyBmdW5jdGlvbiAobywgbSwgaywgazIpIHtcbiAgICAgICAgICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG5cbiAgICAgICAgICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICAgICAgICAgIGRlc2MgPSB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBtW2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbiAgICAgICAgICB9IDogZnVuY3Rpb24gKG8sIG0sIGssIGsyKSB7XG4gICAgICAgICAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgICAgICAgICAgb1trMl0gPSBtW2tdO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQgfHwgKE9iamVjdC5jcmVhdGUgPyBmdW5jdGlvbiAobywgdikge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7XG4gICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgIHZhbHVlOiB2XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IDogZnVuY3Rpb24gKG8sIHYpIHtcbiAgICAgICAgICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBfX2ltcG9ydFN0YXIgPSB0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgICAgICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgICAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSB7XG4gICAgICAgICAgICAgIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuRHJhd0dyaWQgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgY2FsYyA9IF9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi9pbnRlcm5hbC9jYWxjICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL2NhbGMuanNcIikpO1xuXG4gICAgICAgICAgdmFyIGhpRFBJID0gX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uL2ludGVybmFsL2hpRFBJICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL2hpRFBJLmpzXCIpKTtcblxuICAgICAgICAgIHZhciBzdHlsZSA9IF9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi9pbnRlcm5hbC9zdHlsZSAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC9zdHlsZS5qc1wiKSk7XG5cbiAgICAgICAgICB2YXIgdXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uL2ludGVybmFsL3V0aWxzICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL3V0aWxzLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIHBhc3RlX3V0aWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi9pbnRlcm5hbC9wYXN0ZS11dGlscyAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC9wYXN0ZS11dGlscy5qc1wiKTtcblxuICAgICAgICAgIHZhciBER19FVkVOVF9UWVBFXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL0RHX0VWRU5UX1RZUEUgKi9cbiAgICAgICAgICBcIi4vY29yZS9ER19FVkVOVF9UWVBFLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIEV2ZW50SGFuZGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vaW50ZXJuYWwvRXZlbnRIYW5kbGVyICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL0V2ZW50SGFuZGxlci5qc1wiKTtcblxuICAgICAgICAgIHZhciBFdmVudFRhcmdldF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9FdmVudFRhcmdldCAqL1xuICAgICAgICAgIFwiLi9jb3JlL0V2ZW50VGFyZ2V0LmpzXCIpO1xuXG4gICAgICAgICAgdmFyIE51bWJlck1hcF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vaW50ZXJuYWwvTnVtYmVyTWFwICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL051bWJlck1hcC5qc1wiKTtcblxuICAgICAgICAgIHZhciBSZWN0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi9pbnRlcm5hbC9SZWN0ICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL1JlY3QuanNcIik7XG5cbiAgICAgICAgICB2YXIgU2Nyb2xsYWJsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vaW50ZXJuYWwvU2Nyb2xsYWJsZSAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC9TY3JvbGxhYmxlLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIGNhbnZhc2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi9pbnRlcm5hbC9jYW52YXNlcyAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC9jYW52YXNlcy5qc1wiKTsgLy9wcm90ZWN0ZWQgc3ltYm9sXG5cblxuICAgICAgICAgIHZhciBzeW1ib2xNYW5hZ2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi9pbnRlcm5hbC9zeW1ib2xNYW5hZ2VyICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL3N5bWJvbE1hbmFnZXIuanNcIik7XG5cbiAgICAgICAgICB2YXIgX3V0aWxzXzEkZXZlbnQgPSB1dGlsc18xLmV2ZW50LFxuICAgICAgICAgICAgICBpc1RvdWNoRXZlbnQgPSBfdXRpbHNfMSRldmVudC5pc1RvdWNoRXZlbnQsXG4gICAgICAgICAgICAgIGdldE1vdXNlQnV0dG9ucyA9IF91dGlsc18xJGV2ZW50LmdldE1vdXNlQnV0dG9ucyxcbiAgICAgICAgICAgICAgZ2V0S2V5Q29kZSA9IF91dGlsc18xJGV2ZW50LmdldEtleUNvZGUsXG4gICAgICAgICAgICAgIGNhbmNlbEV2ZW50ID0gX3V0aWxzXzEkZXZlbnQuY2FuY2VsO1xuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gICAgICAgICAgdmFyIF8gPSAoMCwgc3ltYm9sTWFuYWdlcl8xLmdldFByb3RlY3RlZFN5bWJvbCkoKTtcbiAgICAgICAgICAvKiogQHByaXZhdGUgKi9cblxuXG4gICAgICAgICAgZnVuY3Rpb24gY3JlYXRlUm9vdEVsZW1lbnQoKSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJjaGVldGFoLWdyaWRcIik7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cblxuICAgICAgICAgIHZhciBLRVlfQlMgPSA4O1xuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gICAgICAgICAgdmFyIEtFWV9UQUIgPSA5O1xuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gICAgICAgICAgdmFyIEtFWV9FTlRFUiA9IDEzO1xuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gICAgICAgICAgdmFyIEtFWV9FTkQgPSAzNTtcbiAgICAgICAgICAvKiogQHByaXZhdGUgKi9cblxuICAgICAgICAgIHZhciBLRVlfSE9NRSA9IDM2O1xuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gICAgICAgICAgdmFyIEtFWV9MRUZUID0gMzc7XG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cbiAgICAgICAgICB2YXIgS0VZX1VQID0gMzg7XG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cbiAgICAgICAgICB2YXIgS0VZX1JJR0hUID0gMzk7XG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cbiAgICAgICAgICB2YXIgS0VZX0RPV04gPSA0MDtcbiAgICAgICAgICAvKiogQHByaXZhdGUgKi9cblxuICAgICAgICAgIHZhciBLRVlfREVMID0gNDY7XG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cbiAgICAgICAgICB2YXIgS0VZX0FMUEhBX0EgPSA2NTtcbiAgICAgICAgICAvKiogQHByaXZhdGUgKi9cblxuICAgICAgICAgIHZhciBLRVlfQUxQSEFfQyA9IDY3O1xuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gICAgICAgICAgdmFyIEtFWV9BTFBIQV9WID0gODY7IC8vcHJpdmF0ZSBtZXRob2RzXG5cbiAgICAgICAgICAvKiogQHByaXZhdGUgKi9cblxuICAgICAgICAgIGZ1bmN0aW9uIF92aWJyYXRlKGUpIHtcbiAgICAgICAgICAgIGlmIChuYXZpZ2F0b3IudmlicmF0ZSAmJiBpc1RvdWNoRXZlbnQoZSkpIHtcbiAgICAgICAgICAgICAgbmF2aWdhdG9yLnZpYnJhdGUoNTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvKiogQHByaXZhdGUgKi9cblxuXG4gICAgICAgICAgZnVuY3Rpb24gX2dldFRhcmdldFJvd0F0KGFic29sdXRlWSkge1xuICAgICAgICAgICAgdmFyIF90aGlzNjEgPSB0aGlzO1xuXG4gICAgICAgICAgICB2YXIgaW50ZXJuYWwgPSB0aGlzLmdldFRhcmdldFJvd0F0SW50ZXJuYWwoYWJzb2x1dGVZKTtcblxuICAgICAgICAgICAgaWYgKGludGVybmFsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZmluZEJlZm9yZSA9IGZ1bmN0aW9uIGZpbmRCZWZvcmUoc3RhcnRSb3csIHN0YXJ0Qm90dG9tKSB7XG4gICAgICAgICAgICAgIHZhciBib3R0b20gPSBzdGFydEJvdHRvbTtcblxuICAgICAgICAgICAgICBmb3IgKHZhciByb3cgPSBzdGFydFJvdzsgcm93ID49IDA7IHJvdy0tKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IF9nZXRSb3dIZWlnaHQuY2FsbChfdGhpczYxLCByb3cpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHRvcCA9IGJvdHRvbSAtIGhlaWdodDtcblxuICAgICAgICAgICAgICAgIGlmICh0b3AgPD0gYWJzb2x1dGVZICYmIGFic29sdXRlWSA8IGJvdHRvbSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdG9wOiB0b3AsXG4gICAgICAgICAgICAgICAgICAgIHJvdzogcm93XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJvdHRvbSA9IHRvcDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGZpbmRBZnRlciA9IGZ1bmN0aW9uIGZpbmRBZnRlcihzdGFydFJvdywgc3RhcnRCb3R0b20pIHtcbiAgICAgICAgICAgICAgdmFyIHRvcCA9IHN0YXJ0Qm90dG9tIC0gX2dldFJvd0hlaWdodC5jYWxsKF90aGlzNjEsIHN0YXJ0Um93KTtcblxuICAgICAgICAgICAgICB2YXIgcm93Q291bnQgPSBfdGhpczYxW19dLnJvd0NvdW50O1xuXG4gICAgICAgICAgICAgIGZvciAodmFyIHJvdyA9IHN0YXJ0Um93OyByb3cgPCByb3dDb3VudDsgcm93KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gX2dldFJvd0hlaWdodC5jYWxsKF90aGlzNjEsIHJvdyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgX2JvdHRvbSA9IHRvcCArIGhlaWdodDtcblxuICAgICAgICAgICAgICAgIGlmICh0b3AgPD0gYWJzb2x1dGVZICYmIGFic29sdXRlWSA8IF9ib3R0b20pIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHRvcDogdG9wLFxuICAgICAgICAgICAgICAgICAgICByb3c6IHJvd1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0b3AgPSBfYm90dG9tO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgY2FuZGlkYXRlUm93ID0gTWF0aC5taW4oTWF0aC5jZWlsKGFic29sdXRlWSAvIHRoaXNbX10uZGVmYXVsdFJvd0hlaWdodCksIHRoaXMucm93Q291bnQgLSAxKTtcblxuICAgICAgICAgICAgdmFyIGJvdHRvbSA9IF9nZXRSb3dzSGVpZ2h0LmNhbGwodGhpcywgMCwgY2FuZGlkYXRlUm93KTtcblxuICAgICAgICAgICAgaWYgKGFic29sdXRlWSA+PSBib3R0b20pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZpbmRBZnRlcihjYW5kaWRhdGVSb3csIGJvdHRvbSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gZmluZEJlZm9yZShjYW5kaWRhdGVSb3csIGJvdHRvbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgICAgICAgICBmdW5jdGlvbiBfZ2V0VGFyZ2V0Q29sQXQoZ3JpZCwgYWJzb2x1dGVYKSB7XG4gICAgICAgICAgICB2YXIgbGVmdCA9IDA7XG4gICAgICAgICAgICB2YXIgY29sQ291bnQgPSBncmlkW19dLmNvbENvdW50O1xuXG4gICAgICAgICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBjb2xDb3VudDsgY29sKyspIHtcbiAgICAgICAgICAgICAgdmFyIHdpZHRoID0gX2dldENvbFdpZHRoKGdyaWQsIGNvbCk7XG5cbiAgICAgICAgICAgICAgdmFyIHJpZ2h0ID0gbGVmdCArIHdpZHRoO1xuXG4gICAgICAgICAgICAgIGlmIChyaWdodCA+IGFic29sdXRlWCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgICAgICAgY29sOiBjb2xcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbGVmdCA9IHJpZ2h0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cblxuICAgICAgICAgIGZ1bmN0aW9uIF9nZXRUYXJnZXRGcm96ZW5Sb3dBdChncmlkLCBhYnNvbHV0ZVkpIHtcbiAgICAgICAgICAgIGlmICghZ3JpZFtfXS5mcm96ZW5Sb3dDb3VudCkge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRvcCA9IGdyaWRbX10uc2Nyb2xsLnRvcDtcbiAgICAgICAgICAgIHZhciByb3dDb3VudCA9IGdyaWRbX10uZnJvemVuUm93Q291bnQ7XG5cbiAgICAgICAgICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IHJvd0NvdW50OyByb3crKykge1xuICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gX2dldFJvd0hlaWdodC5jYWxsKGdyaWQsIHJvdyk7XG5cbiAgICAgICAgICAgICAgdmFyIGJvdHRvbSA9IHRvcCArIGhlaWdodDtcblxuICAgICAgICAgICAgICBpZiAoYm90dG9tID4gYWJzb2x1dGVZKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIHRvcDogdG9wLFxuICAgICAgICAgICAgICAgICAgcm93OiByb3dcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdG9wID0gYm90dG9tO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cblxuICAgICAgICAgIGZ1bmN0aW9uIF9nZXRUYXJnZXRGcm96ZW5Db2xBdChncmlkLCBhYnNvbHV0ZVgpIHtcbiAgICAgICAgICAgIGlmICghZ3JpZFtfXS5mcm96ZW5Db2xDb3VudCkge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGxlZnQgPSBncmlkW19dLnNjcm9sbC5sZWZ0O1xuICAgICAgICAgICAgdmFyIGNvbENvdW50ID0gZ3JpZFtfXS5mcm96ZW5Db2xDb3VudDtcblxuICAgICAgICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgY29sQ291bnQ7IGNvbCsrKSB7XG4gICAgICAgICAgICAgIHZhciB3aWR0aCA9IF9nZXRDb2xXaWR0aChncmlkLCBjb2wpO1xuXG4gICAgICAgICAgICAgIHZhciByaWdodCA9IGxlZnQgKyB3aWR0aDtcblxuICAgICAgICAgICAgICBpZiAocmlnaHQgPiBhYnNvbHV0ZVgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICAgICAgICAgIGNvbDogY29sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGxlZnQgPSByaWdodDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgICAgICAgICBmdW5jdGlvbiBfZ2V0RnJvemVuUm93c1JlY3QoZ3JpZCkge1xuICAgICAgICAgICAgaWYgKCFncmlkW19dLmZyb3plblJvd0NvdW50KSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdG9wID0gZ3JpZFtfXS5zY3JvbGwudG9wO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IDA7XG4gICAgICAgICAgICB2YXIgcm93Q291bnQgPSBncmlkW19dLmZyb3plblJvd0NvdW50O1xuXG4gICAgICAgICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCByb3dDb3VudDsgcm93KyspIHtcbiAgICAgICAgICAgICAgaGVpZ2h0ICs9IF9nZXRSb3dIZWlnaHQuY2FsbChncmlkLCByb3cpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlY3RfMS5SZWN0KGdyaWRbX10uc2Nyb2xsLmxlZnQsIHRvcCwgZ3JpZFtfXS5jYW52YXMud2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgICAgICAgICBmdW5jdGlvbiBfZ2V0RnJvemVuQ29sc1JlY3QoZ3JpZCkge1xuICAgICAgICAgICAgaWYgKCFncmlkW19dLmZyb3plbkNvbENvdW50KSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbGVmdCA9IGdyaWRbX10uc2Nyb2xsLmxlZnQ7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSAwO1xuICAgICAgICAgICAgdmFyIGNvbENvdW50ID0gZ3JpZFtfXS5mcm96ZW5Db2xDb3VudDtcblxuICAgICAgICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgY29sQ291bnQ7IGNvbCsrKSB7XG4gICAgICAgICAgICAgIHdpZHRoICs9IF9nZXRDb2xXaWR0aChncmlkLCBjb2wpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlY3RfMS5SZWN0KGxlZnQsIGdyaWRbX10uc2Nyb2xsLnRvcCwgd2lkdGgsIGdyaWRbX10uY2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgICAgICAgICBmdW5jdGlvbiBfZ2V0Q2VsbERyYXdpbmcoZ3JpZCwgY29sLCByb3cpIHtcbiAgICAgICAgICAgIGlmICghZ3JpZFtfXS5kcmF3Q2VsbHNbcm93XSkge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGdyaWRbX10uZHJhd0NlbGxzW3Jvd11bY29sXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cblxuICAgICAgICAgIGZ1bmN0aW9uIF9wdXRDZWxsRHJhd2luZyhncmlkLCBjb2wsIHJvdywgY29udGV4dCkge1xuICAgICAgICAgICAgaWYgKCFncmlkW19dLmRyYXdDZWxsc1tyb3ddKSB7XG4gICAgICAgICAgICAgIGdyaWRbX10uZHJhd0NlbGxzW3Jvd10gPSB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ3JpZFtfXS5kcmF3Q2VsbHNbcm93XVtjb2xdID0gY29udGV4dDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cblxuICAgICAgICAgIGZ1bmN0aW9uIF9yZW1vdmVDZWxsRHJhd2luZyhncmlkLCBjb2wsIHJvdykge1xuICAgICAgICAgICAgaWYgKCFncmlkW19dLmRyYXdDZWxsc1tyb3ddKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVsZXRlIGdyaWRbX10uZHJhd0NlbGxzW3Jvd11bY29sXTtcblxuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKGdyaWRbX10uZHJhd0NlbGxzW3Jvd10pLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICBkZWxldGUgZ3JpZFtfXS5kcmF3Q2VsbHNbcm93XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cblxuICAgICAgICAgIGZ1bmN0aW9uIF9kcmF3Q2VsbChjdHgsIGNvbCwgYWJzb2x1dGVMZWZ0LCB3aWR0aCwgcm93LCBhYnNvbHV0ZVRvcCwgaGVpZ2h0LCB2aXNpYmxlUmVjdCwgc2tpcEFic29sdXRlVG9wLCBza2lwQWJzb2x1dGVMZWZ0LCBkcmF3TGF5ZXJzKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXM2MiA9IHRoaXM7XG5cbiAgICAgICAgICAgIHZhciByZWN0ID0gbmV3IFJlY3RfMS5SZWN0KGFic29sdXRlTGVmdCAtIHZpc2libGVSZWN0LmxlZnQsIGFic29sdXRlVG9wIC0gdmlzaWJsZVJlY3QudG9wLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIHZhciBkcmF3UmVjdCA9IFJlY3RfMS5SZWN0LmJvdW5kcyhNYXRoLm1heChhYnNvbHV0ZUxlZnQsIHNraXBBYnNvbHV0ZUxlZnQpIC0gdmlzaWJsZVJlY3QubGVmdCwgTWF0aC5tYXgoYWJzb2x1dGVUb3AsIHNraXBBYnNvbHV0ZVRvcCkgLSB2aXNpYmxlUmVjdC50b3AsIHJlY3QucmlnaHQsIHJlY3QuYm90dG9tKTtcblxuICAgICAgICAgICAgaWYgKGRyYXdSZWN0LmhlaWdodCA+IDAgJiYgZHJhd1JlY3Qud2lkdGggPiAwKSB7XG4gICAgICAgICAgICAgIGN0eC5zYXZlKCk7XG5cbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgY2VsbERyYXdpbmcgPSBfZ2V0Q2VsbERyYXdpbmcodGhpcywgY29sLCByb3cpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNlbGxEcmF3aW5nKSB7XG4gICAgICAgICAgICAgICAgICBjZWxsRHJhd2luZy5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgZGNDb250ZXh0ID0gbmV3IERyYXdDZWxsQ29udGV4dChjb2wsIHJvdywgY3R4LCByZWN0LCBkcmF3UmVjdCwgISFjZWxsRHJhd2luZywgdGhpc1tfXS5zZWxlY3Rpb24sIGRyYXdMYXllcnMpO1xuICAgICAgICAgICAgICAgIHZhciBwID0gdGhpcy5vbkRyYXdDZWxsKGNvbCwgcm93LCBkY0NvbnRleHQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCgwLCB1dGlsc18xLmlzUHJvbWlzZSkocCkpIHtcbiAgICAgICAgICAgICAgICAgIC8v6YGF5bu25o+P55S7XG4gICAgICAgICAgICAgICAgICBfcHV0Q2VsbERyYXdpbmcodGhpcywgY29sLCByb3csIGRjQ29udGV4dCk7XG5cbiAgICAgICAgICAgICAgICAgIHZhciBwQ29sID0gY29sO1xuXG4gICAgICAgICAgICAgICAgICBkY0NvbnRleHQuX2RlbGF5TW9kZSh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF9yZW1vdmVDZWxsRHJhd2luZyhfdGhpczYyLCBwQ29sLCByb3cpO1xuICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgIHAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRjQ29udGV4dC50ZXJtaW5hdGUoKTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgICAgICAgICBmdW5jdGlvbiBfZHJhd1JvdyhncmlkLCBjdHgsIGluaXRGcm96ZW5Db2wsIGluaXRDb2wsIGRyYXdSaWdodCwgcm93LCBhYnNvbHV0ZVRvcCwgaGVpZ2h0LCB2aXNpYmxlUmVjdCwgc2tpcEFic29sdXRlVG9wLCBkcmF3TGF5ZXJzKSB7XG4gICAgICAgICAgICB2YXIgY29sQ291bnQgPSBncmlkW19dLmNvbENvdW50O1xuXG4gICAgICAgICAgICB2YXIgZHJhd091dGVyID0gZnVuY3Rpb24gZHJhd091dGVyKGNvbCwgYWJzb2x1dGVMZWZ0KSB7XG4gICAgICAgICAgICAgIC8v44OH44O844K/56+E5Zuy5aSW44Gu5o+P55S7XG4gICAgICAgICAgICAgIGlmIChjb2wgPj0gY29sQ291bnQgLSAxICYmIGdyaWRbX10uY2FudmFzLndpZHRoID4gYWJzb2x1dGVMZWZ0IC0gdmlzaWJsZVJlY3QubGVmdCkge1xuICAgICAgICAgICAgICAgIHZhciBvdXRlckxlZnQgPSBhYnNvbHV0ZUxlZnQgLSB2aXNpYmxlUmVjdC5sZWZ0O1xuICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBncmlkLnVuZGVybGF5QmFja2dyb3VuZENvbG9yIHx8IFwiI0Y2RjZGNlwiO1xuICAgICAgICAgICAgICAgIGN0eC5yZWN0KG91dGVyTGVmdCwgYWJzb2x1dGVUb3AgLSB2aXNpYmxlUmVjdC50b3AsIGdyaWRbX10uY2FudmFzLndpZHRoIC0gb3V0ZXJMZWZ0LCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIHNraXBBYnNvbHV0ZUxlZnQgPSAwO1xuXG4gICAgICAgICAgICBpZiAoaW5pdEZyb3plbkNvbCkge1xuICAgICAgICAgICAgICB2YXIgX2Fic29sdXRlTGVmdCA9IGluaXRGcm96ZW5Db2wubGVmdDtcbiAgICAgICAgICAgICAgdmFyIGNvdW50ID0gZ3JpZFtfXS5mcm96ZW5Db2xDb3VudDtcblxuICAgICAgICAgICAgICBmb3IgKHZhciBjb2wgPSBpbml0RnJvemVuQ29sLmNvbDsgY29sIDwgY291bnQ7IGNvbCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gX2dldENvbFdpZHRoKGdyaWQsIGNvbCk7XG5cbiAgICAgICAgICAgICAgICBfZHJhd0NlbGwuY2FsbChncmlkLCBjdHgsIGNvbCwgX2Fic29sdXRlTGVmdCwgd2lkdGgsIHJvdywgYWJzb2x1dGVUb3AsIGhlaWdodCwgdmlzaWJsZVJlY3QsIHNraXBBYnNvbHV0ZVRvcCwgMCwgZHJhd0xheWVycyk7XG5cbiAgICAgICAgICAgICAgICBfYWJzb2x1dGVMZWZ0ICs9IHdpZHRoO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRyYXdSaWdodCA8PSBfYWJzb2x1dGVMZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAvL+aPj+eUu+evhOWbsuWklu+8iOe1guS6hu+8iVxuICAgICAgICAgICAgICAgICAgZHJhd091dGVyKGNvbCwgX2Fic29sdXRlTGVmdCk7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgc2tpcEFic29sdXRlTGVmdCA9IF9hYnNvbHV0ZUxlZnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBhYnNvbHV0ZUxlZnQgPSBpbml0Q29sLmxlZnQ7XG5cbiAgICAgICAgICAgIGZvciAodmFyIF9jb2wyID0gaW5pdENvbC5jb2w7IF9jb2wyIDwgY29sQ291bnQ7IF9jb2wyKyspIHtcbiAgICAgICAgICAgICAgdmFyIF93aWR0aDIgPSBfZ2V0Q29sV2lkdGgoZ3JpZCwgX2NvbDIpO1xuXG4gICAgICAgICAgICAgIF9kcmF3Q2VsbC5jYWxsKGdyaWQsIGN0eCwgX2NvbDIsIGFic29sdXRlTGVmdCwgX3dpZHRoMiwgcm93LCBhYnNvbHV0ZVRvcCwgaGVpZ2h0LCB2aXNpYmxlUmVjdCwgc2tpcEFic29sdXRlVG9wLCBza2lwQWJzb2x1dGVMZWZ0LCBkcmF3TGF5ZXJzKTtcblxuICAgICAgICAgICAgICBhYnNvbHV0ZUxlZnQgKz0gX3dpZHRoMjtcblxuICAgICAgICAgICAgICBpZiAoZHJhd1JpZ2h0IDw9IGFic29sdXRlTGVmdCkge1xuICAgICAgICAgICAgICAgIC8v5o+P55S756+E5Zuy5aSW77yI57WC5LqG77yJXG4gICAgICAgICAgICAgICAgZHJhd091dGVyKF9jb2wyLCBhYnNvbHV0ZUxlZnQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkcmF3T3V0ZXIoY29sQ291bnQgLSAxLCBhYnNvbHV0ZUxlZnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKiogQHByaXZhdGUgKi9cblxuXG4gICAgICAgICAgZnVuY3Rpb24gX2dldEluaXRDb250ZXh0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldEluaXRDb250ZXh0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgICAgICAgICBmdW5jdGlvbiBfaW52YWxpZGF0ZVJlY3QoZ3JpZCwgZHJhd1JlY3QpIHtcbiAgICAgICAgICAgIHZhciB2aXNpYmxlUmVjdCA9IF9nZXRWaXNpYmxlUmVjdChncmlkKTtcblxuICAgICAgICAgICAgdmFyIHJvd0NvdW50ID0gZ3JpZFtfXS5yb3dDb3VudDtcblxuICAgICAgICAgICAgdmFyIGN0eCA9IF9nZXRJbml0Q29udGV4dC5jYWxsKGdyaWQpO1xuXG4gICAgICAgICAgICB2YXIgaW5pdFJvdyA9IF9nZXRUYXJnZXRSb3dBdC5jYWxsKGdyaWQsIE1hdGgubWF4KHZpc2libGVSZWN0LnRvcCwgZHJhd1JlY3QudG9wKSkgfHwge1xuICAgICAgICAgICAgICB0b3A6IF9nZXRSb3dzSGVpZ2h0LmNhbGwoZ3JpZCwgMCwgcm93Q291bnQgLSAxKSxcbiAgICAgICAgICAgICAgcm93OiByb3dDb3VudFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBpbml0Q29sID0gX2dldFRhcmdldENvbEF0KGdyaWQsIE1hdGgubWF4KHZpc2libGVSZWN0LmxlZnQsIGRyYXdSZWN0LmxlZnQpKSB8fCB7XG4gICAgICAgICAgICAgIGxlZnQ6IF9nZXRDb2xzV2lkdGgoZ3JpZCwgMCwgZ3JpZFtfXS5jb2xDb3VudCAtIDEpLFxuICAgICAgICAgICAgICBjb2w6IGdyaWRbX10uY29sQ291bnRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgZHJhd0JvdHRvbSA9IE1hdGgubWluKHZpc2libGVSZWN0LmJvdHRvbSwgZHJhd1JlY3QuYm90dG9tKTtcbiAgICAgICAgICAgIHZhciBkcmF3UmlnaHQgPSBNYXRoLm1pbih2aXNpYmxlUmVjdC5yaWdodCwgZHJhd1JlY3QucmlnaHQpO1xuXG4gICAgICAgICAgICB2YXIgaW5pdEZyb3plblJvdyA9IF9nZXRUYXJnZXRGcm96ZW5Sb3dBdChncmlkLCBNYXRoLm1heCh2aXNpYmxlUmVjdC50b3AsIGRyYXdSZWN0LnRvcCkpO1xuXG4gICAgICAgICAgICB2YXIgaW5pdEZyb3plbkNvbCA9IF9nZXRUYXJnZXRGcm96ZW5Db2xBdChncmlkLCBNYXRoLm1heCh2aXNpYmxlUmVjdC5sZWZ0LCBkcmF3UmVjdC5sZWZ0KSk7XG5cbiAgICAgICAgICAgIHZhciBkcmF3TGF5ZXJzID0gbmV3IERyYXdMYXllcnMoKTtcblxuICAgICAgICAgICAgdmFyIGRyYXdPdXRlciA9IGZ1bmN0aW9uIGRyYXdPdXRlcihyb3csIGFic29sdXRlVG9wKSB7XG4gICAgICAgICAgICAgIC8v44OH44O844K/56+E5Zuy5aSW44Gu5o+P55S7XG4gICAgICAgICAgICAgIGlmIChyb3cgPj0gcm93Q291bnQgLSAxICYmIGdyaWRbX10uY2FudmFzLmhlaWdodCA+IGFic29sdXRlVG9wIC0gdmlzaWJsZVJlY3QudG9wKSB7XG4gICAgICAgICAgICAgICAgdmFyIG91dGVyVG9wID0gYWJzb2x1dGVUb3AgLSB2aXNpYmxlUmVjdC50b3A7XG4gICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGdyaWQudW5kZXJsYXlCYWNrZ3JvdW5kQ29sb3IgfHwgXCIjRjZGNkY2XCI7XG4gICAgICAgICAgICAgICAgY3R4LnJlY3QoMCwgb3V0ZXJUb3AsIGdyaWRbX10uY2FudmFzLndpZHRoLCBncmlkW19dLmNhbnZhcy5oZWlnaHQgLSBvdXRlclRvcCk7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgc2tpcEFic29sdXRlVG9wID0gMDtcblxuICAgICAgICAgICAgaWYgKGluaXRGcm96ZW5Sb3cpIHtcbiAgICAgICAgICAgICAgdmFyIF9hYnNvbHV0ZVRvcCA9IGluaXRGcm96ZW5Sb3cudG9wO1xuICAgICAgICAgICAgICB2YXIgY291bnQgPSBncmlkW19dLmZyb3plblJvd0NvdW50O1xuXG4gICAgICAgICAgICAgIGZvciAodmFyIHJvdyA9IGluaXRGcm96ZW5Sb3cucm93OyByb3cgPCBjb3VudDsgcm93KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gX2dldFJvd0hlaWdodC5jYWxsKGdyaWQsIHJvdyk7XG5cbiAgICAgICAgICAgICAgICBfZHJhd1JvdyhncmlkLCBjdHgsIGluaXRGcm96ZW5Db2wsIGluaXRDb2wsIGRyYXdSaWdodCwgcm93LCBfYWJzb2x1dGVUb3AsIGhlaWdodCwgdmlzaWJsZVJlY3QsIDAsIGRyYXdMYXllcnMpO1xuXG4gICAgICAgICAgICAgICAgX2Fic29sdXRlVG9wICs9IGhlaWdodDtcblxuICAgICAgICAgICAgICAgIGlmIChkcmF3Qm90dG9tIDw9IF9hYnNvbHV0ZVRvcCkge1xuICAgICAgICAgICAgICAgICAgLy/mj4/nlLvnr4Tlm7LlpJbvvIjntYLkuobvvIlcbiAgICAgICAgICAgICAgICAgIGRyYXdPdXRlcihyb3csIF9hYnNvbHV0ZVRvcCk7XG4gICAgICAgICAgICAgICAgICBkcmF3TGF5ZXJzLmRyYXcoY3R4KTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBza2lwQWJzb2x1dGVUb3AgPSBfYWJzb2x1dGVUb3A7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBhYnNvbHV0ZVRvcCA9IGluaXRSb3cudG9wO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBfcm93MiA9IGluaXRSb3cucm93OyBfcm93MiA8IHJvd0NvdW50OyBfcm93MisrKSB7XG4gICAgICAgICAgICAgIHZhciBfaGVpZ2h0MiA9IF9nZXRSb3dIZWlnaHQuY2FsbChncmlkLCBfcm93Mik7IC8v6KGM44Gu5o+P55S7XG5cblxuICAgICAgICAgICAgICBfZHJhd1JvdyhncmlkLCBjdHgsIGluaXRGcm96ZW5Db2wsIGluaXRDb2wsIGRyYXdSaWdodCwgX3JvdzIsIGFic29sdXRlVG9wLCBfaGVpZ2h0MiwgdmlzaWJsZVJlY3QsIHNraXBBYnNvbHV0ZVRvcCwgZHJhd0xheWVycyk7XG5cbiAgICAgICAgICAgICAgYWJzb2x1dGVUb3AgKz0gX2hlaWdodDI7XG5cbiAgICAgICAgICAgICAgaWYgKGRyYXdCb3R0b20gPD0gYWJzb2x1dGVUb3ApIHtcbiAgICAgICAgICAgICAgICAvL+aPj+eUu+evhOWbsuWklu+8iOe1guS6hu+8iVxuICAgICAgICAgICAgICAgIGRyYXdPdXRlcihfcm93MiwgYWJzb2x1dGVUb3ApO1xuICAgICAgICAgICAgICAgIGRyYXdMYXllcnMuZHJhdyhjdHgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkcmF3T3V0ZXIocm93Q291bnQgLSAxLCBhYnNvbHV0ZVRvcCk7XG4gICAgICAgICAgICBkcmF3TGF5ZXJzLmRyYXcoY3R4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cblxuICAgICAgICAgIGZ1bmN0aW9uIF90b1B4V2lkdGgoZ3JpZCwgd2lkdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKGNhbGMudG9QeCh3aWR0aCwgZ3JpZFtfXS5jYWxjV2lkdGhDb250ZXh0KSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgICAgICAgICBmdW5jdGlvbiBfYWRqdXN0Q29sV2lkdGgoZ3JpZCwgY29sLCBvcmdXaWR0aCkge1xuICAgICAgICAgICAgdmFyIGxpbWl0cyA9IF9nZXRDb2xXaWR0aExpbWl0cyhncmlkLCBjb2wpO1xuXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoX2FwcGx5Q29sV2lkdGhMaW1pdHMobGltaXRzLCBvcmdXaWR0aCksIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKiogQHByaXZhdGUgKi9cblxuXG4gICAgICAgICAgZnVuY3Rpb24gX2FwcGx5Q29sV2lkdGhMaW1pdHMobGltaXRzLCBvcmdXaWR0aCkge1xuICAgICAgICAgICAgaWYgKCFsaW1pdHMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG9yZ1dpZHRoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobGltaXRzLm1pbikge1xuICAgICAgICAgICAgICBpZiAobGltaXRzLm1pbiA+IG9yZ1dpZHRoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpbWl0cy5taW47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxpbWl0cy5tYXgpIHtcbiAgICAgICAgICAgICAgaWYgKGxpbWl0cy5tYXggPCBvcmdXaWR0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsaW1pdHMubWF4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvcmdXaWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogR2V0cyB0aGUgZGVmaW5pdGlvbiBvZiB0aGUgY29sdW1uIHdpZHRoLlxuICAgICAgICAgICAqIEBwYXJhbSB7RHJhd0dyaWR9IGdyaWQgZ3JpZCBpbnN0YW5jZVxuICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2wgbnVtYmVyIG9mIGNvbHVtblxuICAgICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVtYmVyfSB3aWR0aCBkZWZpbml0aW9uXG4gICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgKi9cblxuXG4gICAgICAgICAgZnVuY3Rpb24gX2dldENvbFdpZHRoRGVmaW5lKGdyaWQsIGNvbCkge1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gZ3JpZFtfXS5jb2xXaWR0aHNNYXAuZ2V0KGNvbCk7XG5cbiAgICAgICAgICAgIGlmICh3aWR0aCkge1xuICAgICAgICAgICAgICByZXR1cm4gd2lkdGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBncmlkLmRlZmF1bHRDb2xXaWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogR2V0cyB0aGUgY29sdW1uIHdpZHRoIGxpbWl0cy5cbiAgICAgICAgICAgKiBAcGFyYW0ge0RyYXdHcmlkfSBncmlkIGdyaWQgaW5zdGFuY2VcbiAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sIG51bWJlciBvZiBjb2x1bW5cbiAgICAgICAgICAgKiBAcmV0dXJucyB7b2JqZWN0fG51bGx9IHRoZSBjb2x1bW4gd2lkdGggbGltaXRzXG4gICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgKi9cblxuXG4gICAgICAgICAgZnVuY3Rpb24gX2dldENvbFdpZHRoTGltaXRzKGdyaWQsIGNvbCkge1xuICAgICAgICAgICAgdmFyIGxpbWl0ID0gZ3JpZFtfXS5jb2xXaWR0aHNMaW1pdFtjb2xdO1xuXG4gICAgICAgICAgICBpZiAoIWxpbWl0KSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XG5cbiAgICAgICAgICAgIGlmIChsaW1pdC5taW4pIHtcbiAgICAgICAgICAgICAgcmVzdWx0Lm1pbiA9IF90b1B4V2lkdGgoZ3JpZCwgbGltaXQubWluKTtcbiAgICAgICAgICAgICAgcmVzdWx0Lm1pbkRlZiA9IGxpbWl0Lm1pbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxpbWl0Lm1heCkge1xuICAgICAgICAgICAgICByZXN1bHQubWF4ID0gX3RvUHhXaWR0aChncmlkLCBsaW1pdC5tYXgpO1xuICAgICAgICAgICAgICByZXN1bHQubWF4RGVmID0gbGltaXQubWF4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIHdpZHRoIGRlZmluaXRpb24gaXMgYGF1dG9gLlxuICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gd2lkdGggd2lkdGggZGVmaW5pdGlvbiB0byBjaGVja1xuICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZSBgIGlmIHRoZSBnaXZlbiB3aWR0aCBkZWZpbml0aW9uIGlzIGBhdXRvYFxuICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICovXG5cblxuICAgICAgICAgIGZ1bmN0aW9uIGlzQXV0b0RlZmluZSh3aWR0aCkge1xuICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4od2lkdGggJiYgdHlwZW9mIHdpZHRoID09PSBcInN0cmluZ1wiICYmIHdpZHRoLnRvTG93ZXJDYXNlKCkgPT09IFwiYXV0b1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQ3JlYXRlcyBhIGZvcm11bGEgdG8gY2FsY3VsYXRlIHRoZSBhdXRvIHdpZHRoLlxuICAgICAgICAgICAqIEBwYXJhbSB7RHJhd0dyaWR9IGdyaWQgZ3JpZCBpbnN0YW5jZVxuICAgICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IGZvcm11bGFcbiAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAqL1xuXG5cbiAgICAgICAgICBmdW5jdGlvbiBfY2FsY0F1dG9Db2xXaWR0aEV4cHIoZ3JpZCkge1xuICAgICAgICAgICAgdmFyIHNob3J0Q2lyY3VpdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICAgICAgICAgIHZhciBmdWxsV2lkdGggPSBncmlkW19dLmNhbGNXaWR0aENvbnRleHQuZnVsbDtcbiAgICAgICAgICAgIHZhciBzdW1NaW4gPSAwO1xuICAgICAgICAgICAgdmFyIG90aGVycyA9IFtdO1xuICAgICAgICAgICAgdmFyIGF1dG9Db3VudCA9IDA7XG4gICAgICAgICAgICB2YXIgaGFzTGltaXRzT25BdXRvID0gW107XG5cbiAgICAgICAgICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IGdyaWRbX10uY29sQ291bnQ7IGNvbCsrKSB7XG4gICAgICAgICAgICAgIHZhciBkZWYgPSBfZ2V0Q29sV2lkdGhEZWZpbmUoZ3JpZCwgY29sKTtcblxuICAgICAgICAgICAgICB2YXIgbGltaXRzID0gX2dldENvbFdpZHRoTGltaXRzKGdyaWQsIGNvbCk7XG5cbiAgICAgICAgICAgICAgaWYgKGlzQXV0b0RlZmluZShkZWYpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpbWl0cykge1xuICAgICAgICAgICAgICAgICAgaGFzTGltaXRzT25BdXRvLnB1c2gobGltaXRzKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKGxpbWl0cy5taW4pIHtcbiAgICAgICAgICAgICAgICAgICAgc3VtTWluICs9IGxpbWl0cy5taW47XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYXV0b0NvdW50Kys7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGV4cHIgPSBkZWY7XG5cbiAgICAgICAgICAgICAgICBpZiAobGltaXRzKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgb3JnV2lkdGggPSBfdG9QeFdpZHRoKGdyaWQsIGV4cHIpO1xuXG4gICAgICAgICAgICAgICAgICB2YXIgbmV3V2lkdGggPSBfYXBwbHlDb2xXaWR0aExpbWl0cyhsaW1pdHMsIG9yZ1dpZHRoKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKG9yZ1dpZHRoICE9PSBuZXdXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBleHByID0gXCJcIi5jb25jYXQobmV3V2lkdGgsIFwicHhcIik7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHN1bU1pbiArPSBuZXdXaWR0aDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBvdGhlcnMucHVzaChleHByKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChzaG9ydENpcmN1aXQgJiYgc3VtTWluID4gZnVsbFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgLy8gUmV0dXJucyAwcHggYmVjYXVzZSBpdCBoYXMgY29uc3VtZWQgdGhlIGZ1bGwgd2lkdGguXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiMHB4XCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGhhc0xpbWl0c09uQXV0by5sZW5ndGggJiYgb3RoZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICB2YXIgYXV0b1B4ID0gKGZ1bGxXaWR0aCAtIF90b1B4V2lkdGgoZ3JpZCwgXCJjYWxjKFwiLmNvbmNhdChvdGhlcnMubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBjID09PSBcIm51bWJlclwiID8gXCJcIi5jb25jYXQoYywgXCJweFwiKSA6IGM7XG4gICAgICAgICAgICAgIH0pLmpvaW4oXCIgKyBcIiksIFwiKVwiKSkpIC8gYXV0b0NvdW50O1xuICAgICAgICAgICAgICBoYXNMaW1pdHNPbkF1dG8uZm9yRWFjaChmdW5jdGlvbiAobGltaXRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpbWl0cy5taW4gJiYgYXV0b1B4IDwgbGltaXRzLm1pbikge1xuICAgICAgICAgICAgICAgICAgb3RoZXJzLnB1c2gobGltaXRzLm1pbkRlZik7XG4gICAgICAgICAgICAgICAgICBhdXRvQ291bnQtLTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxpbWl0cy5tYXggJiYgbGltaXRzLm1heCA8IGF1dG9QeCkge1xuICAgICAgICAgICAgICAgICAgb3RoZXJzLnB1c2gobGltaXRzLm1heERlZik7XG4gICAgICAgICAgICAgICAgICBhdXRvQ291bnQtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGlmIChzaG9ydENpcmN1aXQgJiYgYXV0b0NvdW50IDw9IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQoYXV0b1B4LCBcInB4XCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvdGhlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHZhciBzdHJEZWZzID0gW107XG4gICAgICAgICAgICAgIHZhciBudW0gPSAwO1xuICAgICAgICAgICAgICBvdGhlcnMuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgbnVtICs9IGM7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHN0ckRlZnMucHVzaChjKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBzdHJEZWZzLnB1c2goXCJcIi5jb25jYXQobnVtLCBcInB4XCIpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIFwiY2FsYygoMTAwJSAtIChcIi5jb25jYXQoc3RyRGVmcy5qb2luKFwiICsgXCIpLCBcIikpIC8gXCIpLmNvbmNhdChhdXRvQ291bnQsIFwiKVwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBcIlwiLmNvbmNhdCgxMDAgLyBhdXRvQ291bnQsIFwiJVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQ2FsY3VsYXRlIHRoZSBwaXhlbHMgb2Ygd2lkdGggZnJvbSB0aGUgZGVmaW5pdGlvbiBvZiB3aWR0aC5cbiAgICAgICAgICAgKiBAcGFyYW0ge0RyYXdHcmlkfSBncmlkIGdyaWQgaW5zdGFuY2VcbiAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHdpZHRoIHdpZHRoIGRlZmluaXRpb25cbiAgICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSB0aGUgcGl4ZWxzIG9mIHdpZHRoXG4gICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgKi9cblxuXG4gICAgICAgICAgZnVuY3Rpb24gX2NvbFdpZHRoRGVmaW5lVG9QeFdpZHRoKGdyaWQsIHdpZHRoKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRvRGVmaW5lKHdpZHRoKSkge1xuICAgICAgICAgICAgICByZXR1cm4gX3RvUHhXaWR0aChncmlkLCBfY2FsY0F1dG9Db2xXaWR0aEV4cHIoZ3JpZCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX3RvUHhXaWR0aChncmlkLCB3aWR0aCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgICAgICAgICBmdW5jdGlvbiBfZ2V0Q29sV2lkdGgoZ3JpZCwgY29sKSB7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBfZ2V0Q29sV2lkdGhEZWZpbmUoZ3JpZCwgY29sKTtcblxuICAgICAgICAgICAgcmV0dXJuIF9hZGp1c3RDb2xXaWR0aChncmlkLCBjb2wsIF9jb2xXaWR0aERlZmluZVRvUHhXaWR0aChncmlkLCB3aWR0aCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKiogQHByaXZhdGUgKi9cblxuXG4gICAgICAgICAgZnVuY3Rpb24gX3NldENvbFdpZHRoKGdyaWQsIGNvbCwgd2lkdGgpIHtcbiAgICAgICAgICAgIGlmICh3aWR0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGdyaWRbX10uY29sV2lkdGhzTWFwLnB1dChjb2wsIHdpZHRoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGdyaWRbX10uY29sV2lkdGhzTWFwLnJlbW92ZShjb2wpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBPdmVyd3JpdGVzIHRoZSBkZWZpbml0aW9uIG9mIGEgY29sdW1uIHdob3NlIHdpZHRoIGlzIHNldCB0byBgYXV0b2Agd2l0aCB0aGUgY3VycmVudCBhdXRvIHdpZHRoIGZvcm11bGEuXG4gICAgICAgICAgICogQHBhcmFtIHtEcmF3R3JpZH0gZ3JpZCBncmlkIGluc3RhbmNlXG4gICAgICAgICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgKi9cblxuXG4gICAgICAgICAgZnVuY3Rpb24gX3N0b3JlQXV0b0NvbFdpZHRoRXhwcnMoZ3JpZCkge1xuICAgICAgICAgICAgdmFyIGV4cHIgPSBudWxsO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBncmlkW19dLmNvbENvdW50OyBjb2wrKykge1xuICAgICAgICAgICAgICB2YXIgZGVmID0gX2dldENvbFdpZHRoRGVmaW5lKGdyaWQsIGNvbCk7XG5cbiAgICAgICAgICAgICAgaWYgKGlzQXV0b0RlZmluZShkZWYpKSB7XG4gICAgICAgICAgICAgICAgX3NldENvbFdpZHRoKGdyaWQsIGNvbCwgZXhwciB8fCAoZXhwciA9IF9jYWxjQXV0b0NvbFdpZHRoRXhwcihncmlkLCBmYWxzZSkpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvKiogQHByaXZhdGUgKi9cblxuXG4gICAgICAgICAgZnVuY3Rpb24gX2dldENvbHNXaWR0aChncmlkLCBzdGFydENvbCwgZW5kQ29sKSB7XG4gICAgICAgICAgICB2YXIgZGVmYXVsdENvbFB4V2lkdGggPSBfY29sV2lkdGhEZWZpbmVUb1B4V2lkdGgoZ3JpZCwgZ3JpZC5kZWZhdWx0Q29sV2lkdGgpO1xuXG4gICAgICAgICAgICB2YXIgY29sQ291bnQgPSBlbmRDb2wgLSBzdGFydENvbCArIDE7XG4gICAgICAgICAgICB2YXIgdyA9IGRlZmF1bHRDb2xQeFdpZHRoICogY29sQ291bnQ7XG5cbiAgICAgICAgICAgIGdyaWRbX10uY29sV2lkdGhzTWFwLmVhY2goc3RhcnRDb2wsIGVuZENvbCwgZnVuY3Rpb24gKHdpZHRoLCBjb2wpIHtcbiAgICAgICAgICAgICAgdyArPSBfYWRqdXN0Q29sV2lkdGgoZ3JpZCwgY29sLCBfY29sV2lkdGhEZWZpbmVUb1B4V2lkdGgoZ3JpZCwgd2lkdGgpKSAtIGRlZmF1bHRDb2xQeFdpZHRoO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGNvbCA9IHN0YXJ0Q29sOyBjb2wgPD0gZW5kQ29sOyBjb2wrKykge1xuICAgICAgICAgICAgICBpZiAoZ3JpZFtfXS5jb2xXaWR0aHNNYXAuaGFzKGNvbCkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBhZGogPSBfYWRqdXN0Q29sV2lkdGgoZ3JpZCwgY29sLCBkZWZhdWx0Q29sUHhXaWR0aCk7XG5cbiAgICAgICAgICAgICAgaWYgKGFkaiAhPT0gZGVmYXVsdENvbFB4V2lkdGgpIHtcbiAgICAgICAgICAgICAgICB3ICs9IGFkaiAtIGRlZmF1bHRDb2xQeFdpZHRoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB3O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKiogQHByaXZhdGUgKi9cblxuXG4gICAgICAgICAgZnVuY3Rpb24gX2dldFJvd0hlaWdodChyb3cpIHtcbiAgICAgICAgICAgIHZhciBpbnRlcm5hbCA9IHRoaXMuZ2V0Um93SGVpZ2h0SW50ZXJuYWwocm93KTtcblxuICAgICAgICAgICAgaWYgKGludGVybmFsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpc1tfXS5yb3dIZWlnaHRzTWFwLmdldChyb3cpO1xuXG4gICAgICAgICAgICBpZiAoaGVpZ2h0KSB7XG4gICAgICAgICAgICAgIHJldHVybiBoZWlnaHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzW19dLmRlZmF1bHRSb3dIZWlnaHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgICAgICAgICBmdW5jdGlvbiBfc2V0Um93SGVpZ2h0KGdyaWQsIHJvdywgaGVpZ2h0KSB7XG4gICAgICAgICAgICBpZiAoaGVpZ2h0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgZ3JpZFtfXS5yb3dIZWlnaHRzTWFwLnB1dChyb3csIGhlaWdodCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBncmlkW19dLnJvd0hlaWdodHNNYXAucmVtb3ZlKHJvdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgICAgICAgICBmdW5jdGlvbiBfZ2V0Um93c0hlaWdodChzdGFydFJvdywgZW5kUm93KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXM2MyA9IHRoaXM7XG5cbiAgICAgICAgICAgIHZhciBpbnRlcm5hbCA9IHRoaXMuZ2V0Um93c0hlaWdodEludGVybmFsKHN0YXJ0Um93LCBlbmRSb3cpO1xuXG4gICAgICAgICAgICBpZiAoaW50ZXJuYWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByb3dDb3VudCA9IGVuZFJvdyAtIHN0YXJ0Um93ICsgMTtcbiAgICAgICAgICAgIHZhciBoID0gdGhpc1tfXS5kZWZhdWx0Um93SGVpZ2h0ICogcm93Q291bnQ7XG5cbiAgICAgICAgICAgIHRoaXNbX10ucm93SGVpZ2h0c01hcC5lYWNoKHN0YXJ0Um93LCBlbmRSb3csIGZ1bmN0aW9uIChoZWlnaHQpIHtcbiAgICAgICAgICAgICAgaCArPSBoZWlnaHQgLSBfdGhpczYzW19dLmRlZmF1bHRSb3dIZWlnaHQ7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgICAgICAgICBmdW5jdGlvbiBfZ2V0U2Nyb2xsV2lkdGgoZ3JpZCkge1xuICAgICAgICAgICAgcmV0dXJuIF9nZXRDb2xzV2lkdGgoZ3JpZCwgMCwgZ3JpZFtfXS5jb2xDb3VudCAtIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKiogQHByaXZhdGUgKi9cblxuXG4gICAgICAgICAgZnVuY3Rpb24gX2dldFNjcm9sbEhlaWdodChyb3cpIHtcbiAgICAgICAgICAgIHZhciBfdGhpczY0ID0gdGhpcztcblxuICAgICAgICAgICAgdmFyIGludGVybmFsID0gdGhpcy5nZXRTY3JvbGxIZWlnaHRJbnRlcm5hbChyb3cpO1xuXG4gICAgICAgICAgICBpZiAoaW50ZXJuYWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBoID0gdGhpc1tfXS5kZWZhdWx0Um93SGVpZ2h0ICogdGhpc1tfXS5yb3dDb3VudDtcblxuICAgICAgICAgICAgdGhpc1tfXS5yb3dIZWlnaHRzTWFwLmVhY2goMCwgdGhpc1tfXS5yb3dDb3VudCAtIDEsIGZ1bmN0aW9uIChoZWlnaHQpIHtcbiAgICAgICAgICAgICAgaCArPSBoZWlnaHQgLSBfdGhpczY0W19dLmRlZmF1bHRSb3dIZWlnaHQ7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgICAgICAgICBmdW5jdGlvbiBfb25TY3JvbGwoZ3JpZCwgX2UpIHtcbiAgICAgICAgICAgIHZhciBsYXN0TGVmdCA9IGdyaWRbX10uc2Nyb2xsLmxlZnQ7XG4gICAgICAgICAgICB2YXIgbGFzdFRvcCA9IGdyaWRbX10uc2Nyb2xsLnRvcDtcbiAgICAgICAgICAgIHZhciBtb3ZlWCA9IGdyaWRbX10uc2Nyb2xsYWJsZS5zY3JvbGxMZWZ0IC0gbGFzdExlZnQ7XG4gICAgICAgICAgICB2YXIgbW92ZVkgPSBncmlkW19dLnNjcm9sbGFibGUuc2Nyb2xsVG9wIC0gbGFzdFRvcDsgLy/mrKHlm57oqIjnrpfnlKjmg4XloLHjgpLkv53mjIFcblxuICAgICAgICAgICAgZ3JpZFtfXS5zY3JvbGwgPSB7XG4gICAgICAgICAgICAgIGxlZnQ6IGdyaWRbX10uc2Nyb2xsYWJsZS5zY3JvbGxMZWZ0LFxuICAgICAgICAgICAgICB0b3A6IGdyaWRbX10uc2Nyb2xsYWJsZS5zY3JvbGxUb3BcbiAgICAgICAgICAgIH07IC8vIElmIHRoZSBmb2N1cyBpcyBvbiB0aGUgaGVhZGVyLCByZWNhbGN1bGF0ZSBhbmQgbW92ZSB0aGUgZm9jdXMgcG9zaXRpb24uXG5cbiAgICAgICAgICAgIHZhciBmb2N1cyA9IGdyaWRbX10uc2VsZWN0aW9uLmZvY3VzO1xuICAgICAgICAgICAgdmFyIGlzRnJvemVuQ2VsbCA9IGdyaWQuaXNGcm96ZW5DZWxsKGZvY3VzLmNvbCwgZm9jdXMucm93KTtcblxuICAgICAgICAgICAgaWYgKGlzRnJvemVuQ2VsbCAmJiAoKGlzRnJvemVuQ2VsbCA9PT0gbnVsbCB8fCBpc0Zyb3plbkNlbGwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGlzRnJvemVuQ2VsbC5jb2wpICYmIG1vdmVYIHx8IChpc0Zyb3plbkNlbGwgPT09IG51bGwgfHwgaXNGcm96ZW5DZWxsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpc0Zyb3plbkNlbGwucm93KSAmJiBtb3ZlWSkpIHtcbiAgICAgICAgICAgICAgZ3JpZC5zZXRGb2N1c0N1cnNvcihmb2N1cy5jb2wsIGZvY3VzLnJvdyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB2aXNpYmxlUmVjdCA9IF9nZXRWaXNpYmxlUmVjdChncmlkKTtcblxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKG1vdmVYKSA+PSB2aXNpYmxlUmVjdC53aWR0aCB8fCBNYXRoLmFicyhtb3ZlWSkgPj0gdmlzaWJsZVJlY3QuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgIC8v5YWo5YaN5o+P55S7XG4gICAgICAgICAgICAgIF9pbnZhbGlkYXRlUmVjdChncmlkLCB2aXNpYmxlUmVjdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvL+W3ruWIhuWGjeaPj+eUu1xuICAgICAgICAgICAgICBncmlkW19dLmNvbnRleHQuZHJhd0ltYWdlKGdyaWRbX10uY2FudmFzLCAtbW92ZVgsIC1tb3ZlWSk7XG5cbiAgICAgICAgICAgICAgaWYgKG1vdmVYICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgLy/mqKrnp7vli5Xjga7lho3mj4/nlLvnr4Tlm7LjgpLoqIjnrpdcbiAgICAgICAgICAgICAgICB2YXIgcmVkcmF3UmVjdCA9IHZpc2libGVSZWN0LmNvcHkoKTtcblxuICAgICAgICAgICAgICAgIGlmIChtb3ZlWCA8IDApIHtcbiAgICAgICAgICAgICAgICAgIHJlZHJhd1JlY3Qud2lkdGggPSAtbW92ZVg7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChncmlkW19dLmZyb3plbkNvbENvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAvL+WbuuWumuWIl+OBjOOBguOCi+WgtOWQiOWbuuWumuWIl+WIhuaPj+eUu1xuICAgICAgICAgICAgICAgICAgICB2YXIgZnJvemVuUmVjdCA9IF9nZXRGcm96ZW5Db2xzUmVjdChncmlkKTtcblxuICAgICAgICAgICAgICAgICAgICByZWRyYXdSZWN0LndpZHRoICs9IGZyb3plblJlY3Qud2lkdGg7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtb3ZlWCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIHJlZHJhd1JlY3QubGVmdCA9IHJlZHJhd1JlY3QucmlnaHQgLSBtb3ZlWDtcbiAgICAgICAgICAgICAgICB9IC8v5YaN5o+P55S7XG5cblxuICAgICAgICAgICAgICAgIF9pbnZhbGlkYXRlUmVjdChncmlkLCByZWRyYXdSZWN0KTtcblxuICAgICAgICAgICAgICAgIGlmIChtb3ZlWCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIGlmIChncmlkW19dLmZyb3plbkNvbENvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAvL+WbuuWumuWIl+OBjOOBguOCi+WgtOWQiOWbuuWumuWIl+aPj+eUu1xuICAgICAgICAgICAgICAgICAgICBfaW52YWxpZGF0ZVJlY3QoZ3JpZCwgX2dldEZyb3plbkNvbHNSZWN0KGdyaWQpKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAobW92ZVkgIT09IDApIHtcbiAgICAgICAgICAgICAgICAvL+e4puenu+WLleOBruWGjeaPj+eUu+evhOWbsuOCkuioiOeul1xuICAgICAgICAgICAgICAgIHZhciBfcmVkcmF3UmVjdCA9IHZpc2libGVSZWN0LmNvcHkoKTtcblxuICAgICAgICAgICAgICAgIGlmIChtb3ZlWSA8IDApIHtcbiAgICAgICAgICAgICAgICAgIF9yZWRyYXdSZWN0LmhlaWdodCA9IC1tb3ZlWTtcblxuICAgICAgICAgICAgICAgICAgaWYgKGdyaWRbX10uZnJvemVuUm93Q291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8v5Zu65a6a6KGM44GM44GC44KL5aC05ZCI5Zu65a6a6KGM5YiG5o+P55S7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfZnJvemVuUmVjdDIgPSBfZ2V0RnJvemVuUm93c1JlY3QoZ3JpZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgX3JlZHJhd1JlY3QuaGVpZ2h0ICs9IF9mcm96ZW5SZWN0Mi5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtb3ZlWSA+IDApIHtcbiAgICAgICAgICAgICAgICAgIF9yZWRyYXdSZWN0LnRvcCA9IF9yZWRyYXdSZWN0LmJvdHRvbSAtIG1vdmVZO1xuICAgICAgICAgICAgICAgIH0gLy/lho3mj4/nlLtcblxuXG4gICAgICAgICAgICAgICAgX2ludmFsaWRhdGVSZWN0KGdyaWQsIF9yZWRyYXdSZWN0KTtcblxuICAgICAgICAgICAgICAgIGlmIChtb3ZlWSA+IDApIHtcbiAgICAgICAgICAgICAgICAgIGlmIChncmlkW19dLmZyb3plblJvd0NvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAvL+WbuuWumuihjOOBjOOBguOCi+WgtOWQiOWbuuWumuihjOaPj+eUu1xuICAgICAgICAgICAgICAgICAgICBfaW52YWxpZGF0ZVJlY3QoZ3JpZCwgX2dldEZyb3plblJvd3NSZWN0KGdyaWQpKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcblxuXG4gICAgICAgICAgZnVuY3Rpb24gX29uS2V5RG93bk1vdmUoZSkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG5cbiAgICAgICAgICAgIHZhciBrZXlDb2RlID0gZ2V0S2V5Q29kZShlKTtcbiAgICAgICAgICAgIHZhciBmb2N1c0NlbGwgPSBlLnNoaWZ0S2V5ID8gdGhpcy5zZWxlY3Rpb24uZm9jdXMgOiB0aGlzLnNlbGVjdGlvbi5zZWxlY3Q7XG4gICAgICAgICAgICB2YXIgY3RybE9yTWV0YSA9IGUuY3RybEtleSB8fCBlLm1ldGFLZXk7XG5cbiAgICAgICAgICAgIGlmIChrZXlDb2RlID09PSBLRVlfTEVGVCkge1xuICAgICAgICAgICAgICBpZiAoZS5hbHRLZXkpIHJldHVybjsgLy8gdW5rbm93biBtb2RpZmllciBrZXlcblxuICAgICAgICAgICAgICBpZiAoY3RybE9yTWV0YSkge1xuICAgICAgICAgICAgICAgIG1vdmUodGhpcywgbnVsbCwgXCJXXCIsIGUuc2hpZnRLZXkpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghaE1vdmUuY2FsbCh0aGlzLCBcIldcIiwgZS5zaGlmdEtleSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjYW5jZWxFdmVudChlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5Q29kZSA9PT0gS0VZX1VQKSB7XG4gICAgICAgICAgICAgIGlmIChlLmFsdEtleSkgcmV0dXJuOyAvLyB1bmtub3duIG1vZGlmaWVyIGtleVxuXG4gICAgICAgICAgICAgIGlmIChjdHJsT3JNZXRhKSB7XG4gICAgICAgICAgICAgICAgbW92ZSh0aGlzLCBcIk5cIiwgbnVsbCwgZS5zaGlmdEtleSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCF2TW92ZS5jYWxsKHRoaXMsIFwiTlwiLCBlLnNoaWZ0S2V5KSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNhbmNlbEV2ZW50KGUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChrZXlDb2RlID09PSBLRVlfUklHSFQpIHtcbiAgICAgICAgICAgICAgaWYgKGUuYWx0S2V5KSByZXR1cm47IC8vIHVua25vd24gbW9kaWZpZXIga2V5XG5cbiAgICAgICAgICAgICAgaWYgKGN0cmxPck1ldGEpIHtcbiAgICAgICAgICAgICAgICBtb3ZlKHRoaXMsIG51bGwsIFwiRVwiLCBlLnNoaWZ0S2V5KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIWhNb3ZlLmNhbGwodGhpcywgXCJFXCIsIGUuc2hpZnRLZXkpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY2FuY2VsRXZlbnQoZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtleUNvZGUgPT09IEtFWV9ET1dOKSB7XG4gICAgICAgICAgICAgIGlmIChlLmFsdEtleSkgcmV0dXJuOyAvLyB1bmtub3duIG1vZGlmaWVyIGtleVxuXG4gICAgICAgICAgICAgIGlmIChjdHJsT3JNZXRhKSB7XG4gICAgICAgICAgICAgICAgbW92ZSh0aGlzLCBcIlNcIiwgbnVsbCwgZS5zaGlmdEtleSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCF2TW92ZS5jYWxsKHRoaXMsIFwiU1wiLCBlLnNoaWZ0S2V5KSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNhbmNlbEV2ZW50KGUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChrZXlDb2RlID09PSBLRVlfSE9NRSkge1xuICAgICAgICAgICAgICBpZiAoZS5hbHRLZXkpIHJldHVybjsgLy8gdW5rbm93biBtb2RpZmllciBrZXlcblxuICAgICAgICAgICAgICBpZiAoY3RybE9yTWV0YSkge1xuICAgICAgICAgICAgICAgIG1vdmUodGhpcywgXCJOXCIsIFwiV1wiLCBlLnNoaWZ0S2V5KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtb3ZlKHRoaXMsIG51bGwsIFwiV1wiLCBlLnNoaWZ0S2V5KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNhbmNlbEV2ZW50KGUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChrZXlDb2RlID09PSBLRVlfRU5EKSB7XG4gICAgICAgICAgICAgIGlmIChlLmFsdEtleSkgcmV0dXJuOyAvLyB1bmtub3duIG1vZGlmaWVyIGtleVxuXG4gICAgICAgICAgICAgIGlmIChjdHJsT3JNZXRhKSB7XG4gICAgICAgICAgICAgICAgbW92ZSh0aGlzLCBcIlNcIiwgXCJFXCIsIGUuc2hpZnRLZXkpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1vdmUodGhpcywgbnVsbCwgXCJFXCIsIGUuc2hpZnRLZXkpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY2FuY2VsRXZlbnQoZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCgoX2EgPSB0aGlzLmtleWJvYXJkT3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1vdmVDZWxsT25UYWIpICYmIGtleUNvZGUgPT09IEtFWV9UQUIpIHtcbiAgICAgICAgICAgICAgaWYgKGUuYWx0S2V5IHx8IGN0cmxPck1ldGEpIHJldHVybjsgLy8gdW5rbm93biBtb2RpZmllciBrZXlcblxuICAgICAgICAgICAgICB2YXIgbmV3Q2VsbCA9IG51bGw7XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmtleWJvYXJkT3B0aW9ucy5tb3ZlQ2VsbE9uVGFiID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBuZXdDZWxsID0gdGhpcy5rZXlib2FyZE9wdGlvbnMubW92ZUNlbGxPblRhYih7XG4gICAgICAgICAgICAgICAgICBjZWxsOiBmb2N1c0NlbGwsXG4gICAgICAgICAgICAgICAgICBncmlkOiB0aGlzLFxuICAgICAgICAgICAgICAgICAgZXZlbnQ6IGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChuZXdDZWxsKSB7XG4gICAgICAgICAgICAgICAgX21vdmVGb2N1c0NlbGwuY2FsbCh0aGlzLCBuZXdDZWxsLmNvbCwgbmV3Q2VsbC5yb3csIGZhbHNlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFoTW92ZS5jYWxsKHRoaXMsIFwiV1wiLCBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICAgIHZhciByb3cgPSB0aGlzLmdldE1vdmVVcFJvd0J5S2V5RG93bkludGVybmFsKGZvY3VzQ2VsbCk7XG5cbiAgICAgICAgICAgICAgICAgIGlmICgwID4gcm93KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgX21vdmVGb2N1c0NlbGwuY2FsbCh0aGlzLCB0aGlzLmNvbENvdW50IC0gMSwgcm93LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghaE1vdmUuY2FsbCh0aGlzLCBcIkVcIiwgZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgX3JvdzMgPSB0aGlzLmdldE1vdmVEb3duUm93QnlLZXlEb3duSW50ZXJuYWwoZm9jdXNDZWxsKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucm93Q291bnQgPD0gX3JvdzMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBfbW92ZUZvY3VzQ2VsbC5jYWxsKHRoaXMsIDAsIF9yb3czLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY2FuY2VsRXZlbnQoZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCgoX2IgPSB0aGlzLmtleWJvYXJkT3B0aW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm1vdmVDZWxsT25FbnRlcikgJiYga2V5Q29kZSA9PT0gS0VZX0VOVEVSKSB7XG4gICAgICAgICAgICAgIGlmIChlLmFsdEtleSB8fCBjdHJsT3JNZXRhKSByZXR1cm47IC8vIHVua25vd24gbW9kaWZpZXIga2V5XG5cbiAgICAgICAgICAgICAgdmFyIF9uZXdDZWxsID0gbnVsbDtcblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMua2V5Ym9hcmRPcHRpb25zLm1vdmVDZWxsT25FbnRlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgX25ld0NlbGwgPSB0aGlzLmtleWJvYXJkT3B0aW9ucy5tb3ZlQ2VsbE9uRW50ZXIoe1xuICAgICAgICAgICAgICAgICAgY2VsbDogZm9jdXNDZWxsLFxuICAgICAgICAgICAgICAgICAgZ3JpZDogdGhpcyxcbiAgICAgICAgICAgICAgICAgIGV2ZW50OiBlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoX25ld0NlbGwpIHtcbiAgICAgICAgICAgICAgICBfbW92ZUZvY3VzQ2VsbC5jYWxsKHRoaXMsIF9uZXdDZWxsLmNvbCwgX25ld0NlbGwucm93LCBmYWxzZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoZS5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgIGlmICghdk1vdmUuY2FsbCh0aGlzLCBcIk5cIiwgZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY29sID0gdGhpcy5nZXRNb3ZlTGVmdENvbEJ5S2V5RG93bkludGVybmFsKGZvY3VzQ2VsbCk7XG5cbiAgICAgICAgICAgICAgICAgIGlmICgwID4gY29sKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgX21vdmVGb2N1c0NlbGwuY2FsbCh0aGlzLCBjb2wsIHRoaXMucm93Q291bnQgLSAxLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghdk1vdmUuY2FsbCh0aGlzLCBcIlNcIiwgZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgX2NvbDMgPSB0aGlzLmdldE1vdmVSaWdodENvbEJ5S2V5RG93bkludGVybmFsKGZvY3VzQ2VsbCk7XG5cbiAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbENvdW50IDw9IF9jb2wzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgX21vdmVGb2N1c0NlbGwuY2FsbCh0aGlzLCBfY29sMywgTWF0aC5taW4odGhpcy5mcm96ZW5Sb3dDb3VudCwgdGhpcy5yb3dDb3VudCAtIDEpLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY2FuY2VsRXZlbnQoZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCgoX2MgPSB0aGlzLmtleWJvYXJkT3B0aW9ucykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnNlbGVjdEFsbE9uQ3RybEEpICYmIGtleUNvZGUgPT09IEtFWV9BTFBIQV9BKSB7XG4gICAgICAgICAgICAgIGlmIChlLmFsdEtleSB8fCBlLnNoaWZ0S2V5KSByZXR1cm47IC8vIHVua25vd24gbW9kaWZpZXIga2V5XG5cbiAgICAgICAgICAgICAgaWYgKCFjdHJsT3JNZXRhKSByZXR1cm47XG4gICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLnJhbmdlID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICAgICAgICBjb2w6IDAsXG4gICAgICAgICAgICAgICAgICByb3c6IDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVuZDoge1xuICAgICAgICAgICAgICAgICAgY29sOiB0aGlzLmNvbENvdW50IC0gMSxcbiAgICAgICAgICAgICAgICAgIHJvdzogdGhpcy5yb3dDb3VudCAtIDFcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgICAgICAgICAgICBjYW5jZWxFdmVudChlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gbW92ZShncmlkLCB2RGlyLCBoRGlyLCBzaGlmdEtleUZsZykge1xuICAgICAgICAgICAgICB2YXIgcm93ID0gdkRpciA9PT0gXCJTXCIgPyBncmlkLnJvd0NvdW50IC0gMSA6IHZEaXIgPT09IFwiTlwiID8gMCA6IGZvY3VzQ2VsbC5yb3c7XG4gICAgICAgICAgICAgIHZhciBjb2wgPSBoRGlyID09PSBcIkVcIiA/IGdyaWQuY29sQ291bnQgLSAxIDogaERpciA9PT0gXCJXXCIgPyAwIDogZm9jdXNDZWxsLmNvbDtcblxuICAgICAgICAgICAgICBfbW92ZUZvY3VzQ2VsbC5jYWxsKGdyaWQsIGNvbCwgcm93LCBzaGlmdEtleUZsZyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHZNb3ZlKHZEaXIsIHNoaWZ0S2V5RmxnKSB7XG4gICAgICAgICAgICAgIHZhciBjb2wgPSBmb2N1c0NlbGwuY29sO1xuICAgICAgICAgICAgICB2YXIgcm93O1xuXG4gICAgICAgICAgICAgIGlmICh2RGlyID09PSBcIlNcIikge1xuICAgICAgICAgICAgICAgIHJvdyA9IHRoaXMuZ2V0TW92ZURvd25Sb3dCeUtleURvd25JbnRlcm5hbChmb2N1c0NlbGwpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucm93Q291bnQgPD0gcm93KSB7XG4gICAgICAgICAgICAgICAgICAvLyBBdm9pZHMgdGhlIHByb2JsZW0gb2YgdGhlIHNjcm9sbCBwb3NpdGlvbiBicmVha2luZyBkdWUgdG8gYSBkZWxheWVkIHNjcm9sbGluZyBldmVudCBpZiB1c2VyIGhvbGQgZG93biB0aGUgYXJyb3cga2V5cy5cbiAgICAgICAgICAgICAgICAgIHRoaXMubWFrZVZpc2libGVDZWxsKGNvbCwgdGhpcy5yb3dDb3VudCAtIDEpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByb3cgPSB0aGlzLmdldE1vdmVVcFJvd0J5S2V5RG93bkludGVybmFsKGZvY3VzQ2VsbCk7XG5cbiAgICAgICAgICAgICAgICBpZiAocm93IDwgMCkge1xuICAgICAgICAgICAgICAgICAgLy8gQXZvaWRzIHRoZSBwcm9ibGVtIG9mIHRoZSBzY3JvbGwgcG9zaXRpb24gYnJlYWtpbmcgZHVlIHRvIGEgZGVsYXllZCBzY3JvbGxpbmcgZXZlbnQgaWYgdXNlciBob2xkIGRvd24gdGhlIGFycm93IGtleXMuXG4gICAgICAgICAgICAgICAgICB0aGlzLm1ha2VWaXNpYmxlQ2VsbChjb2wsIDApO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIF9tb3ZlRm9jdXNDZWxsLmNhbGwodGhpcywgY29sLCByb3csIHNoaWZ0S2V5RmxnKTtcblxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gaE1vdmUoaERpciwgc2hpZnRLZXlGbGcpIHtcbiAgICAgICAgICAgICAgdmFyIHJvdyA9IGZvY3VzQ2VsbC5yb3c7XG4gICAgICAgICAgICAgIHZhciBjb2w7XG5cbiAgICAgICAgICAgICAgaWYgKGhEaXIgPT09IFwiRVwiKSB7XG4gICAgICAgICAgICAgICAgY29sID0gdGhpcy5nZXRNb3ZlUmlnaHRDb2xCeUtleURvd25JbnRlcm5hbChmb2N1c0NlbGwpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29sQ291bnQgPD0gY29sKSB7XG4gICAgICAgICAgICAgICAgICAvLyBBdm9pZHMgdGhlIHByb2JsZW0gb2YgdGhlIHNjcm9sbCBwb3NpdGlvbiBicmVha2luZyBkdWUgdG8gYSBkZWxheWVkIHNjcm9sbGluZyBldmVudCBpZiB1c2VyIGhvbGQgZG93biB0aGUgYXJyb3cga2V5cy5cbiAgICAgICAgICAgICAgICAgIHRoaXMubWFrZVZpc2libGVDZWxsKHRoaXMuY29sQ291bnQgLSAxLCByb3cpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb2wgPSB0aGlzLmdldE1vdmVMZWZ0Q29sQnlLZXlEb3duSW50ZXJuYWwoZm9jdXNDZWxsKTtcblxuICAgICAgICAgICAgICAgIGlmIChjb2wgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAvLyBBdm9pZHMgdGhlIHByb2JsZW0gb2YgdGhlIHNjcm9sbCBwb3NpdGlvbiBicmVha2luZyBkdWUgdG8gYSBkZWxheWVkIHNjcm9sbGluZyBldmVudCBpZiB1c2VyIGhvbGQgZG93biB0aGUgYXJyb3cga2V5cy5cbiAgICAgICAgICAgICAgICAgIHRoaXMubWFrZVZpc2libGVDZWxsKDAsIHJvdyk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgX21vdmVGb2N1c0NlbGwuY2FsbCh0aGlzLCBjb2wsIHJvdywgc2hpZnRLZXlGbGcpO1xuXG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvKiogQHByaXZhdGUgKi9cblxuXG4gICAgICAgICAgZnVuY3Rpb24gX21vdmVGb2N1c0NlbGwoY29sLCByb3csIHNoaWZ0S2V5KSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5nZXRPZmZzZXRJbnZhbGlkYXRlQ2VsbHMoKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gZXh0ZW5kUmFuZ2UocmFuZ2UpIHtcbiAgICAgICAgICAgICAgaWYgKG9mZnNldCA+IDApIHtcbiAgICAgICAgICAgICAgICByYW5nZS5zdGFydC5jb2wgLT0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIHJhbmdlLnN0YXJ0LnJvdyAtPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgcmFuZ2UuZW5kLmNvbCArPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgcmFuZ2UuZW5kLnJvdyArPSBvZmZzZXQ7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBiZWZvcmVSYW5nZSA9IGV4dGVuZFJhbmdlKHRoaXMuc2VsZWN0aW9uLnJhbmdlKTtcbiAgICAgICAgICAgIHZhciBiZWZvcmVSZWN0ID0gdGhpcy5nZXRDZWxsUmFuZ2VSZWN0KGJlZm9yZVJhbmdlKTtcblxuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24uX3NldEZvY3VzQ2VsbChjb2wsIHJvdywgc2hpZnRLZXkpO1xuXG4gICAgICAgICAgICB0aGlzLm1ha2VWaXNpYmxlQ2VsbChjb2wsIHJvdyk7XG4gICAgICAgICAgICB0aGlzLmZvY3VzQ2VsbChjb2wsIHJvdyk7XG4gICAgICAgICAgICB2YXIgYWZ0ZXJSYW5nZSA9IGV4dGVuZFJhbmdlKHRoaXMuc2VsZWN0aW9uLnJhbmdlKTtcbiAgICAgICAgICAgIHZhciBhZnRlclJlY3QgPSB0aGlzLmdldENlbGxSYW5nZVJlY3QoYWZ0ZXJSYW5nZSk7XG5cbiAgICAgICAgICAgIGlmIChhZnRlclJlY3QuaW50ZXJzZWN0aW9uKGJlZm9yZVJlY3QpKSB7XG4gICAgICAgICAgICAgIHZhciBpbnZhbGlkYXRlUmVjdCA9IFJlY3RfMS5SZWN0Lm1heChhZnRlclJlY3QsIGJlZm9yZVJlY3QpO1xuXG4gICAgICAgICAgICAgIF9pbnZhbGlkYXRlUmVjdCh0aGlzLCBpbnZhbGlkYXRlUmVjdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBfaW52YWxpZGF0ZVJlY3QodGhpcywgYmVmb3JlUmVjdCk7XG5cbiAgICAgICAgICAgICAgX2ludmFsaWRhdGVSZWN0KHRoaXMsIGFmdGVyUmVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgICAgICAgICBmdW5jdGlvbiBfdXBkYXRlZFNlbGVjdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBmb2N1c0NvbnRyb2wgPSB0aGlzW19dLmZvY3VzQ29udHJvbDtcbiAgICAgICAgICAgIHZhciBfdGhpcyRfJHNlbGVjdGlvbiRzZWwgPSB0aGlzW19dLnNlbGVjdGlvbi5zZWxlY3QsXG4gICAgICAgICAgICAgICAgc2VsQ29sID0gX3RoaXMkXyRzZWxlY3Rpb24kc2VsLmNvbCxcbiAgICAgICAgICAgICAgICBzZWxSb3cgPSBfdGhpcyRfJHNlbGVjdGlvbiRzZWwucm93O1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB0aGlzLmZpcmVMaXN0ZW5lcnMoREdfRVZFTlRfVFlQRV8xLkRHX0VWRU5UX1RZUEUuRURJVEFCTEVJTlBVVF9DRUxMLCB7XG4gICAgICAgICAgICAgIGNvbDogc2VsQ29sLFxuICAgICAgICAgICAgICByb3c6IHNlbFJvd1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgZWRpdE1vZGUgPSB1dGlsc18xLmFycmF5LmZpbmRJbmRleChyZXN1bHRzLCBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICByZXR1cm4gISF2O1xuICAgICAgICAgICAgfSkgPj0gMDtcbiAgICAgICAgICAgIGZvY3VzQ29udHJvbC5lZGl0TW9kZSA9IGVkaXRNb2RlO1xuXG4gICAgICAgICAgICBpZiAoZWRpdE1vZGUpIHtcbiAgICAgICAgICAgICAgZm9jdXNDb250cm9sLnN0b3JlSW5wdXRTdGF0dXMoKTtcbiAgICAgICAgICAgICAgZm9jdXNDb250cm9sLnNldERlZmF1bHRJbnB1dFN0YXR1cygpO1xuICAgICAgICAgICAgICB0aGlzLmZpcmVMaXN0ZW5lcnMoREdfRVZFTlRfVFlQRV8xLkRHX0VWRU5UX1RZUEUuTU9ESUZZX1NUQVRVU19FRElUQUJMRUlOUFVUX0NFTEwsIHtcbiAgICAgICAgICAgICAgICBjb2w6IHNlbENvbCxcbiAgICAgICAgICAgICAgICByb3c6IHNlbFJvdyxcbiAgICAgICAgICAgICAgICBpbnB1dDogZm9jdXNDb250cm9sLmlucHV0XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvKiogQHByaXZhdGUgKi9cblxuXG4gICAgICAgICAgZnVuY3Rpb24gX2dldE1vdXNlQWJzdHJhY3RQb2ludChncmlkLCBldnQpIHtcbiAgICAgICAgICAgIHZhciBlO1xuXG4gICAgICAgICAgICBpZiAoaXNUb3VjaEV2ZW50KGV2dCkpIHtcbiAgICAgICAgICAgICAgZSA9IGV2dC5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGUgPSBldnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjbGllbnRYID0gZS5jbGllbnRYIHx8IGUucGFnZVggKyB3aW5kb3cuc2Nyb2xsWDtcbiAgICAgICAgICAgIHZhciBjbGllbnRZID0gZS5jbGllbnRZIHx8IGUucGFnZVkgKyB3aW5kb3cuc2Nyb2xsWTtcblxuICAgICAgICAgICAgdmFyIHJlY3QgPSBncmlkW19dLmNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICAgICAgaWYgKHJlY3QucmlnaHQgPD0gY2xpZW50WCkge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJlY3QuYm90dG9tIDw9IGNsaWVudFkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB4ID0gY2xpZW50WCAtIHJlY3QubGVmdCArIGdyaWRbX10uc2Nyb2xsLmxlZnQ7XG4gICAgICAgICAgICB2YXIgeSA9IGNsaWVudFkgLSByZWN0LnRvcCArIGdyaWRbX10uc2Nyb2xsLnRvcDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgIHk6IHlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgICAgICAgICBmdW5jdGlvbiBfYmluZEV2ZW50cygpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXRoaXMsIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzXG4gICAgICAgICAgICB2YXIgZ3JpZCA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgX2dyaWQkXyA9IGdyaWRbX10sXG4gICAgICAgICAgICAgICAgaGFuZGxlciA9IF9ncmlkJF8uaGFuZGxlcixcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gX2dyaWQkXy5lbGVtZW50LFxuICAgICAgICAgICAgICAgIHNjcm9sbGFibGUgPSBfZ3JpZCRfLnNjcm9sbGFibGU7XG5cbiAgICAgICAgICAgIHZhciBnZXRDZWxsRXZlbnRBcmdzU2V0ID0gZnVuY3Rpb24gZ2V0Q2VsbEV2ZW50QXJnc1NldChlKSB7XG4gICAgICAgICAgICAgIHZhciBhYnN0cmFjdFBvcyA9IF9nZXRNb3VzZUFic3RyYWN0UG9pbnQoZ3JpZCwgZSk7XG5cbiAgICAgICAgICAgICAgaWYgKCFhYnN0cmFjdFBvcykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBjZWxsID0gZ3JpZC5nZXRDZWxsQXQoYWJzdHJhY3RQb3MueCwgYWJzdHJhY3RQb3MueSk7XG5cbiAgICAgICAgICAgICAgaWYgKGNlbGwuY29sIDwgMCB8fCBjZWxsLnJvdyA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgYWJzdHJhY3RQb3M6IGFic3RyYWN0UG9zLFxuICAgICAgICAgICAgICAgICAgY2VsbDogY2VsbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgZXZlbnRBcmdzID0ge1xuICAgICAgICAgICAgICAgIGNvbDogY2VsbC5jb2wsXG4gICAgICAgICAgICAgICAgcm93OiBjZWxsLnJvdyxcbiAgICAgICAgICAgICAgICBldmVudDogZVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFic3RyYWN0UG9zOiBhYnN0cmFjdFBvcyxcbiAgICAgICAgICAgICAgICBjZWxsOiBjZWxsLFxuICAgICAgICAgICAgICAgIGV2ZW50QXJnczogZXZlbnRBcmdzXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgY2FuUmVzaXplQ29sdW1uID0gZnVuY3Rpb24gY2FuUmVzaXplQ29sdW1uKGNvbCkge1xuICAgICAgICAgICAgICBpZiAoZ3JpZFtfXS5kaXNhYmxlQ29sdW1uUmVzaXplKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIGxpbWl0ID0gZ3JpZFtfXS5jb2xXaWR0aHNMaW1pdFtjb2xdO1xuXG4gICAgICAgICAgICAgIGlmICghbGltaXQgfHwgIWxpbWl0Lm1pbiB8fCAhbGltaXQubWF4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gbGltaXQubWF4ICE9PSBsaW1pdC5taW47XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBoYW5kbGVyLm9uKGVsZW1lbnQsIFwibW91c2Vkb3duXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIHZhciBldmVudEFyZ3NTZXQgPSBnZXRDZWxsRXZlbnRBcmdzU2V0KGUpO1xuICAgICAgICAgICAgICB2YXIgYWJzdHJhY3RQb3MgPSBldmVudEFyZ3NTZXQuYWJzdHJhY3RQb3MsXG4gICAgICAgICAgICAgICAgICBldmVudEFyZ3MgPSBldmVudEFyZ3NTZXQuZXZlbnRBcmdzO1xuXG4gICAgICAgICAgICAgIGlmICghYWJzdHJhY3RQb3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoZXZlbnRBcmdzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSBncmlkLmZpcmVMaXN0ZW5lcnMoREdfRVZFTlRfVFlQRV8xLkRHX0VWRU5UX1RZUEUuTU9VU0VET1dOX0NFTEwsIGV2ZW50QXJncyk7XG5cbiAgICAgICAgICAgICAgICBpZiAodXRpbHNfMS5hcnJheS5maW5kSW5kZXgocmVzdWx0cywgZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAhdjtcbiAgICAgICAgICAgICAgICB9KSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGdldE1vdXNlQnV0dG9ucyhlKSAhPT0gMSAmJiAvLyBGb3IgbW9iaWxlIHNhZmFyaS4gSWYgd2UgZG8gbm90IHBvc3QtcHJvY2VzcyBoZXJlLCB0aGUga2V5Ym9hcmQgd2lsbCBub3Qgc3RhcnQgaW4gTW9iaWxlIFNhZmFyaS5cbiAgICAgICAgICAgICAgZS5idXR0b25zICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIHJlc2l6ZUNvbCA9IF9nZXRSZXNpemVDb2xBdChncmlkLCBhYnN0cmFjdFBvcy54LCBhYnN0cmFjdFBvcy55KTtcblxuICAgICAgICAgICAgICBpZiAocmVzaXplQ29sID49IDAgJiYgY2FuUmVzaXplQ29sdW1uKHJlc2l6ZUNvbCkpIHtcbiAgICAgICAgICAgICAgICAvL+W5heWkieabtFxuICAgICAgICAgICAgICAgIGdyaWRbX10uY29sdW1uUmVzaXplci5zdGFydChyZXNpemVDb2wsIGUpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8v6YG45oqeXG4gICAgICAgICAgICAgICAgZ3JpZFtfXS5jZWxsU2VsZWN0b3Iuc3RhcnQoZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaGFuZGxlci5vbihlbGVtZW50LCBcIm1vdXNldXBcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgaWYgKCFncmlkLmhhc0xpc3RlbmVycyhER19FVkVOVF9UWVBFXzEuREdfRVZFTlRfVFlQRS5NT1VTRVVQX0NFTEwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIF9nZXRDZWxsRXZlbnRBcmdzU2V0ID0gZ2V0Q2VsbEV2ZW50QXJnc1NldChlKSxcbiAgICAgICAgICAgICAgICAgIGV2ZW50QXJncyA9IF9nZXRDZWxsRXZlbnRBcmdzU2V0LmV2ZW50QXJncztcblxuICAgICAgICAgICAgICBpZiAoZXZlbnRBcmdzKSB7XG4gICAgICAgICAgICAgICAgZ3JpZC5maXJlTGlzdGVuZXJzKERHX0VWRU5UX1RZUEVfMS5ER19FVkVOVF9UWVBFLk1PVVNFVVBfQ0VMTCwgZXZlbnRBcmdzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgZG91YmxlVGFwQmVmb3JlID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBsb25nVG91Y2hJZCA9IG51bGw7XG4gICAgICAgICAgICB2YXIgdXNlVG91Y2ggPSBudWxsO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiB1c2VUb3VjaFN0YXJ0KCkge1xuICAgICAgICAgICAgICBpZiAoKHVzZVRvdWNoID09PSBudWxsIHx8IHVzZVRvdWNoID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1c2VUb3VjaC50aW1lb3V0SWQpICE9IG51bGwpIGNsZWFyVGltZW91dCh1c2VUb3VjaC50aW1lb3V0SWQpO1xuICAgICAgICAgICAgICB1c2VUb3VjaCA9IHt9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiB1c2VUb3VjaEVuZCgpIHtcbiAgICAgICAgICAgICAgaWYgKHVzZVRvdWNoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVzZVRvdWNoLnRpbWVvdXRJZCAhPSBudWxsKSBjbGVhclRpbWVvdXQodXNlVG91Y2gudGltZW91dElkKTtcbiAgICAgICAgICAgICAgICB1c2VUb3VjaC50aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHVzZVRvdWNoID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9LCAzNTApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGhhbmRsZXIub24oZWxlbWVudCwgXCJ0b3VjaHN0YXJ0XCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIC8vIFNpbmNlIGl0IGlzIGFuIGVudmlyb25tZW50IHdoZXJlIHRvdWNoIHN0YXJ0IGNhbiBiZSB1c2VkLCBpdCBibG9ja3MgbW91c2Vtb3ZlIHRoYXQgb2NjdXJzIGFmdGVyIHRoaXMuXG4gICAgICAgICAgICAgIHVzZVRvdWNoU3RhcnQoKTtcblxuICAgICAgICAgICAgICB2YXIgX2dldENlbGxFdmVudEFyZ3NTZXQyID0gZ2V0Q2VsbEV2ZW50QXJnc1NldChlKSxcbiAgICAgICAgICAgICAgICAgIGV2ZW50QXJncyA9IF9nZXRDZWxsRXZlbnRBcmdzU2V0Mi5ldmVudEFyZ3M7XG5cbiAgICAgICAgICAgICAgaWYgKGV2ZW50QXJncykge1xuICAgICAgICAgICAgICAgIGdyaWQuZmlyZUxpc3RlbmVycyhER19FVkVOVF9UWVBFXzEuREdfRVZFTlRfVFlQRS5UT1VDSFNUQVJUX0NFTEwsIGV2ZW50QXJncyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIWRvdWJsZVRhcEJlZm9yZSkge1xuICAgICAgICAgICAgICAgIGRvdWJsZVRhcEJlZm9yZSA9IGV2ZW50QXJncztcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIGRvdWJsZVRhcEJlZm9yZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSwgMzUwKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRBcmdzICYmIGV2ZW50QXJncy5jb2wgPT09IGRvdWJsZVRhcEJlZm9yZS5jb2wgJiYgZXZlbnRBcmdzLnJvdyA9PT0gZG91YmxlVGFwQmVmb3JlLnJvdykge1xuICAgICAgICAgICAgICAgICAgZ3JpZC5maXJlTGlzdGVuZXJzKERHX0VWRU5UX1RZUEVfMS5ER19FVkVOVF9UWVBFLkRCTFRBUF9DRUxMLCBldmVudEFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRvdWJsZVRhcEJlZm9yZSA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICBpZiAoZS5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGUudGFyZ2V0VG91Y2hlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdG91Y2hzdGFydCB3aXRoIG11bHRpcGxlIGZpbmdlcnMsXG4gICAgICAgICAgICAgICAgLy8gaXQgaXMgbm90IGNvbnNpZGVyZWQgYXMgYW4gb3BlcmF0aW9uIGV2ZW50LlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGxvbmdUb3VjaElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy/plbfmirzjgZfjgZfjgZ/loLTlkIjpgbjmip7jg6Ljg7zjg4lcbiAgICAgICAgICAgICAgICBsb25nVG91Y2hJZCA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICB2YXIgYWJzdHJhY3RQb3MgPSBfZ2V0TW91c2VBYnN0cmFjdFBvaW50KGdyaWQsIGUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFhYnN0cmFjdFBvcykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciByZXNpemVDb2wgPSBfZ2V0UmVzaXplQ29sQXQoZ3JpZCwgYWJzdHJhY3RQb3MueCwgYWJzdHJhY3RQb3MueSwgMTUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJlc2l6ZUNvbCA+PSAwICYmIGNhblJlc2l6ZUNvbHVtbihyZXNpemVDb2wpKSB7XG4gICAgICAgICAgICAgICAgICAvL+W5heWkieabtFxuICAgICAgICAgICAgICAgICAgZ3JpZFtfXS5jb2x1bW5SZXNpemVyLnN0YXJ0KHJlc2l6ZUNvbCwgZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8v6YG45oqeXG4gICAgICAgICAgICAgICAgICBncmlkW19dLmNlbGxTZWxlY3Rvci5zdGFydChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sIDUwMCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gY2FuY2VsKF9lKSB7XG4gICAgICAgICAgICAgIGlmIChsb25nVG91Y2hJZCkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChsb25nVG91Y2hJZCk7XG4gICAgICAgICAgICAgICAgbG9uZ1RvdWNoSWQgPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGhhbmRsZXIub24oZWxlbWVudCwgXCJ0b3VjaGNhbmNlbFwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICBjYW5jZWwoZSk7XG4gICAgICAgICAgICAgIHVzZVRvdWNoRW5kKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGhhbmRsZXIub24oZWxlbWVudCwgXCJ0b3VjaG1vdmVcIiwgY2FuY2VsKTtcbiAgICAgICAgICAgIGhhbmRsZXIub24oZWxlbWVudCwgXCJ0b3VjaGVuZFwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICB1c2VUb3VjaEVuZCgpO1xuXG4gICAgICAgICAgICAgIGlmIChsb25nVG91Y2hJZCkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChsb25nVG91Y2hJZCk7XG5cbiAgICAgICAgICAgICAgICBncmlkW19dLmNlbGxTZWxlY3Rvci5zZWxlY3QoZSk7XG5cbiAgICAgICAgICAgICAgICBsb25nVG91Y2hJZCA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGlzTW91c2VvdmVyID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgbW91c2VFbnRlckNlbGwgPSBudWxsO1xuICAgICAgICAgICAgdmFyIG1vdXNlT3ZlckNlbGwgPSBudWxsO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBvbk1vdXNlZW50ZXJDZWxsKGNlbGwsIHByb3BzKSB7XG4gICAgICAgICAgICAgIGdyaWQuZmlyZUxpc3RlbmVycyhER19FVkVOVF9UWVBFXzEuREdfRVZFTlRfVFlQRS5NT1VTRUVOVEVSX0NFTEwsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMpLCB7XG4gICAgICAgICAgICAgICAgY29sOiBjZWxsLmNvbCxcbiAgICAgICAgICAgICAgICByb3c6IGNlbGwucm93XG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgbW91c2VFbnRlckNlbGwgPSBjZWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBvbk1vdXNlbGVhdmVDZWxsKHByb3BzKSB7XG4gICAgICAgICAgICAgIHZhciBiZWZvcmVNb3VzZUNlbGwgPSBtb3VzZUVudGVyQ2VsbDtcbiAgICAgICAgICAgICAgbW91c2VFbnRlckNlbGwgPSBudWxsO1xuXG4gICAgICAgICAgICAgIGlmIChiZWZvcmVNb3VzZUNlbGwpIHtcbiAgICAgICAgICAgICAgICBncmlkLmZpcmVMaXN0ZW5lcnMoREdfRVZFTlRfVFlQRV8xLkRHX0VWRU5UX1RZUEUuTU9VU0VMRUFWRV9DRUxMLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByb3BzKSwge1xuICAgICAgICAgICAgICAgICAgY29sOiBiZWZvcmVNb3VzZUNlbGwuY29sLFxuICAgICAgICAgICAgICAgICAgcm93OiBiZWZvcmVNb3VzZUNlbGwucm93XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGJlZm9yZU1vdXNlQ2VsbCB8fCB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIG9uTW91c2VvdmVyQ2VsbChjZWxsLCBwcm9wcykge1xuICAgICAgICAgICAgICBncmlkLmZpcmVMaXN0ZW5lcnMoREdfRVZFTlRfVFlQRV8xLkRHX0VWRU5UX1RZUEUuTU9VU0VPVkVSX0NFTEwsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMpLCB7XG4gICAgICAgICAgICAgICAgY29sOiBjZWxsLmNvbCxcbiAgICAgICAgICAgICAgICByb3c6IGNlbGwucm93XG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgbW91c2VPdmVyQ2VsbCA9IGNlbGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIG9uTW91c2VvdXRDZWxsKHByb3BzKSB7XG4gICAgICAgICAgICAgIHZhciBiZWZvcmVNb3VzZUNlbGwgPSBtb3VzZU92ZXJDZWxsO1xuICAgICAgICAgICAgICBtb3VzZU92ZXJDZWxsID0gbnVsbDtcblxuICAgICAgICAgICAgICBpZiAoYmVmb3JlTW91c2VDZWxsKSB7XG4gICAgICAgICAgICAgICAgZ3JpZC5maXJlTGlzdGVuZXJzKERHX0VWRU5UX1RZUEVfMS5ER19FVkVOVF9UWVBFLk1PVVNFT1VUX0NFTEwsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMpLCB7XG4gICAgICAgICAgICAgICAgICBjb2w6IGJlZm9yZU1vdXNlQ2VsbC5jb2wsXG4gICAgICAgICAgICAgICAgICByb3c6IGJlZm9yZU1vdXNlQ2VsbC5yb3dcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gYmVmb3JlTW91c2VDZWxsIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHNjcm9sbEVsZW1lbnQgPSBzY3JvbGxhYmxlLmdldEVsZW1lbnQoKTtcbiAgICAgICAgICAgIGhhbmRsZXIub24oc2Nyb2xsRWxlbWVudCwgXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24gKF9lKSB7XG4gICAgICAgICAgICAgIGlzTW91c2VvdmVyID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaGFuZGxlci5vbihzY3JvbGxFbGVtZW50LCBcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICBpc01vdXNlb3ZlciA9IGZhbHNlO1xuICAgICAgICAgICAgICBvbk1vdXNlb3V0Q2VsbCh7XG4gICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBoYW5kbGVyLm9uKGVsZW1lbnQsIFwibW91c2VsZWF2ZVwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgb25Nb3VzZWxlYXZlQ2VsbCh7XG4gICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBoYW5kbGVyLm9uKGVsZW1lbnQsIFwibW91c2Vtb3ZlXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIGlmICh1c2VUb3VjaCkge1xuICAgICAgICAgICAgICAgIC8vIFByb2JhYmx5IGEgbW91c2Vtb3ZlIGV2ZW50IHRyaWdnZXJlZCBieSBhIHRvdWNoc3RhcnQuIFRoZXJlZm9yZSwgdGhpcyBldmVudCBpcyBibG9ja2VkLlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBldmVudEFyZ3NTZXQgPSBnZXRDZWxsRXZlbnRBcmdzU2V0KGUpO1xuICAgICAgICAgICAgICB2YXIgYWJzdHJhY3RQb3MgPSBldmVudEFyZ3NTZXQuYWJzdHJhY3RQb3MsXG4gICAgICAgICAgICAgICAgICBldmVudEFyZ3MgPSBldmVudEFyZ3NTZXQuZXZlbnRBcmdzO1xuXG4gICAgICAgICAgICAgIGlmIChldmVudEFyZ3MpIHtcbiAgICAgICAgICAgICAgICB2YXIgYmVmb3JlTW91c2VDZWxsID0gbW91c2VFbnRlckNlbGw7XG5cbiAgICAgICAgICAgICAgICBpZiAoYmVmb3JlTW91c2VDZWxsKSB7XG4gICAgICAgICAgICAgICAgICBncmlkLmZpcmVMaXN0ZW5lcnMoREdfRVZFTlRfVFlQRV8xLkRHX0VWRU5UX1RZUEUuTU9VU0VNT1ZFX0NFTEwsIGV2ZW50QXJncyk7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChiZWZvcmVNb3VzZUNlbGwuY29sICE9PSBldmVudEFyZ3MuY29sIHx8IGJlZm9yZU1vdXNlQ2VsbC5yb3cgIT09IGV2ZW50QXJncy5yb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVudGVyQ2VsbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICBjb2w6IGV2ZW50QXJncy5jb2wsXG4gICAgICAgICAgICAgICAgICAgICAgcm93OiBldmVudEFyZ3Mucm93XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHZhciBvdXRDZWxsID0gb25Nb3VzZW91dENlbGwoe1xuICAgICAgICAgICAgICAgICAgICAgIHJlbGF0ZWQ6IGVudGVyQ2VsbCxcbiAgICAgICAgICAgICAgICAgICAgICBldmVudDogZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlYXZlQ2VsbCA9IG9uTW91c2VsZWF2ZUNlbGwoe1xuICAgICAgICAgICAgICAgICAgICAgIHJlbGF0ZWQ6IGVudGVyQ2VsbCxcbiAgICAgICAgICAgICAgICAgICAgICBldmVudDogZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgb25Nb3VzZWVudGVyQ2VsbChlbnRlckNlbGwsIHtcbiAgICAgICAgICAgICAgICAgICAgICByZWxhdGVkOiBsZWF2ZUNlbGwsXG4gICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTW91c2VvdmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgb25Nb3VzZW92ZXJDZWxsKGVudGVyQ2VsbCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRlZDogb3V0Q2VsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBlXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNNb3VzZW92ZXIgJiYgIW1vdXNlT3ZlckNlbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgb25Nb3VzZW92ZXJDZWxsKHtcbiAgICAgICAgICAgICAgICAgICAgICBjb2w6IGV2ZW50QXJncy5jb2wsXG4gICAgICAgICAgICAgICAgICAgICAgcm93OiBldmVudEFyZ3Mucm93XG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICBldmVudDogZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFyIF9lbnRlckNlbGwgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbDogZXZlbnRBcmdzLmNvbCxcbiAgICAgICAgICAgICAgICAgICAgcm93OiBldmVudEFyZ3Mucm93XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgb25Nb3VzZWVudGVyQ2VsbChfZW50ZXJDZWxsLCB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBlXG4gICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgaWYgKGlzTW91c2VvdmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uTW91c2VvdmVyQ2VsbChfZW50ZXJDZWxsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGdyaWQuZmlyZUxpc3RlbmVycyhER19FVkVOVF9UWVBFXzEuREdfRVZFTlRfVFlQRS5NT1VTRU1PVkVfQ0VMTCwgZXZlbnRBcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb25Nb3VzZW91dENlbGwoe1xuICAgICAgICAgICAgICAgICAgZXZlbnQ6IGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBvbk1vdXNlbGVhdmVDZWxsKHtcbiAgICAgICAgICAgICAgICAgIGV2ZW50OiBlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoZ3JpZFtfXS5jb2x1bW5SZXNpemVyLm1vdmluZyhlKSB8fCBncmlkW19dLmNlbGxTZWxlY3Rvci5tb3ZpbmcoZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgc3R5bGUgPSBlbGVtZW50LnN0eWxlO1xuXG4gICAgICAgICAgICAgIGlmICghYWJzdHJhY3RQb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3R5bGUuY3Vyc29yID09PSBcImNvbC1yZXNpemVcIikge1xuICAgICAgICAgICAgICAgICAgc3R5bGUuY3Vyc29yID0gXCJcIjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgcmVzaXplQ29sID0gX2dldFJlc2l6ZUNvbEF0KGdyaWQsIGFic3RyYWN0UG9zLngsIGFic3RyYWN0UG9zLnkpO1xuXG4gICAgICAgICAgICAgIGlmIChyZXNpemVDb2wgPj0gMCAmJiBjYW5SZXNpemVDb2x1bW4ocmVzaXplQ29sKSkge1xuICAgICAgICAgICAgICAgIHN0eWxlLmN1cnNvciA9IFwiY29sLXJlc2l6ZVwiO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChzdHlsZS5jdXJzb3IgPT09IFwiY29sLXJlc2l6ZVwiKSB7XG4gICAgICAgICAgICAgICAgICBzdHlsZS5jdXJzb3IgPSBcIlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBoYW5kbGVyLm9uKGVsZW1lbnQsIFwiY2xpY2tcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgaWYgKGdyaWRbX10uY29sdW1uUmVzaXplci5sYXN0TW92aW5nKGUpIHx8IGdyaWRbX10uY2VsbFNlbGVjdG9yLmxhc3RNb3ZpbmcoZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIWdyaWQuaGFzTGlzdGVuZXJzKERHX0VWRU5UX1RZUEVfMS5ER19FVkVOVF9UWVBFLkNMSUNLX0NFTEwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIF9nZXRDZWxsRXZlbnRBcmdzU2V0MyA9IGdldENlbGxFdmVudEFyZ3NTZXQoZSksXG4gICAgICAgICAgICAgICAgICBldmVudEFyZ3MgPSBfZ2V0Q2VsbEV2ZW50QXJnc1NldDMuZXZlbnRBcmdzO1xuXG4gICAgICAgICAgICAgIGlmICghZXZlbnRBcmdzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZ3JpZC5maXJlTGlzdGVuZXJzKERHX0VWRU5UX1RZUEVfMS5ER19FVkVOVF9UWVBFLkNMSUNLX0NFTEwsIGV2ZW50QXJncyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGhhbmRsZXIub24oZWxlbWVudCwgXCJjb250ZXh0bWVudVwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICBpZiAoIWdyaWQuaGFzTGlzdGVuZXJzKERHX0VWRU5UX1RZUEVfMS5ER19FVkVOVF9UWVBFLkNPTlRFWFRNRU5VX0NFTEwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIF9nZXRDZWxsRXZlbnRBcmdzU2V0NCA9IGdldENlbGxFdmVudEFyZ3NTZXQoZSksXG4gICAgICAgICAgICAgICAgICBldmVudEFyZ3MgPSBfZ2V0Q2VsbEV2ZW50QXJnc1NldDQuZXZlbnRBcmdzO1xuXG4gICAgICAgICAgICAgIGlmICghZXZlbnRBcmdzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZ3JpZC5maXJlTGlzdGVuZXJzKERHX0VWRU5UX1RZUEVfMS5ER19FVkVOVF9UWVBFLkNPTlRFWFRNRU5VX0NFTEwsIGV2ZW50QXJncyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGhhbmRsZXIub24oZWxlbWVudCwgXCJkYmxjbGlja1wiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICBpZiAoIWdyaWQuaGFzTGlzdGVuZXJzKERHX0VWRU5UX1RZUEVfMS5ER19FVkVOVF9UWVBFLkRCTENMSUNLX0NFTEwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIF9nZXRDZWxsRXZlbnRBcmdzU2V0NSA9IGdldENlbGxFdmVudEFyZ3NTZXQoZSksXG4gICAgICAgICAgICAgICAgICBldmVudEFyZ3MgPSBfZ2V0Q2VsbEV2ZW50QXJnc1NldDUuZXZlbnRBcmdzO1xuXG4gICAgICAgICAgICAgIGlmICghZXZlbnRBcmdzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZ3JpZC5maXJlTGlzdGVuZXJzKERHX0VWRU5UX1RZUEVfMS5ER19FVkVOVF9UWVBFLkRCTENMSUNLX0NFTEwsIGV2ZW50QXJncyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZ3JpZFtfXS5mb2N1c0NvbnRyb2wub25LZXlEb3duKGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgICAgICAgZ3JpZC5maXJlTGlzdGVuZXJzKERHX0VWRU5UX1RZUEVfMS5ER19FVkVOVF9UWVBFLktFWURPV04sIGV2dCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZ3JpZFtfXS5zZWxlY3Rpb24ubGlzdGVuKERHX0VWRU5UX1RZUEVfMS5ER19FVkVOVF9UWVBFLlNFTEVDVEVEX0NFTEwsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgIGdyaWQuZmlyZUxpc3RlbmVycyhER19FVkVOVF9UWVBFXzEuREdfRVZFTlRfVFlQRS5TRUxFQ1RFRF9DRUxMLCBkYXRhLCBkYXRhLnNlbGVjdGVkKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBzY3JvbGxhYmxlLm9uU2Nyb2xsKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIF9vblNjcm9sbChncmlkLCBlKTtcblxuICAgICAgICAgICAgICBncmlkLmZpcmVMaXN0ZW5lcnMoREdfRVZFTlRfVFlQRV8xLkRHX0VWRU5UX1RZUEUuU0NST0xMLCB7XG4gICAgICAgICAgICAgICAgZXZlbnQ6IGVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZ3JpZFtfXS5mb2N1c0NvbnRyb2wub25LZXlEb3duTW92ZShmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICBfb25LZXlEb3duTW92ZS5jYWxsKGdyaWQsIGUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGdyaWQubGlzdGVuKFwiY29weWRhdGFcIiwgZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgICAgICAgIHZhciBjb3B5UmFuZ2UgPSBncmlkLmdldENvcHlSYW5nZUludGVybmFsKHJhbmdlKTtcbiAgICAgICAgICAgICAgdmFyIGNvcHlMaW5lcyA9IFtdO1xuXG4gICAgICAgICAgICAgIGZvciAodmFyIHJvdyA9IGNvcHlSYW5nZS5zdGFydC5yb3c7IHJvdyA8PSBjb3B5UmFuZ2UuZW5kLnJvdzsgcm93KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY29weUxpbmUgPSBcIlwiO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgY29sID0gY29weVJhbmdlLnN0YXJ0LmNvbDsgY29sIDw9IGNvcHlSYW5nZS5lbmQuY29sOyBjb2wrKykge1xuICAgICAgICAgICAgICAgICAgdmFyIGNvcHlDZWxsVmFsdWUgPSBncmlkLmdldENvcHlDZWxsVmFsdWUoY29sLCByb3csIGNvcHlSYW5nZSk7XG4gICAgICAgICAgICAgICAgICB2YXIgc3RyQ2VsbFZhbHVlID0gdm9pZCAwO1xuXG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvcHlDZWxsVmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyQ2VsbFZhbHVlID0gY29weUNlbGxWYWx1ZTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29weUNlbGxWYWx1ZSA9PSBudWxsIHx8IC8vIEFzeW5jaHJvbm91cyBkYXRhIGlzIHRyZWF0ZWQgYXMgZW1wdHkuXG4gICAgICAgICAgICAgICAgICB0eXBlb2YgUHJvbWlzZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjb3B5Q2VsbFZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICBzdHJDZWxsVmFsdWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC10ZW1wbGF0ZS1leHByZXNzaW9uc1xuICAgICAgICAgICAgICAgICAgICBzdHJDZWxsVmFsdWUgPSBcIlwiLmNvbmNhdChjb3B5Q2VsbFZhbHVlKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoL15cXFtvYmplY3QgLipcXF0kLy5leGVjKHN0ckNlbGxWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgbWF5YmUgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgc3RyQ2VsbFZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBjb3B5TGluZSArPSAvW1xcdFxcbl0vLnRlc3Qoc3RyQ2VsbFZhbHVlKSA/IC8vIE5lZWQgcXVvdGVcbiAgICAgICAgICAgICAgICAgIFwiXFxcIlwiLmNvbmNhdChzdHJDZWxsVmFsdWUucmVwbGFjZSgvXCIvZywgJ1wiXCInKSwgXCJcXFwiXCIpIDogc3RyQ2VsbFZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoY29sIDwgY29weVJhbmdlLmVuZC5jb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgY29weUxpbmUgKz0gXCJcXHRcIjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb3B5TGluZXMucHVzaChjb3B5TGluZSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gY29weUxpbmVzLmpvaW4oXCJcXG5cIik7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZ3JpZFtfXS5mb2N1c0NvbnRyb2wub25Db3B5KGZ1bmN0aW9uIChfZSkge1xuICAgICAgICAgICAgICByZXR1cm4gdXRpbHNfMS5hcnJheS5maW5kKGdyaWQuZmlyZUxpc3RlbmVycyhcImNvcHlkYXRhXCIsIGdyaWRbX10uc2VsZWN0aW9uLnJhbmdlKSwgZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gciAhPSBudWxsO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBncmlkW19dLmZvY3VzQ29udHJvbC5vblBhc3RlKGZ1bmN0aW9uIChfcmVmNTEpIHtcbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gX3JlZjUxLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgZXZlbnQgPSBfcmVmNTEuZXZlbnQ7XG4gICAgICAgICAgICAgIHZhciB0cmltT25QYXN0ZSA9IGdyaWQudHJpbU9uUGFzdGU7XG4gICAgICAgICAgICAgIHZhciBub3JtYWxpemVkVmFsdWUgPSAoMCwgcGFzdGVfdXRpbHNfMS5ub3JtYWxpemVQYXN0ZVZhbHVlKSh2YWx1ZSk7XG4gICAgICAgICAgICAgIHZhciBfZ3JpZCRfJHNlbGVjdGlvbiRzZWwgPSBncmlkW19dLnNlbGVjdGlvbi5zZWxlY3QsXG4gICAgICAgICAgICAgICAgICBjb2wgPSBfZ3JpZCRfJHNlbGVjdGlvbiRzZWwuY29sLFxuICAgICAgICAgICAgICAgICAgcm93ID0gX2dyaWQkXyRzZWxlY3Rpb24kc2VsLnJvdztcbiAgICAgICAgICAgICAgdmFyIG11bHRpID0gL1tcXHJcXG5cXHUyMDI4XFx1MjAyOVxcdF0vLnRlc3Qobm9ybWFsaXplZFZhbHVlKTsgLy8gaXMgbXVsdGkgY2VsbCB2YWx1ZXNcblxuICAgICAgICAgICAgICB2YXIgcmFuZ2VCb3hWYWx1ZXMgPSBudWxsO1xuICAgICAgICAgICAgICB2YXIgcGFzdGVDZWxsRXZlbnQgPSB7XG4gICAgICAgICAgICAgICAgY29sOiBjb2wsXG4gICAgICAgICAgICAgICAgcm93OiByb3csXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZVZhbHVlOiB0cmltT25QYXN0ZSA/IG5vcm1hbGl6ZWRWYWx1ZS50cmltKCkgOiBub3JtYWxpemVkVmFsdWUsXG4gICAgICAgICAgICAgICAgbXVsdGk6IG11bHRpLFxuXG4gICAgICAgICAgICAgICAgZ2V0IHJhbmdlQm94VmFsdWVzKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlQm94VmFsdWVzICE9PSBudWxsICYmIHJhbmdlQm94VmFsdWVzICE9PSB2b2lkIDAgPyByYW5nZUJveFZhbHVlcyA6IHJhbmdlQm94VmFsdWVzID0gKDAsIHBhc3RlX3V0aWxzXzEucGFyc2VQYXN0ZVJhbmdlQm94VmFsdWVzKShub3JtYWxpemVkVmFsdWUsIHtcbiAgICAgICAgICAgICAgICAgICAgdHJpbU9uUGFzdGU6IHRyaW1PblBhc3RlXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGdyaWQuZmlyZUxpc3RlbmVycyhER19FVkVOVF9UWVBFXzEuREdfRVZFTlRfVFlQRS5QQVNURV9DRUxMLCBwYXN0ZUNlbGxFdmVudCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZ3JpZFtfXS5mb2N1c0NvbnRyb2wub25JbnB1dChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgdmFyIF9ncmlkJF8kc2VsZWN0aW9uJHNlbDIgPSBncmlkW19dLnNlbGVjdGlvbi5zZWxlY3QsXG4gICAgICAgICAgICAgICAgICBjb2wgPSBfZ3JpZCRfJHNlbGVjdGlvbiRzZWwyLmNvbCxcbiAgICAgICAgICAgICAgICAgIHJvdyA9IF9ncmlkJF8kc2VsZWN0aW9uJHNlbDIucm93O1xuICAgICAgICAgICAgICBncmlkLmZpcmVMaXN0ZW5lcnMoREdfRVZFTlRfVFlQRV8xLkRHX0VWRU5UX1RZUEUuSU5QVVRfQ0VMTCwge1xuICAgICAgICAgICAgICAgIGNvbDogY29sLFxuICAgICAgICAgICAgICAgIHJvdzogcm93LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBncmlkW19dLmZvY3VzQ29udHJvbC5vbkRlbGV0ZShmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgdmFyIF9ncmlkJF8kc2VsZWN0aW9uJHNlbDMgPSBncmlkW19dLnNlbGVjdGlvbi5zZWxlY3QsXG4gICAgICAgICAgICAgICAgICBjb2wgPSBfZ3JpZCRfJHNlbGVjdGlvbiRzZWwzLmNvbCxcbiAgICAgICAgICAgICAgICAgIHJvdyA9IF9ncmlkJF8kc2VsZWN0aW9uJHNlbDMucm93O1xuICAgICAgICAgICAgICBncmlkLmZpcmVMaXN0ZW5lcnMoREdfRVZFTlRfVFlQRV8xLkRHX0VWRU5UX1RZUEUuREVMRVRFX0NFTEwsIHtcbiAgICAgICAgICAgICAgICBjb2w6IGNvbCxcbiAgICAgICAgICAgICAgICByb3c6IHJvdyxcbiAgICAgICAgICAgICAgICBldmVudDogZXZlbnRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZ3JpZFtfXS5mb2N1c0NvbnRyb2wub25Gb2N1cyhmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICBncmlkLmZpcmVMaXN0ZW5lcnMoREdfRVZFTlRfVFlQRV8xLkRHX0VWRU5UX1RZUEUuRk9DVVNfR1JJRCwgZSk7XG4gICAgICAgICAgICAgIGdyaWRbX10uZm9jdXNlZEdyaWQgPSB0cnVlO1xuICAgICAgICAgICAgICB2YXIgX2dyaWQkXyRzZWxlY3Rpb24kc2VsNCA9IGdyaWRbX10uc2VsZWN0aW9uLnNlbGVjdCxcbiAgICAgICAgICAgICAgICAgIGNvbCA9IF9ncmlkJF8kc2VsZWN0aW9uJHNlbDQuY29sLFxuICAgICAgICAgICAgICAgICAgcm93ID0gX2dyaWQkXyRzZWxlY3Rpb24kc2VsNC5yb3c7XG4gICAgICAgICAgICAgIGdyaWQuaW52YWxpZGF0ZUNlbGwoY29sLCByb3cpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGdyaWRbX10uZm9jdXNDb250cm9sLm9uQmx1cihmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICBncmlkLmZpcmVMaXN0ZW5lcnMoREdfRVZFTlRfVFlQRV8xLkRHX0VWRU5UX1RZUEUuQkxVUl9HUklELCBlKTtcbiAgICAgICAgICAgICAgZ3JpZFtfXS5mb2N1c2VkR3JpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICB2YXIgX2dyaWQkXyRzZWxlY3Rpb24kc2VsNSA9IGdyaWRbX10uc2VsZWN0aW9uLnNlbGVjdCxcbiAgICAgICAgICAgICAgICAgIGNvbCA9IF9ncmlkJF8kc2VsZWN0aW9uJHNlbDUuY29sLFxuICAgICAgICAgICAgICAgICAgcm93ID0gX2dyaWQkXyRzZWxlY3Rpb24kc2VsNS5yb3c7XG4gICAgICAgICAgICAgIGdyaWQuaW52YWxpZGF0ZUNlbGwoY29sLCByb3cpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgICAgICAgICBmdW5jdGlvbiBfZ2V0UmVzaXplQ29sQXQoZ3JpZCwgYWJzdHJhY3RYLCBhYnN0cmFjdFkpIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDU7XG5cbiAgICAgICAgICAgIGlmIChncmlkW19dLmZyb3plblJvd0NvdW50IDw9IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZnJvemVuUmVjdCA9IF9nZXRGcm96ZW5Sb3dzUmVjdChncmlkKTtcblxuICAgICAgICAgICAgaWYgKCFmcm96ZW5SZWN0LmluUG9pbnQoYWJzdHJhY3RYLCBhYnN0cmFjdFkpKSB7XG4gICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGNlbGwgPSBncmlkLmdldENlbGxBdChhYnN0cmFjdFgsIGFic3RyYWN0WSk7XG4gICAgICAgICAgICB2YXIgY2VsbFJlY3QgPSBncmlkLmdldENlbGxSZWN0KGNlbGwuY29sLCBjZWxsLnJvdyk7XG5cbiAgICAgICAgICAgIGlmIChhYnN0cmFjdFggPCBjZWxsUmVjdC5sZWZ0ICsgb2Zmc2V0KSB7XG4gICAgICAgICAgICAgIHJldHVybiBjZWxsLmNvbCAtIDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjZWxsUmVjdC5yaWdodCAtIG9mZnNldCA8IGFic3RyYWN0WCkge1xuICAgICAgICAgICAgICByZXR1cm4gY2VsbC5jb2w7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cblxuICAgICAgICAgIGZ1bmN0aW9uIF9nZXRWaXNpYmxlUmVjdChncmlkKSB7XG4gICAgICAgICAgICB2YXIgX2dyaWQkXzIgPSBncmlkW19dLFxuICAgICAgICAgICAgICAgIF9ncmlkJF8yJHNjcm9sbCA9IF9ncmlkJF8yLnNjcm9sbCxcbiAgICAgICAgICAgICAgICBsZWZ0ID0gX2dyaWQkXzIkc2Nyb2xsLmxlZnQsXG4gICAgICAgICAgICAgICAgdG9wID0gX2dyaWQkXzIkc2Nyb2xsLnRvcCxcbiAgICAgICAgICAgICAgICBfZ3JpZCRfMiRjYW52YXMgPSBfZ3JpZCRfMi5jYW52YXMsXG4gICAgICAgICAgICAgICAgd2lkdGggPSBfZ3JpZCRfMiRjYW52YXMud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gX2dyaWQkXzIkY2FudmFzLmhlaWdodDtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVjdF8xLlJlY3QobGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cblxuICAgICAgICAgIGZ1bmN0aW9uIF9nZXRTY3JvbGxhYmxlVmlzaWJsZVJlY3QoZ3JpZCkge1xuICAgICAgICAgICAgdmFyIGZyb3plbkNvbHNXaWR0aCA9IDA7XG5cbiAgICAgICAgICAgIGlmIChncmlkW19dLmZyb3plbkNvbENvdW50ID4gMCkge1xuICAgICAgICAgICAgICAvL+WbuuWumuWIl+OBjOOBguOCi+WgtOWQiOWbuuWumuWIl+WIhuaPj+eUu1xuICAgICAgICAgICAgICB2YXIgZnJvemVuUmVjdCA9IF9nZXRGcm96ZW5Db2xzUmVjdChncmlkKTtcblxuICAgICAgICAgICAgICBmcm96ZW5Db2xzV2lkdGggPSBmcm96ZW5SZWN0LndpZHRoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZnJvemVuUm93c0hlaWdodCA9IDA7XG5cbiAgICAgICAgICAgIGlmIChncmlkW19dLmZyb3plblJvd0NvdW50ID4gMCkge1xuICAgICAgICAgICAgICAvL+WbuuWumuWIl+OBjOOBguOCi+WgtOWQiOWbuuWumuWIl+WIhuaPj+eUu1xuICAgICAgICAgICAgICB2YXIgX2Zyb3plblJlY3QzID0gX2dldEZyb3plblJvd3NSZWN0KGdyaWQpO1xuXG4gICAgICAgICAgICAgIGZyb3plblJvd3NIZWlnaHQgPSBfZnJvemVuUmVjdDMuaGVpZ2h0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlY3RfMS5SZWN0KGdyaWRbX10uc2Nyb2xsYWJsZS5zY3JvbGxMZWZ0ICsgZnJvemVuQ29sc1dpZHRoLCBncmlkW19dLnNjcm9sbGFibGUuc2Nyb2xsVG9wICsgZnJvemVuUm93c0hlaWdodCwgZ3JpZFtfXS5jYW52YXMud2lkdGggLSBmcm96ZW5Db2xzV2lkdGgsIGdyaWRbX10uY2FudmFzLmhlaWdodCAtIGZyb3plblJvd3NIZWlnaHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKiogQHByaXZhdGUgKi9cblxuXG4gICAgICAgICAgZnVuY3Rpb24gX3RvUmVsYXRpdmVSZWN0KGdyaWQsIGFic29sdXRlUmVjdCkge1xuICAgICAgICAgICAgdmFyIHJlY3QgPSBhYnNvbHV0ZVJlY3QuY29weSgpO1xuXG4gICAgICAgICAgICB2YXIgdmlzaWJsZVJlY3QgPSBfZ2V0VmlzaWJsZVJlY3QoZ3JpZCk7XG5cbiAgICAgICAgICAgIHJlY3Qub2Zmc2V0TGVmdCgtdmlzaWJsZVJlY3QubGVmdCk7XG4gICAgICAgICAgICByZWN0Lm9mZnNldFRvcCgtdmlzaWJsZVJlY3QudG9wKTtcbiAgICAgICAgICAgIHJldHVybiByZWN0O1xuICAgICAgICAgIH0gLy9lbmQgcHJpdmF0ZSBtZXRob2RzXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vXG4gICAgICAgICAgLy9cblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIG1hbmFnaW5nIG1vdXNlIGRvd24gbW92aW5nXG4gICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgKi9cblxuXG4gICAgICAgICAgdmFyIEJhc2VNb3VzZURvd25Nb3ZlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBCYXNlTW91c2VEb3duTW92ZXIoZ3JpZCkge1xuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmFzZU1vdXNlRG93bk1vdmVyKTtcblxuICAgICAgICAgICAgICB0aGlzLl9ncmlkID0gZ3JpZDtcbiAgICAgICAgICAgICAgdGhpcy5faGFuZGxlciA9IG5ldyBFdmVudEhhbmRsZXJfMS5FdmVudEhhbmRsZXIoKTtcbiAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgdGhpcy5fbW92ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKEJhc2VNb3VzZURvd25Nb3ZlciwgW3tcbiAgICAgICAgICAgICAga2V5OiBcIm1vdmluZ1wiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbW92aW5nKF9lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhdGhpcy5fc3RhcnRlZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwibGFzdE1vdmluZ1wiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbGFzdE1vdmluZyhlKSB7XG4gICAgICAgICAgICAgICAgLy8gbW91c2V1cOW+jOOBmeOBkOOBq+OAgWNsaWNr44Kk44OZ44Oz44OI44KS5Y+N5b+c44GX44Gq44GE44KI44GG44Gr44GZ44KL5Yi25b6h6KaBXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubW92aW5nKGUpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgbGFzdCA9IHRoaXMuX21vdXNlRW5kUG9pbnQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWxhc3QpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcHQgPSBfZ2V0TW91c2VBYnN0cmFjdFBvaW50KHRoaXMuX2dyaWQsIGUpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHB0ICE9IG51bGwgJiYgcHQueCA9PT0gbGFzdC54ICYmIHB0LnkgPT09IGxhc3QueTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiX2JpbmRNb3ZlQW5kVXBcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9iaW5kTW92ZUFuZFVwKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXM2NSA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgICAgICAgICAgIHZhciBoYW5kbGVyID0gdGhpcy5faGFuZGxlcjtcblxuICAgICAgICAgICAgICAgIGlmICghaXNUb3VjaEV2ZW50KGUpKSB7XG4gICAgICAgICAgICAgICAgICBldmVudHMubW91c2Vtb3ZlID0gaGFuZGxlci5vbihkb2N1bWVudC5ib2R5LCBcIm1vdXNlbW92ZVwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM2NS5fbW91c2VNb3ZlKGUpO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBldmVudHMubW91c2V1cCA9IGhhbmRsZXIub24oZG9jdW1lbnQuYm9keSwgXCJtb3VzZXVwXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczY1Ll9tb3VzZVVwKGUpO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGV2ZW50cy50b3VjaG1vdmUgPSBoYW5kbGVyLm9uKGRvY3VtZW50LmJvZHksIFwidG91Y2htb3ZlXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczY1Ll9tb3VzZU1vdmUoZSk7XG4gICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGV2ZW50cy50b3VjaGVuZCA9IGhhbmRsZXIub24oZG9jdW1lbnQuYm9keSwgXCJ0b3VjaGVuZFwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM2NS5fbW91c2VVcChlKTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgZXZlbnRzLnRvdWNoY2FuY2VsID0gaGFuZGxlci5vbihkb2N1bWVudC5ib2R5LCBcInRvdWNoY2FuY2VsXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczY1Ll9tb3VzZVVwKGUpO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW92ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiX21vdXNlTW92ZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX21vdXNlTW92ZShlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1RvdWNoRXZlbnQoZSkpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChnZXRNb3VzZUJ1dHRvbnMoZSkgIT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbW91c2VVcChlKTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fbW92ZWQgPSB0aGlzLl9tb3ZlSW50ZXJuYWwoZSkgfHwgdGhpcy5fbW92ZWRcbiAgICAgICAgICAgICAgICAvKmNhbGN1bGF0aW9uIG9uIGFmdGVyKi9cbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgY2FuY2VsRXZlbnQoZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIl9tb3ZlSW50ZXJuYWxcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9tb3ZlSW50ZXJuYWwoX2UpIHtcbiAgICAgICAgICAgICAgICAvL3Byb3RlY3RlZFxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiX21vdXNlVXBcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9tb3VzZVVwKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXM2NiA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgICAgICAgICAgIHZhciBoYW5kbGVyID0gdGhpcy5faGFuZGxlcjtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLm9mZihldmVudHMubW91c2Vtb3ZlKTtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLm9mZihldmVudHMudG91Y2htb3ZlKTtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLm9mZihldmVudHMubW91c2V1cCk7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5vZmYoZXZlbnRzLnRvdWNoZW5kKTsgLy8gaGFuZGxlci5vZmYodGhpcy5fZXZlbnRzLm1vdXNlbGVhdmUpO1xuXG4gICAgICAgICAgICAgICAgaGFuZGxlci5vZmYoZXZlbnRzLnRvdWNoY2FuY2VsKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl91cEludGVybmFsKGUpOyAvLyBtb3VzZXVw5b6M44GZ44GQ44Gr44CBY2xpY2vjgqTjg5njg7Pjg4jjgpLlj43lv5zjgZfjgarjgYTjgojjgYbjgavjgZnjgovliLblvqHopoFcblxuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX21vdmVkKSB7XG4gICAgICAgICAgICAgICAgICAvL+enu+WLleOBjOeZuueUn+OBl+OBpuOBhOOBn+OCiVxuICAgICAgICAgICAgICAgICAgdGhpcy5fbW91c2VFbmRQb2ludCA9IF9nZXRNb3VzZUFic3RyYWN0UG9pbnQodGhpcy5fZ3JpZCwgZSk7XG4gICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXM2Ni5fbW91c2VFbmRQb2ludCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICB9LCAxMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJfdXBJbnRlcm5hbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3VwSW50ZXJuYWwoX2UpIHsvL3Byb3RlY3RlZFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJkaXNwb3NlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZXIuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBCYXNlTW91c2VEb3duTW92ZXI7XG4gICAgICAgICAgfSgpO1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIG1hbmFnaW5nIGNlbGwgc2VsZWN0aW9uIG9wZXJhdGlvbiB3aXRoIG1vdXNlXG4gICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgKi9cblxuXG4gICAgICAgICAgdmFyIENlbGxTZWxlY3RvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Jhc2VNb3VzZURvd25Nb3Zlcikge1xuICAgICAgICAgICAgX2luaGVyaXRzKENlbGxTZWxlY3RvciwgX0Jhc2VNb3VzZURvd25Nb3Zlcik7XG5cbiAgICAgICAgICAgIHZhciBfc3VwZXI0NiA9IF9jcmVhdGVTdXBlcihDZWxsU2VsZWN0b3IpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBDZWxsU2VsZWN0b3IoKSB7XG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDZWxsU2VsZWN0b3IpO1xuXG4gICAgICAgICAgICAgIHJldHVybiBfc3VwZXI0Ni5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoQ2VsbFNlbGVjdG9yLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwic3RhcnRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2VsbCA9IHRoaXMuX2dldFRhcmdldENlbGwoZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWNlbGwpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfbW92ZUZvY3VzQ2VsbC5jYWxsKHRoaXMuX2dyaWQsIGNlbGwuY29sLCBjZWxsLnJvdywgZS5zaGlmdEtleSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9iaW5kTW92ZUFuZFVwKGUpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fY2VsbCA9IGNlbGw7XG4gICAgICAgICAgICAgICAgY2FuY2VsRXZlbnQoZSk7XG5cbiAgICAgICAgICAgICAgICBfdmlicmF0ZShlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwic2VsZWN0XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3QoZSkge1xuICAgICAgICAgICAgICAgIHZhciBjZWxsID0gdGhpcy5fZ2V0VGFyZ2V0Q2VsbChlKTtcblxuICAgICAgICAgICAgICAgIGlmICghY2VsbCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9tb3ZlRm9jdXNDZWxsLmNhbGwodGhpcy5fZ3JpZCwgY2VsbC5jb2wsIGNlbGwucm93LCBlLnNoaWZ0S2V5KTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2NlbGwgPSBjZWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJfbW92ZUludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbW92ZUludGVybmFsKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2VsbCA9IHRoaXMuX2dldFRhcmdldENlbGwoZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWNlbGwpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMkX2NlbGwgPSB0aGlzLl9jZWxsLFxuICAgICAgICAgICAgICAgICAgICBvbGRDb2wgPSBfdGhpcyRfY2VsbC5jb2wsXG4gICAgICAgICAgICAgICAgICAgIG9sZFJvdyA9IF90aGlzJF9jZWxsLnJvdztcbiAgICAgICAgICAgICAgICB2YXIgbmV3Q29sID0gY2VsbC5jb2wsXG4gICAgICAgICAgICAgICAgICAgIG5ld1JvdyA9IGNlbGwucm93O1xuXG4gICAgICAgICAgICAgICAgaWYgKG9sZENvbCA9PT0gbmV3Q29sICYmIG9sZFJvdyA9PT0gbmV3Um93KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGdyaWQgPSB0aGlzLl9ncmlkO1xuXG4gICAgICAgICAgICAgICAgX21vdmVGb2N1c0NlbGwuY2FsbChncmlkLCBuZXdDb2wsIG5ld1JvdywgdHJ1ZSk7IC8vbWFrZSB2aXNpYmxlXG5cblxuICAgICAgICAgICAgICAgIHZhciBtYWtlVmlzaWJsZUNvbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChuZXdDb2wgPCBvbGRDb2wgJiYgMCA8IG5ld0NvbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBtb3ZlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld0NvbCAtIDE7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9sZENvbCA8IG5ld0NvbCAmJiBuZXdDb2wgKyAxIDwgZ3JpZC5jb2xDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBtb3ZlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdDb2wgKyAxO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gbmV3Q29sO1xuICAgICAgICAgICAgICAgIH0oKTtcblxuICAgICAgICAgICAgICAgIHZhciBtYWtlVmlzaWJsZVJvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChuZXdSb3cgPCBvbGRSb3cgJiYgMCA8IG5ld1Jvdykge1xuICAgICAgICAgICAgICAgICAgICAvLyBtb3ZlIHVwXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdSb3cgLSAxO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvbGRSb3cgPCBuZXdSb3cgJiYgbmV3Um93ICsgMSA8IGdyaWQucm93Q291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbW92ZSBkb3duXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdSb3cgKyAxO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gbmV3Um93O1xuICAgICAgICAgICAgICAgIH0oKTtcblxuICAgICAgICAgICAgICAgIGlmIChtYWtlVmlzaWJsZUNvbCAhPT0gbmV3Q29sIHx8IG1ha2VWaXNpYmxlUm93ICE9PSBuZXdSb3cpIHtcbiAgICAgICAgICAgICAgICAgIGdyaWQubWFrZVZpc2libGVDZWxsKG1ha2VWaXNpYmxlQ29sLCBtYWtlVmlzaWJsZVJvdyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fY2VsbCA9IGNlbGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIl9nZXRUYXJnZXRDZWxsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0VGFyZ2V0Q2VsbChlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGdyaWQgPSB0aGlzLl9ncmlkO1xuXG4gICAgICAgICAgICAgICAgdmFyIGFic3RyYWN0UG9zID0gX2dldE1vdXNlQWJzdHJhY3RQb2ludChncmlkLCBlKTtcblxuICAgICAgICAgICAgICAgIGlmICghYWJzdHJhY3RQb3MpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBjZWxsID0gZ3JpZC5nZXRDZWxsQXQoYWJzdHJhY3RQb3MueCwgYWJzdHJhY3RQb3MueSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY2VsbC5jb2wgPCAwIHx8IGNlbGwucm93IDwgMCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNlbGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIENlbGxTZWxlY3RvcjtcbiAgICAgICAgICB9KEJhc2VNb3VzZURvd25Nb3Zlcik7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogbWFuYWdpbmcgcm93IHdpZHRoIGNoYW5naW5nIG9wZXJhdGlvbiB3aXRoIG1vdXNlXG4gICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgKi9cblxuXG4gICAgICAgICAgdmFyIENvbHVtblJlc2l6ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXNlTW91c2VEb3duTW92ZXIyKSB7XG4gICAgICAgICAgICBfaW5oZXJpdHMoQ29sdW1uUmVzaXplciwgX0Jhc2VNb3VzZURvd25Nb3ZlcjIpO1xuXG4gICAgICAgICAgICB2YXIgX3N1cGVyNDcgPSBfY3JlYXRlU3VwZXIoQ29sdW1uUmVzaXplcik7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIENvbHVtblJlc2l6ZXIoZ3JpZCkge1xuICAgICAgICAgICAgICB2YXIgX3RoaXM2NztcblxuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29sdW1uUmVzaXplcik7XG5cbiAgICAgICAgICAgICAgX3RoaXM2NyA9IF9zdXBlcjQ3LmNhbGwodGhpcywgZ3JpZCk7XG4gICAgICAgICAgICAgIF90aGlzNjcuX3ggPSAtMTtcbiAgICAgICAgICAgICAgX3RoaXM2Ny5fcHJlWCA9IC0xO1xuICAgICAgICAgICAgICBfdGhpczY3Ll9pbnZhbGlkYXRlQWJzb2x1dGVMZWZ0ID0gLTE7XG4gICAgICAgICAgICAgIF90aGlzNjcuX3RhcmdldENvbCA9IC0xO1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXM2NztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKENvbHVtblJlc2l6ZXIsIFt7XG4gICAgICAgICAgICAgIGtleTogXCJzdGFydFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnQoY29sLCBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhZ2VYO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFpc1RvdWNoRXZlbnQoZSkpIHtcbiAgICAgICAgICAgICAgICAgIHBhZ2VYID0gZS5wYWdlWDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcGFnZVggPSBlLmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VYO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX3ggPSBwYWdlWDtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcmVYID0gMDtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2JpbmRNb3ZlQW5kVXAoZSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl90YXJnZXRDb2wgPSBjb2w7XG4gICAgICAgICAgICAgICAgdGhpcy5faW52YWxpZGF0ZUFic29sdXRlTGVmdCA9IF9nZXRDb2xzV2lkdGgodGhpcy5fZ3JpZCwgMCwgY29sIC0gMSk7XG4gICAgICAgICAgICAgICAgY2FuY2VsRXZlbnQoZSk7XG5cbiAgICAgICAgICAgICAgICBfdmlicmF0ZShlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiX21vdmVJbnRlcm5hbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX21vdmVJbnRlcm5hbChlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhZ2VYID0gaXNUb3VjaEV2ZW50KGUpID8gZS5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWCA6IGUucGFnZVg7XG4gICAgICAgICAgICAgICAgdmFyIHggPSBwYWdlWCAtIHRoaXMuX3g7XG4gICAgICAgICAgICAgICAgdmFyIG1vdmVYID0geCAtIHRoaXMuX3ByZVg7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJlWCA9IHg7XG5cbiAgICAgICAgICAgICAgICB2YXIgcHJlID0gdGhpcy5fZ3JpZC5nZXRDb2xXaWR0aCh0aGlzLl90YXJnZXRDb2wpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGFmdGVyU2l6ZSA9IF9hZGp1c3RDb2xXaWR0aCh0aGlzLl9ncmlkLCB0aGlzLl90YXJnZXRDb2wsIHByZSArIG1vdmVYKTtcblxuICAgICAgICAgICAgICAgIGlmIChhZnRlclNpemUgPCAxMCAmJiBtb3ZlWCA8IDApIHtcbiAgICAgICAgICAgICAgICAgIGFmdGVyU2l6ZSA9IDEwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9zdG9yZUF1dG9Db2xXaWR0aEV4cHJzKHRoaXMuX2dyaWQpO1xuXG4gICAgICAgICAgICAgICAgX3NldENvbFdpZHRoKHRoaXMuX2dyaWQsIHRoaXMuX3RhcmdldENvbCwgYWZ0ZXJTaXplKTtcblxuICAgICAgICAgICAgICAgIHZhciByZWN0ID0gX2dldFZpc2libGVSZWN0KHRoaXMuX2dyaWQpO1xuXG4gICAgICAgICAgICAgICAgcmVjdC5sZWZ0ID0gdGhpcy5faW52YWxpZGF0ZUFic29sdXRlTGVmdDtcblxuICAgICAgICAgICAgICAgIF9pbnZhbGlkYXRlUmVjdCh0aGlzLl9ncmlkLCByZWN0KTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2dyaWQuZmlyZUxpc3RlbmVycyhER19FVkVOVF9UWVBFXzEuREdfRVZFTlRfVFlQRS5SRVNJWkVfQ09MVU1OLCB7XG4gICAgICAgICAgICAgICAgICBjb2w6IHRoaXMuX3RhcmdldENvbFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIl91cEludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBJbnRlcm5hbChfZSkge1xuICAgICAgICAgICAgICAgIHZhciBncmlkID0gdGhpcy5fZ3JpZDtcblxuICAgICAgICAgICAgICAgIGlmIChncmlkLnVwZGF0ZVNjcm9sbCgpKSB7XG4gICAgICAgICAgICAgICAgICBncmlkLmludmFsaWRhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIENvbHVtblJlc2l6ZXI7XG4gICAgICAgICAgfShCYXNlTW91c2VEb3duTW92ZXIpO1xuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgICAgICAgICBmdW5jdGlvbiBzZXRTYWZlSW5wdXRWYWx1ZShpbnB1dCwgdmFsdWUpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gaW5wdXQudHlwZTtcbiAgICAgICAgICAgIGlucHV0LnR5cGUgPSBcIlwiO1xuICAgICAgICAgICAgaW5wdXQudmFsdWUgPSB2YWx1ZTtcblxuICAgICAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgICAgaW5wdXQudHlwZSA9IHR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIElHTk9SRV9TVE9SRV9BVFRSUyA9IFtcInN0eWxlXCIsIFwicmVhZG9ubHlcIl07XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogTWFuYWdlIGZvY3VzXG4gICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgKi9cblxuICAgICAgICAgIHZhciBGb2N1c0NvbnRyb2wgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FdmVudFRhcmdldF8xJEV2ZW50VDIpIHtcbiAgICAgICAgICAgIF9pbmhlcml0cyhGb2N1c0NvbnRyb2wsIF9FdmVudFRhcmdldF8xJEV2ZW50VDIpO1xuXG4gICAgICAgICAgICB2YXIgX3N1cGVyNDggPSBfY3JlYXRlU3VwZXIoRm9jdXNDb250cm9sKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gRm9jdXNDb250cm9sKGdyaWQsIHBhcmVudEVsZW1lbnQsIHNjcm9sbGFibGUsIHNlbGVjdGlvbikge1xuICAgICAgICAgICAgICB2YXIgX3RoaXM2ODtcblxuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRm9jdXNDb250cm9sKTtcblxuICAgICAgICAgICAgICBfdGhpczY4ID0gX3N1cGVyNDguY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgX3RoaXM2OC5fZ3JpZCA9IGdyaWQ7XG4gICAgICAgICAgICAgIF90aGlzNjguX3Njcm9sbGFibGUgPSBzY3JvbGxhYmxlO1xuICAgICAgICAgICAgICB2YXIgaGFuZGxlciA9IF90aGlzNjguX2hhbmRsZXIgPSBuZXcgRXZlbnRIYW5kbGVyXzEuRXZlbnRIYW5kbGVyKCk7XG4gICAgICAgICAgICAgIHZhciBpbnB1dCA9IF90aGlzNjguX2lucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgICAgICAgICAgICBpbnB1dC5jbGFzc0xpc3QuYWRkKFwiZ3JpZC1mb2N1cy1jb250cm9sXCIpO1xuICAgICAgICAgICAgICBpbnB1dC5yZWFkT25seSA9IHRydWU7XG4gICAgICAgICAgICAgIHBhcmVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoaW5wdXQpO1xuICAgICAgICAgICAgICBoYW5kbGVyLm9uKGlucHV0LCBcImNvbXBvc2l0aW9uc3RhcnRcIiwgZnVuY3Rpb24gKF9lKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQuY2xhc3NMaXN0LmFkZChcImNvbXBvc2l0aW9uXCIpO1xuICAgICAgICAgICAgICAgIGlucHV0LnN0eWxlLmZvbnQgPSBncmlkLmZvbnQgfHwgXCIxNnB4IHNhbnMtc2VyaWZcIjtcbiAgICAgICAgICAgICAgICBfdGhpczY4Ll9pc0NvbXBvc2l0aW9uID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIGlmIChfdGhpczY4Ll9jb21wb3NpdGlvbkVuZCkge1xuICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzNjguX2NvbXBvc2l0aW9uRW5kKTtcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZSBfdGhpczY4Ll9jb21wb3NpdGlvbkVuZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBncmlkLmZvY3VzKCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB2YXIgbGFzdElucHV0VmFsdWU7XG5cbiAgICAgICAgICAgICAgdmFyIGlucHV0Q2xlYXIgPSBmdW5jdGlvbiBpbnB1dENsZWFyKHN0b3JlTGFzdElucHV0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBsYXN0SW5wdXRWYWx1ZSA9IGlucHV0LnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzNjguX2lzQ29tcG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobGFzdElucHV0VmFsdWUgIT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgIHNldFNhZmVJbnB1dFZhbHVlKGlucHV0LCBcIlwiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIXN0b3JlTGFzdElucHV0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIGxhc3RJbnB1dFZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgdmFyIGhhbmRsZUNvbXBvc2l0aW9uRW5kID0gZnVuY3Rpb24gaGFuZGxlQ29tcG9zaXRpb25FbmQoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXM2OC5faXNDb21wb3NpdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlucHV0LmNsYXNzTGlzdC5yZW1vdmUoXCJjb21wb3NpdGlvblwiKTtcbiAgICAgICAgICAgICAgICBpbnB1dC5zdHlsZS5mb250ID0gXCJcIjtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBpbnB1dC52YWx1ZTtcbiAgICAgICAgICAgICAgICBpbnB1dENsZWFyKGZhbHNlKTtcblxuICAgICAgICAgICAgICAgIGlmICghaW5wdXQucmVhZE9ubHkpIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzNjguZmlyZUxpc3RlbmVycyhcImlucHV0XCIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoX3RoaXM2OC5fY29tcG9zaXRpb25FbmQpIHtcbiAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChfdGhpczY4Ll9jb21wb3NpdGlvbkVuZCk7XG4gICAgICAgICAgICAgICAgICBkZWxldGUgX3RoaXM2OC5fY29tcG9zaXRpb25FbmQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIGhhbmRsZXIub24oaW5wdXQsIFwiY29tcG9zaXRpb25lbmRcIiwgZnVuY3Rpb24gKF9lKSB7XG4gICAgICAgICAgICAgICAgX3RoaXM2OC5fY29tcG9zaXRpb25FbmQgPSBzZXRUaW1lb3V0KGhhbmRsZUNvbXBvc2l0aW9uRW5kLCAxKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHNlbGVjdGlvbi5saXN0ZW4oXCJiZWZvcmVfaG9va1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzNjguX2NvbXBvc2l0aW9uRW5kKSB7XG4gICAgICAgICAgICAgICAgICBoYW5kbGVDb21wb3NpdGlvbkVuZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGhhbmRsZXIub24oaW5wdXQsIFwia2V5cHJlc3NcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXM2OC5faXNDb21wb3NpdGlvbikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghaW5wdXQucmVhZE9ubHkgJiYgZS5rZXkgJiYgZS5rZXkubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZS5jdHJsS2V5IHx8IGUubWV0YUtleSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5rZXkgPT09IFwiY1wiKSB7Ly9jb3B5ISBmb3IgRmlyZWZveCAmIFNhZmFyaVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGUua2V5ID09PSBcInZcIikgey8vcGFzdGUhIGZvciBGaXJlZm94ICYgU2FmYXJpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmtleSA9PT0gXCIgXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBTaW5jZSB0aGUgZnVsbC13aWR0aCBzcGFjZSBjYW5ub3QgYmUgZGV0ZXJtaW5lZCwgaXQgaXMgcHJvY2Vzc2VkIGJ5IFwiaW5wdXRcIi5cbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBfdGhpczY4LmZpcmVMaXN0ZW5lcnMoXCJpbnB1dFwiLCBlLmtleSk7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsRXZlbnQoZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaW5wdXRDbGVhcih0cnVlKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGhhbmRsZXIub24oaW5wdXQsIFwia2V5ZG93blwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcblxuICAgICAgICAgICAgICAgIGlmIChfdGhpczY4Ll9pc0NvbXBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoX3RoaXM2OC5fY29tcG9zaXRpb25FbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlQ29tcG9zaXRpb25FbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsRXZlbnQoZSk7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIga2V5Q29kZSA9IGdldEtleUNvZGUoZSk7XG4gICAgICAgICAgICAgICAgdmFyIHN0b3BDZWxsTW92ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHZhciBldnQgPSB7XG4gICAgICAgICAgICAgICAgICBrZXlDb2RlOiBrZXlDb2RlLFxuICAgICAgICAgICAgICAgICAgZXZlbnQ6IGUsXG4gICAgICAgICAgICAgICAgICBzdG9wQ2VsbE1vdmluZzogZnVuY3Rpb24gc3RvcENlbGxNb3ZpbmcoKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3BDZWxsTW92ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIF90aGlzNjguZmlyZUxpc3RlbmVycyhcImtleWRvd25cIiwgZXZ0KTtcblxuICAgICAgICAgICAgICAgIGlmICghaW5wdXQucmVhZE9ubHkgJiYgbGFzdElucHV0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIC8vIGZvciBTYWZhcmlcbiAgICAgICAgICAgICAgICAgIF90aGlzNjguZmlyZUxpc3RlbmVycyhcImlucHV0XCIsIGxhc3RJbnB1dFZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIXN0b3BDZWxsTW92ZSkgX3RoaXM2OC5maXJlS2V5RG93bk1vdmUoa2V5Q29kZSwgZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoKChfYSA9IF90aGlzNjguX2dyaWQua2V5Ym9hcmRPcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVsZXRlQ2VsbFZhbHVlT25EZWwpICYmIChrZXlDb2RlID09PSBLRVlfREVMIHx8IGtleUNvZGUgPT09IEtFWV9CUykpIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzNjguZmlyZUxpc3RlbmVycyhcImRlbGV0ZVwiLCBlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpbnB1dENsZWFyKHRydWUpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaGFuZGxlci5vbihpbnB1dCwgXCJrZXl1cFwiLCBmdW5jdGlvbiAoX2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXM2OC5faXNDb21wb3NpdGlvbikge1xuICAgICAgICAgICAgICAgICAgaWYgKF90aGlzNjguX2NvbXBvc2l0aW9uRW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUNvbXBvc2l0aW9uRW5kKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaW5wdXRDbGVhcih0cnVlKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGhhbmRsZXIub24oaW5wdXQsIFwiaW5wdXRcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS5kYXRhID09PSBcIiBcIiB8fCBlLmRhdGEgPT09IFwi44CAXCIpIHtcbiAgICAgICAgICAgICAgICAgIC8vIFNpbmNlIHRoZSBmdWxsLXdpZHRoIHNwYWNlIGNhbm5vdCBiZSBkZXRlcm1pbmVkIG9uIFwia2V5cHJlc3NcIiwgaXQgaXMgcHJvY2Vzc2VkIGJ5IFwiaW5wdXRcIi5cbiAgICAgICAgICAgICAgICAgIF90aGlzNjguZmlyZUxpc3RlbmVycyhcImlucHV0XCIsIGUuZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaW5wdXRDbGVhcih0cnVlKTtcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgaWYgKHV0aWxzXzEuYnJvd3Nlci5JRSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIub24oZG9jdW1lbnQsIFwia2V5ZG93blwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGUudGFyZ2V0ICE9PSBpbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHZhciBrZXlDb2RlID0gZ2V0S2V5Q29kZShlKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKGtleUNvZGUgPT09IEtFWV9BTFBIQV9DICYmIGUuY3RybEtleSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHRleHQgaXMgbm90IHNlbGVjdGVkIGNvcHktZXZlbnQgaXMgbm90IGVtaXQsIG9uIElFLlxuICAgICAgICAgICAgICAgICAgICBzZXRTYWZlSW5wdXRWYWx1ZShpbnB1dCwgXCJkdW1teVwiKTtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQuc2VsZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHNldFNhZmVJbnB1dFZhbHVlKGlucHV0LCBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5Q29kZSA9PT0gS0VZX0FMUEhBX1YgJiYgZS5jdHJsS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gaW5wdXQgaXMgcmVhZC1vbmx5IHBhc3RlLWV2ZW50IGlzIG5vdCBlbWl0LCBvbiBJRS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LnJlYWRPbmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgaW5wdXQucmVhZE9ubHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0LnJlYWRPbmx5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFNhZmVJbnB1dFZhbHVlKGlucHV0LCBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICB9LCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICh1dGlsc18xLmJyb3dzZXIuRWRnZSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIub25jZShkb2N1bWVudCwgXCJrZXlkb3duXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgX2E7XG5cbiAgICAgICAgICAgICAgICAgIGlmICghKDAsIHV0aWxzXzEuaXNEZXNjZW5kYW50RWxlbWVudCkocGFyZW50RWxlbWVudCwgZS50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH0gLy8gV2hlbiB0aGUgaW5wdXQgaGFzIGZvY3VzIG9uIHRoZSBmaXJzdCBwYWdlIG9wZW5pbmcsIHRoZSBwYXN0ZS1ldmVudCBhbmQgY29weS1ldmVudCBpcyBub3QgZW1pdCwgb24gRWRnZS5cblxuXG4gICAgICAgICAgICAgICAgICB2YXIgZHVtbXlJbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICAgICAgICAgICAgICAgIGdyaWQuZ2V0RWxlbWVudCgpLmFwcGVuZENoaWxkKGR1bW15SW5wdXQpO1xuICAgICAgICAgICAgICAgICAgZHVtbXlJbnB1dC5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgIChfYSA9IGR1bW15SW5wdXQucGFyZW50RWxlbWVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZUNoaWxkKGR1bW15SW5wdXQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaGFuZGxlci5vbihkb2N1bWVudCwgXCJwYXN0ZVwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGlmICghKDAsIHV0aWxzXzEuaXNEZXNjZW5kYW50RWxlbWVudCkocGFyZW50RWxlbWVudCwgZS50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHBhc3RlVGV4dCA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgICAgIGlmICh1dGlsc18xLmJyb3dzZXIuSUUpIHtcbiAgICAgICAgICAgICAgICAgIC8vIElFXG4gICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgcGFzdGVUZXh0ID0gd2luZG93LmNsaXBib2FyZERhdGEuZ2V0RGF0YShcIlRleHRcIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhciBjbGlwYm9hcmREYXRhID0gZS5jbGlwYm9hcmREYXRhO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoY2xpcGJvYXJkRGF0YS5pdGVtcykge1xuICAgICAgICAgICAgICAgICAgICAvLyBDaHJvbWUgJiBGaXJlZm94ICYgRWRnZVxuICAgICAgICAgICAgICAgICAgICBwYXN0ZVRleHQgPSBjbGlwYm9hcmREYXRhLmdldERhdGEoXCJ0ZXh0L3BsYWluXCIpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2FmYXJpXG4gICAgICAgICAgICAgICAgICAgIGlmICgtMSAhPT0gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChjbGlwYm9hcmREYXRhLnR5cGVzLCBcInRleHQvcGxhaW5cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICBwYXN0ZVRleHQgPSBjbGlwYm9hcmREYXRhLmdldERhdGEoXCJUZXh0XCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHBhc3RlVGV4dCAhPSBudWxsICYmIHBhc3RlVGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzNjguZmlyZUxpc3RlbmVycyhcInBhc3RlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHBhc3RlVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGVcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGhhbmRsZXIub24oZG9jdW1lbnQsIFwiY29weVwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpczY4Ll9pc0NvbXBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCEoMCwgdXRpbHNfMS5pc0Rlc2NlbmRhbnRFbGVtZW50KShwYXJlbnRFbGVtZW50LCBlLnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZXRTYWZlSW5wdXRWYWx1ZShpbnB1dCwgXCJcIik7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB1dGlsc18xLmFycmF5LmZpbmQoX3RoaXM2OC5maXJlTGlzdGVuZXJzKFwiY29weVwiKSwgZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByICE9IG51bGw7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBjYW5jZWxFdmVudChlKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKHV0aWxzXzEuYnJvd3Nlci5JRSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuY2xpcGJvYXJkRGF0YS5zZXREYXRhKFwiVGV4dFwiLCBkYXRhKTsgLy8gSUVcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGUuY2xpcGJvYXJkRGF0YS5zZXREYXRhKFwidGV4dC9wbGFpblwiLCBkYXRhKTsgLy8gQ2hyb21lLCBGaXJlZm94XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaGFuZGxlci5vbihpbnB1dCwgXCJmb2N1c1wiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIF90aGlzNjguZmlyZUxpc3RlbmVycyhcImZvY3VzXCIsIGUpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaGFuZGxlci5vbihpbnB1dCwgXCJibHVyXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXM2OC5maXJlTGlzdGVuZXJzKFwiYmx1clwiLCBlKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczY4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoRm9jdXNDb250cm9sLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiZmlyZUtleURvd25Nb3ZlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmaXJlS2V5RG93bk1vdmUoa2V5Q29kZSwgZSkge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuXG4gICAgICAgICAgICAgICAgdmFyIGZuID0gdGhpcy5fa2V5RG93bk1vdmVDYWxsYmFjaztcblxuICAgICAgICAgICAgICAgIGlmICghZm4pIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNDb21wb3NpdGlvbikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChrZXlDb2RlID09PSBLRVlfTEVGVCB8fCBrZXlDb2RlID09PSBLRVlfVVAgfHwga2V5Q29kZSA9PT0gS0VZX1JJR0hUIHx8IGtleUNvZGUgPT09IEtFWV9ET1dOIHx8IGtleUNvZGUgPT09IEtFWV9IT01FIHx8IGtleUNvZGUgPT09IEtFWV9FTkQpIHtcbiAgICAgICAgICAgICAgICAgIGZuKGUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKChfYSA9IHRoaXMuX2dyaWQua2V5Ym9hcmRPcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubW92ZUNlbGxPblRhYikgJiYga2V5Q29kZSA9PT0gS0VZX1RBQikge1xuICAgICAgICAgICAgICAgICAgZm4oZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICgoKF9iID0gdGhpcy5fZ3JpZC5rZXlib2FyZE9wdGlvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5tb3ZlQ2VsbE9uRW50ZXIpICYmIGtleUNvZGUgPT09IEtFWV9FTlRFUikge1xuICAgICAgICAgICAgICAgICAgZm4oZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICgoKF9jID0gdGhpcy5fZ3JpZC5rZXlib2FyZE9wdGlvbnMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5zZWxlY3RBbGxPbkN0cmxBKSAmJiBrZXlDb2RlID09PSBLRVlfQUxQSEFfQSAmJiAoZS5jdHJsS2V5IHx8IGUubWV0YUtleSkpIHtcbiAgICAgICAgICAgICAgICAgIGZuKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwib25LZXlEb3duTW92ZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25LZXlEb3duTW92ZShmbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2tleURvd25Nb3ZlQ2FsbGJhY2sgPSBmbjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwib25LZXlEb3duXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbktleURvd24oZm4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW4oXCJrZXlkb3duXCIsIGZuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwib25JbnB1dFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25JbnB1dChmbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxpc3RlbihcImlucHV0XCIsIGZuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwib25EZWxldGVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uRGVsZXRlKGZuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuKFwiZGVsZXRlXCIsIGZuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwib25Db3B5XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbkNvcHkoZm4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW4oXCJjb3B5XCIsIGZuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwib25QYXN0ZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25QYXN0ZShmbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxpc3RlbihcInBhc3RlXCIsIGZuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwib25Gb2N1c1wiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25Gb2N1cyhmbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxpc3RlbihcImZvY3VzXCIsIGZuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwib25CbHVyXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbkJsdXIoZm4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW4oXCJibHVyXCIsIGZuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZm9jdXNcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZvY3VzKCkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMuX2lucHV0LnZhbHVlID0gJyc7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5wdXQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwic2V0Rm9jdXNSZWN0XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRGb2N1c1JlY3QocmVjdCkge1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dCA9IHRoaXMuX2lucHV0O1xuXG4gICAgICAgICAgICAgICAgdmFyIHRvcCA9IHRoaXMuX3Njcm9sbGFibGUuY2FsY1RvcChyZWN0LnRvcCk7XG5cbiAgICAgICAgICAgICAgICBpbnB1dC5zdHlsZS50b3AgPSBcIlwiLmNvbmNhdCgodG9wIC0gc3R5bGUuZ2V0U2Nyb2xsQmFyU2l6ZSgpKS50b0ZpeGVkKCksIFwicHhcIik7IC8vcG9zaXRpb246cmVsYXRpdmUg44Gg44Go44Ga44KM44KL44GM44CBSUXjga8gcG9zaXRpb246cmVsYXRpdmXjgZjjgoPjgarjgYTjgajmnIDlpKflgKTjgb7jgafliKnnlKjjgafjgY3jgarjgYRcblxuICAgICAgICAgICAgICAgIGlucHV0LnN0eWxlLmxlZnQgPSBcIlwiLmNvbmNhdChyZWN0LmxlZnQudG9GaXhlZCgpLCBcInB4XCIpO1xuICAgICAgICAgICAgICAgIGlucHV0LnN0eWxlLndpZHRoID0gXCJcIi5jb25jYXQocmVjdC53aWR0aC50b0ZpeGVkKCksIFwicHhcIik7XG4gICAgICAgICAgICAgICAgaW5wdXQuc3R5bGUuaGVpZ2h0ID0gXCJcIi5jb25jYXQocmVjdC5oZWlnaHQudG9GaXhlZCgpLCBcInB4XCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJlZGl0TW9kZVwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIXRoaXMuX2lucHV0LnJlYWRPbmx5O1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChlZGl0TW9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2lucHV0LnJlYWRPbmx5ID0gIWVkaXRNb2RlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJyZXNldElucHV0U3RhdHVzXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldElucHV0U3RhdHVzKCkge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcblxuICAgICAgICAgICAgICAgIHZhciBlbCA9IHRoaXMuX2lucHV0O1xuXG4gICAgICAgICAgICAgICAgaWYgKCFlbC5jbGFzc0xpc3QuY29udGFpbnMoXCJncmlkLWZvY3VzLWNvbnRyb2wtLXN0b3JlZC1zdGF0dXNcIikpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgY29tcG9zaXRpb24gPSBlbC5jbGFzc0xpc3QuY29udGFpbnMoXCJjb21wb3NpdGlvblwiKTtcbiAgICAgICAgICAgICAgICB2YXIgYXR0cnMgPSBlbC5hdHRyaWJ1dGVzO1xuICAgICAgICAgICAgICAgIHZhciByZW1vdmVOYW1lcyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBhdHRycy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIHZhciBhdHRyID0gYXR0cnNbaV07XG4gICAgICAgICAgICAgICAgICBpZiAoSUdOT1JFX1NUT1JFX0FUVFJTLmluZGV4T2YoYXR0ci5uYW1lKSA+PSAwKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgICAgaWYgKCEoKF9hID0gdGhpcy5faW5wdXRTdGF0dXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oYXNPd25Qcm9wZXJ0eShhdHRyLm5vZGVOYW1lKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTmFtZXMucHVzaChhdHRyLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlbW92ZU5hbWVzLmZvckVhY2goZnVuY3Rpb24gKHJlbW92ZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShyZW1vdmVOYW1lKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcy5faW5wdXRTdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZShuYW1lLCB0aGlzLl9pbnB1dFN0YXR1c1tuYW1lXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGNvbXBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKFwiY29tcG9zaXRpb25cIik7XG4gICAgICAgICAgICAgICAgICBlbC5zdHlsZS5mb250ID0gdGhpcy5fZ3JpZC5mb250IHx8IFwiMTZweCBzYW5zLXNlcmlmXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoXCJjb21wb3NpdGlvblwiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKFwiZ3JpZC1mb2N1cy1jb250cm9sLS1zdG9yZWQtc3RhdHVzXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJzdG9yZUlucHV0U3RhdHVzXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9yZUlucHV0U3RhdHVzKCkge1xuICAgICAgICAgICAgICAgIHZhciBlbCA9IHRoaXMuX2lucHV0O1xuXG4gICAgICAgICAgICAgICAgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucyhcImdyaWQtZm9jdXMtY29udHJvbC0tc3RvcmVkLXN0YXR1c1wiKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBpbnB1dFN0YXR1cyA9IHRoaXMuX2lucHV0U3RhdHVzID0ge307XG4gICAgICAgICAgICAgICAgdmFyIGF0dHJzID0gZWwuYXR0cmlidXRlcztcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gYXR0cnMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgYXR0ciA9IGF0dHJzW2ldO1xuICAgICAgICAgICAgICAgICAgaWYgKElHTk9SRV9TVE9SRV9BVFRSUy5pbmRleE9mKGF0dHIubmFtZSkgPj0gMCkgY29udGludWU7XG4gICAgICAgICAgICAgICAgICBpbnB1dFN0YXR1c1thdHRyLm5hbWVdID0gYXR0ci52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKFwiZ3JpZC1mb2N1cy1jb250cm9sLS1zdG9yZWQtc3RhdHVzXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJzZXREZWZhdWx0SW5wdXRTdGF0dXNcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldERlZmF1bHRJbnB1dFN0YXR1cygpIHsvLyDjgarjgZzjgYvjgrnjgq/jg63jg7zjg6vjgYzlsJHjgZfjgZrjgaTjgZrjgozjgabjgYTjgY/jgZPjgajjgYzjgYLjgovjga7jgafjgZPjgZPjgafjga/jgrvjg4Pjg4jjgZfjgarjgYTjgIJcbiAgICAgICAgICAgICAgICAvLyB0aGlzLl9pbnB1dC5zdHlsZS5mb250ID0gdGhpcy5fZ3JpZC5mb250IHx8ICcxNnB4IHNhbnMtc2VyaWYnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJpbnB1dFwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faW5wdXQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImRpc3Bvc2VcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgICAgICAgICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoRm9jdXNDb250cm9sLnByb3RvdHlwZSksIFwiZGlzcG9zZVwiLCB0aGlzKS5jYWxsKHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlci5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIEZvY3VzQ29udHJvbDtcbiAgICAgICAgICB9KEV2ZW50VGFyZ2V0XzEuRXZlbnRUYXJnZXQpO1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFNlbGVjdGVkIGFyZWEgbWFuYWdlbWVudFxuICAgICAgICAgICAqL1xuXG5cbiAgICAgICAgICB2YXIgU2VsZWN0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXZlbnRUYXJnZXRfMSRFdmVudFQzKSB7XG4gICAgICAgICAgICBfaW5oZXJpdHMoU2VsZWN0aW9uLCBfRXZlbnRUYXJnZXRfMSRFdmVudFQzKTtcblxuICAgICAgICAgICAgdmFyIF9zdXBlcjQ5ID0gX2NyZWF0ZVN1cGVyKFNlbGVjdGlvbik7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIFNlbGVjdGlvbihncmlkKSB7XG4gICAgICAgICAgICAgIHZhciBfdGhpczY5O1xuXG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTZWxlY3Rpb24pO1xuXG4gICAgICAgICAgICAgIF90aGlzNjkgPSBfc3VwZXI0OS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICBfdGhpczY5Ll9ncmlkID0gZ3JpZDtcbiAgICAgICAgICAgICAgX3RoaXM2OS5fc2VsID0ge1xuICAgICAgICAgICAgICAgIGNvbDogMCxcbiAgICAgICAgICAgICAgICByb3c6IDBcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgX3RoaXM2OS5fZm9jdXMgPSB7XG4gICAgICAgICAgICAgICAgY29sOiAwLFxuICAgICAgICAgICAgICAgIHJvdzogMFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBfdGhpczY5Ll9zdGFydCA9IHtcbiAgICAgICAgICAgICAgICBjb2w6IDAsXG4gICAgICAgICAgICAgICAgcm93OiAwXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIF90aGlzNjkuX2VuZCA9IHtcbiAgICAgICAgICAgICAgICBjb2w6IDAsXG4gICAgICAgICAgICAgICAgcm93OiAwXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczY5O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoU2VsZWN0aW9uLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwicmFuZ2VcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5fc3RhcnQ7XG4gICAgICAgICAgICAgICAgdmFyIGVuZCA9IHRoaXMuX2VuZDtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRDb2wgPSBNYXRoLm1pbihzdGFydC5jb2wsIGVuZC5jb2wpO1xuICAgICAgICAgICAgICAgIHZhciBzdGFydFJvdyA9IE1hdGgubWluKHN0YXJ0LnJvdywgZW5kLnJvdyk7XG4gICAgICAgICAgICAgICAgdmFyIGVuZENvbCA9IE1hdGgubWF4KHN0YXJ0LmNvbCwgZW5kLmNvbCk7XG4gICAgICAgICAgICAgICAgdmFyIGVuZFJvdyA9IE1hdGgubWF4KHN0YXJ0LnJvdywgZW5kLnJvdyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbDogc3RhcnRDb2wsXG4gICAgICAgICAgICAgICAgICAgIHJvdzogc3RhcnRSb3dcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBlbmQ6IHtcbiAgICAgICAgICAgICAgICAgICAgY29sOiBlbmRDb2wsXG4gICAgICAgICAgICAgICAgICAgIHJvdzogZW5kUm93XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQocmFuZ2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXM3MCA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9jYWxsQmVmb3JlSG9va3MoKTtcblxuICAgICAgICAgICAgICAgIHZhciBzdGFydENvbCA9IE1hdGgubWluKHJhbmdlLnN0YXJ0LmNvbCwgcmFuZ2UuZW5kLmNvbCk7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0Um93ID0gTWF0aC5taW4ocmFuZ2Uuc3RhcnQucm93LCByYW5nZS5lbmQucm93KTtcbiAgICAgICAgICAgICAgICB2YXIgZW5kQ29sID0gTWF0aC5tYXgocmFuZ2Uuc3RhcnQuY29sLCByYW5nZS5lbmQuY29sKTtcbiAgICAgICAgICAgICAgICB2YXIgZW5kUm93ID0gTWF0aC5tYXgocmFuZ2Uuc3RhcnQucm93LCByYW5nZS5lbmQucm93KTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3dyYXBGaXJlU2VsZWN0ZWRFdmVudChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICBfdGhpczcwLl9zZWwgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbDogc3RhcnRDb2wsXG4gICAgICAgICAgICAgICAgICAgIHJvdzogc3RhcnRSb3dcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICBfdGhpczcwLl9mb2N1cyA9IHtcbiAgICAgICAgICAgICAgICAgICAgY29sOiBzdGFydENvbCxcbiAgICAgICAgICAgICAgICAgICAgcm93OiBzdGFydFJvd1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIF90aGlzNzAuX3N0YXJ0ID0ge1xuICAgICAgICAgICAgICAgICAgICBjb2w6IHN0YXJ0Q29sLFxuICAgICAgICAgICAgICAgICAgICByb3c6IHN0YXJ0Um93XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgX3RoaXM3MC5fZW5kID0ge1xuICAgICAgICAgICAgICAgICAgICBjb2w6IGVuZENvbCxcbiAgICAgICAgICAgICAgICAgICAgcm93OiBlbmRSb3dcbiAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgIF91cGRhdGVkU2VsZWN0aW9uLmNhbGwoX3RoaXM3MC5fZ3JpZCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImZvY3VzXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyRfZm9jdXMgPSB0aGlzLl9mb2N1cyxcbiAgICAgICAgICAgICAgICAgICAgY29sID0gX3RoaXMkX2ZvY3VzLmNvbCxcbiAgICAgICAgICAgICAgICAgICAgcm93ID0gX3RoaXMkX2ZvY3VzLnJvdztcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgY29sOiBjb2wsXG4gICAgICAgICAgICAgICAgICByb3c6IHJvd1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInNlbGVjdFwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMkX3NlbCA9IHRoaXMuX3NlbCxcbiAgICAgICAgICAgICAgICAgICAgY29sID0gX3RoaXMkX3NlbC5jb2wsXG4gICAgICAgICAgICAgICAgICAgIHJvdyA9IF90aGlzJF9zZWwucm93O1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICBjb2w6IGNvbCxcbiAgICAgICAgICAgICAgICAgIHJvdzogcm93XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoY2VsbCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpczcxID0gdGhpcztcblxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbGxCZWZvcmVIb29rcygpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fd3JhcEZpcmVTZWxlY3RlZEV2ZW50KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBfY2VsbCRjb2wgPSBjZWxsLmNvbCxcbiAgICAgICAgICAgICAgICAgICAgICBjb2wgPSBfY2VsbCRjb2wgPT09IHZvaWQgMCA/IDAgOiBfY2VsbCRjb2wsXG4gICAgICAgICAgICAgICAgICAgICAgX2NlbGwkcm93ID0gY2VsbC5yb3csXG4gICAgICAgICAgICAgICAgICAgICAgcm93ID0gX2NlbGwkcm93ID09PSB2b2lkIDAgPyAwIDogX2NlbGwkcm93O1xuXG4gICAgICAgICAgICAgICAgICBfdGhpczcxLl9zZXRTZWxlY3RDZWxsKGNvbCwgcm93KTtcblxuICAgICAgICAgICAgICAgICAgX3RoaXM3MS5fc2V0Rm9jdXNDZWxsKGNvbCwgcm93LCB0cnVlLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgICAgX3VwZGF0ZWRTZWxlY3Rpb24uY2FsbChfdGhpczcxLl9ncmlkKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiX3NldFNlbGVjdENlbGxcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRTZWxlY3RDZWxsKGNvbCwgcm93KSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzNzIgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fd3JhcEZpcmVTZWxlY3RlZEV2ZW50KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzNzIuX3NlbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgY29sOiBjb2wsXG4gICAgICAgICAgICAgICAgICAgIHJvdzogcm93XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgX3RoaXM3Mi5fc3RhcnQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbDogY29sLFxuICAgICAgICAgICAgICAgICAgICByb3c6IHJvd1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiX3NldEZvY3VzQ2VsbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3NldEZvY3VzQ2VsbChjb2wsIHJvdywga2VlcFNlbGVjdCwgaWdub3JlQmVmb3JlSG9vaykge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpczczID0gdGhpcztcblxuICAgICAgICAgICAgICAgIGlmICghaWdub3JlQmVmb3JlSG9vaykgdGhpcy5fY2FsbEJlZm9yZUhvb2tzKCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl93cmFwRmlyZVNlbGVjdGVkRXZlbnQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgaWYgKCFrZWVwU2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzNzMuX3NldFNlbGVjdENlbGwoY29sLCByb3cpO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBfdGhpczczLl9mb2N1cyA9IHtcbiAgICAgICAgICAgICAgICAgICAgY29sOiBjb2wsXG4gICAgICAgICAgICAgICAgICAgIHJvdzogcm93XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgX3RoaXM3My5fZW5kID0ge1xuICAgICAgICAgICAgICAgICAgICBjb2w6IGNvbCxcbiAgICAgICAgICAgICAgICAgICAgcm93OiByb3dcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIl93cmFwRmlyZVNlbGVjdGVkRXZlbnRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF93cmFwRmlyZVNlbGVjdGVkRXZlbnQoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNXcmFwcGVkKSB7XG4gICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9pc1dyYXBwZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmVmb3JlID0ge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbDogdGhpcy5fc2VsLmNvbCxcbiAgICAgICAgICAgICAgICAgICAgICByb3c6IHRoaXMuX3NlbC5yb3csXG4gICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgIGFmdGVyOiBudWxsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhZnRlciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICBjb2w6IHRoaXMuX3NlbC5jb2wsXG4gICAgICAgICAgICAgICAgICAgICAgcm93OiB0aGlzLl9zZWwucm93LFxuICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgIGJlZm9yZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sOiBiZWZvcmUuY29sLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm93OiBiZWZvcmUucm93XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBiZWZvcmUuYWZ0ZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29sOiBhZnRlci5jb2wsXG4gICAgICAgICAgICAgICAgICAgICAgcm93OiBhZnRlci5yb3dcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlTGlzdGVuZXJzKERHX0VWRU5UX1RZUEVfMS5ER19FVkVOVF9UWVBFLlNFTEVDVEVEX0NFTEwsIGJlZm9yZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZUxpc3RlbmVycyhER19FVkVOVF9UWVBFXzEuREdfRVZFTlRfVFlQRS5TRUxFQ1RFRF9DRUxMLCBhZnRlcik7XG4gICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pc1dyYXBwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIl91cGRhdGVHcmlkUmFuZ2VcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVHcmlkUmFuZ2UoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzJF9ncmlkID0gdGhpcy5fZ3JpZCxcbiAgICAgICAgICAgICAgICAgICAgcm93Q291bnQgPSBfdGhpcyRfZ3JpZC5yb3dDb3VudCxcbiAgICAgICAgICAgICAgICAgICAgY29sQ291bnQgPSBfdGhpcyRfZ3JpZC5jb2xDb3VudDtcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnRzID0gW3RoaXMuX3NlbCwgdGhpcy5fZm9jdXMsIHRoaXMuX3N0YXJ0LCB0aGlzLl9lbmRdO1xuICAgICAgICAgICAgICAgIHZhciBuZWVkQ2hhbmdlID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgaWYgKGNvbENvdW50IDw9IHBvaW50c1tpXS5jb2wgfHwgcm93Q291bnQgPD0gcG9pbnRzW2ldLnJvdykge1xuICAgICAgICAgICAgICAgICAgICBuZWVkQ2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFuZWVkQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fd3JhcEZpcmVTZWxlY3RlZEV2ZW50KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHBvaW50cy5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICAgICAgICAgIHAuY29sID0gTWF0aC5taW4oY29sQ291bnQgLSAxLCBwLmNvbCk7XG4gICAgICAgICAgICAgICAgICAgIHAucm93ID0gTWF0aC5taW4ocm93Q291bnQgLSAxLCBwLnJvdyk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJfY2FsbEJlZm9yZUhvb2tzXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY2FsbEJlZm9yZUhvb2tzKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZUxpc3RlbmVycyhcImJlZm9yZV9ob29rXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBTZWxlY3Rpb247XG4gICAgICAgICAgfShFdmVudFRhcmdldF8xLkV2ZW50VGFyZ2V0KTtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBUaGlzIGNsYXNzIG1hbmFnZXMgdGhlIGRyYXdpbmcgcHJvY2VzcyBmb3IgZWFjaCBsYXllclxuICAgICAgICAgICAqL1xuXG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cblxuICAgICAgICAgIHZhciBEcmF3TGF5ZXJzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIERyYXdMYXllcnMoKSB7XG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEcmF3TGF5ZXJzKTtcblxuICAgICAgICAgICAgICB0aGlzLl9sYXllcnMgPSB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKERyYXdMYXllcnMsIFt7XG4gICAgICAgICAgICAgIGtleTogXCJhZGREcmF3XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGREcmF3KGxldmVsLCBmbikge1xuICAgICAgICAgICAgICAgIHZhciBsID0gdGhpcy5fbGF5ZXJzW2xldmVsXSB8fCAodGhpcy5fbGF5ZXJzW2xldmVsXSA9IG5ldyBEcmF3TGF5ZXIobGV2ZWwpKTtcbiAgICAgICAgICAgICAgICBsLmFkZERyYXcoZm4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJkcmF3XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCkge1xuICAgICAgICAgICAgICAgIHZhciBsaXN0ID0gW107XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrIGluIHRoaXMuX2xheWVycykge1xuICAgICAgICAgICAgICAgICAgbGlzdC5wdXNoKHRoaXMuX2xheWVyc1trXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGlzdC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gYS5sZXZlbCAtIGIubGV2ZWw7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChsKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbC5kcmF3KGN0eCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIERyYXdMYXllcnM7XG4gICAgICAgICAgfSgpO1xuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgICAgICAgICB2YXIgRHJhd0xheWVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIERyYXdMYXllcihsZXZlbCkge1xuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRHJhd0xheWVyKTtcblxuICAgICAgICAgICAgICB0aGlzLl9sZXZlbCA9IGxldmVsO1xuICAgICAgICAgICAgICB0aGlzLl9saXN0ID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhEcmF3TGF5ZXIsIFt7XG4gICAgICAgICAgICAgIGtleTogXCJsZXZlbFwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbGV2ZWw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImFkZERyYXdcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZERyYXcoZm4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9saXN0LnB1c2goZm4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJkcmF3XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xpc3QuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XG5cbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZuKGN0eCk7XG4gICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBEcmF3TGF5ZXI7XG4gICAgICAgICAgfSgpO1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIENvbnRleHQgb2YgY2VsbCBkcmF3aW5nXG4gICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgKi9cblxuXG4gICAgICAgICAgdmFyIERyYXdDZWxsQ29udGV4dCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyAgcHJpdmF0ZSBfZ3JpZDogYW55O1xuICAgICAgICAgICAgLy8gIHByaXZhdGUgX29uVGVybWluYXRlOiBhbnk7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogY29uc3RydWN0b3JcbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2wgaW5kZXggb2YgY29sdW1uXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93IGluZGV4IG9mIHJvd1xuICAgICAgICAgICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBjb250ZXh0XG4gICAgICAgICAgICAgKiBAcGFyYW0ge1JlY3R9IHJlY3QgcmVjdCBvZiBjZWxsIGFyZWFcbiAgICAgICAgICAgICAqIEBwYXJhbSB7UmVjdH0gZHJhd1JlY3QgcmVjdCBvZiBkcmF3aW5nIGFyZWFcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZHJhd2luZyBgdHJ1ZWAgaWYgZHJhd2luZyBpcyBpbiBwcm9ncmVzc1xuICAgICAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IHNlbGVjdGlvbiB0aGUgc2VsZWN0aW9uXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBkcmF3TGF5ZXJzIGFycmF5IG9mIGRyYXcgbGF5ZXJzXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBEcmF3Q2VsbENvbnRleHQoY29sLCByb3csIGN0eCwgcmVjdCwgZHJhd1JlY3QsIGRyYXdpbmcsIHNlbGVjdGlvbiwgZHJhd0xheWVycykge1xuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRHJhd0NlbGxDb250ZXh0KTtcblxuICAgICAgICAgICAgICB0aGlzLl9yZWN0RmlsdGVyID0gbnVsbDtcbiAgICAgICAgICAgICAgdGhpcy5fY29sID0gY29sO1xuICAgICAgICAgICAgICB0aGlzLl9yb3cgPSByb3c7XG4gICAgICAgICAgICAgIHRoaXMuX21vZGUgPSAwO1xuICAgICAgICAgICAgICB0aGlzLl9jdHggPSBjdHg7XG4gICAgICAgICAgICAgIHRoaXMuX3JlY3QgPSByZWN0O1xuICAgICAgICAgICAgICB0aGlzLl9kcmF3UmVjdCA9IGRyYXdSZWN0O1xuICAgICAgICAgICAgICB0aGlzLl9kcmF3aW5nID0gZHJhd2luZztcbiAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0aW9uID0gc2VsZWN0aW9uO1xuICAgICAgICAgICAgICB0aGlzLl9kcmF3TGF5ZXJzID0gZHJhd0xheWVycztcbiAgICAgICAgICAgICAgdGhpcy5fY2hpbGRDb250ZXh0cyA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoRHJhd0NlbGxDb250ZXh0LCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiZHJhd2luZ1wiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbW9kZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RyYXdpbmc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwicm93XCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yb3c7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNvbFwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY29sO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjYW5jZWxcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYW5jZWwgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fY2hpbGRDb250ZXh0cy5mb3JFYWNoKGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICAgICAgICAgIGN0eC5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogc2VsZWN0IHN0YXR1cy5cbiAgICAgICAgICAgICAgICogQHJldHVybiB7b2JqZWN0fSBzZWxlY3Qgc3RhdHVzXG4gICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJnZXRTZWxlY3Rpb25cIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNlbGVjdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgc2VsZWN0OiB0aGlzLl9zZWxlY3Rpb24uc2VsZWN0LFxuICAgICAgICAgICAgICAgICAgcmFuZ2U6IHRoaXMuX3NlbGVjdGlvbi5yYW5nZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIENhbnZhcyBjb250ZXh0LlxuICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IENhbnZhcyBjb250ZXh0LlxuICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0Q29udGV4dFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29udGV4dCgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbW9kZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2N0eDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9nZXRJbml0Q29udGV4dC5jYWxsKHRoaXMuX2dyaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogUmVjdGFuZ2xlIG9mIGNlbGwuXG4gICAgICAgICAgICAgICAqIEByZXR1cm4ge1JlY3R9IHJlY3QgUmVjdGFuZ2xlIG9mIGNlbGwuXG4gICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJnZXRSZWN0XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRSZWN0KCkge1xuICAgICAgICAgICAgICAgIHZhciByZWN0RmlsdGVyID0gdGhpcy5fcmVjdEZpbHRlcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjdEZpbHRlciA/IHJlY3RGaWx0ZXIodGhpcy5fZ2V0UmVjdEludGVybmFsKCkpIDogdGhpcy5fZ2V0UmVjdEludGVybmFsKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInNldFJlY3RGaWx0ZXJcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldFJlY3RGaWx0ZXIocmVjdEZpbHRlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlY3RGaWx0ZXIgPSByZWN0RmlsdGVyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBSZWN0YW5nbGUgb2YgRHJhd2luZyByYW5nZS5cbiAgICAgICAgICAgICAgICogQHJldHVybiB7UmVjdH0gUmVjdGFuZ2xlIG9mIERyYXdpbmcgcmFuZ2UuXG4gICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJnZXREcmF3UmVjdFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RHJhd1JlY3QoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NhbmNlbCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX21vZGUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kcmF3UmVjdDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzT3V0T2ZSYW5nZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICB2YXIgYWJzb2x1dGVSZWN0ID0gdGhpcy5fZ3JpZC5nZXRDZWxsUmVjdCh0aGlzLl9jb2wsIHRoaXMuX3Jvdyk7XG5cbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90b1JlbGF0aXZlRHJhd1JlY3QoYWJzb2x1dGVSZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIl9pc091dE9mUmFuZ2VcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9pc091dE9mUmFuZ2UoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzJF9ncmlkMiA9IHRoaXMuX2dyaWQsXG4gICAgICAgICAgICAgICAgICAgIGNvbENvdW50ID0gX3RoaXMkX2dyaWQyLmNvbENvdW50LFxuICAgICAgICAgICAgICAgICAgICByb3dDb3VudCA9IF90aGlzJF9ncmlkMi5yb3dDb3VudDtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sQ291bnQgPD0gdGhpcy5fY29sIHx8IHJvd0NvdW50IDw9IHRoaXMuX3JvdztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogZ2V0IENvbnRleHQgb2YgY3VycmVudCBzdGF0ZVxuICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtEcmF3Q2VsbENvbnRleHR9IGN1cnJlbnQgRHJhd0NlbGxDb250ZXh0LlxuICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwidG9DdXJyZW50Q29udGV4dFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9DdXJyZW50Q29udGV4dCgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbW9kZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhciBhYnNvbHV0ZVJlY3QgPSB0aGlzLl9ncmlkLmdldENlbGxSZWN0KHRoaXMuX2NvbCwgdGhpcy5fcm93KTtcblxuICAgICAgICAgICAgICAgICAgdmFyIHJlY3QgPSBfdG9SZWxhdGl2ZVJlY3QodGhpcy5fZ3JpZCwgYWJzb2x1dGVSZWN0KTtcblxuICAgICAgICAgICAgICAgICAgdmFyIGRyYXdSZWN0ID0gdGhpcy5faXNPdXRPZlJhbmdlKCkgPyBudWxsIDogdGhpcy5fdG9SZWxhdGl2ZURyYXdSZWN0KGFic29sdXRlUmVjdCk7XG4gICAgICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IG5ldyBEcmF3Q2VsbENvbnRleHQodGhpcy5fY29sLCB0aGlzLl9yb3csIHRoaXMuZ2V0Q29udGV4dCgpLCByZWN0LCBkcmF3UmVjdCwgdGhpcy5kcmF3aW5nLCB0aGlzLl9zZWxlY3Rpb24sIHRoaXMuX2RyYXdMYXllcnMpOyAvLyB0b0N1cnJlbnRDb250ZXh0IOOBr+iHquWIhuOBriB0b0N1cnJlbnRDb250ZXh044KS5ZG844Gw44Gb44KLXG5cbiAgICAgICAgICAgICAgICAgIGNvbnRleHQudG9DdXJyZW50Q29udGV4dCA9IHRoaXMudG9DdXJyZW50Q29udGV4dC5iaW5kKHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgICB0aGlzLl9jaGlsZENvbnRleHRzLnB1c2goY29udGV4dCk7XG5cbiAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jYW5jZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgY29udGV4dC5fcmVjdEZpbHRlciA9IHRoaXMuX3JlY3RGaWx0ZXI7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImFkZExheWVyRHJhd1wiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkTGF5ZXJEcmF3KGxldmVsLCBmbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYXdMYXllcnMuYWRkRHJhdyhsZXZlbCwgZm4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJfdG9SZWxhdGl2ZURyYXdSZWN0XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdG9SZWxhdGl2ZURyYXdSZWN0KGFic29sdXRlUmVjdCkge1xuICAgICAgICAgICAgICAgIHZhciB2aXNpYmxlUmVjdCA9IF9nZXRWaXNpYmxlUmVjdCh0aGlzLl9ncmlkKTtcblxuICAgICAgICAgICAgICAgIHZhciByZWN0ID0gYWJzb2x1dGVSZWN0LmNvcHkoKTtcblxuICAgICAgICAgICAgICAgIGlmICghcmVjdC5pbnRlcnNlY3Rpb24odmlzaWJsZVJlY3QpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgZ3JpZCA9IHRoaXMuX2dyaWQ7XG4gICAgICAgICAgICAgICAgdmFyIGlzRnJvemVuQ2VsbCA9IGdyaWQuaXNGcm96ZW5DZWxsKHRoaXMuX2NvbCwgdGhpcy5fcm93KTtcblxuICAgICAgICAgICAgICAgIGlmIChncmlkLmZyb3plbkNvbENvdW50ID49IDAgJiYgKCFpc0Zyb3plbkNlbGwgfHwgIWlzRnJvemVuQ2VsbC5jb2wpKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZlJlY3QgPSBncmlkLmdldENlbGxSZWN0KGdyaWQuZnJvemVuQ29sQ291bnQgLSAxLCB0aGlzLl9yb3cpO1xuICAgICAgICAgICAgICAgICAgcmVjdCA9IFJlY3RfMS5SZWN0LmJvdW5kcyhNYXRoLm1heChyZWN0LmxlZnQsIGZSZWN0LnJpZ2h0KSwgcmVjdC50b3AsIHJlY3QucmlnaHQsIHJlY3QuYm90dG9tKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZ3JpZC5mcm96ZW5Sb3dDb3VudCA+PSAwICYmICghaXNGcm96ZW5DZWxsIHx8ICFpc0Zyb3plbkNlbGwucm93KSkge1xuICAgICAgICAgICAgICAgICAgdmFyIF9mUmVjdCA9IGdyaWQuZ2V0Q2VsbFJlY3QodGhpcy5fY29sLCBncmlkLmZyb3plblJvd0NvdW50IC0gMSk7XG5cbiAgICAgICAgICAgICAgICAgIHJlY3QgPSBSZWN0XzEuUmVjdC5ib3VuZHMocmVjdC5sZWZ0LCBNYXRoLm1heChyZWN0LnRvcCwgX2ZSZWN0LmJvdHRvbSksIHJlY3QucmlnaHQsIHJlY3QuYm90dG9tKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIXJlY3QuaW50ZXJzZWN0aW9uKHZpc2libGVSZWN0KSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVjdC5vZmZzZXRMZWZ0KC12aXNpYmxlUmVjdC5sZWZ0KTtcbiAgICAgICAgICAgICAgICByZWN0Lm9mZnNldFRvcCgtdmlzaWJsZVJlY3QudG9wKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiX2RlbGF5TW9kZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2RlbGF5TW9kZShncmlkLCBvblRlcm1pbmF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21vZGUgPSAxO1xuICAgICAgICAgICAgICAgIHRoaXMuX2N0eCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVjdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhd1JlY3QgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuX2dyaWQgPSBncmlkO1xuICAgICAgICAgICAgICAgIHRoaXMuX29uVGVybWluYXRlID0gb25UZXJtaW5hdGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIHRlcm1pbmF0ZVxuICAgICAgICAgICAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwidGVybWluYXRlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0ZXJtaW5hdGUoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX21vZGUgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuX29uVGVybWluYXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIl9nZXRSZWN0SW50ZXJuYWxcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRSZWN0SW50ZXJuYWwoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX21vZGUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWN0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpZiAodGhpcy5fcmVjdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVjdDtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dyaWQuZ2V0Q2VsbFJlbGF0aXZlUmVjdCh0aGlzLl9jb2wsIHRoaXMuX3Jvdyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBEcmF3Q2VsbENvbnRleHQ7XG4gICAgICAgICAgfSgpO1xuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgICAgICAgICB2YXIgcHJvdGVjdGVkS2V5ID0gXztcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBEcmF3R3JpZFxuICAgICAgICAgICAqIEBjbGFzc2Rlc2MgY2hlZXRhaEdyaWQuY29yZS5EcmF3R3JpZFxuICAgICAgICAgICAqIEBtZW1iZXJvZiBjaGVldGFoR3JpZC5jb3JlXG4gICAgICAgICAgICovXG5cbiAgICAgICAgICB2YXIgRHJhd0dyaWQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FdmVudFRhcmdldF8xJEV2ZW50VDQpIHtcbiAgICAgICAgICAgIF9pbmhlcml0cyhEcmF3R3JpZCwgX0V2ZW50VGFyZ2V0XzEkRXZlbnRUNCk7XG5cbiAgICAgICAgICAgIHZhciBfc3VwZXI1MCA9IF9jcmVhdGVTdXBlcihEcmF3R3JpZCk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIERyYXdHcmlkKCkge1xuICAgICAgICAgICAgICB2YXIgX3RoaXM3NDtcblxuICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERyYXdHcmlkKTtcblxuICAgICAgICAgICAgICBfdGhpczc0ID0gX3N1cGVyNTAuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgdmFyIF9vcHRpb25zJHJvd0NvdW50ID0gb3B0aW9ucy5yb3dDb3VudCxcbiAgICAgICAgICAgICAgICAgIHJvd0NvdW50ID0gX29wdGlvbnMkcm93Q291bnQgPT09IHZvaWQgMCA/IDEwIDogX29wdGlvbnMkcm93Q291bnQsXG4gICAgICAgICAgICAgICAgICBfb3B0aW9ucyRjb2xDb3VudCA9IG9wdGlvbnMuY29sQ291bnQsXG4gICAgICAgICAgICAgICAgICBjb2xDb3VudCA9IF9vcHRpb25zJGNvbENvdW50ID09PSB2b2lkIDAgPyAxMCA6IF9vcHRpb25zJGNvbENvdW50LFxuICAgICAgICAgICAgICAgICAgX29wdGlvbnMkZnJvemVuQ29sQ291ID0gb3B0aW9ucy5mcm96ZW5Db2xDb3VudCxcbiAgICAgICAgICAgICAgICAgIGZyb3plbkNvbENvdW50ID0gX29wdGlvbnMkZnJvemVuQ29sQ291ID09PSB2b2lkIDAgPyAwIDogX29wdGlvbnMkZnJvemVuQ29sQ291LFxuICAgICAgICAgICAgICAgICAgX29wdGlvbnMkZnJvemVuUm93Q291ID0gb3B0aW9ucy5mcm96ZW5Sb3dDb3VudCxcbiAgICAgICAgICAgICAgICAgIGZyb3plblJvd0NvdW50ID0gX29wdGlvbnMkZnJvemVuUm93Q291ID09PSB2b2lkIDAgPyAwIDogX29wdGlvbnMkZnJvemVuUm93Q291LFxuICAgICAgICAgICAgICAgICAgX29wdGlvbnMkZGVmYXVsdFJvd0hlID0gb3B0aW9ucy5kZWZhdWx0Um93SGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgZGVmYXVsdFJvd0hlaWdodCA9IF9vcHRpb25zJGRlZmF1bHRSb3dIZSA9PT0gdm9pZCAwID8gNDAgOiBfb3B0aW9ucyRkZWZhdWx0Um93SGUsXG4gICAgICAgICAgICAgICAgICBfb3B0aW9ucyRkZWZhdWx0Q29sV2kgPSBvcHRpb25zLmRlZmF1bHRDb2xXaWR0aCxcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHRDb2xXaWR0aCA9IF9vcHRpb25zJGRlZmF1bHRDb2xXaSA9PT0gdm9pZCAwID8gODAgOiBfb3B0aW9ucyRkZWZhdWx0Q29sV2ksXG4gICAgICAgICAgICAgICAgICBmb250ID0gb3B0aW9ucy5mb250LFxuICAgICAgICAgICAgICAgICAgdW5kZXJsYXlCYWNrZ3JvdW5kQ29sb3IgPSBvcHRpb25zLnVuZGVybGF5QmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgICAgICAga2V5Ym9hcmRPcHRpb25zID0gb3B0aW9ucy5rZXlib2FyZE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICBwYXJlbnRFbGVtZW50ID0gb3B0aW9ucy5wYXJlbnRFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgZGlzYWJsZUNvbHVtblJlc2l6ZSA9IG9wdGlvbnMuZGlzYWJsZUNvbHVtblJlc2l6ZSxcbiAgICAgICAgICAgICAgICAgIHRyaW1PblBhc3RlID0gb3B0aW9ucy50cmltT25QYXN0ZTtcbiAgICAgICAgICAgICAgdmFyIHByb3RlY3RlZFNwYWNlID0gX3RoaXM3NFtfXSA9IHt9O1xuICAgICAgICAgICAgICBzdHlsZS5pbml0RG9jdW1lbnQoKTtcbiAgICAgICAgICAgICAgcHJvdGVjdGVkU3BhY2UuZWxlbWVudCA9IGNyZWF0ZVJvb3RFbGVtZW50KCk7XG4gICAgICAgICAgICAgIHByb3RlY3RlZFNwYWNlLnNjcm9sbGFibGUgPSBuZXcgU2Nyb2xsYWJsZV8xLlNjcm9sbGFibGUoKTtcbiAgICAgICAgICAgICAgcHJvdGVjdGVkU3BhY2UuaGFuZGxlciA9IG5ldyBFdmVudEhhbmRsZXJfMS5FdmVudEhhbmRsZXIoKTtcbiAgICAgICAgICAgICAgcHJvdGVjdGVkU3BhY2Uuc2VsZWN0aW9uID0gbmV3IFNlbGVjdGlvbihfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzNzQpKTtcbiAgICAgICAgICAgICAgcHJvdGVjdGVkU3BhY2UuZm9jdXNDb250cm9sID0gbmV3IEZvY3VzQ29udHJvbChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzNzQpLCBwcm90ZWN0ZWRTcGFjZS5zY3JvbGxhYmxlLmdldEVsZW1lbnQoKSwgcHJvdGVjdGVkU3BhY2Uuc2Nyb2xsYWJsZSwgcHJvdGVjdGVkU3BhY2Uuc2VsZWN0aW9uKTtcbiAgICAgICAgICAgICAgcHJvdGVjdGVkU3BhY2UuY2FudmFzID0gaGlEUEkudHJhbnNmb3JtKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIikpO1xuICAgICAgICAgICAgICBwcm90ZWN0ZWRTcGFjZS5jb250ZXh0ID0gcHJvdGVjdGVkU3BhY2UuY2FudmFzLmdldENvbnRleHQoXCIyZFwiLCB7XG4gICAgICAgICAgICAgICAgYWxwaGE6IGZhbHNlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBwcm90ZWN0ZWRTcGFjZS5yb3dDb3VudCA9IHJvd0NvdW50O1xuICAgICAgICAgICAgICBwcm90ZWN0ZWRTcGFjZS5jb2xDb3VudCA9IGNvbENvdW50O1xuICAgICAgICAgICAgICBwcm90ZWN0ZWRTcGFjZS5mcm96ZW5Db2xDb3VudCA9IGZyb3plbkNvbENvdW50O1xuICAgICAgICAgICAgICBwcm90ZWN0ZWRTcGFjZS5mcm96ZW5Sb3dDb3VudCA9IGZyb3plblJvd0NvdW50O1xuICAgICAgICAgICAgICBwcm90ZWN0ZWRTcGFjZS5kZWZhdWx0Um93SGVpZ2h0ID0gZGVmYXVsdFJvd0hlaWdodDtcbiAgICAgICAgICAgICAgcHJvdGVjdGVkU3BhY2UuZGVmYXVsdENvbFdpZHRoID0gZGVmYXVsdENvbFdpZHRoO1xuICAgICAgICAgICAgICBwcm90ZWN0ZWRTcGFjZS5mb250ID0gZm9udDtcbiAgICAgICAgICAgICAgcHJvdGVjdGVkU3BhY2UudW5kZXJsYXlCYWNrZ3JvdW5kQ29sb3IgPSB1bmRlcmxheUJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgICAgICAgcHJvdGVjdGVkU3BhY2Uua2V5Ym9hcmRPcHRpb25zID0ga2V5Ym9hcmRPcHRpb25zO1xuICAgICAgICAgICAgICBwcm90ZWN0ZWRTcGFjZS5kaXNhYmxlQ29sdW1uUmVzaXplID0gZGlzYWJsZUNvbHVtblJlc2l6ZTtcbiAgICAgICAgICAgICAgcHJvdGVjdGVkU3BhY2UudHJpbU9uUGFzdGUgPSB0cmltT25QYXN0ZSAhPT0gbnVsbCAmJiB0cmltT25QYXN0ZSAhPT0gdm9pZCAwID8gdHJpbU9uUGFzdGUgOiBmYWxzZTsgLy8vLy9cblxuICAgICAgICAgICAgICBwcm90ZWN0ZWRTcGFjZS5yb3dIZWlnaHRzTWFwID0gbmV3IE51bWJlck1hcF8xLk51bWJlck1hcCgpO1xuICAgICAgICAgICAgICBwcm90ZWN0ZWRTcGFjZS5jb2xXaWR0aHNNYXAgPSBuZXcgTnVtYmVyTWFwXzEuTnVtYmVyTWFwKCk7XG4gICAgICAgICAgICAgIHByb3RlY3RlZFNwYWNlLmNvbFdpZHRoc0xpbWl0ID0ge307XG4gICAgICAgICAgICAgIHByb3RlY3RlZFNwYWNlLmNhbGNXaWR0aENvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgXzogcHJvdGVjdGVkU3BhY2UsXG5cbiAgICAgICAgICAgICAgICBnZXQgZnVsbCgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl8uY2FudmFzLndpZHRoO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICBnZXQgZW0oKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGNhbnZhc2VzXzEuZ2V0Rm9udFNpemUpKHRoaXMuXy5jb250ZXh0LCB0aGlzLl8uZm9udCkud2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHByb3RlY3RlZFNwYWNlLmNvbHVtblJlc2l6ZXIgPSBuZXcgQ29sdW1uUmVzaXplcihfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzNzQpKTtcbiAgICAgICAgICAgICAgcHJvdGVjdGVkU3BhY2UuY2VsbFNlbGVjdG9yID0gbmV3IENlbGxTZWxlY3RvcihfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzNzQpKTtcbiAgICAgICAgICAgICAgcHJvdGVjdGVkU3BhY2UuZHJhd0NlbGxzID0ge307XG4gICAgICAgICAgICAgIHByb3RlY3RlZFNwYWNlLmNlbGxUZXh0T3ZlcmZsb3dzID0ge307XG4gICAgICAgICAgICAgIHByb3RlY3RlZFNwYWNlLmZvY3VzZWRHcmlkID0gZmFsc2U7XG4gICAgICAgICAgICAgIHByb3RlY3RlZFNwYWNlLmVsZW1lbnQuYXBwZW5kQ2hpbGQocHJvdGVjdGVkU3BhY2UuY2FudmFzKTtcbiAgICAgICAgICAgICAgcHJvdGVjdGVkU3BhY2UuZWxlbWVudC5hcHBlbmRDaGlsZChwcm90ZWN0ZWRTcGFjZS5zY3JvbGxhYmxlLmdldEVsZW1lbnQoKSk7XG4gICAgICAgICAgICAgIHByb3RlY3RlZFNwYWNlLnNjcm9sbCA9IHtcbiAgICAgICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgICAgIHRvcDogMFxuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIF90aGlzNzQudXBkYXRlU2Nyb2xsKCk7XG5cbiAgICAgICAgICAgICAgaWYgKHBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRFbGVtZW50LmFwcGVuZENoaWxkKHByb3RlY3RlZFNwYWNlLmVsZW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgX3RoaXM3NC51cGRhdGVTaXplKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXM3NC51cGRhdGVTaXplKCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBfYmluZEV2ZW50cy5jYWxsKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXM3NCkpO1xuXG4gICAgICAgICAgICAgIF90aGlzNzQuYmluZEV2ZW50c0ludGVybmFsKCk7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzNzQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldCByb290IGVsZW1lbnQuXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IHJvb3QgZWxlbWVudFxuICAgICAgICAgICAgICovXG5cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKERyYXdHcmlkLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0RWxlbWVudFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RWxlbWVudCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tfXS5lbGVtZW50O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBHZXQgY2FudmFzIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjYW52YXNcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbX10uY2FudmFzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBGb2N1cyB0aGUgZ3JpZC5cbiAgICAgICAgICAgICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImZvY3VzXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmb2N1cygpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMkXyRzZWxlY3Rpb24kc2VsMiA9IHRoaXNbX10uc2VsZWN0aW9uLnNlbGVjdCxcbiAgICAgICAgICAgICAgICAgICAgY29sID0gX3RoaXMkXyRzZWxlY3Rpb24kc2VsMi5jb2wsXG4gICAgICAgICAgICAgICAgICAgIHJvdyA9IF90aGlzJF8kc2VsZWN0aW9uJHNlbDIucm93O1xuICAgICAgICAgICAgICAgIHRoaXMuZm9jdXNDZWxsKGNvbCwgcm93KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiaGFzRm9jdXNHcmlkXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNGb2N1c0dyaWQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbX10uZm9jdXNlZEdyaWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIEdldCB0aGUgc2VsZWN0aW9uIGluc3RhbmNlLlxuICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwic2VsZWN0aW9uXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW19dLnNlbGVjdGlvbjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogR2V0IHRoZSBudW1iZXIgb2Ygcm93cy5cbiAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInJvd0NvdW50XCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW19dLnJvd0NvdW50O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBTZXQgdGhlIG51bWJlciBvZiByb3dzLlxuICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgLFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChyb3dDb3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXNbX10ucm93Q291bnQgPSByb3dDb3VudDtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVNjcm9sbCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXNbX10uc2VsZWN0aW9uLl91cGRhdGVHcmlkUmFuZ2UoKSkge1xuICAgICAgICAgICAgICAgICAgdmFyIF90aGlzJF8kc2VsZWN0aW9uJGZvYyA9IHRoaXNbX10uc2VsZWN0aW9uLmZvY3VzLFxuICAgICAgICAgICAgICAgICAgICAgIGNvbCA9IF90aGlzJF8kc2VsZWN0aW9uJGZvYy5jb2wsXG4gICAgICAgICAgICAgICAgICAgICAgcm93ID0gX3RoaXMkXyRzZWxlY3Rpb24kZm9jLnJvdztcbiAgICAgICAgICAgICAgICAgIHRoaXMubWFrZVZpc2libGVDZWxsKGNvbCwgcm93KTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuc2V0Rm9jdXNDdXJzb3IoY29sLCByb3cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogR2V0IHRoZSBudW1iZXIgb2YgY29sdW1ucy5cbiAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNvbENvdW50XCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW19dLmNvbENvdW50O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBTZXQgdGhlIG51bWJlciBvZiBjb2x1bW5zLlxuICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgLFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChjb2xDb3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXNbX10uY29sQ291bnQgPSBjb2xDb3VudDtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVNjcm9sbCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXNbX10uc2VsZWN0aW9uLl91cGRhdGVHcmlkUmFuZ2UoKSkge1xuICAgICAgICAgICAgICAgICAgdmFyIF90aGlzJF8kc2VsZWN0aW9uJGZvYzIgPSB0aGlzW19dLnNlbGVjdGlvbi5mb2N1cyxcbiAgICAgICAgICAgICAgICAgICAgICBjb2wgPSBfdGhpcyRfJHNlbGVjdGlvbiRmb2MyLmNvbCxcbiAgICAgICAgICAgICAgICAgICAgICByb3cgPSBfdGhpcyRfJHNlbGVjdGlvbiRmb2MyLnJvdztcbiAgICAgICAgICAgICAgICAgIHRoaXMubWFrZVZpc2libGVDZWxsKGNvbCwgcm93KTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuc2V0Rm9jdXNDdXJzb3IoY29sLCByb3cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogR2V0IHRoZSBudW1iZXIgb2YgZnJvemVuIGNvbHVtbnMuXG4gICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJmcm96ZW5Db2xDb3VudFwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tfXS5mcm96ZW5Db2xDb3VudDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogU2V0IHRoZSBudW1iZXIgb2YgZnJvemVuIGNvbHVtbnMuXG4gICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAsXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGZyb3plbkNvbENvdW50KSB7XG4gICAgICAgICAgICAgICAgdGhpc1tfXS5mcm96ZW5Db2xDb3VudCA9IGZyb3plbkNvbENvdW50O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBHZXQgdGhlIG51bWJlciBvZiBmcm96ZW4gcm93cy5cbiAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImZyb3plblJvd0NvdW50XCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW19dLmZyb3plblJvd0NvdW50O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBTZXQgdGhlIG51bWJlciBvZiBmcm96ZW4gcm93cy5cbiAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoZnJvemVuUm93Q291bnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzW19dLmZyb3plblJvd0NvdW50ID0gZnJvemVuUm93Q291bnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIEdldCB0aGUgZGVmYXVsdCByb3cgaGVpZ2h0LlxuICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZGVmYXVsdFJvd0hlaWdodFwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tfXS5kZWZhdWx0Um93SGVpZ2h0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBTZXQgdGhlIGRlZmF1bHQgcm93IGhlaWdodC5cbiAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoZGVmYXVsdFJvd0hlaWdodCkge1xuICAgICAgICAgICAgICAgIHRoaXNbX10uZGVmYXVsdFJvd0hlaWdodCA9IGRlZmF1bHRSb3dIZWlnaHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIEdldCB0aGUgZGVmYXVsdCBjb2x1bW4gd2lkdGguXG4gICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJkZWZhdWx0Q29sV2lkdGhcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbX10uZGVmYXVsdENvbFdpZHRoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBTZXQgdGhlIGRlZmF1bHQgY29sdW1uIHdpZHRoLlxuICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgLFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChkZWZhdWx0Q29sV2lkdGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzW19dLmRlZmF1bHRDb2xXaWR0aCA9IGRlZmF1bHRDb2xXaWR0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogR2V0IHRoZSBmb250IGRlZmluaXRpb24gYXMgYSBzdHJpbmcuXG4gICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJmb250XCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW19dLmZvbnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIFNldCB0aGUgZm9udCBkZWZpbml0aW9uIHdpdGggdGhlIGdpdmVuIHN0cmluZy5cbiAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoZm9udCkge1xuICAgICAgICAgICAgICAgIHRoaXNbX10uZm9udCA9IGZvbnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIEdldCB0aGUgYmFja2dyb3VuZCBjb2xvciBvZiB0aGUgdW5kZXJsYXkuXG4gICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJ1bmRlcmxheUJhY2tncm91bmRDb2xvclwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tfXS51bmRlcmxheUJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogU2V0IHRoZSBiYWNrZ3JvdW5kIGNvbG9yIG9mIHRoZSB1bmRlcmxheS5cbiAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodW5kZXJsYXlCYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzW19dLnVuZGVybGF5QmFja2dyb3VuZENvbG9yID0gdW5kZXJsYXlCYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIElmIHNldCB0byB0cnVlLCB0cmltIHRoZSBwYXN0ZWQgdGV4dCBvbiBwYXN0aW5nLlxuICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwidHJpbU9uUGFzdGVcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbX10udHJpbU9uUGFzdGU7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHRyaW1PblBhc3RlKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tfXS50cmltT25QYXN0ZSA9IHRyaW1PblBhc3RlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJrZXlib2FyZE9wdGlvbnNcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIChfYSA9IHRoaXNbX10ua2V5Ym9hcmRPcHRpb25zKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChrZXlib2FyZE9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzW19dLmtleWJvYXJkT3B0aW9ucyA9IGtleWJvYXJkT3B0aW9ucyAhPT0gbnVsbCAmJiBrZXlib2FyZE9wdGlvbnMgIT09IHZvaWQgMCA/IGtleWJvYXJkT3B0aW9ucyA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjb25maWd1cmVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbmZpZ3VyZShuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBjZmcgPSB0aGlzW19dLmNvbmZpZyB8fCAodGhpc1tfXS5jb25maWcgPSB7fSk7XG5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgY2ZnW25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNmZ1tuYW1lXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogQXBwbHkgdGhlIGNoYW5nZWQgc2l6ZS5cbiAgICAgICAgICAgICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInVwZGF0ZVNpemVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVNpemUoKSB7XG4gICAgICAgICAgICAgICAgLy/jgrnjgr/jgqTjg6vjgpLjgq/jg6rjgqLjgZfjgabjgrXjgqTjgrrlgKTjgpLlj5blvpdcbiAgICAgICAgICAgICAgICB2YXIgY2FudmFzID0gdGhpc1tfXS5jYW52YXM7XG4gICAgICAgICAgICAgICAgY2FudmFzLnN0eWxlLndpZHRoID0gXCJcIjtcbiAgICAgICAgICAgICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gXCJcIjtcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBNYXRoLmZsb29yKGNhbnZhcy5vZmZzZXRXaWR0aCB8fCBjYW52YXMucGFyZW50RWxlbWVudC5vZmZzZXRXaWR0aCAtIHN0eWxlLmdldFNjcm9sbEJhclNpemUoKVxuICAgICAgICAgICAgICAgIC8qZm9yIGxlZ2FjeSovXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gTWF0aC5mbG9vcihjYW52YXMub2Zmc2V0SGVpZ2h0IHx8IGNhbnZhcy5wYXJlbnRFbGVtZW50Lm9mZnNldEhlaWdodCAtIHN0eWxlLmdldFNjcm9sbEJhclNpemUoKVxuICAgICAgICAgICAgICAgIC8qZm9yIGxlZ2FjeSovXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0OyAvL+aVtOaVsOOBp+S4gOiHtOOBleOBm+OCi+OBn+OCgXN0eWxl44KS44K744OD44OI44GX44Gm6L+U44GZXG5cbiAgICAgICAgICAgICAgICBjYW52YXMuc3R5bGUud2lkdGggPSBcIlwiLmNvbmNhdCh3aWR0aCwgXCJweFwiKTtcbiAgICAgICAgICAgICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gXCJcIi5jb25jYXQoaGVpZ2h0LCBcInB4XCIpO1xuICAgICAgICAgICAgICAgIHZhciBmb2N1cyA9IHRoaXNbX10uc2VsZWN0aW9uLmZvY3VzO1xuXG4gICAgICAgICAgICAgICAgdGhpc1tfXS5mb2N1c0NvbnRyb2wuc2V0Rm9jdXNSZWN0KHRoaXMuZ2V0Q2VsbFJlY3QoZm9jdXMuY29sLCBmb2N1cy5yb3cpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogQXBwbHkgdGhlIGNoYW5nZWQgc2Nyb2xsIHNpemUuXG4gICAgICAgICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGVyZSB3YXMgYSBjaGFuZ2UgaW4gdGhlIHNjcm9sbCBzaXplXG4gICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJ1cGRhdGVTY3JvbGxcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVNjcm9sbCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsYWJsZSA9IHRoaXNbX10uc2Nyb2xsYWJsZTtcblxuICAgICAgICAgICAgICAgIHZhciBuZXdIZWlnaHQgPSBfZ2V0U2Nyb2xsSGVpZ2h0LmNhbGwodGhpcyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgbmV3V2lkdGggPSBfZ2V0U2Nyb2xsV2lkdGgodGhpcyk7XG5cbiAgICAgICAgICAgICAgICBpZiAobmV3SGVpZ2h0ID09PSBzY3JvbGxhYmxlLnNjcm9sbEhlaWdodCAmJiBuZXdXaWR0aCA9PT0gc2Nyb2xsYWJsZS5zY3JvbGxXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNjcm9sbGFibGUuc2V0U2Nyb2xsU2l6ZShuZXdXaWR0aCwgbmV3SGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB0aGlzW19dLnNjcm9sbCA9IHtcbiAgICAgICAgICAgICAgICAgIGxlZnQ6IHNjcm9sbGFibGUuc2Nyb2xsTGVmdCxcbiAgICAgICAgICAgICAgICAgIHRvcDogc2Nyb2xsYWJsZS5zY3JvbGxUb3BcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciBmb2N1cyA9IHRoaXNbX10uc2VsZWN0aW9uLmZvY3VzO1xuXG4gICAgICAgICAgICAgICAgdGhpc1tfXS5mb2N1c0NvbnRyb2wuc2V0Rm9jdXNSZWN0KHRoaXMuZ2V0Q2VsbFJlY3QoZm9jdXMuY29sLCBmb2N1cy5yb3cpKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBHZXQgdGhlIHJvdyBoZWlnaHQgb2YgdGhlIGdpdmVuIHRoZSByb3cgaW5kZXguXG4gICAgICAgICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gcm93IFRoZSByb3cgaW5kZXhcbiAgICAgICAgICAgICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgcm93IGhlaWdodFxuICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0Um93SGVpZ2h0XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRSb3dIZWlnaHQocm93KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9nZXRSb3dIZWlnaHQuY2FsbCh0aGlzLCByb3cpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBTZXQgdGhlIHJvdyBoZWlnaHQgb2YgdGhlIGdpdmVuIHRoZSByb3cgaW5kZXguXG4gICAgICAgICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gcm93IFRoZSByb3cgaW5kZXhcbiAgICAgICAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBoZWlnaHQgVGhlIHJvdyBoZWlnaHRcbiAgICAgICAgICAgICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInNldFJvd0hlaWdodFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Um93SGVpZ2h0KHJvdywgaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgX3NldFJvd0hlaWdodCh0aGlzLCByb3csIGhlaWdodCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIEdldCB0aGUgY29sdW1uIHdpZHRoIG9mIHRoZSBnaXZlbiB0aGUgY29sdW1uIGluZGV4LlxuICAgICAgICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGNvbCBUaGUgY29sdW1uIGluZGV4XG4gICAgICAgICAgICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGNvbHVtbiB3aWR0aFxuICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0Q29sV2lkdGhcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldENvbFdpZHRoKGNvbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZ2V0Q29sV2lkdGgodGhpcywgY29sKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogU2V0IHRoZSBjb2x1bW4gd2lkdGggb2YgdGhlIGdpdmVuIHRoZSBjb2x1bW4gaW5kZXguXG4gICAgICAgICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gY29sIFRoZSBjb2x1bW4gaW5kZXhcbiAgICAgICAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB3aWR0aCBUaGUgY29sdW1uIHdpZHRoXG4gICAgICAgICAgICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJzZXRDb2xXaWR0aFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q29sV2lkdGgoY29sLCB3aWR0aCkge1xuICAgICAgICAgICAgICAgIF9zZXRDb2xXaWR0aCh0aGlzLCBjb2wsIHdpZHRoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogR2V0IHRoZSBjb2x1bW4gbWF4IHdpZHRoIG9mIHRoZSBnaXZlbiB0aGUgY29sdW1uIGluZGV4LlxuICAgICAgICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGNvbCBUaGUgY29sdW1uIGluZGV4XG4gICAgICAgICAgICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGNvbHVtbiBtYXggd2lkdGhcbiAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImdldE1heENvbFdpZHRoXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNYXhDb2xXaWR0aChjb2wpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2JqID0gdGhpc1tfXS5jb2xXaWR0aHNMaW1pdFtjb2xdO1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmogJiYgb2JqLm1heCB8fCB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIFNldCB0aGUgY29sdW1uIG1heCB3aWR0aCBvZiB0aGUgZ2l2ZW4gdGhlIGNvbHVtbiBpbmRleC5cbiAgICAgICAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBjb2wgVGhlIGNvbHVtbiBpbmRleFxuICAgICAgICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IG1heHdpZHRoIFRoZSBjb2x1bW4gbWF4IHdpZHRoXG4gICAgICAgICAgICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJzZXRNYXhDb2xXaWR0aFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TWF4Q29sV2lkdGgoY29sLCBtYXh3aWR0aCkge1xuICAgICAgICAgICAgICAgIHZhciBvYmogPSB0aGlzW19dLmNvbFdpZHRoc0xpbWl0W2NvbF0gfHwgKHRoaXNbX10uY29sV2lkdGhzTGltaXRbY29sXSA9IHt9KTtcblxuICAgICAgICAgICAgICAgIGlmIChtYXh3aWR0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBvYmoubWF4ID0gbWF4d2lkdGg7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvYmoubWF4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogR2V0IHRoZSBjb2x1bW4gbWluIHdpZHRoIG9mIHRoZSBnaXZlbiB0aGUgY29sdW1uIGluZGV4LlxuICAgICAgICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGNvbCBUaGUgY29sdW1uIGluZGV4XG4gICAgICAgICAgICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGNvbHVtbiBtaW4gd2lkdGhcbiAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImdldE1pbkNvbFdpZHRoXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNaW5Db2xXaWR0aChjb2wpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2JqID0gdGhpc1tfXS5jb2xXaWR0aHNMaW1pdFtjb2xdO1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmogJiYgb2JqLm1pbiB8fCB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIFNldCB0aGUgY29sdW1uIG1pbiB3aWR0aCBvZiB0aGUgZ2l2ZW4gdGhlIGNvbHVtbiBpbmRleC5cbiAgICAgICAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBjb2wgVGhlIGNvbHVtbiBpbmRleFxuICAgICAgICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IG1pbndpZHRoIFRoZSBjb2x1bW4gbWluIHdpZHRoXG4gICAgICAgICAgICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJzZXRNaW5Db2xXaWR0aFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TWluQ29sV2lkdGgoY29sLCBtaW53aWR0aCkge1xuICAgICAgICAgICAgICAgIHZhciBvYmogPSB0aGlzW19dLmNvbFdpZHRoc0xpbWl0W2NvbF0gfHwgKHRoaXNbX10uY29sV2lkdGhzTGltaXRbY29sXSA9IHt9KTtcblxuICAgICAgICAgICAgICAgIGlmIChtaW53aWR0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBvYmoubWluID0gbWlud2lkdGg7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvYmoubWluO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogR2V0IHRoZSByZWN0IG9mIHRoZSBjZWxsLlxuICAgICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sIGluZGV4IG9mIGNvbHVtbiwgb2YgdGhlIGNlbGxcbiAgICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHJvdyBpbmRleCBvZiByb3csIG9mIHRoZSBjZWxsXG4gICAgICAgICAgICAgICAqIEByZXR1cm5zIHtSZWN0fSB0aGUgcmVjdCBvZiB0aGUgY2VsbC5cbiAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImdldENlbGxSZWN0XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDZWxsUmVjdChjb2wsIHJvdykge1xuICAgICAgICAgICAgICAgIHZhciBpc0Zyb3plbkNlbGwgPSB0aGlzLmlzRnJvemVuQ2VsbChjb2wsIHJvdyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgYWJzb2x1dGVMZWZ0ID0gX2dldENvbHNXaWR0aCh0aGlzLCAwLCBjb2wgLSAxKTtcblxuICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IF9nZXRDb2xXaWR0aCh0aGlzLCBjb2wpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzRnJvemVuQ2VsbCAmJiBpc0Zyb3plbkNlbGwuY29sKSB7XG4gICAgICAgICAgICAgICAgICBhYnNvbHV0ZUxlZnQgKz0gdGhpc1tfXS5zY3JvbGwubGVmdDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgYWJzb2x1dGVUb3AgPSBfZ2V0Um93c0hlaWdodC5jYWxsKHRoaXMsIDAsIHJvdyAtIDEpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IF9nZXRSb3dIZWlnaHQuY2FsbCh0aGlzLCByb3cpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzRnJvemVuQ2VsbCAmJiBpc0Zyb3plbkNlbGwucm93KSB7XG4gICAgICAgICAgICAgICAgICBhYnNvbHV0ZVRvcCArPSB0aGlzW19dLnNjcm9sbC50b3A7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWN0XzEuUmVjdChhYnNvbHV0ZUxlZnQsIGFic29sdXRlVG9wLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogR2V0IHRoZSByZWxhdGl2ZSByZWN0YW5nbGUgb2YgdGhlIGNlbGwuXG4gICAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2wgaW5kZXggb2YgY29sdW1uLCBvZiB0aGUgY2VsbFxuICAgICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93IGluZGV4IG9mIHJvdywgb2YgdGhlIGNlbGxcbiAgICAgICAgICAgICAgICogQHJldHVybnMge1JlY3R9IHRoZSByZWN0IG9mIHRoZSBjZWxsLlxuICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0Q2VsbFJlbGF0aXZlUmVjdFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2VsbFJlbGF0aXZlUmVjdChjb2wsIHJvdykge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdG9SZWxhdGl2ZVJlY3QodGhpcywgdGhpcy5nZXRDZWxsUmVjdChjb2wsIHJvdykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBHZXQgdGhlIHJlY3RhbmdsZSBvZiB0aGUgY2VsbHMgYXJlYS5cbiAgICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0Q29sIGluZGV4IG9mIHRoZSBzdGFydGluZyBjb2x1bW4sIG9mIHRoZSBjZWxsXG4gICAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFJvdyBpbmRleCBvZiB0aGUgc3RhcnRpbmcgcm93LCBvZiB0aGUgY2VsbFxuICAgICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kQ29sIGluZGV4IG9mIHRoZSBlbmRpbmcgY29sdW1uLCBvZiB0aGUgY2VsbFxuICAgICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kUm93IGluZGV4IG9mIHRoZSBlbmRpbmcgcm93LCBvZiB0aGUgY2VsbFxuICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7UmVjdH0gdGhlIHJlY3Qgb2YgdGhlIGNlbGxzLlxuICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0Q2VsbHNSZWN0XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDZWxsc1JlY3Qoc3RhcnRDb2wsIHN0YXJ0Um93LCBlbmRDb2wsIGVuZFJvdykge1xuICAgICAgICAgICAgICAgIHZhciBpc0Zyb3plblN0YXJ0Q2VsbCA9IHRoaXMuaXNGcm96ZW5DZWxsKHN0YXJ0Q29sLCBzdGFydFJvdyk7XG4gICAgICAgICAgICAgICAgdmFyIGlzRnJvemVuRW5kQ2VsbCA9IHRoaXMuaXNGcm96ZW5DZWxsKGVuZENvbCwgZW5kUm93KTtcblxuICAgICAgICAgICAgICAgIHZhciBhYnNvbHV0ZUxlZnQgPSBfZ2V0Q29sc1dpZHRoKHRoaXMsIDAsIHN0YXJ0Q29sIC0gMSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBfZ2V0Q29sc1dpZHRoKHRoaXMsIHN0YXJ0Q29sLCBlbmRDb2wpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzRnJvemVuU3RhcnRDZWxsICYmIGlzRnJvemVuU3RhcnRDZWxsLmNvbCkge1xuICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbExlZnQgPSB0aGlzW19dLnNjcm9sbC5sZWZ0O1xuICAgICAgICAgICAgICAgICAgYWJzb2x1dGVMZWZ0ICs9IHNjcm9sbExlZnQ7XG5cbiAgICAgICAgICAgICAgICAgIGlmICghaXNGcm96ZW5FbmRDZWxsIHx8ICFpc0Zyb3plbkVuZENlbGwuY29sKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoIC09IHNjcm9sbExlZnQ7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gTWF0aC5tYXgod2lkdGgsIF9nZXRDb2xzV2lkdGgodGhpcywgc3RhcnRDb2wsIHRoaXMuZnJvemVuQ29sQ291bnQgLSAxKSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGFic29sdXRlVG9wID0gX2dldFJvd3NIZWlnaHQuY2FsbCh0aGlzLCAwLCBzdGFydFJvdyAtIDEpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IF9nZXRSb3dzSGVpZ2h0LmNhbGwodGhpcywgc3RhcnRSb3csIGVuZFJvdyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNGcm96ZW5TdGFydENlbGwgJiYgaXNGcm96ZW5TdGFydENlbGwucm93KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsVG9wID0gdGhpc1tfXS5zY3JvbGwudG9wO1xuICAgICAgICAgICAgICAgICAgYWJzb2x1dGVUb3AgKz0gc2Nyb2xsVG9wO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoIWlzRnJvemVuRW5kQ2VsbCB8fCAhaXNGcm96ZW5FbmRDZWxsLnJvdykge1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgLT0gc2Nyb2xsVG9wO1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBNYXRoLm1heChoZWlnaHQsIF9nZXRDb2xzV2lkdGgodGhpcywgc3RhcnRSb3csIHRoaXMuZnJvemVuUm93Q291bnQgLSAxKSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWN0XzEuUmVjdChhYnNvbHV0ZUxlZnQsIGFic29sdXRlVG9wLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0Q2VsbFJhbmdlUmVjdFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2VsbFJhbmdlUmVjdChyYW5nZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENlbGxzUmVjdChyYW5nZS5zdGFydC5jb2wsIHJhbmdlLnN0YXJ0LnJvdywgcmFuZ2UuZW5kLmNvbCwgcmFuZ2UuZW5kLnJvdyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImlzRnJvemVuQ2VsbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNGcm96ZW5DZWxsKGNvbCwgcm93KSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzJF8gPSB0aGlzW19dLFxuICAgICAgICAgICAgICAgICAgICBmcm96ZW5Sb3dDb3VudCA9IF90aGlzJF8uZnJvemVuUm93Q291bnQsXG4gICAgICAgICAgICAgICAgICAgIGZyb3plbkNvbENvdW50ID0gX3RoaXMkXy5mcm96ZW5Db2xDb3VudDtcbiAgICAgICAgICAgICAgICB2YXIgaXNGcm96ZW5Sb3cgPSBmcm96ZW5Sb3dDb3VudCA+IDAgJiYgcm93IDwgZnJvemVuUm93Q291bnQ7XG4gICAgICAgICAgICAgICAgdmFyIGlzRnJvemVuQ29sID0gZnJvemVuQ29sQ291bnQgPiAwICYmIGNvbCA8IGZyb3plbkNvbENvdW50O1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzRnJvemVuUm93IHx8IGlzRnJvemVuQ29sKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByb3c6IGlzRnJvemVuUm93LFxuICAgICAgICAgICAgICAgICAgICBjb2w6IGlzRnJvemVuQ29sXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImdldFJvd0F0XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRSb3dBdChhYnNvbHV0ZVkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZnJvemVuID0gX2dldFRhcmdldEZyb3plblJvd0F0KHRoaXMsIGFic29sdXRlWSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZnJvemVuKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZnJvemVuLnJvdztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcm93ID0gX2dldFRhcmdldFJvd0F0LmNhbGwodGhpcywgYWJzb2x1dGVZKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiByb3cgPyByb3cucm93IDogLTE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImdldENvbEF0XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb2xBdChhYnNvbHV0ZVgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZnJvemVuID0gX2dldFRhcmdldEZyb3plbkNvbEF0KHRoaXMsIGFic29sdXRlWCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZnJvemVuKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZnJvemVuLmNvbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgY29sID0gX2dldFRhcmdldENvbEF0KHRoaXMsIGFic29sdXRlWCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY29sID8gY29sLmNvbCA6IC0xO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJnZXRDZWxsQXRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldENlbGxBdChhYnNvbHV0ZVgsIGFic29sdXRlWSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICByb3c6IHRoaXMuZ2V0Um93QXQoYWJzb2x1dGVZKSxcbiAgICAgICAgICAgICAgICAgIGNvbDogdGhpcy5nZXRDb2xBdChhYnNvbHV0ZVgpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogU2Nyb2xsIHRvIHdoZXJlIGNlbGwgaXMgdmlzaWJsZS5cbiAgICAgICAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBjb2wgVGhlIGNvbHVtbiBpbmRleC5cbiAgICAgICAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSByb3cgVGhlIHJvdyBpbmRleFxuICAgICAgICAgICAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwibWFrZVZpc2libGVDZWxsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBtYWtlVmlzaWJsZUNlbGwoY29sLCByb3cpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNGcm96ZW5DZWxsID0gdGhpcy5pc0Zyb3plbkNlbGwoY29sLCByb3cpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzRnJvemVuQ2VsbCAmJiBpc0Zyb3plbkNlbGwuY29sICYmIGlzRnJvemVuQ2VsbC5yb3cpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IHRoaXMuZ2V0Q2VsbFJlY3QoY29sLCByb3cpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHZpc2libGVSZWN0ID0gX2dldFNjcm9sbGFibGVWaXNpYmxlUmVjdCh0aGlzKTtcblxuICAgICAgICAgICAgICAgIGlmICh2aXNpYmxlUmVjdC5jb250YWlucyhyZWN0KSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBzY3JvbGxhYmxlID0gdGhpc1tfXS5zY3JvbGxhYmxlO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFpc0Zyb3plbkNlbGwgfHwgIWlzRnJvemVuQ2VsbC5jb2wpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChyZWN0LmxlZnQgPCB2aXNpYmxlUmVjdC5sZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbGFibGUuc2Nyb2xsTGVmdCAtPSB2aXNpYmxlUmVjdC5sZWZ0IC0gcmVjdC5sZWZ0O1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2aXNpYmxlUmVjdC5yaWdodCA8IHJlY3QucmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsYWJsZS5zY3JvbGxMZWZ0IC09IHZpc2libGVSZWN0LnJpZ2h0IC0gcmVjdC5yaWdodDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWlzRnJvemVuQ2VsbCB8fCAhaXNGcm96ZW5DZWxsLnJvdykge1xuICAgICAgICAgICAgICAgICAgaWYgKHJlY3QudG9wIDwgdmlzaWJsZVJlY3QudG9wKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbGFibGUuc2Nyb2xsVG9wIC09IHZpc2libGVSZWN0LnRvcCAtIHJlY3QudG9wO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2aXNpYmxlUmVjdC5ib3R0b20gPCByZWN0LmJvdHRvbSkge1xuICAgICAgICAgICAgICAgICAgICBzY3JvbGxhYmxlLnNjcm9sbFRvcCAtPSB2aXNpYmxlUmVjdC5ib3R0b20gLSByZWN0LmJvdHRvbTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIE1vdmVzIHRoZSBmb2N1cyBjdXJzb3IgdG8gdGhlIGdpdmVuIGNlbGwuXG4gICAgICAgICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gY29sIFRoZSBjb2x1bW4gaW5kZXguXG4gICAgICAgICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gcm93IFRoZSByb3cgaW5kZXhcbiAgICAgICAgICAgICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInNldEZvY3VzQ3Vyc29yXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRGb2N1c0N1cnNvcihjb2wsIHJvdykge1xuICAgICAgICAgICAgICAgIHZhciBmb2N1c0NvbnRyb2wgPSB0aGlzW19dLmZvY3VzQ29udHJvbDtcbiAgICAgICAgICAgICAgICB2YXIgb2xkRWRpdE1vZGUgPSBmb2N1c0NvbnRyb2wuZWRpdE1vZGU7XG4gICAgICAgICAgICAgICAgZm9jdXNDb250cm9sLnNldEZvY3VzUmVjdCh0aGlzLmdldENlbGxSZWN0KGNvbCwgcm93KSk7XG5cbiAgICAgICAgICAgICAgICBfdXBkYXRlZFNlbGVjdGlvbi5jYWxsKHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9sZEVkaXRNb2RlICYmICFmb2N1c0NvbnRyb2wuZWRpdE1vZGUpIHtcbiAgICAgICAgICAgICAgICAgIGZvY3VzQ29udHJvbC5yZXNldElucHV0U3RhdHVzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBGb2N1cyB0aGUgY2VsbC5cbiAgICAgICAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBjb2wgVGhlIGNvbHVtbiBpbmRleC5cbiAgICAgICAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSByb3cgVGhlIHJvdyBpbmRleFxuICAgICAgICAgICAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZm9jdXNDZWxsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmb2N1c0NlbGwoY29sLCByb3cpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEZvY3VzQ3Vyc29yKGNvbCwgcm93KTsgLy8gRmFpbHVyZSBvY2N1cnMgaW4gSUUgaWYgZm9jdXMgaXMgbm90IGxhc3RcblxuICAgICAgICAgICAgICAgIHRoaXNbX10uZm9jdXNDb250cm9sLmZvY3VzKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIFJlZHJhd3MgdGhlIHJhbmdlIG9mIHRoZSBnaXZlbiBjZWxsLlxuICAgICAgICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGNvbCBUaGUgY29sdW1uIGluZGV4IG9mIGNlbGwuXG4gICAgICAgICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gcm93IFRoZSByb3cgaW5kZXggb2YgY2VsbC5cbiAgICAgICAgICAgICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImludmFsaWRhdGVDZWxsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbnZhbGlkYXRlQ2VsbChjb2wsIHJvdykge1xuICAgICAgICAgICAgICAgIHRoaXMuaW52YWxpZGF0ZUdyaWRSZWN0KGNvbCwgcm93KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogUmVkcmF3cyB0aGUgcmFuZ2Ugb2YgdGhlIGdpdmVuIGNlbGxzLlxuICAgICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRDb2wgaW5kZXggb2YgdGhlIHN0YXJ0aW5nIGNvbHVtbiwgb2YgdGhlIGNlbGxcbiAgICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0Um93IGluZGV4IG9mIHRoZSBzdGFydGluZyByb3csIG9mIHRoZSBjZWxsXG4gICAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmRDb2wgaW5kZXggb2YgdGhlIGVuZGluZyBjb2x1bW4sIG9mIHRoZSBjZWxsXG4gICAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmRSb3cgaW5kZXggb2YgdGhlIGVuZGluZyByb3csIG9mIHRoZSBjZWxsXG4gICAgICAgICAgICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJpbnZhbGlkYXRlR3JpZFJlY3RcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGludmFsaWRhdGVHcmlkUmVjdChzdGFydENvbCwgc3RhcnRSb3cpIHtcbiAgICAgICAgICAgICAgICB2YXIgZW5kQ29sID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBzdGFydENvbDtcbiAgICAgICAgICAgICAgICB2YXIgZW5kUm93ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBzdGFydFJvdztcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5nZXRPZmZzZXRJbnZhbGlkYXRlQ2VsbHMoKTtcblxuICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICBzdGFydENvbCAtPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICBzdGFydFJvdyAtPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICBlbmRDb2wgKz0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgZW5kUm93ICs9IG9mZnNldDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgdmlzaWJsZVJlY3QgPSBfZ2V0VmlzaWJsZVJlY3QodGhpcyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgY2VsbHNSZWN0ID0gdGhpcy5nZXRDZWxsc1JlY3Qoc3RhcnRDb2wsIHN0YXJ0Um93LCBlbmRDb2wsIGVuZFJvdyk7XG4gICAgICAgICAgICAgICAgdmFyIGludmFsaWRhdGVUYXJnZXQgPSB2aXNpYmxlUmVjdC5pbnRlcnNlY3Rpb24oY2VsbHNSZWN0KTtcblxuICAgICAgICAgICAgICAgIGlmIChpbnZhbGlkYXRlVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgX3RoaXMkXzIgPSB0aGlzW19dLFxuICAgICAgICAgICAgICAgICAgICAgIGZyb3plbkNvbENvdW50ID0gX3RoaXMkXzIuZnJvemVuQ29sQ291bnQsXG4gICAgICAgICAgICAgICAgICAgICAgZnJvemVuUm93Q291bnQgPSBfdGhpcyRfMi5mcm96ZW5Sb3dDb3VudDtcblxuICAgICAgICAgICAgICAgICAgaWYgKGZyb3plbkNvbENvdW50ID4gMCAmJiBlbmRDb2wgPj0gZnJvemVuQ29sQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZyb3plblJlY3QgPSBfZ2V0RnJvemVuQ29sc1JlY3QodGhpcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyb3plblJlY3QuaW50ZXJzZWN0aW9uKGludmFsaWRhdGVUYXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaW52YWxpZGF0ZVRhcmdldC5sZWZ0ID0gTWF0aC5taW4oZnJvemVuUmVjdC5yaWdodCAtIDEsIGludmFsaWRhdGVUYXJnZXQubGVmdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgaWYgKGZyb3plblJvd0NvdW50ID4gMCAmJiBlbmRSb3cgPj0gZnJvemVuUm93Q291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9mcm96ZW5SZWN0NCA9IF9nZXRGcm96ZW5Sb3dzUmVjdCh0aGlzKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoX2Zyb3plblJlY3Q0LmludGVyc2VjdGlvbihpbnZhbGlkYXRlVGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICAgIGludmFsaWRhdGVUYXJnZXQudG9wID0gTWF0aC5taW4oX2Zyb3plblJlY3Q0LmJvdHRvbSAtIDEsIGludmFsaWRhdGVUYXJnZXQudG9wKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBfaW52YWxpZGF0ZVJlY3QodGhpcywgaW52YWxpZGF0ZVRhcmdldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJpbnZhbGlkYXRlQ2VsbFJhbmdlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbnZhbGlkYXRlQ2VsbFJhbmdlKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnZhbGlkYXRlR3JpZFJlY3QocmFuZ2Uuc3RhcnQuY29sLCByYW5nZS5zdGFydC5yb3csIHJhbmdlLmVuZC5jb2wsIHJhbmdlLmVuZC5yb3cpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBSZWRyYXdzIHRoZSB3aG9sZSBncmlkLlxuICAgICAgICAgICAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiaW52YWxpZGF0ZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmlzaWJsZVJlY3QgPSBfZ2V0VmlzaWJsZVJlY3QodGhpcyk7XG5cbiAgICAgICAgICAgICAgICBfaW52YWxpZGF0ZVJlY3QodGhpcywgdmlzaWJsZVJlY3QpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBHZXQgdGhlIG51bWJlciBvZiBzY3JvbGxhYmxlIHJvd3MgZnVsbHkgdmlzaWJsZSBpbiB0aGUgZ3JpZC4gdmlzaWJsZVJvd0NvdW50IGRvZXMgbm90IGluY2x1ZGUgdGhlIGZyb3plbiByb3dzIGNvdW50ZWQgYnkgdGhlIGZyb3plblJvd0NvdW50IHByb3BlcnR5LiBJdCBkb2VzIG5vdCBpbmNsdWRlIGFueSBwYXJ0aWFsbHkgdmlzaWJsZSByb3dzIG9uIHRoZSBib3R0b20gb2YgdGhlIGdyaWQuXG4gICAgICAgICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJ2aXNpYmxlUm93Q291bnRcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZyb3plblJvd0NvdW50ID0gdGhpcy5mcm96ZW5Sb3dDb3VudDtcblxuICAgICAgICAgICAgICAgIHZhciB2aXNpYmxlUmVjdCA9IF9nZXRWaXNpYmxlUmVjdCh0aGlzKTtcblxuICAgICAgICAgICAgICAgIHZhciB2aXNpYmxlVG9wID0gZnJvemVuUm93Q291bnQgPiAwID8gdmlzaWJsZVJlY3QudG9wICsgX2dldFJvd3NIZWlnaHQuY2FsbCh0aGlzLCAwLCBmcm96ZW5Sb3dDb3VudCAtIDEpIDogdmlzaWJsZVJlY3QudG9wO1xuXG4gICAgICAgICAgICAgICAgdmFyIGluaXRSb3cgPSBfZ2V0VGFyZ2V0Um93QXQuY2FsbCh0aGlzLCB2aXNpYmxlVG9wKTtcblxuICAgICAgICAgICAgICAgIGlmICghaW5pdFJvdykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0Um93ID0gTWF0aC5tYXgoaW5pdFJvdy50b3AgPj0gdmlzaWJsZVRvcCA/IGluaXRSb3cucm93IDogaW5pdFJvdy5yb3cgKyAxLCBmcm96ZW5Sb3dDb3VudCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgYWJzb2x1dGVUb3AgPSBfZ2V0Um93c0hlaWdodC5jYWxsKHRoaXMsIDAsIHN0YXJ0Um93IC0gMSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICAgICAgICAgIHZhciByb3dDb3VudCA9IHRoaXMucm93Q291bnQ7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciByb3cgPSBzdGFydFJvdzsgcm93IDwgcm93Q291bnQ7IHJvdysrKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gX2dldFJvd0hlaWdodC5jYWxsKHRoaXMsIHJvdyk7XG5cbiAgICAgICAgICAgICAgICAgIHZhciBib3R0b20gPSBhYnNvbHV0ZVRvcCArIGhlaWdodDtcblxuICAgICAgICAgICAgICAgICAgaWYgKHZpc2libGVSZWN0LmJvdHRvbSA8IGJvdHRvbSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgICAgICAgIGFic29sdXRlVG9wID0gYm90dG9tO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBjb3VudDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogR2V0IHRoZSBudW1iZXIgb2Ygc2Nyb2xsYWJsZSBjb2x1bW5zIGZ1bGx5IHZpc2libGUgaW4gdGhlIGdyaWQuIHZpc2libGVDb2xDb3VudCBkb2VzIG5vdCBpbmNsdWRlIHRoZSBmcm96ZW4gY29sdW1ucyBjb3VudGVkIGJ5IHRoZSBmcm96ZW5Db2xDb3VudCBwcm9wZXJ0eS4gSXQgZG9lcyBub3QgaW5jbHVkZSBhbnkgcGFydGlhbGx5IHZpc2libGUgY29sdW1ucyBvbiB0aGUgcmlnaHQgb2YgdGhlIGdyaWQuXG4gICAgICAgICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJ2aXNpYmxlQ29sQ291bnRcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZyb3plbkNvbENvdW50ID0gdGhpcy5mcm96ZW5Db2xDb3VudDtcblxuICAgICAgICAgICAgICAgIHZhciB2aXNpYmxlUmVjdCA9IF9nZXRWaXNpYmxlUmVjdCh0aGlzKTtcblxuICAgICAgICAgICAgICAgIHZhciB2aXNpYmxlTGVmdCA9IGZyb3plbkNvbENvdW50ID4gMCA/IHZpc2libGVSZWN0LmxlZnQgKyBfZ2V0Q29sc1dpZHRoKHRoaXMsIDAsIGZyb3plbkNvbENvdW50IC0gMSkgOiB2aXNpYmxlUmVjdC5sZWZ0O1xuXG4gICAgICAgICAgICAgICAgdmFyIGluaXRDb2wgPSBfZ2V0VGFyZ2V0Q29sQXQodGhpcywgdmlzaWJsZUxlZnQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFpbml0Q29sKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRDb2wgPSBNYXRoLm1heChpbml0Q29sLmxlZnQgPj0gdmlzaWJsZUxlZnQgPyBpbml0Q29sLmNvbCA6IGluaXRDb2wuY29sICsgMSwgZnJvemVuQ29sQ291bnQpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGFic29sdXRlTGVmdCA9IF9nZXRDb2xzV2lkdGgodGhpcywgMCwgc3RhcnRDb2wgLSAxKTtcblxuICAgICAgICAgICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIGNvbENvdW50ID0gdGhpcy5jb2xDb3VudDtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGNvbCA9IHN0YXJ0Q29sOyBjb2wgPCBjb2xDb3VudDsgY29sKyspIHtcbiAgICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IF9nZXRDb2xXaWR0aCh0aGlzLCBjb2wpO1xuXG4gICAgICAgICAgICAgICAgICB2YXIgcmlnaHQgPSBhYnNvbHV0ZUxlZnQgKyB3aWR0aDtcblxuICAgICAgICAgICAgICAgICAgaWYgKHZpc2libGVSZWN0LnJpZ2h0IDwgcmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICAgICAgICBhYnNvbHV0ZUxlZnQgPSByaWdodDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIEdldCB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IHJvdyBpbiB0aGUgc2Nyb2xsYWJsZSByZWdpb24gdGhhdCBpcyB2aXNpYmxlLlxuICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwidG9wUm93XCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHZhciBmcm96ZW5Sb3dDb3VudCA9IHRoaXMuZnJvemVuUm93Q291bnQ7XG5cbiAgICAgICAgICAgICAgICB2YXIgdmlzaWJsZVJlY3QgPSBfZ2V0VmlzaWJsZVJlY3QodGhpcyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgdmlzaWJsZVRvcCA9IGZyb3plblJvd0NvdW50ID4gMCA/IHZpc2libGVSZWN0LnRvcCArIF9nZXRSb3dzSGVpZ2h0LmNhbGwodGhpcywgMCwgZnJvemVuUm93Q291bnQgLSAxKSA6IHZpc2libGVSZWN0LnRvcDtcblxuICAgICAgICAgICAgICAgIHZhciBpbml0Um93ID0gX2dldFRhcmdldFJvd0F0LmNhbGwodGhpcywgdmlzaWJsZVRvcCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWluaXRSb3cpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLm1heChpbml0Um93LnRvcCA+PSB2aXNpYmxlVG9wID8gaW5pdFJvdy5yb3cgOiBpbml0Um93LnJvdyArIDEsIGZyb3plblJvd0NvdW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogR2V0IHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgY29sdW1uIGluIHRoZSBzY3JvbGxhYmxlIHJlZ2lvbiB0aGF0IGlzIHZpc2libGUuXG4gICAgICAgICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJsZWZ0Q29sXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHZhciBmcm96ZW5Db2xDb3VudCA9IHRoaXMuZnJvemVuQ29sQ291bnQ7XG5cbiAgICAgICAgICAgICAgICB2YXIgdmlzaWJsZVJlY3QgPSBfZ2V0VmlzaWJsZVJlY3QodGhpcyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgdmlzaWJsZUxlZnQgPSBmcm96ZW5Db2xDb3VudCA+IDAgPyB2aXNpYmxlUmVjdC5sZWZ0ICsgX2dldENvbHNXaWR0aCh0aGlzLCAwLCBmcm96ZW5Db2xDb3VudCAtIDEpIDogdmlzaWJsZVJlY3QubGVmdDtcblxuICAgICAgICAgICAgICAgIHZhciBpbml0Q29sID0gX2dldFRhcmdldENvbEF0KHRoaXMsIHZpc2libGVMZWZ0KTtcblxuICAgICAgICAgICAgICAgIGlmICghaW5pdENvbCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KGluaXRDb2wubGVmdCA+PSB2aXNpYmxlTGVmdCA/IGluaXRDb2wuY29sIDogaW5pdENvbC5jb2wgKyAxLCBmcm96ZW5Db2xDb3VudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIGdldHMgb3Igc2V0cyB0aGUgbnVtYmVyIG9mIHBpeGVscyB0aGF0IGFuIGVsZW1lbnQncyBjb250ZW50IGlzIHNjcm9sbGVkIHZlcnRpY2FsbHlcbiAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInNjcm9sbFRvcFwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tfXS5zY3JvbGxhYmxlLnNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoc2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tfXS5zY3JvbGxhYmxlLnNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogZ2V0cyBvciBzZXRzIHRoZSBudW1iZXIgb2YgcGl4ZWxzIHRoYXQgYW4gZWxlbWVudCdzIGNvbnRlbnQgaXMgc2Nyb2xsZWQgZnJvbSBpdHMgbGVmdCBlZGdlXG4gICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJzY3JvbGxMZWZ0XCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW19dLnNjcm9sbGFibGUuc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoc2Nyb2xsTGVmdCkge1xuICAgICAgICAgICAgICAgIHRoaXNbX10uc2Nyb2xsYWJsZS5zY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogR2V0IHRoZSB2YWx1ZSBvZiBjZWxsIHdpdGggdGhlIGNvcHkgYWN0aW9uLlxuICAgICAgICAgICAgICAgKiA8cD5cbiAgICAgICAgICAgICAgICogUGxlYXNlIGltcGxlbWVudFxuICAgICAgICAgICAgICAgKiA8L3A+XG4gICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICAgICAgICogQHBhcmFtIGNvbCBDb2x1bW4gaW5kZXggb2YgY2VsbC5cbiAgICAgICAgICAgICAgICogQHBhcmFtIHJvdyBSb3cgaW5kZXggb2YgY2VsbC5cbiAgICAgICAgICAgICAgICogQHBhcmFtIHJhbmdlIENvcHkgcmFuZ2UuXG4gICAgICAgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gdGhlIHZhbHVlIG9mIGNlbGxcbiAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImdldENvcHlDZWxsVmFsdWVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldENvcHlDZWxsVmFsdWUoX2NvbCwgX3JvdywgX3JhbmdlKSB7XG4gICAgICAgICAgICAgICAgLy9QbGVhc2UgaW1wbGVtZW50IGdldCBjZWxsIHZhbHVlISFcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBHZXQgdGhlIG92ZXJmbG93ZWQgdGV4dCBpbiB0aGUgY2VsbCByZWN0YW5nbGUsIGZyb20gdGhlIGdpdmVuIGNlbGwuXG4gICAgICAgICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gY29sIFRoZSBjb2x1bW4gaW5kZXguXG4gICAgICAgICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gcm93IFRoZSByb3cgaW5kZXhcbiAgICAgICAgICAgICAgICogQHJldHVybiB7c3RyaW5nIHwgbnVsbH0gVGhlIHRleHQgb3ZlcmZsb3dpbmcgdGhlIGNlbGwgcmVjdC5cbiAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImdldENlbGxPdmVyZmxvd1RleHRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldENlbGxPdmVyZmxvd1RleHQoY29sLCByb3cpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gXCJcIi5jb25jYXQoY29sLCBcIjpcIikuY29uY2F0KHJvdyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbX10uY2VsbFRleHRPdmVyZmxvd3Nba2V5XSB8fCBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBTZXQgdGhlIG92ZXJmbG93ZWQgdGV4dCBpbiB0aGUgY2VsbCByZWN0YW5nbGUsIHRvIHRoZSBnaXZlbiBjZWxsLlxuICAgICAgICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGNvbCBUaGUgY29sdW1uIGluZGV4LlxuICAgICAgICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHJvdyBUaGUgcm93IGluZGV4XG4gICAgICAgICAgICAgICAqIEBwYXJhbSAge3N0cmluZ30gb3ZlcmZsb3dUZXh0IFRoZSBvdmVyZmxvd2VkIHRleHQgaW4gdGhlIGNlbGwgcmVjdGFuZ2xlLlxuICAgICAgICAgICAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwic2V0Q2VsbE92ZXJmbG93VGV4dFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q2VsbE92ZXJmbG93VGV4dChjb2wsIHJvdywgb3ZlcmZsb3dUZXh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IFwiXCIuY29uY2F0KGNvbCwgXCI6XCIpLmNvbmNhdChyb3cpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG92ZXJmbG93VGV4dCkge1xuICAgICAgICAgICAgICAgICAgdGhpc1tfXS5jZWxsVGV4dE92ZXJmbG93c1trZXldID0gdHlwZW9mIG92ZXJmbG93VGV4dCA9PT0gXCJzdHJpbmdcIiA/IG92ZXJmbG93VGV4dC50cmltKCkgOiBvdmVyZmxvd1RleHQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzW19dLmNlbGxUZXh0T3ZlcmZsb3dzW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJhZGREaXNwb3NhYmxlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGREaXNwb3NhYmxlKGRpc3Bvc2FibGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWRpc3Bvc2FibGUgfHwgIWRpc3Bvc2FibGUuZGlzcG9zZSB8fCB0eXBlb2YgZGlzcG9zYWJsZS5kaXNwb3NlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBkaXNwb3NhYmxlIVwiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgZGlzcG9zYWJsZXMgPSB0aGlzW19dLmRpc3Bvc2FibGVzID0gdGhpc1tfXS5kaXNwb3NhYmxlcyB8fCBbXTtcbiAgICAgICAgICAgICAgICBkaXNwb3NhYmxlcy5wdXNoKGRpc3Bvc2FibGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBEaXNwb3NlIHRoZSBncmlkIGluc3RhbmNlLlxuICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImRpc3Bvc2VcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgICAgICAgICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoRHJhd0dyaWQucHJvdG90eXBlKSwgXCJkaXNwb3NlXCIsIHRoaXMpLmNhbGwodGhpcyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgcHJvdGVjdGVkU3BhY2UgPSB0aGlzW19dO1xuICAgICAgICAgICAgICAgIHByb3RlY3RlZFNwYWNlLmhhbmRsZXIuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIHByb3RlY3RlZFNwYWNlLnNjcm9sbGFibGUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIHByb3RlY3RlZFNwYWNlLmZvY3VzQ29udHJvbC5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgcHJvdGVjdGVkU3BhY2UuY29sdW1uUmVzaXplci5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgcHJvdGVjdGVkU3BhY2UuY2VsbFNlbGVjdG9yLmRpc3Bvc2UoKTtcblxuICAgICAgICAgICAgICAgIGlmIChwcm90ZWN0ZWRTcGFjZS5kaXNwb3NhYmxlcykge1xuICAgICAgICAgICAgICAgICAgcHJvdGVjdGVkU3BhY2UuZGlzcG9zYWJsZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlzcG9zYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGlzcG9zYWJsZS5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIHByb3RlY3RlZFNwYWNlLmRpc3Bvc2FibGVzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50RWxlbWVudCA9IHByb3RlY3RlZFNwYWNlLmVsZW1lbnQucGFyZW50RWxlbWVudDtcblxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICBwYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKHByb3RlY3RlZFNwYWNlLmVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0QXR0YWNoQ2VsbHNBcmVhXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBdHRhY2hDZWxsc0FyZWEocmFuZ2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgZWxlbWVudDogdGhpcy5nZXRFbGVtZW50KCksXG4gICAgICAgICAgICAgICAgICByZWN0OiBfdG9SZWxhdGl2ZVJlY3QodGhpcywgdGhpcy5nZXRDZWxsUmFuZ2VSZWN0KHJhbmdlKSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJvbktleURvd25Nb3ZlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbktleURvd25Nb3ZlKGV2dCkge1xuICAgICAgICAgICAgICAgIF9vbktleURvd25Nb3ZlLmNhbGwodGhpcywgZXZ0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiYmluZEV2ZW50c0ludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kRXZlbnRzSW50ZXJuYWwoKSB7Ly9ub3BcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0VGFyZ2V0Um93QXRJbnRlcm5hbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGFyZ2V0Um93QXRJbnRlcm5hbChfYWJzb2x1dGVZKSB7Ly/ntpnmib/nlKgg6Kit5a6a44KS54Sh6KaW44GX44Gm6KiI566X44GZ44KL5aC05ZCI57aZ5om/44GX44Gm5a6f6KOFXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImdldFJvd3NIZWlnaHRJbnRlcm5hbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Um93c0hlaWdodEludGVybmFsKF9zdGFydFJvdywgX2VuZFJvdykgey8v57aZ5om/55SoIOioreWumuOCkueEoeimluOBl+OBpuioiOeul+OBmeOCi+WgtOWQiOe2meaJv+OBl+OBpuWun+ijhVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJnZXRSb3dIZWlnaHRJbnRlcm5hbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Um93SGVpZ2h0SW50ZXJuYWwoX3Jvdykgey8v57aZ5om/55SoIOioreWumuOCkueEoeimluOBl+OBpuioiOeul+OBmeOCi+WgtOWQiOe2meaJv+OBl+OBpuWun+ijhVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJnZXRTY3JvbGxIZWlnaHRJbnRlcm5hbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2Nyb2xsSGVpZ2h0SW50ZXJuYWwoX3Jvdykgey8v57aZ5om/55SoIOioreWumuOCkueEoeimluOBl+OBpuioiOeul+OBmeOCi+WgtOWQiOe2meaJv+OBl+OBpuWun+ijhVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJnZXRNb3ZlTGVmdENvbEJ5S2V5RG93bkludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNb3ZlTGVmdENvbEJ5S2V5RG93bkludGVybmFsKF9yZWY1Mikge1xuICAgICAgICAgICAgICAgIHZhciBjb2wgPSBfcmVmNTIuY29sO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2wgLSAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJnZXRNb3ZlUmlnaHRDb2xCeUtleURvd25JbnRlcm5hbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TW92ZVJpZ2h0Q29sQnlLZXlEb3duSW50ZXJuYWwoX3JlZjUzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbCA9IF9yZWY1My5jb2w7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbCArIDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImdldE1vdmVVcFJvd0J5S2V5RG93bkludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNb3ZlVXBSb3dCeUtleURvd25JbnRlcm5hbChfcmVmNTQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcm93ID0gX3JlZjU0LnJvdztcbiAgICAgICAgICAgICAgICByZXR1cm4gcm93IC0gMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0TW92ZURvd25Sb3dCeUtleURvd25JbnRlcm5hbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TW92ZURvd25Sb3dCeUtleURvd25JbnRlcm5hbChfcmVmNTUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcm93ID0gX3JlZjU1LnJvdztcbiAgICAgICAgICAgICAgICByZXR1cm4gcm93ICsgMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0T2Zmc2V0SW52YWxpZGF0ZUNlbGxzXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRPZmZzZXRJbnZhbGlkYXRlQ2VsbHMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImdldENvcHlSYW5nZUludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb3B5UmFuZ2VJbnRlcm5hbChyYW5nZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiX2dldEluaXRDb250ZXh0XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0SW5pdENvbnRleHQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXNbX10uY29udGV4dDsgLy/liJ3mnJ/ljJZcblxuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBcIndoaXRlXCI7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gXCJibGFja1wiO1xuICAgICAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImxlZnRcIjtcbiAgICAgICAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gXCJ0b3BcIjtcbiAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gMTtcbiAgICAgICAgICAgICAgICBjdHguZm9udCA9IHRoaXMuZm9udCB8fCBcIjE2cHggc2Fucy1zZXJpZlwiO1xuICAgICAgICAgICAgICAgIHJldHVybiBjdHg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImZpcmVMaXN0ZW5lcnNcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZpcmVMaXN0ZW5lcnModHlwZSkge1xuICAgICAgICAgICAgICAgIHZhciBfZ2V0MztcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9sZW40ID0gYXJndW1lbnRzLmxlbmd0aCwgZXZlbnQgPSBuZXcgQXJyYXkoX2xlbjQgPiAxID8gX2xlbjQgLSAxIDogMCksIF9rZXk0ID0gMTsgX2tleTQgPCBfbGVuNDsgX2tleTQrKykge1xuICAgICAgICAgICAgICAgICAgZXZlbnRbX2tleTQgLSAxXSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIChfZ2V0MyA9IF9nZXQoX2dldFByb3RvdHlwZU9mKERyYXdHcmlkLnByb3RvdHlwZSksIFwiZmlyZUxpc3RlbmVyc1wiLCB0aGlzKSkuY2FsbC5hcHBseShfZ2V0MywgW3RoaXMsIHR5cGVdLmNvbmNhdChldmVudCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSwgW3tcbiAgICAgICAgICAgICAga2V5OiBcIkVWRU5UX1RZUEVcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIERHX0VWRU5UX1RZUEVfMS5ER19FVkVOVF9UWVBFO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBEcmF3R3JpZDtcbiAgICAgICAgICB9KEV2ZW50VGFyZ2V0XzEuRXZlbnRUYXJnZXQpO1xuXG4gICAgICAgICAgZXhwb3J0cy5EcmF3R3JpZCA9IERyYXdHcmlkO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2NvcmUvRXZlbnRUYXJnZXQuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2NvcmUvRXZlbnRUYXJnZXQuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGNvcmVFdmVudFRhcmdldEpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgdmFyIF9hO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuRXZlbnRUYXJnZXQgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgdXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uL2ludGVybmFsL3V0aWxzICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL3V0aWxzLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIHN5bWJvbE1hbmFnZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uL2ludGVybmFsL3N5bWJvbE1hbmFnZXIgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvc3ltYm9sTWFuYWdlci5qc1wiKTsgLy9wcml2YXRlIHN5bWJvbFxuXG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cblxuICAgICAgICAgIHZhciBfID0gKDAsIHN5bWJvbE1hbmFnZXJfMS5nZXQpKCk7XG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cblxuICAgICAgICAgIHZhciBuZXh0SWQgPSAxO1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIGV2ZW50IHRhcmdldC5cbiAgICAgICAgICAgKi9cblxuICAgICAgICAgIHZhciBFdmVudFRhcmdldCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBFdmVudFRhcmdldCgpIHtcbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEV2ZW50VGFyZ2V0KTtcblxuICAgICAgICAgICAgICB0aGlzW19hXSA9IHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnM6IHt9LFxuICAgICAgICAgICAgICAgIGxpc3RlbmVyRGF0YToge31cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQWRkcyBhbiBldmVudCBsaXN0ZW5lci5cbiAgICAgICAgICAgICAqIEBwYXJhbSAge3N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZSBpZC5cbiAgICAgICAgICAgICAqIEBwYXJhbSAge2Z1bmN0aW9ufSBsaXN0ZW5lciBDYWxsYmFjayBtZXRob2QuXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IHVuaXF1ZSBpZCBmb3IgdGhlIGxpc3RlbmVyLlxuICAgICAgICAgICAgICovXG5cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKEV2ZW50VGFyZ2V0LCBbe1xuICAgICAgICAgICAgICBrZXk6IFwibGlzdGVuXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBsaXN0ZW4odHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXM3NSA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICB2YXIgbGlzdCA9IHRoaXNbX10ubGlzdGVuZXJzW3R5cGVdIHx8ICh0aGlzW19dLmxpc3RlbmVyc1t0eXBlXSA9IFtdKTtcbiAgICAgICAgICAgICAgICBsaXN0LnB1c2gobGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIHZhciBpZCA9IG5leHRJZCsrO1xuICAgICAgICAgICAgICAgIHRoaXNbX10ubGlzdGVuZXJEYXRhW2lkXSA9IHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgICBsaXN0ZW5lcjogbGlzdGVuZXIsXG4gICAgICAgICAgICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIF90aGlzNzVbX10ubGlzdGVuZXJEYXRhW2lkXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gbGlzdC5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgbGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXM3NVtfXS5saXN0ZW5lcnNbdHlwZV0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIF90aGlzNzVbX10ubGlzdGVuZXJzW3R5cGVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIFJlbW92ZXMgYW4gZXZlbnQgbGlzdGVuZXIgd2hpY2ggd2FzIGFkZGVkIHdpdGggbGlzdGVuKCkgYnkgdGhlIGlkIHJldHVybmVkIGJ5IGxpc3RlbigpLlxuICAgICAgICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGlkIHRoZSBpZCByZXR1cm5lZCBieSBsaXN0ZW4oKS5cbiAgICAgICAgICAgICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInVubGlzdGVuXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB1bmxpc3RlbihpZCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpc1tfXSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXNbX10ubGlzdGVuZXJEYXRhW2lkXS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiYWRkRXZlbnRMaXN0ZW5lclwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuKHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwicmVtb3ZlRXZlbnRMaXN0ZW5lclwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpczc2ID0gdGhpcztcblxuICAgICAgICAgICAgICAgIGlmICghdGhpc1tfXSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICgwLCB1dGlsc18xLmVhY2gpKHRoaXNbX10ubGlzdGVuZXJEYXRhLCBmdW5jdGlvbiAob2JqLCBpZCkge1xuICAgICAgICAgICAgICAgICAgaWYgKG9iai50eXBlID09PSB0eXBlICYmIG9iai5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXM3Ni51bmxpc3RlbihpZCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImhhc0xpc3RlbmVyc1wiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaGFzTGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXNbX10pIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gISF0aGlzW19dLmxpc3RlbmVyc1t0eXBlXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogRmlyZXMgYWxsIHJlZ2lzdGVyZWQgbGlzdGVuZXJzXG4gICAgICAgICAgICAgICAqIEBwYXJhbSAge3N0cmluZ30gICAgdHlwZSBUaGUgdHlwZSBvZiB0aGUgbGlzdGVuZXJzIHRvIGZpcmUuXG4gICAgICAgICAgICAgICAqIEBwYXJhbSAgey4uLip9IGFyZ3MgZmlyZSBhcmd1bWVudHNcbiAgICAgICAgICAgICAgICogQHJldHVybiB7Kn0gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBsaXN0ZW5lclxuICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZmlyZUxpc3RlbmVyc1wiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZmlyZUxpc3RlbmVycyh0eXBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzNzcgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbjUgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW41ID4gMSA/IF9sZW41IC0gMSA6IDApLCBfa2V5NSA9IDE7IF9rZXk1IDwgX2xlbjU7IF9rZXk1KyspIHtcbiAgICAgICAgICAgICAgICAgIGFyZ3NbX2tleTUgLSAxXSA9IGFyZ3VtZW50c1tfa2V5NV07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzW19dKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGxpc3QgPSB0aGlzW19dLmxpc3RlbmVyc1t0eXBlXTtcblxuICAgICAgICAgICAgICAgIGlmICghbGlzdCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBsaXN0Lm1hcChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lci5jYWxsLmFwcGx5KGxpc3RlbmVyLCBbX3RoaXM3N10uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgICAgICAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByICE9IG51bGw7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImRpc3Bvc2VcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtLSBpZ25vcmVcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpc1tfXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gRXZlbnRUYXJnZXQ7XG4gICAgICAgICAgfSgpO1xuXG4gICAgICAgICAgZXhwb3J0cy5FdmVudFRhcmdldCA9IEV2ZW50VGFyZ2V0O1xuICAgICAgICAgIF9hID0gXztcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9kYXRhLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9kYXRhLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBkYXRhSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5GaWx0ZXJEYXRhU291cmNlID0gZXhwb3J0cy5DYWNoZWREYXRhU291cmNlID0gZXhwb3J0cy5EYXRhU291cmNlID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIERhdGFTb3VyY2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vZGF0YS9EYXRhU291cmNlICovXG4gICAgICAgICAgXCIuL2RhdGEvRGF0YVNvdXJjZS5qc1wiKTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRhdGFTb3VyY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICByZXR1cm4gRGF0YVNvdXJjZV8xLkRhdGFTb3VyY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgQ2FjaGVkRGF0YVNvdXJjZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9kYXRhL0NhY2hlZERhdGFTb3VyY2UgKi9cbiAgICAgICAgICBcIi4vZGF0YS9DYWNoZWREYXRhU291cmNlLmpzXCIpO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2FjaGVkRGF0YVNvdXJjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBDYWNoZWREYXRhU291cmNlXzEuQ2FjaGVkRGF0YVNvdXJjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBGaWx0ZXJEYXRhU291cmNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL2RhdGEvRmlsdGVyRGF0YVNvdXJjZSAqL1xuICAgICAgICAgIFwiLi9kYXRhL0ZpbHRlckRhdGFTb3VyY2UuanNcIik7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGaWx0ZXJEYXRhU291cmNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIEZpbHRlckRhdGFTb3VyY2VfMS5GaWx0ZXJEYXRhU291cmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2RhdGEvQ2FjaGVkRGF0YVNvdXJjZS5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9kYXRhL0NhY2hlZERhdGFTb3VyY2UuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gZGF0YUNhY2hlZERhdGFTb3VyY2VKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLkNhY2hlZERhdGFTb3VyY2UgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgRGF0YVNvdXJjZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9EYXRhU291cmNlICovXG4gICAgICAgICAgXCIuL2RhdGEvRGF0YVNvdXJjZS5qc1wiKTtcbiAgICAgICAgICAvKiogQHByaXZhdGUgKi9cblxuXG4gICAgICAgICAgZnVuY3Rpb24gX3NldEZpZWxkQ2FjaGUoIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgZkNhY2hlLCBpbmRleCwgZmllbGQsIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgdmFsdWUpIHtcbiAgICAgICAgICAgIHZhciByZWNDYWNoZSA9IGZDYWNoZVtpbmRleF0gfHwgKGZDYWNoZVtpbmRleF0gPSBuZXcgTWFwKCkpO1xuICAgICAgICAgICAgcmVjQ2FjaGUuc2V0KGZpZWxkLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIGdyaWQgZGF0YSBzb3VyY2UgZm9yIGNhY2hpbmcgUHJvbWlzZSBkYXRhXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBAY2xhc3NkZXNjIGNoZWV0YWhHcmlkLmRhdGEuQ2FjaGVkRGF0YVNvdXJjZVxuICAgICAgICAgICAqIEBtZW1iZXJvZiBjaGVldGFoR3JpZC5kYXRhXG4gICAgICAgICAgICovXG5cblxuICAgICAgICAgIHZhciBDYWNoZWREYXRhU291cmNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRGF0YVNvdXJjZV8xJERhdGFTb3UpIHtcbiAgICAgICAgICAgIF9pbmhlcml0cyhDYWNoZWREYXRhU291cmNlLCBfRGF0YVNvdXJjZV8xJERhdGFTb3UpO1xuXG4gICAgICAgICAgICB2YXIgX3N1cGVyNTEgPSBfY3JlYXRlU3VwZXIoQ2FjaGVkRGF0YVNvdXJjZSk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIENhY2hlZERhdGFTb3VyY2Uob3B0KSB7XG4gICAgICAgICAgICAgIHZhciBfdGhpczc4O1xuXG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDYWNoZWREYXRhU291cmNlKTtcblxuICAgICAgICAgICAgICBfdGhpczc4ID0gX3N1cGVyNTEuY2FsbCh0aGlzLCBvcHQpO1xuICAgICAgICAgICAgICBfdGhpczc4Ll9yQ2FjaGUgPSB7fTtcbiAgICAgICAgICAgICAgX3RoaXM3OC5fZkNhY2hlID0ge307XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczc4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoQ2FjaGVkRGF0YVNvdXJjZSwgW3tcbiAgICAgICAgICAgICAga2V5OiBcImdldE9yaWdpbmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRPcmlnaW5hbChpbmRleCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9yQ2FjaGUgJiYgdGhpcy5fckNhY2hlW2luZGV4XSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JDYWNoZVtpbmRleF07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9nZXQoX2dldFByb3RvdHlwZU9mKENhY2hlZERhdGFTb3VyY2UucHJvdG90eXBlKSwgXCJnZXRPcmlnaW5hbFwiLCB0aGlzKS5jYWxsKHRoaXMsIGluZGV4KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0T3JpZ2luYWxGaWVsZFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0T3JpZ2luYWxGaWVsZChpbmRleCwgZmllbGQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcm93Q2FjaGUgPSB0aGlzLl9mQ2FjaGUgJiYgdGhpcy5fZkNhY2hlW2luZGV4XTtcblxuICAgICAgICAgICAgICAgIGlmIChyb3dDYWNoZSkge1xuICAgICAgICAgICAgICAgICAgdmFyIGNhY2hlID0gcm93Q2FjaGUuZ2V0KGZpZWxkKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKGNhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2dldChfZ2V0UHJvdG90eXBlT2YoQ2FjaGVkRGF0YVNvdXJjZS5wcm90b3R5cGUpLCBcImdldE9yaWdpbmFsRmllbGRcIiwgdGhpcykuY2FsbCh0aGlzLCBpbmRleCwgZmllbGQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJzZXRPcmlnaW5hbEZpZWxkXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcmlnaW5hbEZpZWxkKGluZGV4LCBmaWVsZCwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZkNhY2hlID0gdGhpcy5fZkNhY2hlO1xuXG4gICAgICAgICAgICAgICAgaWYgKGZDYWNoZSAmJiBmQ2FjaGVbaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgICBkZWxldGUgZkNhY2hlW2luZGV4XTsgLy8gY2xlYXIgcm93IGNhY2hlXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9nZXQoX2dldFByb3RvdHlwZU9mKENhY2hlZERhdGFTb3VyY2UucHJvdG90eXBlKSwgXCJzZXRPcmlnaW5hbEZpZWxkXCIsIHRoaXMpLmNhbGwodGhpcywgaW5kZXgsIGZpZWxkLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNsZWFyQ2FjaGVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyQ2FjaGUoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3JDYWNoZSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fckNhY2hlID0ge307XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2ZDYWNoZSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fZkNhY2hlID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJmaWVsZFByb21pc2VDYWxsQmFja0ludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmaWVsZFByb21pc2VDYWxsQmFja0ludGVybmFsKGluZGV4LCBmaWVsZCwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBfc2V0RmllbGRDYWNoZSh0aGlzLl9mQ2FjaGUsIGluZGV4LCBmaWVsZCwgdmFsdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJyZWNvcmRQcm9taXNlQ2FsbEJhY2tJbnRlcm5hbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVjb3JkUHJvbWlzZUNhbGxCYWNrSW50ZXJuYWwoaW5kZXgsIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgIHJlY29yZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JDYWNoZVtpbmRleF0gPSByZWNvcmQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImRpc3Bvc2VcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgICAgICAgICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoQ2FjaGVkRGF0YVNvdXJjZS5wcm90b3R5cGUpLCBcImRpc3Bvc2VcIiwgdGhpcykuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0sIFt7XG4gICAgICAgICAgICAgIGtleTogXCJFVkVOVF9UWVBFXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBEYXRhU291cmNlXzEuRGF0YVNvdXJjZS5FVkVOVF9UWVBFO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJvZkFycmF5XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvZkFycmF5KGFycmF5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDYWNoZWREYXRhU291cmNlKHtcbiAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcnJheVtpbmRleF07XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgbGVuZ3RoOiBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICBzb3VyY2U6IGFycmF5XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIENhY2hlZERhdGFTb3VyY2U7XG4gICAgICAgICAgfShEYXRhU291cmNlXzEuRGF0YVNvdXJjZSk7XG5cbiAgICAgICAgICBleHBvcnRzLkNhY2hlZERhdGFTb3VyY2UgPSBDYWNoZWREYXRhU291cmNlO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2RhdGEvRGF0YVNvdXJjZS5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9kYXRhL0RhdGFTb3VyY2UuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gZGF0YURhdGFTb3VyY2VKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIHZhciBfX2NyZWF0ZUJpbmRpbmcgPSB0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nIHx8IChPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24gKG8sIG0sIGssIGsyKSB7XG4gICAgICAgICAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgICAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuXG4gICAgICAgICAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgICAgICAgICBkZXNjID0ge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbVtrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG4gICAgICAgICAgfSA6IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICAgICAgICAgICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICAgICAgICAgIG9bazJdID0gbVtrXTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBfX3NldE1vZHVsZURlZmF1bHQgPSB0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0IHx8IChPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24gKG8sIHYpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwge1xuICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICB2YWx1ZTogdlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSA6IGZ1bmN0aW9uIChvLCB2KSB7XG4gICAgICAgICAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgX19pbXBvcnRTdGFyID0gdGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhciB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgICAgICAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICAgICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkge1xuICAgICAgICAgICAgICBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLkRhdGFTb3VyY2UgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgX3NvcnQgPSBfX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vaW50ZXJuYWwvc29ydCAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC9zb3J0LmpzXCIpKTtcblxuICAgICAgICAgIHZhciB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vaW50ZXJuYWwvdXRpbHMgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvdXRpbHMuanNcIik7XG5cbiAgICAgICAgICB2YXIgRXZlbnRUYXJnZXRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uL2NvcmUvRXZlbnRUYXJnZXQgKi9cbiAgICAgICAgICBcIi4vY29yZS9FdmVudFRhcmdldC5qc1wiKTtcbiAgICAgICAgICAvKiogQHByaXZhdGUgKi9cblxuXG4gICAgICAgICAgZnVuY3Rpb24gaXNGaWVsZEFzc2Vzc29yKGZpZWxkKSB7XG4gICAgICAgICAgICBpZiAodXRpbHNfMS5vYmouaXNPYmplY3QoZmllbGQpKSB7XG4gICAgICAgICAgICAgIGlmIChmaWVsZC5nZXQgJiYgZmllbGQuc2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKiogQHByaXZhdGUgKi9cblxuXG4gICAgICAgICAgdmFyIEVWRU5UX1RZUEUgPSB7XG4gICAgICAgICAgICBVUERBVEVfTEVOR1RIOiBcInVwZGF0ZV9sZW5ndGhcIixcbiAgICAgICAgICAgIFVQREFURURfTEVOR1RIOiBcInVwZGF0ZWRfbGVuZ3RoXCIsXG4gICAgICAgICAgICBVUERBVEVEX09SREVSOiBcInVwZGF0ZWRfb3JkZXJcIlxuICAgICAgICAgIH07XG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cbiAgICAgICAgICBmdW5jdGlvbiBhc2NPcmRlckZuKHYxLCB2Mikge1xuICAgICAgICAgICAgaWYgKHYxID09PSB2Mikge1xuICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHYxID09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHYyID09IG51bGwgPyAvLyBJZiBib3RoIGFyZSBudWxsaXNoLCBjb25zaWRlciBhIG1hdGNoLlxuICAgICAgICAgICAgICAwIDogLy8gTnVsbHMgZmlyc3RcbiAgICAgICAgICAgICAgLTE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2MiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIE51bGxzIGZpcnN0XG4gICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdjEgPiB2MiA/IDEgOiAtMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBkZXNjT3JkZXJGbih2MSwgdjIpIHtcbiAgICAgICAgICAgIHJldHVybiBhc2NPcmRlckZuKHYxLCB2MikgKiAtMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cblxuICAgICAgICAgIGZ1bmN0aW9uIGdldFZhbHVlKHZhbHVlLCBzZXRQcm9taXNlQmFjaykge1xuICAgICAgICAgICAgdmFyIG1heWJlUHJvbWlzZVZhbHVlID0gKDAsIHV0aWxzXzEuZ2V0T3JBcHBseSkodmFsdWUpO1xuXG4gICAgICAgICAgICBpZiAoKDAsIHV0aWxzXzEuaXNQcm9taXNlKShtYXliZVByb21pc2VWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgdmFyIHByb21pc2VWYWx1ZSA9IG1heWJlUHJvbWlzZVZhbHVlLnRoZW4oZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgICAgICBzZXRQcm9taXNlQmFjayhyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgICAgICAgfSk7IC8v5LiA5pmC55qE44Gr44Kt44Oj44OD44K344OlXG5cbiAgICAgICAgICAgICAgc2V0UHJvbWlzZUJhY2socHJvbWlzZVZhbHVlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VWYWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBtYXliZVByb21pc2VWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cblxuICAgICAgICAgIGZ1bmN0aW9uIGdldEZpZWxkKHJlY29yZCwgZmllbGQsIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgc2V0UHJvbWlzZUJhY2spIHtcbiAgICAgICAgICAgIGlmIChyZWNvcmQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoKDAsIHV0aWxzXzEuaXNQcm9taXNlKShyZWNvcmQpKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZWNvcmQudGhlbihmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRGaWVsZChyLCBmaWVsZCwgc2V0UHJvbWlzZUJhY2spO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGZpZWxkR2V0ID0gaXNGaWVsZEFzc2Vzc29yKGZpZWxkKSA/IGZpZWxkLmdldCA6IGZpZWxkO1xuXG4gICAgICAgICAgICBpZiAoZmllbGRHZXQgaW4gcmVjb3JkKSB7XG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgIHZhciBfZmllbGRSZXN1bHQgPSByZWNvcmRbZmllbGRHZXRdOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXG4gICAgICAgICAgICAgIHJldHVybiBnZXRWYWx1ZShfZmllbGRSZXN1bHQsIHNldFByb21pc2VCYWNrKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBmaWVsZEdldCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgIHZhciBfZmllbGRSZXN1bHQyID0gZmllbGRHZXQocmVjb3JkKTtcblxuICAgICAgICAgICAgICByZXR1cm4gZ2V0VmFsdWUoX2ZpZWxkUmVzdWx0Miwgc2V0UHJvbWlzZUJhY2spO1xuICAgICAgICAgICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXRlbXBsYXRlLWV4cHJlc3Npb25zXG5cblxuICAgICAgICAgICAgdmFyIHNzID0gU3RyaW5nKGZpZWxkR2V0KS5zcGxpdChcIi5cIik7XG5cbiAgICAgICAgICAgIGlmIChzcy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICB2YXIgX2ZpZWxkUmVzdWx0MyA9IHJlY29yZFtmaWVsZEdldF07XG4gICAgICAgICAgICAgIHJldHVybiBnZXRWYWx1ZShfZmllbGRSZXN1bHQzLCBzZXRQcm9taXNlQmFjayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBmaWVsZFJlc3VsdCA9ICgwLCB1dGlsc18xLmFwcGx5Q2hhaW5TYWZlKS5hcHBseSh2b2lkIDAsIFtyZWNvcmQsIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBmdW5jdGlvbiAodmFsLCBuYW1lKSB7XG4gICAgICAgICAgICAgIHJldHVybiBnZXRGaWVsZCh2YWwsIG5hbWUsIHV0aWxzXzEuZW1wdHlGbik7XG4gICAgICAgICAgICB9XS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHNzKSkpO1xuICAgICAgICAgICAgcmV0dXJuIGdldFZhbHVlKGZpZWxkUmVzdWx0LCBzZXRQcm9taXNlQmFjayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgICAgICAgICBmdW5jdGlvbiBzZXRGaWVsZChyZWNvcmQsIGZpZWxkLCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAocmVjb3JkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZmllbGRTZXQgPSBpc0ZpZWxkQXNzZXNzb3IoZmllbGQpID8gZmllbGQuc2V0IDogZmllbGQ7XG5cbiAgICAgICAgICAgIGlmIChmaWVsZFNldCBpbiByZWNvcmQpIHtcbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgcmVjb3JkW2ZpZWxkU2V0XSA9IHZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZmllbGRTZXQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICByZXR1cm4gZmllbGRTZXQocmVjb3JkLCB2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmaWVsZFNldCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICB2YXIgc3MgPSBcIlwiLmNvbmNhdChmaWVsZFNldCkuc3BsaXQoXCIuXCIpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXG4gICAgICAgICAgICAgIHZhciBvYmogPSByZWNvcmQ7XG4gICAgICAgICAgICAgIHZhciBsZW5ndGggPSBzcy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBmID0gc3NbaV07XG5cbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gbGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgb2JqW2ZdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG9iaiA9IG9ialtmXSB8fCAob2JqW2ZdID0ge30pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgcmVjb3JkW2ZpZWxkU2V0XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cblxuICAgICAgICAgIGZ1bmN0aW9uIF9nZXRJbmRleChzb3J0ZWRJbmRleE1hcCwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghc29ydGVkSW5kZXhNYXApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbWFwSW5kZXggPSBzb3J0ZWRJbmRleE1hcFtpbmRleF07XG4gICAgICAgICAgICByZXR1cm4gbWFwSW5kZXggIT0gbnVsbCA/IG1hcEluZGV4IDogaW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIGdyaWQgZGF0YSBzb3VyY2VcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEBjbGFzc2Rlc2MgY2hlZXRhaEdyaWQuZGF0YS5EYXRhU291cmNlXG4gICAgICAgICAgICogQG1lbWJlcm9mIGNoZWV0YWhHcmlkLmRhdGFcbiAgICAgICAgICAgKi9cblxuXG4gICAgICAgICAgdmFyIERhdGFTb3VyY2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FdmVudFRhcmdldF8xJEV2ZW50VDUpIHtcbiAgICAgICAgICAgIF9pbmhlcml0cyhEYXRhU291cmNlLCBfRXZlbnRUYXJnZXRfMSRFdmVudFQ1KTtcblxuICAgICAgICAgICAgdmFyIF9zdXBlcjUyID0gX2NyZWF0ZVN1cGVyKERhdGFTb3VyY2UpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBEYXRhU291cmNlKG9iaikge1xuICAgICAgICAgICAgICB2YXIgX3RoaXM3OTtcblxuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGF0YVNvdXJjZSk7XG5cbiAgICAgICAgICAgICAgdmFyIF9hO1xuXG4gICAgICAgICAgICAgIF90aGlzNzkgPSBfc3VwZXI1Mi5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICBfdGhpczc5Ll9zb3J0ZWRJbmRleE1hcCA9IG51bGw7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5cbiAgICAgICAgICAgICAgX3RoaXM3OS5fZ2V0ID0gKG9iaiA9PT0gbnVsbCB8fCBvYmogPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iai5nZXQuYmluZChvYmopKSB8fCB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIF90aGlzNzkuX2xlbmd0aCA9IChvYmogPT09IG51bGwgfHwgb2JqID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmoubGVuZ3RoKSB8fCAwO1xuICAgICAgICAgICAgICBfdGhpczc5Ll9zb3VyY2UgPSAoX2EgPSBvYmogPT09IG51bGwgfHwgb2JqID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmouc291cmNlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBvYmo7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczc5O1xuICAgICAgICAgICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhEYXRhU291cmNlLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwic291cmNlXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zb3VyY2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImdldFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3JpZ2luYWwoX2dldEluZGV4KHRoaXMuX3NvcnRlZEluZGV4TWFwLCBpbmRleCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJnZXRGaWVsZFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RmllbGQoaW5kZXgsIGZpZWxkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3JpZ2luYWxGaWVsZChfZ2V0SW5kZXgodGhpcy5fc29ydGVkSW5kZXhNYXAsIGluZGV4KSwgZmllbGQpO1xuICAgICAgICAgICAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImhhc0ZpZWxkXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNGaWVsZChpbmRleCwgZmllbGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYXNPcmlnaW5hbEZpZWxkKF9nZXRJbmRleCh0aGlzLl9zb3J0ZWRJbmRleE1hcCwgaW5kZXgpLCBmaWVsZCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInNldEZpZWxkXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRGaWVsZChpbmRleCwgZmllbGQsIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0T3JpZ2luYWxGaWVsZChfZ2V0SW5kZXgodGhpcy5fc29ydGVkSW5kZXhNYXAsIGluZGV4KSwgZmllbGQsIHZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwic29ydFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc29ydChmaWVsZCwgb3JkZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXM4MCA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICB2YXIgc29ydGVkSW5kZXhNYXAgPSBuZXcgQXJyYXkodGhpcy5fbGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB2YXIgb3JkZXJGbiA9IG9yZGVyICE9PSBcImRlc2NcIiA/IGFzY09yZGVyRm4gOiBkZXNjT3JkZXJGbjtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3NvcnQuc29ydFByb21pc2UoZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gc29ydGVkSW5kZXhNYXBbaW5kZXhdICE9IG51bGwgPyBzb3J0ZWRJbmRleE1hcFtpbmRleF0gOiBzb3J0ZWRJbmRleE1hcFtpbmRleF0gPSBpbmRleDtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoaW5kZXgsIHJlbCkge1xuICAgICAgICAgICAgICAgICAgc29ydGVkSW5kZXhNYXBbaW5kZXhdID0gcmVsO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMuX2xlbmd0aCwgb3JkZXJGbiwgZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM4MC5nZXRPcmlnaW5hbEZpZWxkKGluZGV4LCBmaWVsZCk7XG4gICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICBfdGhpczgwLl9zb3J0ZWRJbmRleE1hcCA9IHNvcnRlZEluZGV4TWFwO1xuXG4gICAgICAgICAgICAgICAgICBfdGhpczgwLmZpcmVMaXN0ZW5lcnMoRVZFTlRfVFlQRS5VUERBVEVEX09SREVSKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwibGVuZ3RoXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9sZW5ndGg7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9sZW5ndGggPT09IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciByZXN1bHRzID0gdGhpcy5maXJlTGlzdGVuZXJzKEVWRU5UX1RZUEUuVVBEQVRFX0xFTkdUSCwgbGVuZ3RoKTtcblxuICAgICAgICAgICAgICAgIGlmICh1dGlsc18xLmFycmF5LmZpbmRJbmRleChyZXN1bHRzLCBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuICF2O1xuICAgICAgICAgICAgICAgIH0pID49IDApIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlTGlzdGVuZXJzKEVWRU5UX1RZUEUuVVBEQVRFRF9MRU5HVEgsIHRoaXMuX2xlbmd0aCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImRhdGFTb3VyY2VcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImRpc3Bvc2VcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgICAgICAgICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoRGF0YVNvdXJjZS5wcm90b3R5cGUpLCBcImRpc3Bvc2VcIiwgdGhpcykuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0T3JpZ2luYWxcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldE9yaWdpbmFsKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzODEgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFZhbHVlKHRoaXMuX2dldChpbmRleCksIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzODEucmVjb3JkUHJvbWlzZUNhbGxCYWNrSW50ZXJuYWwoaW5kZXgsIHZhbCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImdldE9yaWdpbmFsRmllbGRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldE9yaWdpbmFsRmllbGQoaW5kZXgsIGZpZWxkKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzODIgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHJlY29yZCA9IHRoaXMuZ2V0T3JpZ2luYWwoaW5kZXgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRGaWVsZChyZWNvcmQsIGZpZWxkLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgICBfdGhpczgyLmZpZWxkUHJvbWlzZUNhbGxCYWNrSW50ZXJuYWwoaW5kZXgsIGZpZWxkLCB2YWwpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJoYXNPcmlnaW5hbEZpZWxkXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNPcmlnaW5hbEZpZWxkKGluZGV4LCBmaWVsZCkge1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmaWVsZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcmVjb3JkID0gdGhpcy5nZXRPcmlnaW5hbChpbmRleCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4ocmVjb3JkICYmIGZpZWxkIGluIHJlY29yZCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInNldE9yaWdpbmFsRmllbGRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9yaWdpbmFsRmllbGQoaW5kZXgsIGZpZWxkLCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHJlY29yZCA9IHRoaXMuZ2V0T3JpZ2luYWwoaW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCgwLCB1dGlsc18xLmlzUHJvbWlzZSkocmVjb3JkKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlY29yZC50aGVuKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXRGaWVsZChyLCBmaWVsZCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldEZpZWxkKHJlY29yZCwgZmllbGQsIHZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZmllbGRQcm9taXNlQ2FsbEJhY2tJbnRlcm5hbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZmllbGRQcm9taXNlQ2FsbEJhY2tJbnRlcm5hbChfaW5kZXgsIF9maWVsZCwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgX3ZhbHVlKSB7Ly9cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwicmVjb3JkUHJvbWlzZUNhbGxCYWNrSW50ZXJuYWxcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlY29yZFByb21pc2VDYWxsQmFja0ludGVybmFsKF9pbmRleCwgX3JlY29yZCkgey8vXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiRVZFTlRfVFlQRVwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRVZFTlRfVFlQRTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwib2ZBcnJheVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb2ZBcnJheShhcnJheSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGF0YVNvdXJjZSh7XG4gICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldChpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXlbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIGxlbmd0aDogYXJyYXkubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgc291cmNlOiBhcnJheVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBEYXRhU291cmNlO1xuICAgICAgICAgIH0oRXZlbnRUYXJnZXRfMS5FdmVudFRhcmdldCk7XG5cbiAgICAgICAgICBleHBvcnRzLkRhdGFTb3VyY2UgPSBEYXRhU291cmNlOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXG4gICAgICAgICAgRGF0YVNvdXJjZS5FTVBUWSA9IG5ldyBEYXRhU291cmNlKHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAvKm5vb3AgKi9cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsZW5ndGg6IDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9kYXRhL0ZpbHRlckRhdGFTb3VyY2UuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vZGF0YS9GaWx0ZXJEYXRhU291cmNlLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGRhdGFGaWx0ZXJEYXRhU291cmNlSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5GaWx0ZXJEYXRhU291cmNlID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIHV0aWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi9pbnRlcm5hbC91dGlscyAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC91dGlscy5qc1wiKTtcblxuICAgICAgICAgIHZhciBEYXRhU291cmNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL0RhdGFTb3VyY2UgKi9cbiAgICAgICAgICBcIi4vZGF0YS9EYXRhU291cmNlLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIEV2ZW50SGFuZGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vaW50ZXJuYWwvRXZlbnRIYW5kbGVyICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL0V2ZW50SGFuZGxlci5qc1wiKTtcbiAgICAgICAgICAvKiogQHByaXZhdGUgKi9cblxuXG4gICAgICAgICAgdmFyIERhdGFTb3VyY2VJdGVyYXRvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBEYXRhU291cmNlSXRlcmF0b3IoZGF0YVNvdXJjZSkge1xuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGF0YVNvdXJjZUl0ZXJhdG9yKTtcblxuICAgICAgICAgICAgICB0aGlzLl9kYXRhU291cmNlID0gZGF0YVNvdXJjZTtcbiAgICAgICAgICAgICAgdGhpcy5fY3VySW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgdGhpcy5fZGF0YSA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoRGF0YVNvdXJjZUl0ZXJhdG9yLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiaGFzTmV4dFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaGFzTmV4dCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IHRoaXMuX2N1ckluZGV4ICsgMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YVNvdXJjZS5sZW5ndGggPiBuZXh0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJuZXh0XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gdGhpcy5fY3VySW5kZXggKyAxO1xuXG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9nZXRJbmRleERhdGEobmV4dCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJJbmRleCA9IG5leHQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIm1vdmVQcmV2XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBtb3ZlUHJldigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJJbmRleC0tO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJfZ2V0SW5kZXhEYXRhXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0SW5kZXhEYXRhKGluZGV4LCBuZXN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGFTb3VyY2UgPSB0aGlzLl9kYXRhU291cmNlO1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcblxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YVtpbmRleF07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGRhdGFTb3VyY2UubGVuZ3RoIDw9IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciByZWNvcmQgPSB0aGlzLl9kYXRhU291cmNlLmdldChpbmRleCk7XG5cbiAgICAgICAgICAgICAgICBkYXRhW2luZGV4XSA9IHJlY29yZDtcblxuICAgICAgICAgICAgICAgIGlmICgoMCwgdXRpbHNfMS5pc1Byb21pc2UpKHJlY29yZCkpIHtcbiAgICAgICAgICAgICAgICAgIHJlY29yZC50aGVuKGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtpbmRleF0gPSB2YWw7XG4gICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgaWYgKCFuZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IDEwMDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ2V0SW5kZXhEYXRhKGluZGV4ICsgaSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBEYXRhU291cmNlSXRlcmF0b3I7XG4gICAgICAgICAgfSgpO1xuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgICAgICAgICB2YXIgRmlsdGVyRGF0YSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBGaWx0ZXJEYXRhKGRjLCBvcmlnaW5hbCwgZmlsdGVyKSB7XG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGaWx0ZXJEYXRhKTtcblxuICAgICAgICAgICAgICB0aGlzLl9jYW5jZWwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgdGhpcy5fb3duZXIgPSBkYztcbiAgICAgICAgICAgICAgdGhpcy5fZGF0YVNvdXJjZUl0ciA9IG5ldyBEYXRhU291cmNlSXRlcmF0b3Iob3JpZ2luYWwpO1xuICAgICAgICAgICAgICB0aGlzLl9maWx0ZXIgPSBmaWx0ZXI7XG4gICAgICAgICAgICAgIHRoaXMuX2ZpbHRlcmVkTGlzdCA9IFtdO1xuICAgICAgICAgICAgICB0aGlzLl9xdWV1ZXMgPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKEZpbHRlckRhdGEsIFt7XG4gICAgICAgICAgICAgIGtleTogXCJnZXRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldChpbmRleCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jYW5jZWwpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGZpbHRlcmVkTGlzdCA9IHRoaXMuX2ZpbHRlcmVkTGlzdDtcblxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IGZpbHRlcmVkTGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmaWx0ZXJlZExpc3RbaW5kZXhdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBxdWV1ZXMgPSB0aGlzLl9xdWV1ZXM7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4UXVldWUgPSBxdWV1ZXNbaW5kZXhdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4UXVldWUpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBpbmRleFF1ZXVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBxdWV1ZXNbaW5kZXhdIHx8IHRoaXMuX2ZpbmRJbmRleChpbmRleCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNhbmNlbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhbmNlbCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIl9maW5kSW5kZXhcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5kSW5kZXgoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAod2luZG93LlByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgIHZhciB0aW1lb3V0ID0gRGF0ZS5ub3coKSArIDEwMDtcbiAgICAgICAgICAgICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZmluZEluZGV4V2l0aFRpbWVvdXQoaW5kZXgsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnQrKztcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnQgPj0gMTAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY291bnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aW1lb3V0IDwgRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9maW5kSW5kZXhXaXRoVGltZW91dChpbmRleCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJfZmluZEluZGV4V2l0aFRpbWVvdXRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5kSW5kZXhXaXRoVGltZW91dChpbmRleCwgdGVzdFRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXM4MyA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICB2YXIgZmlsdGVyZWRMaXN0ID0gdGhpcy5fZmlsdGVyZWRMaXN0O1xuICAgICAgICAgICAgICAgIHZhciBmaWx0ZXIgPSB0aGlzLl9maWx0ZXI7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGFTb3VyY2VJdHIgPSB0aGlzLl9kYXRhU291cmNlSXRyO1xuICAgICAgICAgICAgICAgIHZhciBxdWV1ZXMgPSB0aGlzLl9xdWV1ZXM7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAoZGF0YVNvdXJjZUl0ci5oYXNOZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jYW5jZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgdmFyIHJlY29yZCA9IGRhdGFTb3VyY2VJdHIubmV4dCgpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoKDAsIHV0aWxzXzEuaXNQcm9taXNlKShyZWNvcmQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFTb3VyY2VJdHIubW92ZVByZXYoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHF1ZXVlID0gcmVjb3JkLnRoZW4oZnVuY3Rpb24gKF92YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlc1tpbmRleF0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczgzLmdldChpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBxdWV1ZXNbaW5kZXhdID0gcXVldWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBxdWV1ZTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlcihyZWNvcmQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcmVkTGlzdC5wdXNoKHJlY29yZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgZmlsdGVyZWRMaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWx0ZXJlZExpc3RbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGlmICh0ZXN0VGltZW91dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICB9LCAzMDApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgX3F1ZXVlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICBxdWV1ZXNbaW5kZXhdID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM4My5nZXQoaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBxdWV1ZXNbaW5kZXhdID0gX3F1ZXVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3F1ZXVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBkYyA9IHRoaXMuX293bmVyO1xuICAgICAgICAgICAgICAgIGRjLmxlbmd0aCA9IGZpbHRlcmVkTGlzdC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gRmlsdGVyRGF0YTtcbiAgICAgICAgICB9KCk7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogZ3JpZCBkYXRhIHNvdXJjZSBmb3IgZmlsdGVyXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBAY2xhc3NkZXNjIGNoZWV0YWhHcmlkLmRhdGEuRmlsdGVyRGF0YVNvdXJjZVxuICAgICAgICAgICAqIEBtZW1iZXJvZiBjaGVldGFoR3JpZC5kYXRhXG4gICAgICAgICAgICovXG5cblxuICAgICAgICAgIHZhciBGaWx0ZXJEYXRhU291cmNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRGF0YVNvdXJjZV8xJERhdGFTb3UyKSB7XG4gICAgICAgICAgICBfaW5oZXJpdHMoRmlsdGVyRGF0YVNvdXJjZSwgX0RhdGFTb3VyY2VfMSREYXRhU291Mik7XG5cbiAgICAgICAgICAgIHZhciBfc3VwZXI1MyA9IF9jcmVhdGVTdXBlcihGaWx0ZXJEYXRhU291cmNlKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gRmlsdGVyRGF0YVNvdXJjZShkYXRhU291cmNlLCBmaWx0ZXIpIHtcbiAgICAgICAgICAgICAgdmFyIF90aGlzODQ7XG5cbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZpbHRlckRhdGFTb3VyY2UpO1xuXG4gICAgICAgICAgICAgIF90aGlzODQgPSBfc3VwZXI1My5jYWxsKHRoaXMsIGRhdGFTb3VyY2UpO1xuICAgICAgICAgICAgICBfdGhpczg0Ll9maWx0ZXJEYXRhID0gbnVsbDtcbiAgICAgICAgICAgICAgX3RoaXM4NC5fZGF0YVNvdXJjZSA9IGRhdGFTb3VyY2U7XG4gICAgICAgICAgICAgIF90aGlzODQuZmlsdGVyID0gZmlsdGVyO1xuICAgICAgICAgICAgICB2YXIgaGFuZGxlciA9IF90aGlzODQuX2hhbmRsZXIgPSBuZXcgRXZlbnRIYW5kbGVyXzEuRXZlbnRIYW5kbGVyKCk7XG4gICAgICAgICAgICAgIGhhbmRsZXIub24oZGF0YVNvdXJjZSwgRGF0YVNvdXJjZV8xLkRhdGFTb3VyY2UuRVZFTlRfVFlQRS5VUERBVEVEX09SREVSLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVzZXRcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1hc3NpZ25cbiAgICAgICAgICAgICAgICBfdGhpczg0LmZpbHRlciA9IF90aGlzODQuZmlsdGVyO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgKDAsIHV0aWxzXzEuZWFjaCkoRGF0YVNvdXJjZV8xLkRhdGFTb3VyY2UuRVZFTlRfVFlQRSwgZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLm9uKGRhdGFTb3VyY2UsIHR5cGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBfdGhpczg1O1xuXG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBfbGVuNiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjYpLCBfa2V5NiA9IDA7IF9rZXk2IDwgX2xlbjY7IF9rZXk2KyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnc1tfa2V5Nl0gPSBhcmd1bWVudHNbX2tleTZdO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gKF90aGlzODUgPSBfdGhpczg0KS5maXJlTGlzdGVuZXJzLmFwcGx5KF90aGlzODUsIFt0eXBlXS5jb25jYXQoYXJncykpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzODQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhGaWx0ZXJEYXRhU291cmNlLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiZmlsdGVyXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcblxuICAgICAgICAgICAgICAgIHJldHVybiAoKF9hID0gdGhpcy5fZmlsdGVyRGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLl9maWx0ZXIpIHx8IG51bGw7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGZpbHRlcikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9maWx0ZXJEYXRhKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9maWx0ZXJEYXRhLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX2ZpbHRlckRhdGEgPSBmaWx0ZXIgPyBuZXcgRmlsdGVyRGF0YSh0aGlzLCB0aGlzLl9kYXRhU291cmNlLCBmaWx0ZXIpIDogbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aCA9IHRoaXMuX2RhdGFTb3VyY2UubGVuZ3RoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJnZXRPcmlnaW5hbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0T3JpZ2luYWwoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2ZpbHRlckRhdGEpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfZ2V0KF9nZXRQcm90b3R5cGVPZihGaWx0ZXJEYXRhU291cmNlLnByb3RvdHlwZSksIFwiZ2V0T3JpZ2luYWxcIiwgdGhpcykuY2FsbCh0aGlzLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbHRlckRhdGEuZ2V0KGluZGV4KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwic29ydFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc29ydChmaWVsZCwgb3JkZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YVNvdXJjZS5zb3J0KGZpZWxkLCBvcmRlcik7XG4gICAgICAgICAgICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwic291cmNlXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhU291cmNlLnNvdXJjZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZGF0YVNvdXJjZVwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YVNvdXJjZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZGlzcG9zZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyLmRpc3Bvc2UoKTtcblxuICAgICAgICAgICAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKEZpbHRlckRhdGFTb3VyY2UucHJvdG90eXBlKSwgXCJkaXNwb3NlXCIsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiRVZFTlRfVFlQRVwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRGF0YVNvdXJjZV8xLkRhdGFTb3VyY2UuRVZFTlRfVFlQRTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gRmlsdGVyRGF0YVNvdXJjZTtcbiAgICAgICAgICB9KERhdGFTb3VyY2VfMS5EYXRhU291cmNlKTtcblxuICAgICAgICAgIGV4cG9ydHMuRmlsdGVyRGF0YVNvdXJjZSA9IEZpbHRlckRhdGFTb3VyY2U7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vZWxlbWVudC9JbmxpbmUuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9lbGVtZW50L0lubGluZS5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGVsZW1lbnRJbmxpbmVKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLklubGluZSA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vaW50ZXJuYWwvdXRpbHMgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvdXRpbHMuanNcIik7XG5cbiAgICAgICAgICBmdW5jdGlvbiBnZXRXaWR0aChjdHgsIGNvbnRlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBjdHgubWVhc3VyZVRleHQoY29udGVudCkud2lkdGg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gYnJlYWtXaWR0aChjdHgsIGNvbnRlbnQsIGl0ciwgY2FuZGlkYXRlSW5kZXgsIHdpZHRoKSB7XG4gICAgICAgICAgICB2YXIgY2hhcnMgPSBbXTtcbiAgICAgICAgICAgIHZhciByZXQgPSBpdHIubmV4dCgpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbmRpZGF0ZUluZGV4ICYmIHJldCAhPT0gbnVsbDsgaSsrLCByZXQgPSBpdHIubmV4dCgpKSB7XG4gICAgICAgICAgICAgIGNoYXJzLnB1c2gocmV0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGJlZm9yZVdpZHRoID0gZ2V0V2lkdGgoY3R4LCBjaGFycy5qb2luKFwiXCIpKTtcblxuICAgICAgICAgICAgaWYgKGJlZm9yZVdpZHRoID4gd2lkdGgpIHtcbiAgICAgICAgICAgICAgd2hpbGUgKGNoYXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBjID0gY2hhcnMucG9wKCk7XG4gICAgICAgICAgICAgICAgYmVmb3JlV2lkdGggLT0gZ2V0V2lkdGgoY3R4LCBjIHx8IFwiXCIpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGJlZm9yZVdpZHRoIDw9IHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYmVmb3JlV2lkdGggPCB3aWR0aCkge1xuICAgICAgICAgICAgICB3aGlsZSAocmV0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoYXJXaWR0aCA9IGdldFdpZHRoKGN0eCwgcmV0KTtcblxuICAgICAgICAgICAgICAgIGlmIChiZWZvcmVXaWR0aCArIGNoYXJXaWR0aCA+IHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjaGFycy5wdXNoKHJldCk7XG4gICAgICAgICAgICAgICAgYmVmb3JlV2lkdGggKz0gY2hhcldpZHRoO1xuICAgICAgICAgICAgICAgIHJldCA9IGl0ci5uZXh0KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGJlZm9yZUNvbnRlbnQgPSBjaGFycy5qb2luKFwiXCIpLnJlcGxhY2UoL1xccyskLywgXCJcIik7XG4gICAgICAgICAgICB2YXIgYWZ0ZXJDb250ZW50ID0gY29udGVudC5zbGljZShiZWZvcmVDb250ZW50Lmxlbmd0aCkucmVwbGFjZSgvXlxccysvLCBcIlwiKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGJlZm9yZTogYmVmb3JlQ29udGVudCA/IG5ldyBJbmxpbmUoYmVmb3JlQ29udGVudCkgOiBudWxsLFxuICAgICAgICAgICAgICBhZnRlcjogYWZ0ZXJDb250ZW50ID8gbmV3IElubGluZShhZnRlckNvbnRlbnQpIDogbnVsbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgSW5saW5lID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIElubGluZShjb250ZW50KSB7XG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbmxpbmUpO1xuXG4gICAgICAgICAgICAgIHRoaXMuX2NvbnRlbnQgPSBjb250ZW50ICE9IG51bGwgPyBjb250ZW50IDogXCJcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKElubGluZSwgW3tcbiAgICAgICAgICAgICAga2V5OiBcIndpZHRoXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB3aWR0aChfcmVmNTYpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3R4ID0gX3JlZjU2LmN0eDtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0V2lkdGgoY3R4LCB0aGlzLl9jb250ZW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZm9udFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZm9udCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY29sb3JcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbG9yKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjYW5EcmF3XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjYW5EcmF3KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktZnVuY3Rpb25cblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwib25SZWFkeVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25SZWFkeShfY2FsbGJhY2spIHt9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJkcmF3XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KF9yZWY1Nykge1xuICAgICAgICAgICAgICAgIHZhciBjdHggPSBfcmVmNTcuY3R4LFxuICAgICAgICAgICAgICAgICAgICBjYW52YXNoZWxwZXIgPSBfcmVmNTcuY2FudmFzaGVscGVyLFxuICAgICAgICAgICAgICAgICAgICByZWN0ID0gX3JlZjU3LnJlY3QsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IF9yZWY1Ny5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldExlZnQgPSBfcmVmNTcub2Zmc2V0TGVmdCxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0UmlnaHQgPSBfcmVmNTcub2Zmc2V0UmlnaHQsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFRvcCA9IF9yZWY1Ny5vZmZzZXRUb3AsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldEJvdHRvbSA9IF9yZWY1Ny5vZmZzZXRCb3R0b207XG4gICAgICAgICAgICAgICAgY2FudmFzaGVscGVyLmZpbGxUZXh0UmVjdChjdHgsIHRoaXMuX2NvbnRlbnQsIHJlY3QubGVmdCwgcmVjdC50b3AsIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0LCB7XG4gICAgICAgICAgICAgICAgICBvZmZzZXQ6IG9mZnNldCArIDEsXG4gICAgICAgICAgICAgICAgICBwYWRkaW5nOiB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IG9mZnNldExlZnQsXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBvZmZzZXRSaWdodCxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiBvZmZzZXRUb3AsXG4gICAgICAgICAgICAgICAgICAgIGJvdHRvbTogb2Zmc2V0Qm90dG9tXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNhbkJyZWFrXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjYW5CcmVhaygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gISF0aGlzLl9jb250ZW50O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJzcGxpdEluZGV4XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzcGxpdEluZGV4KGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSB0aGlzLl9jb250ZW50O1xuICAgICAgICAgICAgICAgIHZhciBpdHIgPSB1dGlsc18xLnN0ci5nZW5DaGFycyhjb250ZW50KTtcbiAgICAgICAgICAgICAgICB2YXIgY2hhcnMgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0gaXRyLm5leHQoKTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5kZXggJiYgcmV0ICE9PSBudWxsOyBpKyssIHJldCA9IGl0ci5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgIGNoYXJzLnB1c2gocmV0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgYmVmb3JlQ29udGVudCA9IGNoYXJzLmpvaW4oXCJcIik7XG4gICAgICAgICAgICAgICAgdmFyIGFmdGVyQ29udGVudCA9IGNvbnRlbnQuc2xpY2UoYmVmb3JlQ29udGVudC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICBiZWZvcmU6IGJlZm9yZUNvbnRlbnQgPyBuZXcgSW5saW5lKGJlZm9yZUNvbnRlbnQpIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgIGFmdGVyOiBhZnRlckNvbnRlbnQgPyBuZXcgSW5saW5lKGFmdGVyQ29udGVudCkgOiBudWxsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiYnJlYWtXb3JkXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBicmVha1dvcmQoY3R4LCB3aWR0aCkge1xuICAgICAgICAgICAgICAgIHZhciBjb250ZW50ID0gdGhpcy5fY29udGVudDtcbiAgICAgICAgICAgICAgICB2YXIgYWxsV2lkdGggPSB0aGlzLndpZHRoKHtcbiAgICAgICAgICAgICAgICAgIGN0eDogY3R4XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IE1hdGguZmxvb3IodGhpcy5fY29udGVudC5sZW5ndGggKiB3aWR0aCAvIGFsbFdpZHRoKTtcbiAgICAgICAgICAgICAgICB2YXIgaXRyID0gdXRpbHNfMS5zdHIuZ2VuV29yZHMoY29udGVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJyZWFrV2lkdGgoY3R4LCBjb250ZW50LCBpdHIsIGNhbmRpZGF0ZSwgd2lkdGgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJicmVha0FsbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYnJlYWtBbGwoY3R4LCB3aWR0aCkge1xuICAgICAgICAgICAgICAgIHZhciBjb250ZW50ID0gdGhpcy5fY29udGVudDtcbiAgICAgICAgICAgICAgICB2YXIgYWxsV2lkdGggPSB0aGlzLndpZHRoKHtcbiAgICAgICAgICAgICAgICAgIGN0eDogY3R4XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IE1hdGguZmxvb3IodGhpcy5fY29udGVudC5sZW5ndGggKiB3aWR0aCAvIGFsbFdpZHRoKTtcbiAgICAgICAgICAgICAgICB2YXIgaXRyID0gdXRpbHNfMS5zdHIuZ2VuQ2hhcnMoY29udGVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJyZWFrV2lkdGgoY3R4LCBjb250ZW50LCBpdHIsIGNhbmRpZGF0ZSwgd2lkdGgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRlbnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIElubGluZTtcbiAgICAgICAgICB9KCk7XG5cbiAgICAgICAgICBleHBvcnRzLklubGluZSA9IElubGluZTtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9lbGVtZW50L0lubGluZURyYXdlci5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2VsZW1lbnQvSW5saW5lRHJhd2VyLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gZWxlbWVudElubGluZURyYXdlckpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuSW5saW5lRHJhd2VyID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIElubGluZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9JbmxpbmUgKi9cbiAgICAgICAgICBcIi4vZWxlbWVudC9JbmxpbmUuanNcIik7XG5cbiAgICAgICAgICB2YXIgSW5saW5lRHJhd2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfSW5saW5lXzEkSW5saW5lKSB7XG4gICAgICAgICAgICBfaW5oZXJpdHMoSW5saW5lRHJhd2VyLCBfSW5saW5lXzEkSW5saW5lKTtcblxuICAgICAgICAgICAgdmFyIF9zdXBlcjU0ID0gX2NyZWF0ZVN1cGVyKElubGluZURyYXdlcik7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIElubGluZURyYXdlcihfcmVmNTgpIHtcbiAgICAgICAgICAgICAgdmFyIF90aGlzODY7XG5cbiAgICAgICAgICAgICAgdmFyIGRyYXcgPSBfcmVmNTguZHJhdyxcbiAgICAgICAgICAgICAgICAgIHdpZHRoID0gX3JlZjU4LndpZHRoLFxuICAgICAgICAgICAgICAgICAgY29sb3IgPSBfcmVmNTguY29sb3I7XG5cbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIElubGluZURyYXdlcik7XG5cbiAgICAgICAgICAgICAgX3RoaXM4NiA9IF9zdXBlcjU0LmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgIF90aGlzODYuX2RyYXcgPSBkcmF3O1xuICAgICAgICAgICAgICBfdGhpczg2Ll93aWR0aCA9IHdpZHRoOyAvLyB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgICAgICAgICAgX3RoaXM4Ni5fY29sb3IgPSBjb2xvcjtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzODY7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhJbmxpbmVEcmF3ZXIsIFt7XG4gICAgICAgICAgICAgIGtleTogXCJ3aWR0aFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gd2lkdGgoX2FyZykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93aWR0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZm9udFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZm9udCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY29sb3JcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbG9yKCkge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcblxuICAgICAgICAgICAgICAgIHJldHVybiAoX2EgPSB0aGlzLl9jb2xvcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY2FuRHJhd1wiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2FuRHJhdygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWZ1bmN0aW9uXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIm9uUmVhZHlcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uUmVhZHkoX2NhbGxiYWNrKSB7fVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZHJhd1wiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhfcmVmNTkpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3R4ID0gX3JlZjU5LmN0eCxcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzaGVscGVyID0gX3JlZjU5LmNhbnZhc2hlbHBlcixcbiAgICAgICAgICAgICAgICAgICAgcmVjdCA9IF9yZWY1OS5yZWN0LFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBfcmVmNTkub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXRMZWZ0ID0gX3JlZjU5Lm9mZnNldExlZnQsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFJpZ2h0ID0gX3JlZjU5Lm9mZnNldFJpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXRUb3AgPSBfcmVmNTkub2Zmc2V0VG9wLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXRCb3R0b20gPSBfcmVmNTkub2Zmc2V0Qm90dG9tO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhdyh7XG4gICAgICAgICAgICAgICAgICBjdHg6IGN0eCxcbiAgICAgICAgICAgICAgICAgIGNhbnZhc2hlbHBlcjogY2FudmFzaGVscGVyLFxuICAgICAgICAgICAgICAgICAgcmVjdDogcmVjdCxcbiAgICAgICAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgb2Zmc2V0TGVmdDogb2Zmc2V0TGVmdCxcbiAgICAgICAgICAgICAgICAgIG9mZnNldFJpZ2h0OiBvZmZzZXRSaWdodCxcbiAgICAgICAgICAgICAgICAgIG9mZnNldFRvcDogb2Zmc2V0VG9wLFxuICAgICAgICAgICAgICAgICAgb2Zmc2V0Qm90dG9tOiBvZmZzZXRCb3R0b21cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY2FuQnJlYWtcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNhbkJyZWFrKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBJbmxpbmVEcmF3ZXI7XG4gICAgICAgICAgfShJbmxpbmVfMS5JbmxpbmUpO1xuXG4gICAgICAgICAgZXhwb3J0cy5JbmxpbmVEcmF3ZXIgPSBJbmxpbmVEcmF3ZXI7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vZWxlbWVudC9JbmxpbmVJY29uLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2VsZW1lbnQvSW5saW5lSWNvbi5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBlbGVtZW50SW5saW5lSWNvbkpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgdmFyIF9fY3JlYXRlQmluZGluZyA9IHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcgfHwgKE9iamVjdC5jcmVhdGUgPyBmdW5jdGlvbiAobywgbSwgaywgazIpIHtcbiAgICAgICAgICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG5cbiAgICAgICAgICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICAgICAgICAgIGRlc2MgPSB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBtW2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbiAgICAgICAgICB9IDogZnVuY3Rpb24gKG8sIG0sIGssIGsyKSB7XG4gICAgICAgICAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgICAgICAgICAgb1trMl0gPSBtW2tdO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQgfHwgKE9iamVjdC5jcmVhdGUgPyBmdW5jdGlvbiAobywgdikge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7XG4gICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgIHZhbHVlOiB2XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IDogZnVuY3Rpb24gKG8sIHYpIHtcbiAgICAgICAgICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBfX2ltcG9ydFN0YXIgPSB0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgICAgICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgICAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSB7XG4gICAgICAgICAgICAgIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuSW5saW5lSWNvbiA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBmb250cyA9IF9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi9pbnRlcm5hbC9mb250cyAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC9mb250cy5qc1wiKSk7XG5cbiAgICAgICAgICB2YXIgSW5saW5lXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL0lubGluZSAqL1xuICAgICAgICAgIFwiLi9lbGVtZW50L0lubGluZS5qc1wiKTtcblxuICAgICAgICAgIHZhciBJbmxpbmVJY29uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfSW5saW5lXzEkSW5saW5lMikge1xuICAgICAgICAgICAgX2luaGVyaXRzKElubGluZUljb24sIF9JbmxpbmVfMSRJbmxpbmUyKTtcblxuICAgICAgICAgICAgdmFyIF9zdXBlcjU1ID0gX2NyZWF0ZVN1cGVyKElubGluZUljb24pO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBJbmxpbmVJY29uKGljb24pIHtcbiAgICAgICAgICAgICAgdmFyIF90aGlzODc7XG5cbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIElubGluZUljb24pO1xuXG4gICAgICAgICAgICAgIF90aGlzODcgPSBfc3VwZXI1NS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICBfdGhpczg3Ll9pY29uID0gaWNvbiB8fCB7fTtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzODc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhJbmxpbmVJY29uLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwid2lkdGhcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHdpZHRoKF9yZWY2MCkge1xuICAgICAgICAgICAgICAgIHZhciBjdHggPSBfcmVmNjAuY3R4O1xuICAgICAgICAgICAgICAgIHZhciBpY29uID0gdGhpcy5faWNvbjtcblxuICAgICAgICAgICAgICAgIGlmIChpY29uLndpZHRoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gaWNvbi53aWR0aDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaWNvbi5mb250ICYmIGZvbnRzLmNoZWNrKGljb24uZm9udCwgaWNvbi5jb250ZW50IHx8IFwiXCIpKSB7XG4gICAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgICAgICAgY3R4LmNhbnZhcy5zdHlsZS5sZXR0ZXJTcGFjaW5nID0gXCJub3JtYWxcIjtcblxuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZvbnQgPSBpY29uLmZvbnQgfHwgY3R4LmZvbnQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjdHgubWVhc3VyZVRleHQoaWNvbi5jb250ZW50IHx8IFwiXCIpLndpZHRoO1xuICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmNhbnZhcy5zdHlsZS5sZXR0ZXJTcGFjaW5nID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gMDsgLy91bmtub3duXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImZvbnRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZvbnQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuX2ljb24uZm9udCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY29sb3JcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbG9yKCkge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcblxuICAgICAgICAgICAgICAgIHJldHVybiAoX2EgPSB0aGlzLl9pY29uLmNvbG9yKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjYW5EcmF3XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjYW5EcmF3KCkge1xuICAgICAgICAgICAgICAgIHZhciBpY29uID0gdGhpcy5faWNvbjtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWNvbi5mb250ID8gZm9udHMuY2hlY2soaWNvbi5mb250LCBpY29uLmNvbnRlbnQgfHwgXCJcIikgOiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJvblJlYWR5XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvblJlYWR5KGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGljb24gPSB0aGlzLl9pY29uO1xuXG4gICAgICAgICAgICAgICAgaWYgKGljb24uZm9udCAmJiAhZm9udHMuY2hlY2soaWNvbi5mb250LCBpY29uLmNvbnRlbnQgfHwgXCJcIikpIHtcbiAgICAgICAgICAgICAgICAgIGZvbnRzLmxvYWQoaWNvbi5mb250LCBpY29uLmNvbnRlbnQgfHwgXCJcIiwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZHJhd1wiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhfcmVmNjEpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3R4ID0gX3JlZjYxLmN0eCxcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzaGVscGVyID0gX3JlZjYxLmNhbnZhc2hlbHBlcixcbiAgICAgICAgICAgICAgICAgICAgcmVjdCA9IF9yZWY2MS5yZWN0LFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBfcmVmNjEub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXRMZWZ0ID0gX3JlZjYxLm9mZnNldExlZnQsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFJpZ2h0ID0gX3JlZjYxLm9mZnNldFJpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXRUb3AgPSBfcmVmNjEub2Zmc2V0VG9wLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXRCb3R0b20gPSBfcmVmNjEub2Zmc2V0Qm90dG9tO1xuICAgICAgICAgICAgICAgIHZhciBpY29uID0gdGhpcy5faWNvbjtcblxuICAgICAgICAgICAgICAgIGlmIChpY29uLmNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgIGN0eC5jYW52YXMuc3R5bGUubGV0dGVyU3BhY2luZyA9IFwibm9ybWFsXCI7XG5cbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWFzc2lnblxuICAgICAgICAgICAgICAgICAgICBjdHguZm9udCA9IGN0eC5mb250OyAvLyBUbyBhcHBseSBsZXR0ZXJTcGFjaW5nLCB3ZSBuZWVkIHRvIHJlc2V0IGl0LlxuXG4gICAgICAgICAgICAgICAgICAgIGNhbnZhc2hlbHBlci5maWxsVGV4dFJlY3QoY3R4LCBpY29uLmNvbnRlbnQsIHJlY3QubGVmdCwgcmVjdC50b3AsIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQgKyAxLFxuICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IG9mZnNldExlZnQgKyAodGhpcy5faWNvbi5vZmZzZXRMZWZ0IHx8IDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IG9mZnNldFJpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBvZmZzZXRUb3AgKyAodGhpcy5faWNvbi5vZmZzZXRUb3AgfHwgMCksXG4gICAgICAgICAgICAgICAgICAgICAgICBib3R0b206IG9mZnNldEJvdHRvbVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBjdHguY2FudmFzLnN0eWxlLmxldHRlclNwYWNpbmcgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY2FuQnJlYWtcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNhbkJyZWFrKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBJbmxpbmVJY29uO1xuICAgICAgICAgIH0oSW5saW5lXzEuSW5saW5lKTtcblxuICAgICAgICAgIGV4cG9ydHMuSW5saW5lSWNvbiA9IElubGluZUljb247XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vZWxlbWVudC9JbmxpbmVJbWFnZS5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vZWxlbWVudC9JbmxpbmVJbWFnZS5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gZWxlbWVudElubGluZUltYWdlSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5JbmxpbmVJbWFnZSA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBJbmxpbmVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vSW5saW5lICovXG4gICAgICAgICAgXCIuL2VsZW1lbnQvSW5saW5lLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIGltZ3NfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uL2ludGVybmFsL2ltZ3MgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvaW1ncy5qc1wiKTtcblxuICAgICAgICAgIHZhciB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vaW50ZXJuYWwvdXRpbHMgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvdXRpbHMuanNcIik7XG5cbiAgICAgICAgICB2YXIgSW5saW5lSW1hZ2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9JbmxpbmVfMSRJbmxpbmUzKSB7XG4gICAgICAgICAgICBfaW5oZXJpdHMoSW5saW5lSW1hZ2UsIF9JbmxpbmVfMSRJbmxpbmUzKTtcblxuICAgICAgICAgICAgdmFyIF9zdXBlcjU2ID0gX2NyZWF0ZVN1cGVyKElubGluZUltYWdlKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gSW5saW5lSW1hZ2UoX3JlZjYyKSB7XG4gICAgICAgICAgICAgIHZhciBfdGhpczg4O1xuXG4gICAgICAgICAgICAgIHZhciBzcmMgPSBfcmVmNjIuc3JjLFxuICAgICAgICAgICAgICAgICAgd2lkdGggPSBfcmVmNjIud2lkdGgsXG4gICAgICAgICAgICAgICAgICBoZWlnaHQgPSBfcmVmNjIuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgaW1hZ2VMZWZ0ID0gX3JlZjYyLmltYWdlTGVmdCxcbiAgICAgICAgICAgICAgICAgIGltYWdlVG9wID0gX3JlZjYyLmltYWdlVG9wLFxuICAgICAgICAgICAgICAgICAgaW1hZ2VXaWR0aCA9IF9yZWY2Mi5pbWFnZVdpZHRoLFxuICAgICAgICAgICAgICAgICAgaW1hZ2VIZWlnaHQgPSBfcmVmNjIuaW1hZ2VIZWlnaHQ7XG5cbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIElubGluZUltYWdlKTtcblxuICAgICAgICAgICAgICBfdGhpczg4ID0gX3N1cGVyNTYuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgX3RoaXM4OC5faW5saW5lSW1nUHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICAgIF90aGlzODguX2lubGluZUltZyA9IG51bGw7XG4gICAgICAgICAgICAgIF90aGlzODguX3NyYyA9IHNyYztcbiAgICAgICAgICAgICAgX3RoaXM4OC5fd2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgICAgX3RoaXM4OC5faGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgICBfdGhpczg4Ll9pbWFnZUxlZnQgPSBpbWFnZUxlZnQ7XG4gICAgICAgICAgICAgIF90aGlzODguX2ltYWdlVG9wID0gaW1hZ2VUb3A7XG4gICAgICAgICAgICAgIF90aGlzODguX2ltYWdlV2lkdGggPSBpbWFnZVdpZHRoO1xuICAgICAgICAgICAgICBfdGhpczg4Ll9pbWFnZUhlaWdodCA9IGltYWdlSGVpZ2h0O1xuICAgICAgICAgICAgICBfdGhpczg4Ll9vbmxvYWRlZCA9IFtdO1xuXG4gICAgICAgICAgICAgIGlmICgoMCwgdXRpbHNfMS5pc1Byb21pc2UpKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMudGhlbihmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgICAgICAgX3RoaXM4OC5fc3JjID0gcztcblxuICAgICAgICAgICAgICAgICAgX3RoaXM4OC5fbG9hZEltYWdlKHMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF90aGlzODguX2xvYWRJbWFnZShzcmMpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzODg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhJbmxpbmVJbWFnZSwgW3tcbiAgICAgICAgICAgICAga2V5OiBcIl9sb2FkSW1hZ2VcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9sb2FkSW1hZ2Uoc3JjKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzODkgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgdmFyIGltZyA9IHRoaXMuX2lubGluZUltZ1Byb21pc2UgPSAoMCwgaW1nc18xLmdldENhY2hlT3JMb2FkKShcIklubGluZUltYWdlXCIsIDUwLCBzcmMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCgwLCB1dGlsc18xLmlzUHJvbWlzZSkoaW1nKSkge1xuICAgICAgICAgICAgICAgICAgaW1nLnRoZW4oZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXM4OS5faW5saW5lSW1nID0gaTtcblxuICAgICAgICAgICAgICAgICAgICBfdGhpczg5Ll9vbmxvYWRlZC5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmbigpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9pbmxpbmVJbWcgPSBpbWc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJ3aWR0aFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gd2lkdGgoX2FyZykge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2lkdGggfHwgKChfYiA9IChfYSA9IHRoaXMuX2lubGluZUltZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLndpZHRoKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZm9udFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZm9udCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY29sb3JcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbG9yKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjYW5EcmF3XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjYW5EcmF3KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhIXRoaXMuX2lubGluZUltZztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwib25SZWFkeVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25SZWFkeShjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGlmICgoMCwgdXRpbHNfMS5pc1Byb21pc2UpKHRoaXMuX3NyYykgfHwgKDAsIHV0aWxzXzEuaXNQcm9taXNlKSh0aGlzLl9pbmxpbmVJbWdQcm9taXNlKSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fb25sb2FkZWQucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJkcmF3XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KF9yZWY2Mykge1xuICAgICAgICAgICAgICAgIHZhciBjdHggPSBfcmVmNjMuY3R4LFxuICAgICAgICAgICAgICAgICAgICBjYW52YXNoZWxwZXIgPSBfcmVmNjMuY2FudmFzaGVscGVyLFxuICAgICAgICAgICAgICAgICAgICByZWN0ID0gX3JlZjYzLnJlY3QsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IF9yZWY2My5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldExlZnQgPSBfcmVmNjMub2Zmc2V0TGVmdCxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0UmlnaHQgPSBfcmVmNjMub2Zmc2V0UmlnaHQsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFRvcCA9IF9yZWY2My5vZmZzZXRUb3AsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldEJvdHRvbSA9IF9yZWY2My5vZmZzZXRCb3R0b207XG4gICAgICAgICAgICAgICAgdmFyIGltZyA9IHRoaXMuX2lubGluZUltZztcbiAgICAgICAgICAgICAgICBjYW52YXNoZWxwZXIuZHJhd0lubGluZUltYWdlUmVjdChjdHgsIGltZywgdGhpcy5faW1hZ2VMZWZ0IHx8IDAsIHRoaXMuX2ltYWdlVG9wIHx8IDAsIHRoaXMuX2ltYWdlV2lkdGggfHwgaW1nLndpZHRoLCB0aGlzLl9pbWFnZUhlaWdodCB8fCBpbWcuaGVpZ2h0LCB0aGlzLl93aWR0aCB8fCBpbWcud2lkdGgsIHRoaXMuX2hlaWdodCB8fCBpbWcuaGVpZ2h0LCByZWN0LmxlZnQsIHJlY3QudG9wLCByZWN0LndpZHRoLCByZWN0LmhlaWdodCwge1xuICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQgKyAxLFxuICAgICAgICAgICAgICAgICAgcGFkZGluZzoge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBvZmZzZXRMZWZ0LFxuICAgICAgICAgICAgICAgICAgICByaWdodDogb2Zmc2V0UmlnaHQsXG4gICAgICAgICAgICAgICAgICAgIHRvcDogb2Zmc2V0VG9wLFxuICAgICAgICAgICAgICAgICAgICBib3R0b206IG9mZnNldEJvdHRvbVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjYW5CcmVha1wiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2FuQnJlYWsoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIElubGluZUltYWdlO1xuICAgICAgICAgIH0oSW5saW5lXzEuSW5saW5lKTtcblxuICAgICAgICAgIGV4cG9ydHMuSW5saW5lSW1hZ2UgPSBJbmxpbmVJbWFnZTtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9lbGVtZW50L0lubGluZVBhdGgyRC5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2VsZW1lbnQvSW5saW5lUGF0aDJELmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gZWxlbWVudElubGluZVBhdGgyREpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgdmFyIF9fY3JlYXRlQmluZGluZyA9IHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcgfHwgKE9iamVjdC5jcmVhdGUgPyBmdW5jdGlvbiAobywgbSwgaywgazIpIHtcbiAgICAgICAgICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG5cbiAgICAgICAgICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICAgICAgICAgIGRlc2MgPSB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBtW2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbiAgICAgICAgICB9IDogZnVuY3Rpb24gKG8sIG0sIGssIGsyKSB7XG4gICAgICAgICAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgICAgICAgICAgb1trMl0gPSBtW2tdO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQgfHwgKE9iamVjdC5jcmVhdGUgPyBmdW5jdGlvbiAobywgdikge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7XG4gICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgIHZhbHVlOiB2XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IDogZnVuY3Rpb24gKG8sIHYpIHtcbiAgICAgICAgICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBfX2ltcG9ydFN0YXIgPSB0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgICAgICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgICAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSB7XG4gICAgICAgICAgICAgIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuSW5saW5lUGF0aDJEID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIHBhdGgyRE1hbmFnZXIgPSBfX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vaW50ZXJuYWwvcGF0aDJETWFuYWdlciAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC9wYXRoMkRNYW5hZ2VyLmpzXCIpKTtcblxuICAgICAgICAgIHZhciBJbmxpbmVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vSW5saW5lICovXG4gICAgICAgICAgXCIuL2VsZW1lbnQvSW5saW5lLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIGNhbnZhc2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi9pbnRlcm5hbC9jYW52YXNlcyAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC9jYW52YXNlcy5qc1wiKTtcblxuICAgICAgICAgIHZhciBJbmxpbmVQYXRoMkQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9JbmxpbmVfMSRJbmxpbmU0KSB7XG4gICAgICAgICAgICBfaW5oZXJpdHMoSW5saW5lUGF0aDJELCBfSW5saW5lXzEkSW5saW5lNCk7XG5cbiAgICAgICAgICAgIHZhciBfc3VwZXI1NyA9IF9jcmVhdGVTdXBlcihJbmxpbmVQYXRoMkQpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBJbmxpbmVQYXRoMkQoX3JlZjY0KSB7XG4gICAgICAgICAgICAgIHZhciBfdGhpczkwO1xuXG4gICAgICAgICAgICAgIHZhciBwYXRoID0gX3JlZjY0LnBhdGgsXG4gICAgICAgICAgICAgICAgICB3aWR0aCA9IF9yZWY2NC53aWR0aCxcbiAgICAgICAgICAgICAgICAgIGhlaWdodCA9IF9yZWY2NC5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICBjb2xvciA9IF9yZWY2NC5jb2xvcjtcblxuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5saW5lUGF0aDJEKTtcblxuICAgICAgICAgICAgICBfdGhpczkwID0gX3N1cGVyNTcuY2FsbCh0aGlzKTsgLy8g44GT44Gu44K/44Kk44Of44Oz44Kw44Gn44Gq44GE44GoSUXjgadQYXRoMkTjga5wb2x5ZmlsbOOBjOWPjeaYoOOBleOCjOOBquOBhFxuXG4gICAgICAgICAgICAgIHZhciBQYXRoMkQgPSBwYXRoMkRNYW5hZ2VyLmdldFBhdGgyRCgpO1xuICAgICAgICAgICAgICBfdGhpczkwLl9wYXRoID0gbmV3IFBhdGgyRChwYXRoKTtcbiAgICAgICAgICAgICAgX3RoaXM5MC5fd2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgICAgX3RoaXM5MC5faGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgICBfdGhpczkwLl9jb2xvciA9IGNvbG9yO1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXM5MDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKElubGluZVBhdGgyRCwgW3tcbiAgICAgICAgICAgICAga2V5OiBcIndpZHRoXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB3aWR0aChfYXJnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dpZHRoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJmb250XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmb250KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjb2xvclwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY29sb3IoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuX2NvbG9yKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjYW5EcmF3XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjYW5EcmF3KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktZnVuY3Rpb25cblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwib25SZWFkeVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25SZWFkeShfY2FsbGJhY2spIHt9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJkcmF3XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KF9yZWY2NSkge1xuICAgICAgICAgICAgICAgIHZhciBjdHggPSBfcmVmNjUuY3R4LFxuICAgICAgICAgICAgICAgICAgICByZWN0ID0gX3JlZjY1LnJlY3QsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IF9yZWY2NS5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldExlZnQgPSBfcmVmNjUub2Zmc2V0TGVmdCxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0UmlnaHQgPSBfcmVmNjUub2Zmc2V0UmlnaHQsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFRvcCA9IF9yZWY2NS5vZmZzZXRUb3AsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldEJvdHRvbSA9IF9yZWY2NS5vZmZzZXRCb3R0b207XG4gICAgICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICAgICAgdmFyIHBhZGRpbmcgPSB7XG4gICAgICAgICAgICAgICAgICBsZWZ0OiBvZmZzZXRMZWZ0LFxuICAgICAgICAgICAgICAgICAgcmlnaHQ6IG9mZnNldFJpZ2h0LFxuICAgICAgICAgICAgICAgICAgdG9wOiBvZmZzZXRUb3AsXG4gICAgICAgICAgICAgICAgICBib3R0b206IG9mZnNldEJvdHRvbVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICBjdHgucmVjdChyZWN0LmxlZnQsIHJlY3QudG9wLCByZWN0LndpZHRoLCByZWN0LmhlaWdodCk7IC8vY2xpcFxuXG4gICAgICAgICAgICAgICAgICBjdHguY2xpcCgpOyAvL+aWh+Wtl+aPj+eUu1xuXG4gICAgICAgICAgICAgICAgICB2YXIgcG9zID0gKDAsIGNhbnZhc2VzXzEuY2FsY1N0YXJ0UG9zaXRpb24pKGN0eCwgcmVjdCwgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCwge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogcGFkZGluZ1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKHBvcy54LCBwb3MueSk7XG4gICAgICAgICAgICAgICAgICBjdHguZmlsbCh0aGlzLl9wYXRoKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNhbkJyZWFrXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjYW5CcmVhaygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gSW5saW5lUGF0aDJEO1xuICAgICAgICAgIH0oSW5saW5lXzEuSW5saW5lKTtcblxuICAgICAgICAgIGV4cG9ydHMuSW5saW5lUGF0aDJEID0gSW5saW5lUGF0aDJEO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2VsZW1lbnQvSW5saW5lU3ZnLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vZWxlbWVudC9JbmxpbmVTdmcuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBlbGVtZW50SW5saW5lU3ZnSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5JbmxpbmVTdmcgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgdXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uL2ludGVybmFsL3V0aWxzICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL3V0aWxzLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIElubGluZUltYWdlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL0lubGluZUltYWdlICovXG4gICAgICAgICAgXCIuL2VsZW1lbnQvSW5saW5lSW1hZ2UuanNcIik7XG5cbiAgICAgICAgICBmdW5jdGlvbiBidWlsZFN2Z0RhdGFVcmwoc3ZnKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHR5cGVvZiBzdmcgPT09IFwic3RyaW5nXCIgPyBzdmcgOiBuZXcgWE1MU2VyaWFsaXplcigpLnNlcmlhbGl6ZVRvU3RyaW5nKHN2Zyk7XG4gICAgICAgICAgICB2YXIgdXJsID0gXCJkYXRhOmltYWdlL3N2Zyt4bWw7Y2hhcnNldD11dGYtOCxcIi5jb25jYXQoZW5jb2RlVVJJQ29tcG9uZW50KGRhdGEpKTsgLy9zdmfjg4fjg7zjgr/jgpJiYXNlNjTjgavlpInmj5tcblxuICAgICAgICAgICAgcmV0dXJuIHVybDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBnZXRTdmdFbGVtZW50KHN2Zykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdmcgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgdmFyIHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlci5wYXJzZUZyb21TdHJpbmcoc3ZnLCBcImltYWdlL3N2Zyt4bWxcIikuY2hpbGRyZW5bMF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gc3ZnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBJbmxpbmVTdmcgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9JbmxpbmVJbWFnZV8xJElubGluZSkge1xuICAgICAgICAgICAgX2luaGVyaXRzKElubGluZVN2ZywgX0lubGluZUltYWdlXzEkSW5saW5lKTtcblxuICAgICAgICAgICAgdmFyIF9zdXBlcjU4ID0gX2NyZWF0ZVN1cGVyKElubGluZVN2Zyk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIElubGluZVN2ZyhfcmVmNjYpIHtcbiAgICAgICAgICAgICAgdmFyIHN2ZyA9IF9yZWY2Ni5zdmcsXG4gICAgICAgICAgICAgICAgICB3aWR0aCA9IF9yZWY2Ni53aWR0aCxcbiAgICAgICAgICAgICAgICAgIGhlaWdodCA9IF9yZWY2Ni5oZWlnaHQ7XG5cbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIElubGluZVN2Zyk7XG5cbiAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcblxuICAgICAgICAgICAgICB2YXIgc3ZnRWxlbSA9ICgwLCB1dGlsc18xLnRoZW4pKHN2ZywgZ2V0U3ZnRWxlbWVudCk7XG4gICAgICAgICAgICAgIHZhciBlbG1XaWR0aCA9ICEoMCwgdXRpbHNfMS5pc1Byb21pc2UpKHN2Z0VsZW0pID8gKF9hID0gc3ZnRWxlbS5nZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdW5kZWZpbmVkIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICB2YXIgZWxtSGVpZ2h0ID0gISgwLCB1dGlsc18xLmlzUHJvbWlzZSkoc3ZnRWxlbSkgPyAoX2IgPSBzdmdFbGVtLmdldEF0dHJpYnV0ZShcImhlaWdodFwiKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdW5kZWZpbmVkIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICB2YXIgbnVtRWxtV2lkdGggPSBlbG1XaWR0aCAhPSBudWxsID8gTnVtYmVyKGVsbVdpZHRoKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgdmFyIG51bUVsbUhlaWdodCA9IGVsbUhlaWdodCAhPSBudWxsID8gTnVtYmVyKGVsbUhlaWdodCkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIHJldHVybiBfc3VwZXI1OC5jYWxsKHRoaXMsIHtcbiAgICAgICAgICAgICAgICBzcmM6ICgwLCB1dGlsc18xLnRoZW4pKHN2ZywgYnVpbGRTdmdEYXRhVXJsKSxcbiAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGggfHwgbnVtRWxtV2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQgfHwgbnVtRWxtSGVpZ2h0LFxuICAgICAgICAgICAgICAgIGltYWdlV2lkdGg6IG51bUVsbVdpZHRoLFxuICAgICAgICAgICAgICAgIGltYWdlSGVpZ2h0OiBudW1FbG1IZWlnaHRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhJbmxpbmVTdmcsIFt7XG4gICAgICAgICAgICAgIGtleTogXCJjYW5CcmVha1wiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2FuQnJlYWsoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIElubGluZVN2ZztcbiAgICAgICAgICB9KElubGluZUltYWdlXzEuSW5saW5lSW1hZ2UpO1xuXG4gICAgICAgICAgZXhwb3J0cy5JbmxpbmVTdmcgPSBJbmxpbmVTdmc7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vZWxlbWVudC9pbmxpbmVzLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2VsZW1lbnQvaW5saW5lcy5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBlbGVtZW50SW5saW5lc0pzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgdmFyIF9fY3JlYXRlQmluZGluZyA9IHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcgfHwgKE9iamVjdC5jcmVhdGUgPyBmdW5jdGlvbiAobywgbSwgaywgazIpIHtcbiAgICAgICAgICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG5cbiAgICAgICAgICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICAgICAgICAgIGRlc2MgPSB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBtW2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbiAgICAgICAgICB9IDogZnVuY3Rpb24gKG8sIG0sIGssIGsyKSB7XG4gICAgICAgICAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgICAgICAgICAgb1trMl0gPSBtW2tdO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQgfHwgKE9iamVjdC5jcmVhdGUgPyBmdW5jdGlvbiAobywgdikge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7XG4gICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgIHZhbHVlOiB2XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IDogZnVuY3Rpb24gKG8sIHYpIHtcbiAgICAgICAgICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBfX2ltcG9ydFN0YXIgPSB0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgICAgICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgICAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSB7XG4gICAgICAgICAgICAgIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuc3RyaW5nID0gZXhwb3J0cy5idWlsZElubGluZXMgPSBleHBvcnRzLm9mID0gZXhwb3J0cy5pY29uT2YgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgaWNvbnMgPSBfX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vaWNvbnMgKi9cbiAgICAgICAgICBcIi4vaWNvbnMuanNcIikpO1xuXG4gICAgICAgICAgdmFyIHBhdGgyRE1hbmFnZXIgPSBfX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vaW50ZXJuYWwvcGF0aDJETWFuYWdlciAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC9wYXRoMkRNYW5hZ2VyLmpzXCIpKTtcblxuICAgICAgICAgIHZhciBJbmxpbmVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vSW5saW5lICovXG4gICAgICAgICAgXCIuL2VsZW1lbnQvSW5saW5lLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIElubGluZURyYXdlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9JbmxpbmVEcmF3ZXIgKi9cbiAgICAgICAgICBcIi4vZWxlbWVudC9JbmxpbmVEcmF3ZXIuanNcIik7XG5cbiAgICAgICAgICB2YXIgSW5saW5lSWNvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9JbmxpbmVJY29uICovXG4gICAgICAgICAgXCIuL2VsZW1lbnQvSW5saW5lSWNvbi5qc1wiKTtcblxuICAgICAgICAgIHZhciBJbmxpbmVJbWFnZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9JbmxpbmVJbWFnZSAqL1xuICAgICAgICAgIFwiLi9lbGVtZW50L0lubGluZUltYWdlLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIElubGluZVBhdGgyRF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9JbmxpbmVQYXRoMkQgKi9cbiAgICAgICAgICBcIi4vZWxlbWVudC9JbmxpbmVQYXRoMkQuanNcIik7XG5cbiAgICAgICAgICB2YXIgSW5saW5lU3ZnXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL0lubGluZVN2ZyAqL1xuICAgICAgICAgIFwiLi9lbGVtZW50L0lubGluZVN2Zy5qc1wiKTtcblxuICAgICAgICAgIHZhciBjYW52YXNlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vaW50ZXJuYWwvY2FudmFzZXMgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvY2FudmFzZXMuanNcIik7XG5cbiAgICAgICAgICBmdW5jdGlvbiBkcmF3UmVnaXN0ZXJlZEljb24oY3R4LCBpY29uLCBkcmF3V2lkdGgsIGRyYXdIZWlnaHQsIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgICAgdmFyIF9yZWY2NyA9IGFyZ3VtZW50cy5sZW5ndGggPiA4ICYmIGFyZ3VtZW50c1s4XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzhdIDoge30sXG4gICAgICAgICAgICAgICAgX3JlZjY3JG9mZnNldCA9IF9yZWY2Ny5vZmZzZXQsXG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gX3JlZjY3JG9mZnNldCA9PT0gdm9pZCAwID8gMiA6IF9yZWY2NyRvZmZzZXQsXG4gICAgICAgICAgICAgICAgcGFkZGluZyA9IF9yZWY2Ny5wYWRkaW5nO1xuXG4gICAgICAgICAgICB2YXIgcmVjdCA9IHtcbiAgICAgICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICAgICAgdG9wOiB0b3AsXG4gICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgICAgIHJpZ2h0OiBsZWZ0ICsgd2lkdGgsXG4gICAgICAgICAgICAgIGJvdHRvbTogdG9wICsgaGVpZ2h0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY3R4LnNhdmUoKTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICBjdHgucmVjdChyZWN0LmxlZnQsIHJlY3QudG9wLCByZWN0LndpZHRoLCByZWN0LmhlaWdodCk7IC8vY2xpcFxuXG4gICAgICAgICAgICAgIGN0eC5jbGlwKCk7IC8v5paH5a2X5o+P55S7XG5cbiAgICAgICAgICAgICAgdmFyIHBvcyA9ICgwLCBjYW52YXNlc18xLmNhbGNTdGFydFBvc2l0aW9uKShjdHgsIHJlY3QsIGRyYXdXaWR0aCwgZHJhd0hlaWdodCwge1xuICAgICAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICAgICAgICAgIHBhZGRpbmc6IHBhZGRpbmdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHBhdGgyRE1hbmFnZXIuZmlsbChpY29uLCBjdHgsIHBvcy54LCBwb3MueSwgZHJhd1dpZHRoLCBkcmF3SGVpZ2h0KTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gaXNJY29uQ29uc3RydWN0b3JPcHRpb24oaWNvbikge1xuICAgICAgICAgICAgaWYgKGljb24uZm9udCAmJiBpY29uLmNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBpc0lubGluZUltYWdlQ29uc3RydWN0b3JPcHRpb24oaWNvbikge1xuICAgICAgICAgICAgaWYgKGljb24uc3JjKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gaXNJbmxpbmVTdmdDb25zdHJ1Y3Rvck9wdGlvbihpY29uKSB7XG4gICAgICAgICAgICBpZiAoaWNvbi5wYXRoKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gaWNvbk9mKGljb24pIHtcbiAgICAgICAgICAgIGlmIChpY29uIGluc3RhbmNlb2YgSW5saW5lXzEuSW5saW5lKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpY29uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWljb24pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc0ljb25Db25zdHJ1Y3Rvck9wdGlvbihpY29uKSkge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IElubGluZUljb25fMS5JbmxpbmVJY29uKGljb24pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNJbmxpbmVJbWFnZUNvbnN0cnVjdG9yT3B0aW9uKGljb24pKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgSW5saW5lSW1hZ2VfMS5JbmxpbmVJbWFnZSh7XG4gICAgICAgICAgICAgICAgc3JjOiBpY29uLnNyYyxcbiAgICAgICAgICAgICAgICB3aWR0aDogaWNvbi53aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGljb24ud2lkdGhcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpY29uLnN2Zykge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IElubGluZVN2Z18xLklubGluZVN2Zyh7XG4gICAgICAgICAgICAgICAgc3ZnOiBpY29uLnN2ZyxcbiAgICAgICAgICAgICAgICB3aWR0aDogaWNvbi53aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGljb24ud2lkdGhcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc0lubGluZVN2Z0NvbnN0cnVjdG9yT3B0aW9uKGljb24pKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgSW5saW5lUGF0aDJEXzEuSW5saW5lUGF0aDJEKHtcbiAgICAgICAgICAgICAgICBwYXRoOiBpY29uLnBhdGgsXG4gICAgICAgICAgICAgICAgd2lkdGg6IGljb24ud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBpY29uLndpZHRoLFxuICAgICAgICAgICAgICAgIGNvbG9yOiBpY29uLmNvbG9yXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmVnaXN0ZXJlZEljb25zID0gaWNvbnMuZ2V0KCk7XG5cbiAgICAgICAgICAgIGlmIChpY29uLm5hbWUgJiYgcmVnaXN0ZXJlZEljb25zW2ljb24ubmFtZV0pIHtcbiAgICAgICAgICAgICAgdmFyIHJlZ2lzdGVyZWRJY29uID0gcmVnaXN0ZXJlZEljb25zW2ljb24ubmFtZV07XG4gICAgICAgICAgICAgIHZhciB3aWR0aCA9IGljb24ud2lkdGggfHwgTWF0aC5tYXgocmVnaXN0ZXJlZEljb24ud2lkdGgsIHJlZ2lzdGVyZWRJY29uLmhlaWdodCk7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgSW5saW5lRHJhd2VyXzEuSW5saW5lRHJhd2VyKHtcbiAgICAgICAgICAgICAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KF9yZWY2OCkge1xuICAgICAgICAgICAgICAgICAgdmFyIGN0eCA9IF9yZWY2OC5jdHgsXG4gICAgICAgICAgICAgICAgICAgICAgcmVjdCA9IF9yZWY2OC5yZWN0LFxuICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IF9yZWY2OC5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0TGVmdCA9IF9yZWY2OC5vZmZzZXRMZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgIG9mZnNldFJpZ2h0ID0gX3JlZjY4Lm9mZnNldFJpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgIG9mZnNldFRvcCA9IF9yZWY2OC5vZmZzZXRUb3AsXG4gICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0Qm90dG9tID0gX3JlZjY4Lm9mZnNldEJvdHRvbTtcbiAgICAgICAgICAgICAgICAgIGRyYXdSZWdpc3RlcmVkSWNvbihjdHgsIHJlZ2lzdGVyZWRJY29uLCB3aWR0aCwgd2lkdGgsIHJlY3QubGVmdCwgcmVjdC50b3AsIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0LCB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0ICsgMSxcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZzoge1xuICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IG9mZnNldExlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IG9mZnNldFJpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgIHRvcDogb2Zmc2V0VG9wLFxuICAgICAgICAgICAgICAgICAgICAgIGJvdHRvbTogb2Zmc2V0Qm90dG9tXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogd2lkdGgsXG4gICAgICAgICAgICAgICAgY29sb3I6IGljb24uY29sb3JcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgSW5saW5lSWNvbl8xLklubGluZUljb24oaWNvbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5pY29uT2YgPSBpY29uT2Y7XG5cbiAgICAgICAgICBmdW5jdGlvbiBvZihjb250ZW50KSB7XG4gICAgICAgICAgICBpZiAoY29udGVudCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY29udGVudCBpbnN0YW5jZW9mIElubGluZV8xLklubGluZSkge1xuICAgICAgICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbmxpbmVfMS5JbmxpbmUoY29udGVudCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5vZiA9IG9mO1xuXG4gICAgICAgICAgZnVuY3Rpb24gYnVpbGRJbmxpbmVzKGljb25zLCBpbmxpbmUpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICAgICAgaWYgKGljb25zKSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5wdXNoLmFwcGx5KHJlc3VsdCwgX3RvQ29uc3VtYWJsZUFycmF5KGljb25zLm1hcChmdW5jdGlvbiAoaWNvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBpY29uT2YoaWNvbik7XG4gICAgICAgICAgICAgIH0pLmZpbHRlcihmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpICE9IG51bGw7XG4gICAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGlubGluZSkgLy8gJiYgaW5saW5lLmZpbHRlcihpbCA9PiBpbCBpbnN0YW5jZW9mIElubGluZSkubGVuZ3RoIDwtID9cbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoLmFwcGx5KHJlc3VsdCwgX3RvQ29uc3VtYWJsZUFycmF5KGlubGluZS5tYXAoZnVuY3Rpb24gKGlsKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gb2YoaWwpO1xuICAgICAgICAgICAgICAgIH0pLmZpbHRlcihmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGkgIT0gbnVsbDtcbiAgICAgICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgaWwgPSBvZihpbmxpbmUpO1xuXG4gICAgICAgICAgICAgIGlmIChpbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGlsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMuYnVpbGRJbmxpbmVzID0gYnVpbGRJbmxpbmVzO1xuXG4gICAgICAgICAgZnVuY3Rpb24gc3RyaW5nKGlubGluZSkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkSW5saW5lcyh1bmRlZmluZWQsIGlubGluZSkuam9pbihcIlwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRzLnN0cmluZyA9IHN0cmluZztcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9nZXQtaW50ZXJuYWwuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vZ2V0LWludGVybmFsLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGdldEludGVybmFsSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5nZXRJbnRlcm5hbCA9IHZvaWQgMDtcblxuICAgICAgICAgIGZ1bmN0aW9uIGdldEludGVybmFsKCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwidXNlIGludGVybmFsISFcIik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBjb2xvcjogX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgICAgLyohIC4vaW50ZXJuYWwvY29sb3IgKi9cbiAgICAgICAgICAgICAgXCIuL2ludGVybmFsL2NvbG9yLmpzXCIpLFxuICAgICAgICAgICAgICBzb3J0OiBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgICAvKiEgLi9pbnRlcm5hbC9zb3J0ICovXG4gICAgICAgICAgICAgIFwiLi9pbnRlcm5hbC9zb3J0LmpzXCIpLFxuICAgICAgICAgICAgICBjYWxjOiBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgICAvKiEgLi9pbnRlcm5hbC9jYWxjICovXG4gICAgICAgICAgICAgIFwiLi9pbnRlcm5hbC9jYWxjLmpzXCIpLFxuICAgICAgICAgICAgICBzeW1ib2xNYW5hZ2VyOiBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgICAvKiEgLi9pbnRlcm5hbC9zeW1ib2xNYW5hZ2VyICovXG4gICAgICAgICAgICAgIFwiLi9pbnRlcm5hbC9zeW1ib2xNYW5hZ2VyLmpzXCIpLFxuICAgICAgICAgICAgICBwYXRoMkRNYW5hZ2VyOiBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgICAvKiEgLi9pbnRlcm5hbC9wYXRoMkRNYW5hZ2VyICovXG4gICAgICAgICAgICAgIFwiLi9pbnRlcm5hbC9wYXRoMkRNYW5hZ2VyLmpzXCIpLFxuICAgICAgICAgICAgICBwYXN0ZVV0aWxzOiBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgICAvKiEgLi9pbnRlcm5hbC9wYXN0ZS11dGlscyAqL1xuICAgICAgICAgICAgICBcIi4vaW50ZXJuYWwvcGFzdGUtdXRpbHMuanNcIilcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5nZXRJbnRlcm5hbCA9IGdldEludGVybmFsO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2hlYWRlci9hY3Rpb24uanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2hlYWRlci9hY3Rpb24uanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGhlYWRlckFjdGlvbkpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMub2ZDZWxsID0gZXhwb3J0cy5vZiA9IGV4cG9ydHMuQ2hlY2tIZWFkZXJBY3Rpb24gPSBleHBvcnRzLlNvcnRIZWFkZXJBY3Rpb24gPSBleHBvcnRzLkJhc2VBY3Rpb24gPSBleHBvcnRzLkFDVElPTlMgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgQmFzZUFjdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9hY3Rpb24vQmFzZUFjdGlvbiAqL1xuICAgICAgICAgIFwiLi9oZWFkZXIvYWN0aW9uL0Jhc2VBY3Rpb24uanNcIik7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCYXNlQWN0aW9uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIEJhc2VBY3Rpb25fMS5CYXNlQWN0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIENoZWNrSGVhZGVyQWN0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL2FjdGlvbi9DaGVja0hlYWRlckFjdGlvbiAqL1xuICAgICAgICAgIFwiLi9oZWFkZXIvYWN0aW9uL0NoZWNrSGVhZGVyQWN0aW9uLmpzXCIpO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2hlY2tIZWFkZXJBY3Rpb25cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICByZXR1cm4gQ2hlY2tIZWFkZXJBY3Rpb25fMS5DaGVja0hlYWRlckFjdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBTb3J0SGVhZGVyQWN0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL2FjdGlvbi9Tb3J0SGVhZGVyQWN0aW9uICovXG4gICAgICAgICAgXCIuL2hlYWRlci9hY3Rpb24vU29ydEhlYWRlckFjdGlvbi5qc1wiKTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNvcnRIZWFkZXJBY3Rpb25cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICByZXR1cm4gU29ydEhlYWRlckFjdGlvbl8xLlNvcnRIZWFkZXJBY3Rpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgSW1tdXRhYmxlU29ydEhlYWRlckFjdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1NvcnRIZWFkZXJBY3Rpb25fMSRTKSB7XG4gICAgICAgICAgICBfaW5oZXJpdHMoSW1tdXRhYmxlU29ydEhlYWRlckFjdGlvbiwgX1NvcnRIZWFkZXJBY3Rpb25fMSRTKTtcblxuICAgICAgICAgICAgdmFyIF9zdXBlcjU5ID0gX2NyZWF0ZVN1cGVyKEltbXV0YWJsZVNvcnRIZWFkZXJBY3Rpb24pO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBJbW11dGFibGVTb3J0SGVhZGVyQWN0aW9uKCkge1xuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW1tdXRhYmxlU29ydEhlYWRlckFjdGlvbik7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlcjU5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhJbW11dGFibGVTb3J0SGVhZGVyQWN0aW9uLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiZGlzYWJsZWRcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc2FibGVkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBJbW11dGFibGVTb3J0SGVhZGVyQWN0aW9uO1xuICAgICAgICAgIH0oU29ydEhlYWRlckFjdGlvbl8xLlNvcnRIZWFkZXJBY3Rpb24pO1xuXG4gICAgICAgICAgdmFyIEltbXV0YWJsZUNoZWNrSGVhZGVyQWN0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ2hlY2tIZWFkZXJBY3Rpb25fMSQpIHtcbiAgICAgICAgICAgIF9pbmhlcml0cyhJbW11dGFibGVDaGVja0hlYWRlckFjdGlvbiwgX0NoZWNrSGVhZGVyQWN0aW9uXzEkKTtcblxuICAgICAgICAgICAgdmFyIF9zdXBlcjYwID0gX2NyZWF0ZVN1cGVyKEltbXV0YWJsZUNoZWNrSGVhZGVyQWN0aW9uKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gSW1tdXRhYmxlQ2hlY2tIZWFkZXJBY3Rpb24oKSB7XG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbW11dGFibGVDaGVja0hlYWRlckFjdGlvbik7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlcjYwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhJbW11dGFibGVDaGVja0hlYWRlckFjdGlvbiwgW3tcbiAgICAgICAgICAgICAga2V5OiBcImRpc2FibGVkXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaXNhYmxlZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gSW1tdXRhYmxlQ2hlY2tIZWFkZXJBY3Rpb247XG4gICAgICAgICAgfShDaGVja0hlYWRlckFjdGlvbl8xLkNoZWNrSGVhZGVyQWN0aW9uKTtcblxuICAgICAgICAgIGV4cG9ydHMuQUNUSU9OUyA9IHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBTT1JUOiBuZXcgSW1tdXRhYmxlU29ydEhlYWRlckFjdGlvbigpLFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIENIRUNLOiBuZXcgSW1tdXRhYmxlQ2hlY2tIZWFkZXJBY3Rpb24oKVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBmdW5jdGlvbiBvZihoZWFkZXJBY3Rpb24pIHtcbiAgICAgICAgICAgIGlmICghaGVhZGVyQWN0aW9uKSB7XG4gICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBoZWFkZXJBY3Rpb24gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgdmFyIGtleSA9IGhlYWRlckFjdGlvbi50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5BQ1RJT05TW2tleV0gfHwgb2YobnVsbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gaGVhZGVyQWN0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMub2YgPSBvZjtcblxuICAgICAgICAgIGZ1bmN0aW9uIG9mQ2VsbChoZWFkZXJDZWxsKSB7XG4gICAgICAgICAgICBpZiAoaGVhZGVyQ2VsbC5zb3J0KSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgaGVhZGVyQ2VsbC5zb3J0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgc29ydE1ldGhvZCA9IGhlYWRlckNlbGwuc29ydDsgLy8gMC45LjAgQmFja3dhcmQgY29tcGF0aWJpbGl0eVxuXG4gICAgICAgICAgICAgICAgdmFyIHNvcnQgPSBmdW5jdGlvbiBzb3J0KF9yZWY2OSkge1xuICAgICAgICAgICAgICAgICAgdmFyIG9yZGVyID0gX3JlZjY5Lm9yZGVyLFxuICAgICAgICAgICAgICAgICAgICAgIGNvbCA9IF9yZWY2OS5jb2wsXG4gICAgICAgICAgICAgICAgICAgICAgZ3JpZCA9IF9yZWY2OS5ncmlkO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHNvcnRNZXRob2QuY2FsbChoZWFkZXJDZWxsLCBvcmRlciwgY29sLCBncmlkKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbW11dGFibGVTb3J0SGVhZGVyQWN0aW9uKHtcbiAgICAgICAgICAgICAgICAgIHNvcnQ6IHNvcnRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgaGVhZGVyQ2VsbC5zb3J0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbW11dGFibGVTb3J0SGVhZGVyQWN0aW9uKHtcbiAgICAgICAgICAgICAgICAgIHNvcnQ6IGhlYWRlckNlbGwuc29ydFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuQUNUSU9OUy5TT1JUO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb2YoaGVhZGVyQ2VsbC5oZWFkZXJBY3Rpb24pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMub2ZDZWxsID0gb2ZDZWxsO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2hlYWRlci9hY3Rpb24vQmFzZUFjdGlvbi5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9oZWFkZXIvYWN0aW9uL0Jhc2VBY3Rpb24uanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gaGVhZGVyQWN0aW9uQmFzZUFjdGlvbkpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuQmFzZUFjdGlvbiA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBCYXNlQWN0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIEJhc2VBY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHZhciBvcHRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCYXNlQWN0aW9uKTtcblxuICAgICAgICAgICAgICB0aGlzLl9kaXNhYmxlZCA9ICEhb3B0aW9uLmRpc2FibGVkIHx8IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoQmFzZUFjdGlvbiwgW3tcbiAgICAgICAgICAgICAga2V5OiBcImRpc2FibGVkXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaXNhYmxlZDtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXNhYmxlZCA9IGRpc2FibGVkO1xuICAgICAgICAgICAgICAgIHRoaXMub25DaGFuZ2VEaXNhYmxlZEludGVybmFsKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNsb25lXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJhc2VBY3Rpb24odGhpcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImJpbmRHcmlkRXZlbnRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRHcmlkRXZlbnQoX2dyaWQsIF9jZWxsSWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIm9uQ2hhbmdlRGlzYWJsZWRJbnRlcm5hbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25DaGFuZ2VEaXNhYmxlZEludGVybmFsKCkgey8vIGltcGxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gQmFzZUFjdGlvbjtcbiAgICAgICAgICB9KCk7XG5cbiAgICAgICAgICBleHBvcnRzLkJhc2VBY3Rpb24gPSBCYXNlQWN0aW9uO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2hlYWRlci9hY3Rpb24vQ2hlY2tIZWFkZXJBY3Rpb24uanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2hlYWRlci9hY3Rpb24vQ2hlY2tIZWFkZXJBY3Rpb24uanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGhlYWRlckFjdGlvbkNoZWNrSGVhZGVyQWN0aW9uSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5DaGVja0hlYWRlckFjdGlvbiA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBhY3Rpb25CaW5kXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL2FjdGlvbkJpbmQgKi9cbiAgICAgICAgICBcIi4vaGVhZGVyL2FjdGlvbi9hY3Rpb25CaW5kLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIEJhc2VBY3Rpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vQmFzZUFjdGlvbiAqL1xuICAgICAgICAgIFwiLi9oZWFkZXIvYWN0aW9uL0Jhc2VBY3Rpb24uanNcIik7XG5cbiAgICAgICAgICB2YXIgYW5pbWF0ZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vaW50ZXJuYWwvYW5pbWF0ZSAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC9hbmltYXRlLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIHN5bWJvbE1hbmFnZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uL2ludGVybmFsL3N5bWJvbE1hbmFnZXIgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvc3ltYm9sTWFuYWdlci5qc1wiKTtcblxuICAgICAgICAgIHZhciB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vaW50ZXJuYWwvdXRpbHMgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvdXRpbHMuanNcIik7XG5cbiAgICAgICAgICB2YXIgQ0hFQ0tfSEVBREVSX1NUQVRFX0lEID0gKDAsIHN5bWJvbE1hbmFnZXJfMS5nZXRDaGVja0hlYWRlclN0YXRlSWQpKCk7XG5cbiAgICAgICAgICBmdW5jdGlvbiBnZXRTdGF0ZShncmlkKSB7XG4gICAgICAgICAgICB2YXIgc3RhdGUgPSBncmlkW0NIRUNLX0hFQURFUl9TVEFURV9JRF07XG5cbiAgICAgICAgICAgIGlmICghc3RhdGUpIHtcbiAgICAgICAgICAgICAgc3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgZWxhcHNlZDoge30sXG4gICAgICAgICAgICAgICAgYmxvY2s6IHt9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHV0aWxzXzEub2JqLnNldFJlYWRvbmx5KGdyaWQsIENIRUNLX0hFQURFUl9TVEFURV9JRCwgc3RhdGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIENoZWNrSGVhZGVyQWN0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZUFjdGlvbl8xJEJhc2VBY3QzKSB7XG4gICAgICAgICAgICBfaW5oZXJpdHMoQ2hlY2tIZWFkZXJBY3Rpb24sIF9CYXNlQWN0aW9uXzEkQmFzZUFjdDMpO1xuXG4gICAgICAgICAgICB2YXIgX3N1cGVyNjEgPSBfY3JlYXRlU3VwZXIoQ2hlY2tIZWFkZXJBY3Rpb24pO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBDaGVja0hlYWRlckFjdGlvbigpIHtcbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENoZWNrSGVhZGVyQWN0aW9uKTtcblxuICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyNjEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKENoZWNrSGVhZGVyQWN0aW9uLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiY2xvbmVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ2hlY2tIZWFkZXJBY3Rpb24odGhpcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImJpbmRHcmlkRXZlbnRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRHcmlkRXZlbnQoZ3JpZCwgY2VsbElkKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzOTEgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgdmFyIHN0YXRlID0gZ2V0U3RhdGUoZ3JpZCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgYWN0aW9uID0gZnVuY3Rpb24gYWN0aW9uKF9yZWY3MCkge1xuICAgICAgICAgICAgICAgICAgdmFyIGNvbCA9IF9yZWY3MC5jb2wsXG4gICAgICAgICAgICAgICAgICAgICAgcm93ID0gX3JlZjcwLnJvdztcbiAgICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IGdyaWQuZ2V0Q2VsbFJhbmdlKGNvbCwgcm93KTtcbiAgICAgICAgICAgICAgICAgIHZhciBjZWxsS2V5ID0gXCJcIi5jb25jYXQocmFuZ2Uuc3RhcnQuY29sLCBcIjpcIikuY29uY2F0KHJhbmdlLnN0YXJ0LnJvdyk7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChfdGhpczkxLmRpc2FibGVkIHx8IHN0YXRlLmJsb2NrW2NlbGxLZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgdmFyIGNoZWNrZWQgPSBncmlkLmdldEhlYWRlclZhbHVlKHJhbmdlLnN0YXJ0LmNvbCwgcmFuZ2Uuc3RhcnQucm93KTtcbiAgICAgICAgICAgICAgICAgIGdyaWQuc2V0SGVhZGVyVmFsdWUocmFuZ2Uuc3RhcnQuY29sLCByYW5nZS5zdGFydC5yb3csICFjaGVja2VkKTtcblxuICAgICAgICAgICAgICAgICAgdmFyIG9uQ2hhbmdlID0gZnVuY3Rpb24gb25DaGFuZ2UoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrYm94IGFuaW1hdGlvblxuICAgICAgICAgICAgICAgICAgICAoMCwgYW5pbWF0ZV8xLmFuaW1hdGUpKDIwMCwgZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHBvaW50ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgc3RhdGUuZWxhcHNlZFtjZWxsS2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuZWxhcHNlZFtjZWxsS2V5XSA9IHBvaW50O1xuICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgIGdyaWQuaW52YWxpZGF0ZUNlbGxSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgb25DaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoKDAsIGFjdGlvbkJpbmRfMS5iaW5kQ2VsbENsaWNrQWN0aW9uKShncmlkLCBjZWxsSWQsIHtcbiAgICAgICAgICAgICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICAgICAgICAgICAgbW91c2VPdmVyOiBmdW5jdGlvbiBtb3VzZU92ZXIoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXM5MS5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLm1vdXNlQWN0aXZlQ2VsbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICBjb2w6IGUuY29sLFxuICAgICAgICAgICAgICAgICAgICAgIHJvdzogZS5yb3dcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gZ3JpZC5nZXRDZWxsUmFuZ2UoZS5jb2wsIGUucm93KTtcbiAgICAgICAgICAgICAgICAgICAgZ3JpZC5pbnZhbGlkYXRlQ2VsbFJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgbW91c2VPdXQ6IGZ1bmN0aW9uIG1vdXNlT3V0KGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHN0YXRlLm1vdXNlQWN0aXZlQ2VsbDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gZ3JpZC5nZXRDZWxsUmFuZ2UoZS5jb2wsIGUucm93KTtcbiAgICAgICAgICAgICAgICAgICAgZ3JpZC5pbnZhbGlkYXRlQ2VsbFJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSksIF90b0NvbnN1bWFibGVBcnJheSgoMCwgYWN0aW9uQmluZF8xLmJpbmRDZWxsS2V5QWN0aW9uKShncmlkLCBjZWxsSWQsIHtcbiAgICAgICAgICAgICAgICAgIGFjdGlvbjogYWN0aW9uXG4gICAgICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gQ2hlY2tIZWFkZXJBY3Rpb247XG4gICAgICAgICAgfShCYXNlQWN0aW9uXzEuQmFzZUFjdGlvbik7XG5cbiAgICAgICAgICBleHBvcnRzLkNoZWNrSGVhZGVyQWN0aW9uID0gQ2hlY2tIZWFkZXJBY3Rpb247XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vaGVhZGVyL2FjdGlvbi9Tb3J0SGVhZGVyQWN0aW9uLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2hlYWRlci9hY3Rpb24vU29ydEhlYWRlckFjdGlvbi5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBoZWFkZXJBY3Rpb25Tb3J0SGVhZGVyQWN0aW9uSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5Tb3J0SGVhZGVyQWN0aW9uID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIEJhc2VBY3Rpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vQmFzZUFjdGlvbiAqL1xuICAgICAgICAgIFwiLi9oZWFkZXIvYWN0aW9uL0Jhc2VBY3Rpb24uanNcIik7XG5cbiAgICAgICAgICB2YXIgYWN0aW9uQmluZF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9hY3Rpb25CaW5kICovXG4gICAgICAgICAgXCIuL2hlYWRlci9hY3Rpb24vYWN0aW9uQmluZC5qc1wiKTtcblxuICAgICAgICAgIHZhciBTb3J0SGVhZGVyQWN0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZUFjdGlvbl8xJEJhc2VBY3Q0KSB7XG4gICAgICAgICAgICBfaW5oZXJpdHMoU29ydEhlYWRlckFjdGlvbiwgX0Jhc2VBY3Rpb25fMSRCYXNlQWN0NCk7XG5cbiAgICAgICAgICAgIHZhciBfc3VwZXI2MiA9IF9jcmVhdGVTdXBlcihTb3J0SGVhZGVyQWN0aW9uKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gU29ydEhlYWRlckFjdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIF90aGlzOTI7XG5cbiAgICAgICAgICAgICAgdmFyIG9wdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNvcnRIZWFkZXJBY3Rpb24pO1xuXG4gICAgICAgICAgICAgIHZhciBfYTtcblxuICAgICAgICAgICAgICBfdGhpczkyID0gX3N1cGVyNjIuY2FsbCh0aGlzLCBvcHRpb24pO1xuICAgICAgICAgICAgICBfdGhpczkyLl9zb3J0ID0gKF9hID0gb3B0aW9uLnNvcnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRydWU7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczkyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoU29ydEhlYWRlckFjdGlvbiwgW3tcbiAgICAgICAgICAgICAga2V5OiBcInNvcnRcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NvcnQ7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHNvcnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zb3J0ID0gc29ydDtcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ2hhbmdlRGlzYWJsZWRJbnRlcm5hbCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjbG9uZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTb3J0SGVhZGVyQWN0aW9uKHRoaXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJfZXhlY3V0ZVNvcnRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9leGVjdXRlU29ydChuZXdTdGF0ZSwgZ3JpZCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5fc29ydCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9zb3J0KHtcbiAgICAgICAgICAgICAgICAgICAgb3JkZXI6IG5ld1N0YXRlLm9yZGVyIHx8IFwiYXNjXCIsXG4gICAgICAgICAgICAgICAgICAgIGNvbDogbmV3U3RhdGUuY29sLFxuICAgICAgICAgICAgICAgICAgICByb3c6IG5ld1N0YXRlLnJvdyxcbiAgICAgICAgICAgICAgICAgICAgZ3JpZDogZ3JpZFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5fc29ydCA9PT0gXCJzdHJpbmdcIiAmJiAoIC8vIHYxLjYuMyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAgICAgICAgICAgICAgdGhpcy5fc29ydCAhPT0gXCJ0cnVlXCIgfHwgaGFzVHJ1ZUZpZWxkKGdyaWQpKSkge1xuICAgICAgICAgICAgICAgICAgdmFyIGZpZWxkID0gdGhpcy5fc29ydDtcbiAgICAgICAgICAgICAgICAgIGdyaWQuZGF0YVNvdXJjZS5zb3J0KGZpZWxkLCBuZXdTdGF0ZS5vcmRlciB8fCBcImFzY1wiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFyIGZpZWxkUm93ID0gTWF0aC5taW4oZ3JpZC5yZWNvcmRSb3dDb3VudCAtIDEsIG5ld1N0YXRlLnJvdykgKyBncmlkLmZyb3plblJvd0NvdW50O1xuXG4gICAgICAgICAgICAgICAgICB2YXIgX2ZpZWxkMyA9IGdyaWQuZ2V0RmllbGQobmV3U3RhdGUuY29sLCBmaWVsZFJvdyk7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChfZmllbGQzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBncmlkLmRhdGFTb3VyY2Uuc29ydChfZmllbGQzLCBuZXdTdGF0ZS5vcmRlciB8fCBcImFzY1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImJpbmRHcmlkRXZlbnRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRHcmlkRXZlbnQoZ3JpZCwgY2VsbElkKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzOTMgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gaXNUYXJnZXQoY29sLCByb3cpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBncmlkLmdldExheW91dENlbGxJZChjb2wsIHJvdykgPT09IGNlbGxJZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgYWN0aW9uID0gZnVuY3Rpb24gYWN0aW9uKGNlbGwpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChfdGhpczkzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgdmFyIHN0YXRlID0gZ3JpZC5zb3J0U3RhdGU7XG4gICAgICAgICAgICAgICAgICB2YXIgbmV3U3RhdGU7XG4gICAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBncmlkLmdldENlbGxSYW5nZShjZWxsLmNvbCwgY2VsbC5yb3cpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoaXNUYXJnZXQoc3RhdGUuY29sLCBjZWxsLnJvdykpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3U3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29sOiByYW5nZS5zdGFydC5jb2wsXG4gICAgICAgICAgICAgICAgICAgICAgcm93OiByYW5nZS5zdGFydC5yb3csXG4gICAgICAgICAgICAgICAgICAgICAgb3JkZXI6IHN0YXRlLm9yZGVyID09PSBcImFzY1wiID8gXCJkZXNjXCIgOiBcImFzY1wiXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICBjb2w6IHJhbmdlLnN0YXJ0LmNvbCxcbiAgICAgICAgICAgICAgICAgICAgICByb3c6IHJhbmdlLnN0YXJ0LnJvdyxcbiAgICAgICAgICAgICAgICAgICAgICBvcmRlcjogXCJhc2NcIlxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBncmlkLnNvcnRTdGF0ZSA9IG5ld1N0YXRlO1xuXG4gICAgICAgICAgICAgICAgICBfdGhpczkzLl9leGVjdXRlU29ydChuZXdTdGF0ZSwgZ3JpZCk7XG5cbiAgICAgICAgICAgICAgICAgIGdyaWQuaW52YWxpZGF0ZUdyaWRSZWN0KDAsIDAsIGdyaWQuY29sQ291bnQgLSAxLCBncmlkLnJvd0NvdW50IC0gMSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBfdG9Db25zdW1hYmxlQXJyYXkoKDAsIGFjdGlvbkJpbmRfMS5iaW5kQ2VsbENsaWNrQWN0aW9uKShncmlkLCBjZWxsSWQsIHtcbiAgICAgICAgICAgICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICAgICAgICAgICAgbW91c2VPdmVyOiBmdW5jdGlvbiBtb3VzZU92ZXIoX2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzOTMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIFNvcnRIZWFkZXJBY3Rpb247XG4gICAgICAgICAgfShCYXNlQWN0aW9uXzEuQmFzZUFjdGlvbik7XG5cbiAgICAgICAgICBleHBvcnRzLlNvcnRIZWFkZXJBY3Rpb24gPSBTb3J0SGVhZGVyQWN0aW9uO1xuXG4gICAgICAgICAgZnVuY3Rpb24gaGFzVHJ1ZUZpZWxkKGdyaWQpIHtcbiAgICAgICAgICAgIGlmIChncmlkLmRhdGFTb3VyY2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICB2YXIgcmVjb3JkID0gZ3JpZC5kYXRhU291cmNlLmdldCgwKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlY29yZCAhPSBudWxsICYmIFwidHJ1ZVwiIGluIHJlY29yZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKioqL1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2hlYWRlci9hY3Rpb24vYWN0aW9uQmluZC5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9oZWFkZXIvYWN0aW9uL2FjdGlvbkJpbmQuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gaGVhZGVyQWN0aW9uQWN0aW9uQmluZEpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuYmluZENlbGxLZXlBY3Rpb24gPSBleHBvcnRzLmJpbmRDZWxsQ2xpY2tBY3Rpb24gPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgREdfRVZFTlRfVFlQRV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vY29yZS9ER19FVkVOVF9UWVBFICovXG4gICAgICAgICAgXCIuL2NvcmUvREdfRVZFTlRfVFlQRS5qc1wiKTtcblxuICAgICAgICAgIHZhciB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vaW50ZXJuYWwvdXRpbHMgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvdXRpbHMuanNcIik7XG5cbiAgICAgICAgICB2YXIgS0VZX0VOVEVSID0gMTM7XG4gICAgICAgICAgdmFyIEtFWV9TUEFDRSA9IDMyO1xuXG4gICAgICAgICAgZnVuY3Rpb24gYmluZENlbGxDbGlja0FjdGlvbihncmlkLCBjZWxsSWQsIF9yZWY3MSkge1xuICAgICAgICAgICAgdmFyIGFjdGlvbiA9IF9yZWY3MS5hY3Rpb24sXG4gICAgICAgICAgICAgICAgbW91c2VPdmVyID0gX3JlZjcxLm1vdXNlT3ZlcixcbiAgICAgICAgICAgICAgICBtb3VzZU91dCA9IF9yZWY3MS5tb3VzZU91dDtcblxuICAgICAgICAgICAgZnVuY3Rpb24gaXNUYXJnZXQoY29sLCByb3cpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdyaWQuZ2V0TGF5b3V0Q2VsbElkKGNvbCwgcm93KSA9PT0gY2VsbElkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaW5Nb3VzZTtcbiAgICAgICAgICAgIHJldHVybiBbLy8gY2xpY2tcbiAgICAgICAgICAgIGdyaWQubGlzdGVuKERHX0VWRU5UX1RZUEVfMS5ER19FVkVOVF9UWVBFLkNMSUNLX0NFTEwsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIGlmICghaXNUYXJnZXQoZS5jb2wsIGUucm93KSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGFjdGlvbih7XG4gICAgICAgICAgICAgICAgY29sOiBlLmNvbCxcbiAgICAgICAgICAgICAgICByb3c6IGUucm93XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSksIC8vIG1vdXNlIG1vdmVcbiAgICAgICAgICAgIGdyaWQubGlzdGVuKERHX0VWRU5UX1RZUEVfMS5ER19FVkVOVF9UWVBFLk1PVVNFT1ZFUl9DRUxMLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICBpZiAoIWlzVGFyZ2V0KGUuY29sLCBlLnJvdykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAobW91c2VPdmVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFtb3VzZU92ZXIoe1xuICAgICAgICAgICAgICAgICAgY29sOiBlLmNvbCxcbiAgICAgICAgICAgICAgICAgIHJvdzogZS5yb3dcbiAgICAgICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGdyaWQuZ2V0RWxlbWVudCgpLnN0eWxlLmN1cnNvciA9IFwicG9pbnRlclwiO1xuICAgICAgICAgICAgICBpbk1vdXNlID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pLCAvL+aoquOBi+OCiU1PVVNFRU5URVLjgZfjgZ/loLTlkIjjgIEnY29sLXJlc2l6ZSfjga7lh6bnkIbjgajnq7blkIjjgZnjgovjga7jgadtb3Zl44KS55uj6KaW44GX44Gm5Yem55CG44GZ44KLXG4gICAgICAgICAgICBncmlkLmxpc3RlbihER19FVkVOVF9UWVBFXzEuREdfRVZFTlRfVFlQRS5NT1VTRU1PVkVfQ0VMTCwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc1RhcmdldChlLmNvbCwgZS5yb3cpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGluTW91c2UgJiYgIWdyaWQuZ2V0RWxlbWVudCgpLnN0eWxlLmN1cnNvcikge1xuICAgICAgICAgICAgICAgIGdyaWQuZ2V0RWxlbWVudCgpLnN0eWxlLmN1cnNvciA9IFwicG9pbnRlclwiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSwgZ3JpZC5saXN0ZW4oREdfRVZFTlRfVFlQRV8xLkRHX0VWRU5UX1RZUEUuTU9VU0VPVVRfQ0VMTCwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc1RhcmdldChlLmNvbCwgZS5yb3cpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKG1vdXNlT3V0KSB7XG4gICAgICAgICAgICAgICAgbW91c2VPdXQoe1xuICAgICAgICAgICAgICAgICAgY29sOiBlLmNvbCxcbiAgICAgICAgICAgICAgICAgIHJvdzogZS5yb3dcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGdyaWQuZ2V0RWxlbWVudCgpLnN0eWxlLmN1cnNvciA9IFwiXCI7XG4gICAgICAgICAgICAgIGluTW91c2UgPSBmYWxzZTtcbiAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRzLmJpbmRDZWxsQ2xpY2tBY3Rpb24gPSBiaW5kQ2VsbENsaWNrQWN0aW9uO1xuXG4gICAgICAgICAgZnVuY3Rpb24gYmluZENlbGxLZXlBY3Rpb24oZ3JpZCwgY2VsbElkLCBfcmVmNzIpIHtcbiAgICAgICAgICAgIHZhciBhY3Rpb24gPSBfcmVmNzIuYWN0aW9uLFxuICAgICAgICAgICAgICAgIF9yZWY3MiRhY2NlcHRLZXlzID0gX3JlZjcyLmFjY2VwdEtleXMsXG4gICAgICAgICAgICAgICAgYWNjZXB0S2V5cyA9IF9yZWY3MiRhY2NlcHRLZXlzID09PSB2b2lkIDAgPyBbXSA6IF9yZWY3MiRhY2NlcHRLZXlzO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBpc1RhcmdldChjb2wsIHJvdykge1xuICAgICAgICAgICAgICByZXR1cm4gZ3JpZC5nZXRMYXlvdXRDZWxsSWQoY29sLCByb3cpID09PSBjZWxsSWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFjY2VwdEtleXMgPSBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGFjY2VwdEtleXMpLCBbS0VZX0VOVEVSLCBLRVlfU1BBQ0VdKTtcbiAgICAgICAgICAgIHJldHVybiBbLy8gZW50ZXIga2V5IGRvd25cbiAgICAgICAgICAgIGdyaWQubGlzdGVuKERHX0VWRU5UX1RZUEVfMS5ER19FVkVOVF9UWVBFLktFWURPV04sIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIHZhciBfYTtcblxuICAgICAgICAgICAgICBpZiAoYWNjZXB0S2V5cy5pbmRleE9mKGUua2V5Q29kZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCgoX2EgPSBncmlkLmtleWJvYXJkT3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1vdmVDZWxsT25FbnRlcikgJiYgZS5rZXlDb2RlID09PSBLRVlfRU5URVIpIHtcbiAgICAgICAgICAgICAgICAvLyBXaGVuIG1vdmluZyB3aXRoIHRoZSBlbnRlciBrZXksIG5vIGFjdGlvbiBpcyB0YWtlbiB3aXRoIHRoZSBlbnRlciBrZXkuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIHNlbCA9IGdyaWQuc2VsZWN0aW9uLnNlbGVjdDtcblxuICAgICAgICAgICAgICBpZiAoIWlzVGFyZ2V0KHNlbC5jb2wsIHNlbC5yb3cpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYWN0aW9uKHtcbiAgICAgICAgICAgICAgICBjb2w6IHNlbC5jb2wsXG4gICAgICAgICAgICAgICAgcm93OiBzZWwucm93XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB1dGlsc18xLmV2ZW50LmNhbmNlbChlLmV2ZW50KTtcbiAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRzLmJpbmRDZWxsS2V5QWN0aW9uID0gYmluZENlbGxLZXlBY3Rpb247XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vaGVhZGVyL3N0eWxlLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2hlYWRlci9zdHlsZS5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBoZWFkZXJTdHlsZUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMub2YgPSBleHBvcnRzLk11bHRpbGluZVRleHRIZWFkZXJTdHlsZSA9IGV4cG9ydHMuQ2hlY2tIZWFkZXJTdHlsZSA9IGV4cG9ydHMuU29ydEhlYWRlclN0eWxlID0gZXhwb3J0cy5TdHlsZSA9IGV4cG9ydHMuQmFzZVN0eWxlID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIEJhc2VTdHlsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9zdHlsZS9CYXNlU3R5bGUgKi9cbiAgICAgICAgICBcIi4vaGVhZGVyL3N0eWxlL0Jhc2VTdHlsZS5qc1wiKTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJhc2VTdHlsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBCYXNlU3R5bGVfMS5CYXNlU3R5bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgQ2hlY2tIZWFkZXJTdHlsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9zdHlsZS9DaGVja0hlYWRlclN0eWxlICovXG4gICAgICAgICAgXCIuL2hlYWRlci9zdHlsZS9DaGVja0hlYWRlclN0eWxlLmpzXCIpO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2hlY2tIZWFkZXJTdHlsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBDaGVja0hlYWRlclN0eWxlXzEuQ2hlY2tIZWFkZXJTdHlsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBNdWx0aWxpbmVUZXh0SGVhZGVyU3R5bGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vc3R5bGUvTXVsdGlsaW5lVGV4dEhlYWRlclN0eWxlICovXG4gICAgICAgICAgXCIuL2hlYWRlci9zdHlsZS9NdWx0aWxpbmVUZXh0SGVhZGVyU3R5bGUuanNcIik7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNdWx0aWxpbmVUZXh0SGVhZGVyU3R5bGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICByZXR1cm4gTXVsdGlsaW5lVGV4dEhlYWRlclN0eWxlXzEuTXVsdGlsaW5lVGV4dEhlYWRlclN0eWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIFNvcnRIZWFkZXJTdHlsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9zdHlsZS9Tb3J0SGVhZGVyU3R5bGUgKi9cbiAgICAgICAgICBcIi4vaGVhZGVyL3N0eWxlL1NvcnRIZWFkZXJTdHlsZS5qc1wiKTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNvcnRIZWFkZXJTdHlsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBTb3J0SGVhZGVyU3R5bGVfMS5Tb3J0SGVhZGVyU3R5bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgU3R5bGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vc3R5bGUvU3R5bGUgKi9cbiAgICAgICAgICBcIi4vaGVhZGVyL3N0eWxlL1N0eWxlLmpzXCIpO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU3R5bGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICByZXR1cm4gU3R5bGVfMS5TdHlsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGZ1bmN0aW9uIG9mKGhlYWRlclN0eWxlLCBTdHlsZUNsYXNzKSB7XG4gICAgICAgICAgICBpZiAoaGVhZGVyU3R5bGUpIHtcbiAgICAgICAgICAgICAgaWYgKGhlYWRlclN0eWxlIGluc3RhbmNlb2YgU3R5bGVfMS5TdHlsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoZWFkZXJTdHlsZTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaGVhZGVyU3R5bGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBvZihoZWFkZXJTdHlsZSgpLCBTdHlsZUNsYXNzKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBuZXcgU3R5bGVDbGFzcyhoZWFkZXJTdHlsZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gU3R5bGVDbGFzcy5ERUZBVUxUO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMub2YgPSBvZjtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9oZWFkZXIvc3R5bGUvQmFzZVN0eWxlLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9oZWFkZXIvc3R5bGUvQmFzZVN0eWxlLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBoZWFkZXJTdHlsZUJhc2VTdHlsZUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuQmFzZVN0eWxlID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIEV2ZW50VGFyZ2V0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi9jb3JlL0V2ZW50VGFyZ2V0ICovXG4gICAgICAgICAgXCIuL2NvcmUvRXZlbnRUYXJnZXQuanNcIik7XG5cbiAgICAgICAgICB2YXIgRVZFTlRfVFlQRSA9IHtcbiAgICAgICAgICAgIENIQU5HRV9TVFlMRTogXCJjaGFuZ2Vfc3R5bGVcIlxuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIGRlZmF1bHRTdHlsZTtcblxuICAgICAgICAgIHZhciBCYXNlU3R5bGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FdmVudFRhcmdldF8xJEV2ZW50VDYpIHtcbiAgICAgICAgICAgIF9pbmhlcml0cyhCYXNlU3R5bGUsIF9FdmVudFRhcmdldF8xJEV2ZW50VDYpO1xuXG4gICAgICAgICAgICB2YXIgX3N1cGVyNjMgPSBfY3JlYXRlU3VwZXIoQmFzZVN0eWxlKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gQmFzZVN0eWxlKCkge1xuICAgICAgICAgICAgICB2YXIgX3RoaXM5NDtcblxuICAgICAgICAgICAgICB2YXIgX3JlZjczID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgICAgICAgICAgIGJnQ29sb3IgPSBfcmVmNzMuYmdDb2xvcjtcblxuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmFzZVN0eWxlKTtcblxuICAgICAgICAgICAgICBfdGhpczk0ID0gX3N1cGVyNjMuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgX3RoaXM5NC5fYmdDb2xvciA9IGJnQ29sb3I7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczk0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoQmFzZVN0eWxlLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiYmdDb2xvclwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYmdDb2xvcjtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoYmdDb2xvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2JnQ29sb3IgPSBiZ0NvbG9yO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9DaGFuZ2VTdHlsZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJkb0NoYW5nZVN0eWxlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkb0NoYW5nZVN0eWxlKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZUxpc3RlbmVycyhFVkVOVF9UWVBFLkNIQU5HRV9TVFlMRSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNsb25lXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJhc2VTdHlsZSh0aGlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0sIFt7XG4gICAgICAgICAgICAgIGtleTogXCJFVkVOVF9UWVBFXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBFVkVOVF9UWVBFO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJERUZBVUxUXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0U3R5bGUgPyBkZWZhdWx0U3R5bGUgOiBkZWZhdWx0U3R5bGUgPSBuZXcgQmFzZVN0eWxlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIEJhc2VTdHlsZTtcbiAgICAgICAgICB9KEV2ZW50VGFyZ2V0XzEuRXZlbnRUYXJnZXQpO1xuXG4gICAgICAgICAgZXhwb3J0cy5CYXNlU3R5bGUgPSBCYXNlU3R5bGU7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vaGVhZGVyL3N0eWxlL0NoZWNrSGVhZGVyU3R5bGUuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9oZWFkZXIvc3R5bGUvQ2hlY2tIZWFkZXJTdHlsZS5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGhlYWRlclN0eWxlQ2hlY2tIZWFkZXJTdHlsZUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuQ2hlY2tIZWFkZXJTdHlsZSA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBTdGRUZXh0QmFzZVN0eWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL1N0ZFRleHRCYXNlU3R5bGUgKi9cbiAgICAgICAgICBcIi4vaGVhZGVyL3N0eWxlL1N0ZFRleHRCYXNlU3R5bGUuanNcIik7XG5cbiAgICAgICAgICB2YXIgdXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uL2ludGVybmFsL3V0aWxzICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL3V0aWxzLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIGRlZmF1bHRTdHlsZTtcblxuICAgICAgICAgIHZhciBDaGVja0hlYWRlclN0eWxlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfU3RkVGV4dEJhc2VTdHlsZV8xJFMpIHtcbiAgICAgICAgICAgIF9pbmhlcml0cyhDaGVja0hlYWRlclN0eWxlLCBfU3RkVGV4dEJhc2VTdHlsZV8xJFMpO1xuXG4gICAgICAgICAgICB2YXIgX3N1cGVyNjQgPSBfY3JlYXRlU3VwZXIoQ2hlY2tIZWFkZXJTdHlsZSk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIENoZWNrSGVhZGVyU3R5bGUoKSB7XG4gICAgICAgICAgICAgIHZhciBfdGhpczk1O1xuXG4gICAgICAgICAgICAgIHZhciBzdHlsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENoZWNrSGVhZGVyU3R5bGUpO1xuXG4gICAgICAgICAgICAgIF90aGlzOTUgPSBfc3VwZXI2NC5jYWxsKHRoaXMsICgwLCB1dGlsc18xLmRlZmF1bHRzKShzdHlsZSwge1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbjogXCJjZW50ZXJcIlxuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgIHZhciB1bmNoZWNrQmdDb2xvciA9IHN0eWxlLnVuY2hlY2tCZ0NvbG9yLFxuICAgICAgICAgICAgICAgICAgY2hlY2tCZ0NvbG9yID0gc3R5bGUuY2hlY2tCZ0NvbG9yLFxuICAgICAgICAgICAgICAgICAgYm9yZGVyQ29sb3IgPSBzdHlsZS5ib3JkZXJDb2xvcjtcbiAgICAgICAgICAgICAgX3RoaXM5NS5fdW5jaGVja0JnQ29sb3IgPSB1bmNoZWNrQmdDb2xvcjtcbiAgICAgICAgICAgICAgX3RoaXM5NS5fY2hlY2tCZ0NvbG9yID0gY2hlY2tCZ0NvbG9yO1xuICAgICAgICAgICAgICBfdGhpczk1Ll9ib3JkZXJDb2xvciA9IGJvcmRlckNvbG9yO1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXM5NTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKENoZWNrSGVhZGVyU3R5bGUsIFt7XG4gICAgICAgICAgICAgIGtleTogXCJ1bmNoZWNrQmdDb2xvclwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdW5jaGVja0JnQ29sb3I7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHVuY2hlY2tCZ0NvbG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdW5jaGVja0JnQ29sb3IgPSB1bmNoZWNrQmdDb2xvcjtcbiAgICAgICAgICAgICAgICB0aGlzLmRvQ2hhbmdlU3R5bGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY2hlY2tCZ0NvbG9yXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jaGVja0JnQ29sb3I7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGNoZWNrQmdDb2xvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrQmdDb2xvciA9IGNoZWNrQmdDb2xvcjtcbiAgICAgICAgICAgICAgICB0aGlzLmRvQ2hhbmdlU3R5bGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiYm9yZGVyQ29sb3JcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JvcmRlckNvbG9yO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChib3JkZXJDb2xvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2JvcmRlckNvbG9yID0gYm9yZGVyQ29sb3I7XG4gICAgICAgICAgICAgICAgdGhpcy5kb0NoYW5nZVN0eWxlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNsb25lXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENoZWNrSGVhZGVyU3R5bGUodGhpcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiREVGQVVMVFwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdFN0eWxlID8gZGVmYXVsdFN0eWxlIDogZGVmYXVsdFN0eWxlID0gbmV3IENoZWNrSGVhZGVyU3R5bGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gQ2hlY2tIZWFkZXJTdHlsZTtcbiAgICAgICAgICB9KFN0ZFRleHRCYXNlU3R5bGVfMS5TdGRUZXh0QmFzZVN0eWxlKTtcblxuICAgICAgICAgIGV4cG9ydHMuQ2hlY2tIZWFkZXJTdHlsZSA9IENoZWNrSGVhZGVyU3R5bGU7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vaGVhZGVyL3N0eWxlL011bHRpbGluZVRleHRIZWFkZXJTdHlsZS5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vaGVhZGVyL3N0eWxlL011bHRpbGluZVRleHRIZWFkZXJTdHlsZS5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gaGVhZGVyU3R5bGVNdWx0aWxpbmVUZXh0SGVhZGVyU3R5bGVKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLk11bHRpbGluZVRleHRIZWFkZXJTdHlsZSA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBTdGRNdWx0aWxpbmVUZXh0QmFzZVN0eWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL1N0ZE11bHRpbGluZVRleHRCYXNlU3R5bGUgKi9cbiAgICAgICAgICBcIi4vaGVhZGVyL3N0eWxlL1N0ZE11bHRpbGluZVRleHRCYXNlU3R5bGUuanNcIik7XG5cbiAgICAgICAgICB2YXIgZGVmYXVsdFN0eWxlO1xuXG4gICAgICAgICAgdmFyIE11bHRpbGluZVRleHRIZWFkZXJTdHlsZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1N0ZE11bHRpbGluZVRleHRCYXNlKSB7XG4gICAgICAgICAgICBfaW5oZXJpdHMoTXVsdGlsaW5lVGV4dEhlYWRlclN0eWxlLCBfU3RkTXVsdGlsaW5lVGV4dEJhc2UpO1xuXG4gICAgICAgICAgICB2YXIgX3N1cGVyNjUgPSBfY3JlYXRlU3VwZXIoTXVsdGlsaW5lVGV4dEhlYWRlclN0eWxlKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gTXVsdGlsaW5lVGV4dEhlYWRlclN0eWxlKCkge1xuICAgICAgICAgICAgICB2YXIgc3R5bGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNdWx0aWxpbmVUZXh0SGVhZGVyU3R5bGUpO1xuXG4gICAgICAgICAgICAgIHJldHVybiBfc3VwZXI2NS5jYWxsKHRoaXMsIHN0eWxlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKE11bHRpbGluZVRleHRIZWFkZXJTdHlsZSwgW3tcbiAgICAgICAgICAgICAga2V5OiBcImNsb25lXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE11bHRpbGluZVRleHRIZWFkZXJTdHlsZSh0aGlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0sIFt7XG4gICAgICAgICAgICAgIGtleTogXCJERUZBVUxUXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0U3R5bGUgPyBkZWZhdWx0U3R5bGUgOiBkZWZhdWx0U3R5bGUgPSBuZXcgTXVsdGlsaW5lVGV4dEhlYWRlclN0eWxlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIE11bHRpbGluZVRleHRIZWFkZXJTdHlsZTtcbiAgICAgICAgICB9KFN0ZE11bHRpbGluZVRleHRCYXNlU3R5bGVfMS5TdGRNdWx0aWxpbmVUZXh0QmFzZVN0eWxlKTtcblxuICAgICAgICAgIGV4cG9ydHMuTXVsdGlsaW5lVGV4dEhlYWRlclN0eWxlID0gTXVsdGlsaW5lVGV4dEhlYWRlclN0eWxlO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2hlYWRlci9zdHlsZS9Tb3J0SGVhZGVyU3R5bGUuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2hlYWRlci9zdHlsZS9Tb3J0SGVhZGVyU3R5bGUuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGhlYWRlclN0eWxlU29ydEhlYWRlclN0eWxlSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5Tb3J0SGVhZGVyU3R5bGUgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgU3RkTXVsdGlsaW5lVGV4dEJhc2VTdHlsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9TdGRNdWx0aWxpbmVUZXh0QmFzZVN0eWxlICovXG4gICAgICAgICAgXCIuL2hlYWRlci9zdHlsZS9TdGRNdWx0aWxpbmVUZXh0QmFzZVN0eWxlLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIGRlZmF1bHRTdHlsZTtcblxuICAgICAgICAgIHZhciBTb3J0SGVhZGVyU3R5bGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9TdGRNdWx0aWxpbmVUZXh0QmFzZTIpIHtcbiAgICAgICAgICAgIF9pbmhlcml0cyhTb3J0SGVhZGVyU3R5bGUsIF9TdGRNdWx0aWxpbmVUZXh0QmFzZTIpO1xuXG4gICAgICAgICAgICB2YXIgX3N1cGVyNjYgPSBfY3JlYXRlU3VwZXIoU29ydEhlYWRlclN0eWxlKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gU29ydEhlYWRlclN0eWxlKCkge1xuICAgICAgICAgICAgICB2YXIgX3RoaXM5NjtcblxuICAgICAgICAgICAgICB2YXIgc3R5bGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTb3J0SGVhZGVyU3R5bGUpO1xuXG4gICAgICAgICAgICAgIF90aGlzOTYgPSBfc3VwZXI2Ni5jYWxsKHRoaXMsIHN0eWxlKTtcbiAgICAgICAgICAgICAgX3RoaXM5Ni5fc29ydEFycm93Q29sb3IgPSBzdHlsZS5zb3J0QXJyb3dDb2xvcjtcbiAgICAgICAgICAgICAgX3RoaXM5Ni5fbXVsdGlsaW5lID0gc3R5bGUubXVsdGlsaW5lO1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXM5NjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKFNvcnRIZWFkZXJTdHlsZSwgW3tcbiAgICAgICAgICAgICAga2V5OiBcInNvcnRBcnJvd0NvbG9yXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zb3J0QXJyb3dDb2xvcjtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoc29ydEFycm93Q29sb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zb3J0QXJyb3dDb2xvciA9IHNvcnRBcnJvd0NvbG9yO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9DaGFuZ2VTdHlsZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJtdWx0aWxpbmVcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhdGhpcy5fbXVsdGlsaW5lO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChtdWx0aWxpbmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tdWx0aWxpbmUgPSBtdWx0aWxpbmU7XG4gICAgICAgICAgICAgICAgdGhpcy5kb0NoYW5nZVN0eWxlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNsb25lXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNvcnRIZWFkZXJTdHlsZSh0aGlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0sIFt7XG4gICAgICAgICAgICAgIGtleTogXCJERUZBVUxUXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0U3R5bGUgPyBkZWZhdWx0U3R5bGUgOiBkZWZhdWx0U3R5bGUgPSBuZXcgU29ydEhlYWRlclN0eWxlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIFNvcnRIZWFkZXJTdHlsZTtcbiAgICAgICAgICB9KFN0ZE11bHRpbGluZVRleHRCYXNlU3R5bGVfMS5TdGRNdWx0aWxpbmVUZXh0QmFzZVN0eWxlKTtcblxuICAgICAgICAgIGV4cG9ydHMuU29ydEhlYWRlclN0eWxlID0gU29ydEhlYWRlclN0eWxlO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2hlYWRlci9zdHlsZS9TdGRCYXNlU3R5bGUuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2hlYWRlci9zdHlsZS9TdGRCYXNlU3R5bGUuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGhlYWRlclN0eWxlU3RkQmFzZVN0eWxlSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5TdGRCYXNlU3R5bGUgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgQmFzZVN0eWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL0Jhc2VTdHlsZSAqL1xuICAgICAgICAgIFwiLi9oZWFkZXIvc3R5bGUvQmFzZVN0eWxlLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIGRlZmF1bHRTdHlsZTtcblxuICAgICAgICAgIHZhciBTdGRCYXNlU3R5bGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXNlU3R5bGVfMSRCYXNlU3R5bDMpIHtcbiAgICAgICAgICAgIF9pbmhlcml0cyhTdGRCYXNlU3R5bGUsIF9CYXNlU3R5bGVfMSRCYXNlU3R5bDMpO1xuXG4gICAgICAgICAgICB2YXIgX3N1cGVyNjcgPSBfY3JlYXRlU3VwZXIoU3RkQmFzZVN0eWxlKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gU3RkQmFzZVN0eWxlKCkge1xuICAgICAgICAgICAgICB2YXIgX3RoaXM5NztcblxuICAgICAgICAgICAgICB2YXIgc3R5bGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdGRCYXNlU3R5bGUpO1xuXG4gICAgICAgICAgICAgIF90aGlzOTcgPSBfc3VwZXI2Ny5jYWxsKHRoaXMsIHN0eWxlKTtcbiAgICAgICAgICAgICAgX3RoaXM5Ny5fdGV4dEFsaWduID0gc3R5bGUudGV4dEFsaWduIHx8IFwibGVmdFwiO1xuICAgICAgICAgICAgICBfdGhpczk3Ll90ZXh0QmFzZWxpbmUgPSBzdHlsZS50ZXh0QmFzZWxpbmUgfHwgXCJtaWRkbGVcIjtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzOTc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhTdGRCYXNlU3R5bGUsIFt7XG4gICAgICAgICAgICAgIGtleTogXCJ0ZXh0QWxpZ25cIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RleHRBbGlnbjtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodGV4dEFsaWduKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4dEFsaWduID0gdGV4dEFsaWduO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9DaGFuZ2VTdHlsZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJ0ZXh0QmFzZWxpbmVcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RleHRCYXNlbGluZTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodGV4dEJhc2VsaW5lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4dEJhc2VsaW5lID0gdGV4dEJhc2VsaW5lO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9DaGFuZ2VTdHlsZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjbG9uZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTdGRCYXNlU3R5bGUodGhpcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiREVGQVVMVFwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdFN0eWxlID8gZGVmYXVsdFN0eWxlIDogZGVmYXVsdFN0eWxlID0gbmV3IFN0ZEJhc2VTdHlsZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBTdGRCYXNlU3R5bGU7XG4gICAgICAgICAgfShCYXNlU3R5bGVfMS5CYXNlU3R5bGUpO1xuXG4gICAgICAgICAgZXhwb3J0cy5TdGRCYXNlU3R5bGUgPSBTdGRCYXNlU3R5bGU7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vaGVhZGVyL3N0eWxlL1N0ZE11bHRpbGluZVRleHRCYXNlU3R5bGUuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9oZWFkZXIvc3R5bGUvU3RkTXVsdGlsaW5lVGV4dEJhc2VTdHlsZS5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGhlYWRlclN0eWxlU3RkTXVsdGlsaW5lVGV4dEJhc2VTdHlsZUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuU3RkTXVsdGlsaW5lVGV4dEJhc2VTdHlsZSA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBTdGRUZXh0QmFzZVN0eWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL1N0ZFRleHRCYXNlU3R5bGUgKi9cbiAgICAgICAgICBcIi4vaGVhZGVyL3N0eWxlL1N0ZFRleHRCYXNlU3R5bGUuanNcIik7XG5cbiAgICAgICAgICB2YXIgZGVmYXVsdFN0eWxlO1xuXG4gICAgICAgICAgdmFyIFN0ZE11bHRpbGluZVRleHRCYXNlU3R5bGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9TdGRUZXh0QmFzZVN0eWxlXzEkUzIpIHtcbiAgICAgICAgICAgIF9pbmhlcml0cyhTdGRNdWx0aWxpbmVUZXh0QmFzZVN0eWxlLCBfU3RkVGV4dEJhc2VTdHlsZV8xJFMyKTtcblxuICAgICAgICAgICAgdmFyIF9zdXBlcjY4ID0gX2NyZWF0ZVN1cGVyKFN0ZE11bHRpbGluZVRleHRCYXNlU3R5bGUpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBTdGRNdWx0aWxpbmVUZXh0QmFzZVN0eWxlKCkge1xuICAgICAgICAgICAgICB2YXIgX3RoaXM5ODtcblxuICAgICAgICAgICAgICB2YXIgc3R5bGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdGRNdWx0aWxpbmVUZXh0QmFzZVN0eWxlKTtcblxuICAgICAgICAgICAgICBfdGhpczk4ID0gX3N1cGVyNjguY2FsbCh0aGlzLCBzdHlsZSk7XG4gICAgICAgICAgICAgIF90aGlzOTguX2xpbmVIZWlnaHQgPSBzdHlsZS5saW5lSGVpZ2h0IHx8IFwiMWVtXCI7XG4gICAgICAgICAgICAgIF90aGlzOTguX2F1dG9XcmFwVGV4dCA9IHN0eWxlLmF1dG9XcmFwVGV4dCB8fCBmYWxzZTtcbiAgICAgICAgICAgICAgX3RoaXM5OC5fbGluZUNsYW1wID0gc3R5bGUubGluZUNsYW1wO1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXM5ODtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKFN0ZE11bHRpbGluZVRleHRCYXNlU3R5bGUsIFt7XG4gICAgICAgICAgICAgIGtleTogXCJjbG9uZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTdGRNdWx0aWxpbmVUZXh0QmFzZVN0eWxlKHRoaXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJsaW5lSGVpZ2h0XCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9saW5lSGVpZ2h0O1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChsaW5lSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGluZUhlaWdodCA9IGxpbmVIZWlnaHQ7XG4gICAgICAgICAgICAgICAgdGhpcy5kb0NoYW5nZVN0eWxlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImxpbmVDbGFtcFwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbGluZUNsYW1wO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChsaW5lQ2xhbXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9saW5lQ2xhbXAgPSBsaW5lQ2xhbXA7XG4gICAgICAgICAgICAgICAgdGhpcy5kb0NoYW5nZVN0eWxlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImF1dG9XcmFwVGV4dFwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYXV0b1dyYXBUZXh0O1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChhdXRvV3JhcFRleHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hdXRvV3JhcFRleHQgPSBhdXRvV3JhcFRleHQ7XG4gICAgICAgICAgICAgICAgdGhpcy5kb0NoYW5nZVN0eWxlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiREVGQVVMVFwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdFN0eWxlID8gZGVmYXVsdFN0eWxlIDogZGVmYXVsdFN0eWxlID0gbmV3IFN0ZE11bHRpbGluZVRleHRCYXNlU3R5bGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gU3RkTXVsdGlsaW5lVGV4dEJhc2VTdHlsZTtcbiAgICAgICAgICB9KFN0ZFRleHRCYXNlU3R5bGVfMS5TdGRUZXh0QmFzZVN0eWxlKTtcblxuICAgICAgICAgIGV4cG9ydHMuU3RkTXVsdGlsaW5lVGV4dEJhc2VTdHlsZSA9IFN0ZE11bHRpbGluZVRleHRCYXNlU3R5bGU7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vaGVhZGVyL3N0eWxlL1N0ZFRleHRCYXNlU3R5bGUuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9oZWFkZXIvc3R5bGUvU3RkVGV4dEJhc2VTdHlsZS5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGhlYWRlclN0eWxlU3RkVGV4dEJhc2VTdHlsZUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuU3RkVGV4dEJhc2VTdHlsZSA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBTdGRCYXNlU3R5bGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vU3RkQmFzZVN0eWxlICovXG4gICAgICAgICAgXCIuL2hlYWRlci9zdHlsZS9TdGRCYXNlU3R5bGUuanNcIik7XG5cbiAgICAgICAgICB2YXIgZGVmYXVsdFN0eWxlO1xuXG4gICAgICAgICAgdmFyIFN0ZFRleHRCYXNlU3R5bGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9TdGRCYXNlU3R5bGVfMSRTdGRCYTUpIHtcbiAgICAgICAgICAgIF9pbmhlcml0cyhTdGRUZXh0QmFzZVN0eWxlLCBfU3RkQmFzZVN0eWxlXzEkU3RkQmE1KTtcblxuICAgICAgICAgICAgdmFyIF9zdXBlcjY5ID0gX2NyZWF0ZVN1cGVyKFN0ZFRleHRCYXNlU3R5bGUpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBTdGRUZXh0QmFzZVN0eWxlKCkge1xuICAgICAgICAgICAgICB2YXIgX3RoaXM5OTtcblxuICAgICAgICAgICAgICB2YXIgc3R5bGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdGRUZXh0QmFzZVN0eWxlKTtcblxuICAgICAgICAgICAgICBfdGhpczk5ID0gX3N1cGVyNjkuY2FsbCh0aGlzLCBzdHlsZSk7XG4gICAgICAgICAgICAgIF90aGlzOTkuX2NvbG9yID0gc3R5bGUuY29sb3I7XG4gICAgICAgICAgICAgIF90aGlzOTkuX2ZvbnQgPSBzdHlsZS5mb250O1xuICAgICAgICAgICAgICBfdGhpczk5Ll9wYWRkaW5nID0gc3R5bGUucGFkZGluZztcbiAgICAgICAgICAgICAgX3RoaXM5OS5fdGV4dE92ZXJmbG93ID0gc3R5bGUudGV4dE92ZXJmbG93IHx8IFwiZWxsaXBzaXNcIjtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzOTk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhTdGRUZXh0QmFzZVN0eWxlLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiY29sb3JcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbG9yO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChjb2xvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbG9yID0gY29sb3I7XG4gICAgICAgICAgICAgICAgdGhpcy5kb0NoYW5nZVN0eWxlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImZvbnRcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZvbnQ7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGZvbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mb250ID0gZm9udDtcbiAgICAgICAgICAgICAgICB0aGlzLmRvQ2hhbmdlU3R5bGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwicGFkZGluZ1wiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFkZGluZztcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQocGFkZGluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhZGRpbmcgPSBwYWRkaW5nO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9DaGFuZ2VTdHlsZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJ0ZXh0T3ZlcmZsb3dcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RleHRPdmVyZmxvdztcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodGV4dE92ZXJmbG93KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4dE92ZXJmbG93ID0gdGV4dE92ZXJmbG93O1xuICAgICAgICAgICAgICAgIHRoaXMuZG9DaGFuZ2VTdHlsZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjbG9uZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTdGRUZXh0QmFzZVN0eWxlKHRoaXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSwgW3tcbiAgICAgICAgICAgICAga2V5OiBcIkRFRkFVTFRcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRTdHlsZSA/IGRlZmF1bHRTdHlsZSA6IGRlZmF1bHRTdHlsZSA9IG5ldyBTdGRUZXh0QmFzZVN0eWxlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIFN0ZFRleHRCYXNlU3R5bGU7XG4gICAgICAgICAgfShTdGRCYXNlU3R5bGVfMS5TdGRCYXNlU3R5bGUpO1xuXG4gICAgICAgICAgZXhwb3J0cy5TdGRUZXh0QmFzZVN0eWxlID0gU3RkVGV4dEJhc2VTdHlsZTtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9oZWFkZXIvc3R5bGUvU3R5bGUuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vaGVhZGVyL3N0eWxlL1N0eWxlLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGhlYWRlclN0eWxlU3R5bGVKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLlN0eWxlID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIFN0ZE11bHRpbGluZVRleHRCYXNlU3R5bGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vU3RkTXVsdGlsaW5lVGV4dEJhc2VTdHlsZSAqL1xuICAgICAgICAgIFwiLi9oZWFkZXIvc3R5bGUvU3RkTXVsdGlsaW5lVGV4dEJhc2VTdHlsZS5qc1wiKTtcblxuICAgICAgICAgIHZhciBkZWZhdWx0U3R5bGU7XG5cbiAgICAgICAgICB2YXIgU3R5bGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9TdGRNdWx0aWxpbmVUZXh0QmFzZTMpIHtcbiAgICAgICAgICAgIF9pbmhlcml0cyhTdHlsZSwgX1N0ZE11bHRpbGluZVRleHRCYXNlMyk7XG5cbiAgICAgICAgICAgIHZhciBfc3VwZXI3MCA9IF9jcmVhdGVTdXBlcihTdHlsZSk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIFN0eWxlKCkge1xuICAgICAgICAgICAgICB2YXIgX3RoaXMxMDA7XG5cbiAgICAgICAgICAgICAgdmFyIHN0eWxlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3R5bGUpO1xuXG4gICAgICAgICAgICAgIF90aGlzMTAwID0gX3N1cGVyNzAuY2FsbCh0aGlzLCBzdHlsZSk7XG4gICAgICAgICAgICAgIF90aGlzMTAwLl9tdWx0aWxpbmUgPSBzdHlsZS5tdWx0aWxpbmU7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczEwMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKFN0eWxlLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwibXVsdGlsaW5lXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhIXRoaXMuX211bHRpbGluZTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQobXVsdGlsaW5lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbXVsdGlsaW5lID0gbXVsdGlsaW5lO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9DaGFuZ2VTdHlsZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjbG9uZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHlsZSh0aGlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0sIFt7XG4gICAgICAgICAgICAgIGtleTogXCJERUZBVUxUXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0U3R5bGUgPyBkZWZhdWx0U3R5bGUgOiBkZWZhdWx0U3R5bGUgPSBuZXcgU3R5bGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gU3R5bGU7XG4gICAgICAgICAgfShTdGRNdWx0aWxpbmVUZXh0QmFzZVN0eWxlXzEuU3RkTXVsdGlsaW5lVGV4dEJhc2VTdHlsZSk7XG5cbiAgICAgICAgICBleHBvcnRzLlN0eWxlID0gU3R5bGU7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vaGVhZGVyL3R5cGUuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9oZWFkZXIvdHlwZS5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGhlYWRlclR5cGVKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLm9mQ2VsbCA9IGV4cG9ydHMub2YgPSBleHBvcnRzLk11bHRpbGluZVRleHRIZWFkZXIgPSBleHBvcnRzLkNoZWNrSGVhZGVyID0gZXhwb3J0cy5Tb3J0SGVhZGVyID0gZXhwb3J0cy5IZWFkZXIgPSBleHBvcnRzLkJhc2VIZWFkZXIgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgQmFzZUhlYWRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi90eXBlL0Jhc2VIZWFkZXIgKi9cbiAgICAgICAgICBcIi4vaGVhZGVyL3R5cGUvQmFzZUhlYWRlci5qc1wiKTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJhc2VIZWFkZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICByZXR1cm4gQmFzZUhlYWRlcl8xLkJhc2VIZWFkZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgQ2hlY2tIZWFkZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vdHlwZS9DaGVja0hlYWRlciAqL1xuICAgICAgICAgIFwiLi9oZWFkZXIvdHlwZS9DaGVja0hlYWRlci5qc1wiKTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNoZWNrSGVhZGVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIENoZWNrSGVhZGVyXzEuQ2hlY2tIZWFkZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgSGVhZGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL3R5cGUvSGVhZGVyICovXG4gICAgICAgICAgXCIuL2hlYWRlci90eXBlL0hlYWRlci5qc1wiKTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkhlYWRlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBIZWFkZXJfMS5IZWFkZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgTXVsdGlsaW5lVGV4dEhlYWRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi90eXBlL011bHRpbGluZVRleHRIZWFkZXIgKi9cbiAgICAgICAgICBcIi4vaGVhZGVyL3R5cGUvTXVsdGlsaW5lVGV4dEhlYWRlci5qc1wiKTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk11bHRpbGluZVRleHRIZWFkZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICByZXR1cm4gTXVsdGlsaW5lVGV4dEhlYWRlcl8xLk11bHRpbGluZVRleHRIZWFkZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgU29ydEhlYWRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi90eXBlL1NvcnRIZWFkZXIgKi9cbiAgICAgICAgICBcIi4vaGVhZGVyL3R5cGUvU29ydEhlYWRlci5qc1wiKTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNvcnRIZWFkZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICByZXR1cm4gU29ydEhlYWRlcl8xLlNvcnRIZWFkZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIFRZUEVTID0ge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIERFRkFVTFQ6IG5ldyBIZWFkZXJfMS5IZWFkZXIoKSxcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBTT1JUOiBuZXcgU29ydEhlYWRlcl8xLlNvcnRIZWFkZXIoKSxcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBDSEVDSzogbmV3IENoZWNrSGVhZGVyXzEuQ2hlY2tIZWFkZXIoKSxcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBNVUxUSUxJTkVURVhUOiBuZXcgTXVsdGlsaW5lVGV4dEhlYWRlcl8xLk11bHRpbGluZVRleHRIZWFkZXIoKVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBmdW5jdGlvbiBvZihoZWFkZXJUeXBlKSB7XG4gICAgICAgICAgICBpZiAoIWhlYWRlclR5cGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFRZUEVTLkRFRkFVTFQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBoZWFkZXJUeXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgIHZhciBrZXkgPSBoZWFkZXJUeXBlLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgIHJldHVybiBUWVBFU1trZXldIHx8IG9mKG51bGwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhlYWRlclR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5vZiA9IG9mO1xuXG4gICAgICAgICAgZnVuY3Rpb24gb2ZDZWxsKGhlYWRlckNlbGwpIHtcbiAgICAgICAgICAgIGlmIChoZWFkZXJDZWxsLnNvcnQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFRZUEVTLlNPUlQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvZihoZWFkZXJDZWxsLmhlYWRlclR5cGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMub2ZDZWxsID0gb2ZDZWxsO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2hlYWRlci90eXBlL0Jhc2VIZWFkZXIuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2hlYWRlci90eXBlL0Jhc2VIZWFkZXIuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGhlYWRlclR5cGVCYXNlSGVhZGVySnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICB2YXIgX19jcmVhdGVCaW5kaW5nID0gdGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZyB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICAgICAgICAgICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcblxuICAgICAgICAgICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgICAgICAgICAgZGVzYyA9IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ba107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xuICAgICAgICAgIH0gOiBmdW5jdGlvbiAobywgbSwgaywgazIpIHtcbiAgICAgICAgICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgICAgICAgICBvW2syXSA9IG1ba107XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gdGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCB2KSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHtcbiAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gOiBmdW5jdGlvbiAobywgdikge1xuICAgICAgICAgICAgb1tcImRlZmF1bHRcIl0gPSB2O1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIF9faW1wb3J0U3RhciA9IHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgICAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIHtcbiAgICAgICAgICAgICAgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5CYXNlSGVhZGVyID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIHN0eWxlQ29udGVudHMgPSBfX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vc3R5bGUgKi9cbiAgICAgICAgICBcIi4vaGVhZGVyL3N0eWxlLmpzXCIpKTtcblxuICAgICAgICAgIHZhciBCYXNlU3R5bGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uL3N0eWxlL0Jhc2VTdHlsZSAqL1xuICAgICAgICAgIFwiLi9oZWFkZXIvc3R5bGUvQmFzZVN0eWxlLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIEJhc2VIZWFkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gQmFzZUhlYWRlcigpIHtcbiAgICAgICAgICAgICAgdmFyIF9vcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmFzZUhlYWRlcik7XG5cbiAgICAgICAgICAgICAgdGhpcy5vbkRyYXdDZWxsID0gdGhpcy5vbkRyYXdDZWxsLmJpbmQodGhpcyk7IC8v44K544Kz44O844OX44KS5Zu65a6a44GV44Gb44KLXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhCYXNlSGVhZGVyLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiU3R5bGVDbGFzc1wiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQmFzZVN0eWxlXzEuQmFzZVN0eWxlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJvbkRyYXdDZWxsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbkRyYXdDZWxsKGNlbGxWYWx1ZSwgaW5mbywgY29udGV4dCwgZ3JpZCkge1xuICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9IGluZm8uc3R5bGUsXG4gICAgICAgICAgICAgICAgICAgIGRyYXdDZWxsQmFzZSA9IGluZm8uZHJhd0NlbGxCYXNlO1xuICAgICAgICAgICAgICAgIHZhciBoZWxwZXIgPSBncmlkLmdldEdyaWRDYW52YXNIZWxwZXIoKTtcbiAgICAgICAgICAgICAgICBkcmF3Q2VsbEJhc2UoKTsgLy/mloflrZfmj4/nlLtcblxuICAgICAgICAgICAgICAgIHRoaXMuZHJhd0ludGVybmFsKHRoaXMuY29udmVydEludGVybmFsKGNlbGxWYWx1ZSksIGNvbnRleHQsIHN0eWxlQ29udGVudHMub2Yoc3R5bGUsIHRoaXMuU3R5bGVDbGFzcyksIGhlbHBlciwgZ3JpZCwgaW5mbyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNvbnZlcnRJbnRlcm5hbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY29udmVydEludGVybmFsKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlKCk7XG4gICAgICAgICAgICAgICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXRlbXBsYXRlLWV4cHJlc3Npb25zXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSAhPSBudWxsID8gXCJcIi5jb25jYXQodmFsdWUpIDogXCJcIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiYmluZEdyaWRFdmVudFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYmluZEdyaWRFdmVudChfZ3JpZCwgX2NlbGxJZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0Q29weUNlbGxWYWx1ZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29weUNlbGxWYWx1ZSh2YWx1ZSwgX2dyaWQsIF9jZWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IFwiXCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIEJhc2VIZWFkZXI7XG4gICAgICAgICAgfSgpO1xuXG4gICAgICAgICAgZXhwb3J0cy5CYXNlSGVhZGVyID0gQmFzZUhlYWRlcjtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9oZWFkZXIvdHlwZS9DaGVja0hlYWRlci5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2hlYWRlci90eXBlL0NoZWNrSGVhZGVyLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gaGVhZGVyVHlwZUNoZWNrSGVhZGVySnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICB2YXIgX19jcmVhdGVCaW5kaW5nID0gdGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZyB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICAgICAgICAgICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcblxuICAgICAgICAgICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgICAgICAgICAgZGVzYyA9IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ba107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xuICAgICAgICAgIH0gOiBmdW5jdGlvbiAobywgbSwgaywgazIpIHtcbiAgICAgICAgICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgICAgICAgICBvW2syXSA9IG1ba107XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gdGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCB2KSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHtcbiAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gOiBmdW5jdGlvbiAobywgdikge1xuICAgICAgICAgICAgb1tcImRlZmF1bHRcIl0gPSB2O1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIF9faW1wb3J0U3RhciA9IHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgICAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIHtcbiAgICAgICAgICAgICAgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5DaGVja0hlYWRlciA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBpbmxpbmVVdGlscyA9IF9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi9lbGVtZW50L2lubGluZXMgKi9cbiAgICAgICAgICBcIi4vZWxlbWVudC9pbmxpbmVzLmpzXCIpKTtcblxuICAgICAgICAgIHZhciB1dGlscyA9IF9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi9jb2x1bW5zL3R5cGUvY29sdW1uVXRpbHMgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy90eXBlL2NvbHVtblV0aWxzLmpzXCIpKTtcblxuICAgICAgICAgIHZhciBCYXNlSGVhZGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL0Jhc2VIZWFkZXIgKi9cbiAgICAgICAgICBcIi4vaGVhZGVyL3R5cGUvQmFzZUhlYWRlci5qc1wiKTtcblxuICAgICAgICAgIHZhciBDaGVja0hlYWRlclN0eWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi9zdHlsZS9DaGVja0hlYWRlclN0eWxlICovXG4gICAgICAgICAgXCIuL2hlYWRlci9zdHlsZS9DaGVja0hlYWRlclN0eWxlLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIHN5bWJvbE1hbmFnZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uL2ludGVybmFsL3N5bWJvbE1hbmFnZXIgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvc3ltYm9sTWFuYWdlci5qc1wiKTtcblxuICAgICAgICAgIHZhciB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vaW50ZXJuYWwvdXRpbHMgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvdXRpbHMuanNcIik7XG5cbiAgICAgICAgICB2YXIgQ0hFQ0tfSEVBREVSX1NUQVRFX0lEID0gKDAsIHN5bWJvbE1hbmFnZXJfMS5nZXRDaGVja0hlYWRlclN0YXRlSWQpKCk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5cbiAgICAgICAgICBmdW5jdGlvbiBnZXRTdGF0ZShncmlkKSB7XG4gICAgICAgICAgICB2YXIgc3RhdGUgPSBncmlkW0NIRUNLX0hFQURFUl9TVEFURV9JRF07XG5cbiAgICAgICAgICAgIGlmICghc3RhdGUpIHtcbiAgICAgICAgICAgICAgc3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgZWxhcHNlZDoge30sXG4gICAgICAgICAgICAgICAgYmxvY2s6IHt9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHV0aWxzXzEub2JqLnNldFJlYWRvbmx5KGdyaWQsIENIRUNLX0hFQURFUl9TVEFURV9JRCwgc3RhdGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIENoZWNrSGVhZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZUhlYWRlcl8xJEJhc2VIZWEpIHtcbiAgICAgICAgICAgIF9pbmhlcml0cyhDaGVja0hlYWRlciwgX0Jhc2VIZWFkZXJfMSRCYXNlSGVhKTtcblxuICAgICAgICAgICAgdmFyIF9zdXBlcjcxID0gX2NyZWF0ZVN1cGVyKENoZWNrSGVhZGVyKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gQ2hlY2tIZWFkZXIoKSB7XG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDaGVja0hlYWRlcik7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlcjcxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhDaGVja0hlYWRlciwgW3tcbiAgICAgICAgICAgICAga2V5OiBcIlN0eWxlQ2xhc3NcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIENoZWNrSGVhZGVyU3R5bGVfMS5DaGVja0hlYWRlclN0eWxlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjbG9uZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGVja0hlYWRlcih0aGlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZHJhd0ludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3SW50ZXJuYWwodmFsdWUsIGNvbnRleHQsIHN0eWxlLCBoZWxwZXIsIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgIGdyaWQsIF9yZWY3NCkge1xuICAgICAgICAgICAgICAgIHZhciBkcmF3Q2VsbEJhc2UgPSBfcmVmNzQuZHJhd0NlbGxCYXNlLFxuICAgICAgICAgICAgICAgICAgICBnZXRJY29uID0gX3JlZjc0LmdldEljb247XG4gICAgICAgICAgICAgICAgdmFyIHRleHRBbGlnbiA9IHN0eWxlLnRleHRBbGlnbixcbiAgICAgICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lID0gc3R5bGUudGV4dEJhc2VsaW5lLFxuICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvciA9IHN0eWxlLmJvcmRlckNvbG9yLFxuICAgICAgICAgICAgICAgICAgICBjaGVja0JnQ29sb3IgPSBzdHlsZS5jaGVja0JnQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIHVuY2hlY2tCZ0NvbG9yID0gc3R5bGUudW5jaGVja0JnQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGJnQ29sb3IgPSBzdHlsZS5iZ0NvbG9yLFxuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nID0gc3R5bGUucGFkZGluZyxcbiAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBzdHlsZS5jb2xvcixcbiAgICAgICAgICAgICAgICAgICAgZm9udCA9IHN0eWxlLmZvbnQsXG4gICAgICAgICAgICAgICAgICAgIHRleHRPdmVyZmxvdyA9IHN0eWxlLnRleHRPdmVyZmxvdztcblxuICAgICAgICAgICAgICAgIGlmIChiZ0NvbG9yKSB7XG4gICAgICAgICAgICAgICAgICBkcmF3Q2VsbEJhc2Uoe1xuICAgICAgICAgICAgICAgICAgICBiZ0NvbG9yOiBiZ0NvbG9yXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgY29sID0gY29udGV4dC5jb2wsXG4gICAgICAgICAgICAgICAgICAgIHJvdyA9IGNvbnRleHQucm93O1xuICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IGdyaWQuZ2V0Q2VsbFJhbmdlKGNvbCwgcm93KTtcbiAgICAgICAgICAgICAgICB2YXIgY2VsbEtleSA9IFwiXCIuY29uY2F0KHJhbmdlLnN0YXJ0LmNvbCwgXCI6XCIpLmNvbmNhdChyYW5nZS5zdGFydC5yb3cpO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9nZXRTdGF0ZSA9IGdldFN0YXRlKGdyaWQpLFxuICAgICAgICAgICAgICAgICAgICBlbGFwc2VkID0gX2dldFN0YXRlLmVsYXBzZWRbY2VsbEtleV07XG5cbiAgICAgICAgICAgICAgICB2YXIgY2hlY2tlZCA9IGdyaWQuZ2V0SGVhZGVyVmFsdWUocmFuZ2Uuc3RhcnQuY29sLCByYW5nZS5zdGFydC5yb3cpO1xuICAgICAgICAgICAgICAgIHZhciBvcHQgPSB7XG4gICAgICAgICAgICAgICAgICB0ZXh0QWxpZ246IHRleHRBbGlnbixcbiAgICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZTogdGV4dEJhc2VsaW5lLFxuICAgICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IGJvcmRlckNvbG9yLFxuICAgICAgICAgICAgICAgICAgY2hlY2tCZ0NvbG9yOiBjaGVja0JnQ29sb3IsXG4gICAgICAgICAgICAgICAgICB1bmNoZWNrQmdDb2xvcjogdW5jaGVja0JnQ29sb3JcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgaWYgKGVsYXBzZWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgb3B0LmFuaW1FbGFwc2VkVGltZSA9IGVsYXBzZWQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGlubGluZUNoZWNrID0gaGVscGVyLmJ1aWxkQ2hlY2tCb3hJbmxpbmUoISFjaGVja2VkLCBjb250ZXh0LCBvcHQpO1xuICAgICAgICAgICAgICAgIHV0aWxzLmxvYWRJY29ucyhnZXRJY29uKCksIGNvbnRleHQsIGhlbHBlciwgZnVuY3Rpb24gKGljb25zLCBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY29udGVudHMgPSBbaW5saW5lQ2hlY2tdO1xuICAgICAgICAgICAgICAgICAgY29udGVudHMgPSBjb250ZW50cy5jb25jYXQoaW5saW5lVXRpbHMuYnVpbGRJbmxpbmVzKGljb25zLCB2YWx1ZSAhPSBudWxsID8gU3RyaW5nKHZhbHVlKSA6IFwiXCIpKTtcbiAgICAgICAgICAgICAgICAgIGhlbHBlci50ZXh0KGNvbnRlbnRzLCBjb250ZXh0LCB7XG4gICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbjogdGV4dEFsaWduLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmU6IHRleHRCYXNlbGluZSxcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgICAgICAgICBmb250OiBmb250LFxuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiBwYWRkaW5nLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0T3ZlcmZsb3c6IHRleHRPdmVyZmxvd1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIENoZWNrSGVhZGVyO1xuICAgICAgICAgIH0oQmFzZUhlYWRlcl8xLkJhc2VIZWFkZXIpO1xuXG4gICAgICAgICAgZXhwb3J0cy5DaGVja0hlYWRlciA9IENoZWNrSGVhZGVyO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2hlYWRlci90eXBlL0hlYWRlci5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9oZWFkZXIvdHlwZS9IZWFkZXIuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gaGVhZGVyVHlwZUhlYWRlckpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgdmFyIF9fY3JlYXRlQmluZGluZyA9IHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcgfHwgKE9iamVjdC5jcmVhdGUgPyBmdW5jdGlvbiAobywgbSwgaywgazIpIHtcbiAgICAgICAgICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG5cbiAgICAgICAgICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICAgICAgICAgIGRlc2MgPSB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBtW2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbiAgICAgICAgICB9IDogZnVuY3Rpb24gKG8sIG0sIGssIGsyKSB7XG4gICAgICAgICAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgICAgICAgICAgb1trMl0gPSBtW2tdO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQgfHwgKE9iamVjdC5jcmVhdGUgPyBmdW5jdGlvbiAobywgdikge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7XG4gICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgIHZhbHVlOiB2XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IDogZnVuY3Rpb24gKG8sIHYpIHtcbiAgICAgICAgICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBfX2ltcG9ydFN0YXIgPSB0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgICAgICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgICAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSB7XG4gICAgICAgICAgICAgIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuSGVhZGVyID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIHV0aWxzID0gX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uL2NvbHVtbnMvdHlwZS9jb2x1bW5VdGlscyAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3R5cGUvY29sdW1uVXRpbHMuanNcIikpO1xuXG4gICAgICAgICAgdmFyIEJhc2VIZWFkZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vQmFzZUhlYWRlciAqL1xuICAgICAgICAgIFwiLi9oZWFkZXIvdHlwZS9CYXNlSGVhZGVyLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIFN0eWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi9zdHlsZS9TdHlsZSAqL1xuICAgICAgICAgIFwiLi9oZWFkZXIvc3R5bGUvU3R5bGUuanNcIik7XG5cbiAgICAgICAgICB2YXIgSGVhZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZUhlYWRlcl8xJEJhc2VIZWEyKSB7XG4gICAgICAgICAgICBfaW5oZXJpdHMoSGVhZGVyLCBfQmFzZUhlYWRlcl8xJEJhc2VIZWEyKTtcblxuICAgICAgICAgICAgdmFyIF9zdXBlcjcyID0gX2NyZWF0ZVN1cGVyKEhlYWRlcik7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIEhlYWRlcigpIHtcbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEhlYWRlcik7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlcjcyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhIZWFkZXIsIFt7XG4gICAgICAgICAgICAgIGtleTogXCJTdHlsZUNsYXNzXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBTdHlsZV8xLlN0eWxlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJkcmF3SW50ZXJuYWxcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdJbnRlcm5hbCh2YWx1ZSwgY29udGV4dCwgc3R5bGUsIGhlbHBlciwgX2dyaWQsIF9yZWY3NSkge1xuICAgICAgICAgICAgICAgIHZhciBkcmF3Q2VsbEJhc2UgPSBfcmVmNzUuZHJhd0NlbGxCYXNlLFxuICAgICAgICAgICAgICAgICAgICBnZXRJY29uID0gX3JlZjc1LmdldEljb247XG4gICAgICAgICAgICAgICAgdmFyIHRleHRBbGlnbiA9IHN0eWxlLnRleHRBbGlnbixcbiAgICAgICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lID0gc3R5bGUudGV4dEJhc2VsaW5lLFxuICAgICAgICAgICAgICAgICAgICBjb2xvciA9IHN0eWxlLmNvbG9yLFxuICAgICAgICAgICAgICAgICAgICBmb250ID0gc3R5bGUuZm9udCxcbiAgICAgICAgICAgICAgICAgICAgYmdDb2xvciA9IHN0eWxlLmJnQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmcgPSBzdHlsZS5wYWRkaW5nLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0T3ZlcmZsb3cgPSBzdHlsZS50ZXh0T3ZlcmZsb3csXG4gICAgICAgICAgICAgICAgICAgIGxpbmVIZWlnaHQgPSBzdHlsZS5saW5lSGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBhdXRvV3JhcFRleHQgPSBzdHlsZS5hdXRvV3JhcFRleHQsXG4gICAgICAgICAgICAgICAgICAgIGxpbmVDbGFtcCA9IHN0eWxlLmxpbmVDbGFtcCxcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlsaW5lID0gc3R5bGUubXVsdGlsaW5lO1xuXG4gICAgICAgICAgICAgICAgaWYgKGJnQ29sb3IpIHtcbiAgICAgICAgICAgICAgICAgIGRyYXdDZWxsQmFzZSh7XG4gICAgICAgICAgICAgICAgICAgIGJnQ29sb3I6IGJnQ29sb3JcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciB0ZXh0VmFsdWUgPSB2YWx1ZSAhPSBudWxsID8gU3RyaW5nKHZhbHVlKSA6IFwiXCI7XG4gICAgICAgICAgICAgICAgdXRpbHMubG9hZEljb25zKGdldEljb24oKSwgY29udGV4dCwgaGVscGVyLCBmdW5jdGlvbiAoaWNvbnMsIGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChtdWx0aWxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG11bHRpbGluZXMgPSB0ZXh0VmFsdWUucmVwbGFjZSgvXFxyP1xcbi9nLCBcIlxcblwiKS5yZXBsYWNlKC9cXHIvZywgXCJcXG5cIikuc3BsaXQoXCJcXG5cIik7XG4gICAgICAgICAgICAgICAgICAgIGhlbHBlci5tdWx0aWxpbmVUZXh0KG11bHRpbGluZXMsIGNvbnRleHQsIHtcbiAgICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ246IHRleHRBbGlnbixcbiAgICAgICAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmU6IHRleHRCYXNlbGluZSxcbiAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgZm9udDogZm9udCxcbiAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiBwYWRkaW5nLFxuICAgICAgICAgICAgICAgICAgICAgIGxpbmVIZWlnaHQ6IGxpbmVIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgYXV0b1dyYXBUZXh0OiBhdXRvV3JhcFRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgbGluZUNsYW1wOiBsaW5lQ2xhbXAsXG4gICAgICAgICAgICAgICAgICAgICAgdGV4dE92ZXJmbG93OiB0ZXh0T3ZlcmZsb3csXG4gICAgICAgICAgICAgICAgICAgICAgaWNvbnM6IGljb25zXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaGVscGVyLnRleHQodGV4dFZhbHVlLCBjb250ZXh0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24sXG4gICAgICAgICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lOiB0ZXh0QmFzZWxpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgIGZvbnQ6IGZvbnQsXG4gICAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogcGFkZGluZyxcbiAgICAgICAgICAgICAgICAgICAgICB0ZXh0T3ZlcmZsb3c6IHRleHRPdmVyZmxvdyxcbiAgICAgICAgICAgICAgICAgICAgICBpY29uczogaWNvbnNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIEhlYWRlcjtcbiAgICAgICAgICB9KEJhc2VIZWFkZXJfMS5CYXNlSGVhZGVyKTtcblxuICAgICAgICAgIGV4cG9ydHMuSGVhZGVyID0gSGVhZGVyO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2hlYWRlci90eXBlL011bHRpbGluZVRleHRIZWFkZXIuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2hlYWRlci90eXBlL011bHRpbGluZVRleHRIZWFkZXIuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGhlYWRlclR5cGVNdWx0aWxpbmVUZXh0SGVhZGVySnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICB2YXIgX19jcmVhdGVCaW5kaW5nID0gdGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZyB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICAgICAgICAgICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcblxuICAgICAgICAgICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgICAgICAgICAgZGVzYyA9IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ba107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xuICAgICAgICAgIH0gOiBmdW5jdGlvbiAobywgbSwgaywgazIpIHtcbiAgICAgICAgICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgICAgICAgICBvW2syXSA9IG1ba107XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gdGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCB2KSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHtcbiAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gOiBmdW5jdGlvbiAobywgdikge1xuICAgICAgICAgICAgb1tcImRlZmF1bHRcIl0gPSB2O1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIF9faW1wb3J0U3RhciA9IHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgICAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIHtcbiAgICAgICAgICAgICAgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5NdWx0aWxpbmVUZXh0SGVhZGVyID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIHV0aWxzID0gX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uL2NvbHVtbnMvdHlwZS9jb2x1bW5VdGlscyAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3R5cGUvY29sdW1uVXRpbHMuanNcIikpO1xuXG4gICAgICAgICAgdmFyIEJhc2VIZWFkZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vQmFzZUhlYWRlciAqL1xuICAgICAgICAgIFwiLi9oZWFkZXIvdHlwZS9CYXNlSGVhZGVyLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIE11bHRpbGluZVRleHRIZWFkZXJTdHlsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vc3R5bGUvTXVsdGlsaW5lVGV4dEhlYWRlclN0eWxlICovXG4gICAgICAgICAgXCIuL2hlYWRlci9zdHlsZS9NdWx0aWxpbmVUZXh0SGVhZGVyU3R5bGUuanNcIik7XG5cbiAgICAgICAgICB2YXIgTXVsdGlsaW5lVGV4dEhlYWRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Jhc2VIZWFkZXJfMSRCYXNlSGVhMykge1xuICAgICAgICAgICAgX2luaGVyaXRzKE11bHRpbGluZVRleHRIZWFkZXIsIF9CYXNlSGVhZGVyXzEkQmFzZUhlYTMpO1xuXG4gICAgICAgICAgICB2YXIgX3N1cGVyNzMgPSBfY3JlYXRlU3VwZXIoTXVsdGlsaW5lVGV4dEhlYWRlcik7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIE11bHRpbGluZVRleHRIZWFkZXIoKSB7XG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNdWx0aWxpbmVUZXh0SGVhZGVyKTtcblxuICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyNzMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKE11bHRpbGluZVRleHRIZWFkZXIsIFt7XG4gICAgICAgICAgICAgIGtleTogXCJTdHlsZUNsYXNzXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBNdWx0aWxpbmVUZXh0SGVhZGVyU3R5bGVfMS5NdWx0aWxpbmVUZXh0SGVhZGVyU3R5bGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNsb25lXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE11bHRpbGluZVRleHRIZWFkZXIodGhpcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImRyYXdJbnRlcm5hbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0ludGVybmFsKHZhbHVlLCBjb250ZXh0LCBzdHlsZSwgaGVscGVyLCBfZ3JpZCwgX3JlZjc2KSB7XG4gICAgICAgICAgICAgICAgdmFyIGRyYXdDZWxsQmFzZSA9IF9yZWY3Ni5kcmF3Q2VsbEJhc2UsXG4gICAgICAgICAgICAgICAgICAgIGdldEljb24gPSBfcmVmNzYuZ2V0SWNvbjtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dEFsaWduID0gc3R5bGUudGV4dEFsaWduLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmUgPSBzdHlsZS50ZXh0QmFzZWxpbmUsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yID0gc3R5bGUuY29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGZvbnQgPSBzdHlsZS5mb250LFxuICAgICAgICAgICAgICAgICAgICBiZ0NvbG9yID0gc3R5bGUuYmdDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZyA9IHN0eWxlLnBhZGRpbmcsXG4gICAgICAgICAgICAgICAgICAgIGxpbmVIZWlnaHQgPSBzdHlsZS5saW5lSGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBhdXRvV3JhcFRleHQgPSBzdHlsZS5hdXRvV3JhcFRleHQsXG4gICAgICAgICAgICAgICAgICAgIGxpbmVDbGFtcCA9IHN0eWxlLmxpbmVDbGFtcCxcbiAgICAgICAgICAgICAgICAgICAgdGV4dE92ZXJmbG93ID0gc3R5bGUudGV4dE92ZXJmbG93O1xuXG4gICAgICAgICAgICAgICAgaWYgKGJnQ29sb3IpIHtcbiAgICAgICAgICAgICAgICAgIGRyYXdDZWxsQmFzZSh7XG4gICAgICAgICAgICAgICAgICAgIGJnQ29sb3I6IGJnQ29sb3JcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciB0ZXh0VmFsdWUgPSB2YWx1ZSAhPSBudWxsID8gU3RyaW5nKHZhbHVlKSA6IFwiXCI7XG4gICAgICAgICAgICAgICAgdmFyIG11bHRpbGluZXMgPSB0ZXh0VmFsdWUucmVwbGFjZSgvXFxyP1xcbi9nLCBcIlxcblwiKS5yZXBsYWNlKC9cXHIvZywgXCJcXG5cIikuc3BsaXQoXCJcXG5cIik7XG4gICAgICAgICAgICAgICAgaGVscGVyLnRlc3RGb250TG9hZChmb250LCB0ZXh0VmFsdWUsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIHV0aWxzLmxvYWRJY29ucyhnZXRJY29uKCksIGNvbnRleHQsIGhlbHBlciwgZnVuY3Rpb24gKGljb25zLCBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICBoZWxwZXIubXVsdGlsaW5lVGV4dChtdWx0aWxpbmVzLCBjb250ZXh0LCB7XG4gICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbjogdGV4dEFsaWduLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmU6IHRleHRCYXNlbGluZSxcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgICAgICAgICBmb250OiBmb250LFxuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiBwYWRkaW5nLFxuICAgICAgICAgICAgICAgICAgICBsaW5lSGVpZ2h0OiBsaW5lSGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBhdXRvV3JhcFRleHQ6IGF1dG9XcmFwVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgbGluZUNsYW1wOiBsaW5lQ2xhbXAsXG4gICAgICAgICAgICAgICAgICAgIHRleHRPdmVyZmxvdzogdGV4dE92ZXJmbG93LFxuICAgICAgICAgICAgICAgICAgICBpY29uczogaWNvbnNcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBNdWx0aWxpbmVUZXh0SGVhZGVyO1xuICAgICAgICAgIH0oQmFzZUhlYWRlcl8xLkJhc2VIZWFkZXIpO1xuXG4gICAgICAgICAgZXhwb3J0cy5NdWx0aWxpbmVUZXh0SGVhZGVyID0gTXVsdGlsaW5lVGV4dEhlYWRlcjtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9oZWFkZXIvdHlwZS9Tb3J0SGVhZGVyLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9oZWFkZXIvdHlwZS9Tb3J0SGVhZGVyLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBoZWFkZXJUeXBlU29ydEhlYWRlckpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgdmFyIF9fY3JlYXRlQmluZGluZyA9IHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcgfHwgKE9iamVjdC5jcmVhdGUgPyBmdW5jdGlvbiAobywgbSwgaywgazIpIHtcbiAgICAgICAgICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG5cbiAgICAgICAgICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICAgICAgICAgIGRlc2MgPSB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBtW2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbiAgICAgICAgICB9IDogZnVuY3Rpb24gKG8sIG0sIGssIGsyKSB7XG4gICAgICAgICAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgICAgICAgICAgb1trMl0gPSBtW2tdO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQgfHwgKE9iamVjdC5jcmVhdGUgPyBmdW5jdGlvbiAobywgdikge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7XG4gICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgIHZhbHVlOiB2XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IDogZnVuY3Rpb24gKG8sIHYpIHtcbiAgICAgICAgICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBfX2ltcG9ydFN0YXIgPSB0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgICAgICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgICAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSB7XG4gICAgICAgICAgICAgIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuU29ydEhlYWRlciA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciB1dGlscyA9IF9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi9jb2x1bW5zL3R5cGUvY29sdW1uVXRpbHMgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy90eXBlL2NvbHVtblV0aWxzLmpzXCIpKTtcblxuICAgICAgICAgIHZhciBCYXNlSGVhZGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL0Jhc2VIZWFkZXIgKi9cbiAgICAgICAgICBcIi4vaGVhZGVyL3R5cGUvQmFzZUhlYWRlci5qc1wiKTtcblxuICAgICAgICAgIHZhciBTb3J0SGVhZGVyU3R5bGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uL3N0eWxlL1NvcnRIZWFkZXJTdHlsZSAqL1xuICAgICAgICAgIFwiLi9oZWFkZXIvc3R5bGUvU29ydEhlYWRlclN0eWxlLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIHV0aWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi9pbnRlcm5hbC91dGlscyAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC91dGlscy5qc1wiKTtcblxuICAgICAgICAgIHZhciBjYW52YXNlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vaW50ZXJuYWwvY2FudmFzZXMgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvY2FudmFzZXMuanNcIik7XG5cbiAgICAgICAgICB2YXIgU29ydEhlYWRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Jhc2VIZWFkZXJfMSRCYXNlSGVhNCkge1xuICAgICAgICAgICAgX2luaGVyaXRzKFNvcnRIZWFkZXIsIF9CYXNlSGVhZGVyXzEkQmFzZUhlYTQpO1xuXG4gICAgICAgICAgICB2YXIgX3N1cGVyNzQgPSBfY3JlYXRlU3VwZXIoU29ydEhlYWRlcik7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIFNvcnRIZWFkZXIoKSB7XG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTb3J0SGVhZGVyKTtcblxuICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyNzQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKFNvcnRIZWFkZXIsIFt7XG4gICAgICAgICAgICAgIGtleTogXCJTdHlsZUNsYXNzXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBTb3J0SGVhZGVyU3R5bGVfMS5Tb3J0SGVhZGVyU3R5bGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImRyYXdJbnRlcm5hbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0ludGVybmFsKHZhbHVlLCBjb250ZXh0LCBzdHlsZSwgaGVscGVyLCBncmlkLCBfcmVmNzcpIHtcbiAgICAgICAgICAgICAgICB2YXIgZHJhd0NlbGxCYXNlID0gX3JlZjc3LmRyYXdDZWxsQmFzZSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0SWNvbiA9IF9yZWY3Ny5nZXRJY29uO1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0QWxpZ24gPSBzdHlsZS50ZXh0QWxpZ24sXG4gICAgICAgICAgICAgICAgICAgIF9zdHlsZSR0ZXh0QmFzZWxpbmUgPSBzdHlsZS50ZXh0QmFzZWxpbmUsXG4gICAgICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZSA9IF9zdHlsZSR0ZXh0QmFzZWxpbmUgPT09IHZvaWQgMCA/IFwibWlkZGxlXCIgOiBfc3R5bGUkdGV4dEJhc2VsaW5lLFxuICAgICAgICAgICAgICAgICAgICBjb2xvciA9IHN0eWxlLmNvbG9yLFxuICAgICAgICAgICAgICAgICAgICBiZ0NvbG9yID0gc3R5bGUuYmdDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgZm9udCA9IHN0eWxlLmZvbnQsXG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmcgPSBzdHlsZS5wYWRkaW5nLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0T3ZlcmZsb3cgPSBzdHlsZS50ZXh0T3ZlcmZsb3csXG4gICAgICAgICAgICAgICAgICAgIGxpbmVIZWlnaHQgPSBzdHlsZS5saW5lSGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBhdXRvV3JhcFRleHQgPSBzdHlsZS5hdXRvV3JhcFRleHQsXG4gICAgICAgICAgICAgICAgICAgIGxpbmVDbGFtcCA9IHN0eWxlLmxpbmVDbGFtcCxcbiAgICAgICAgICAgICAgICAgICAgc29ydEFycm93Q29sb3IgPSBzdHlsZS5zb3J0QXJyb3dDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlsaW5lID0gc3R5bGUubXVsdGlsaW5lO1xuXG4gICAgICAgICAgICAgICAgaWYgKGJnQ29sb3IpIHtcbiAgICAgICAgICAgICAgICAgIGRyYXdDZWxsQmFzZSh7XG4gICAgICAgICAgICAgICAgICAgIGJnQ29sb3I6IGJnQ29sb3JcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciB0ZXh0VmFsdWUgPSB2YWx1ZSAhPSBudWxsID8gU3RyaW5nKHZhbHVlKSA6IFwiXCI7XG4gICAgICAgICAgICAgICAgaGVscGVyLnRlc3RGb250TG9hZChmb250LCB0ZXh0VmFsdWUsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIHV0aWxzLmxvYWRJY29ucyhnZXRJY29uKCksIGNvbnRleHQsIGhlbHBlciwgZnVuY3Rpb24gKGljb25zLCBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgc3RhdGUgPSBncmlkLnNvcnRTdGF0ZTtcbiAgICAgICAgICAgICAgICAgIHZhciBvcmRlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgIHZhciBjb2wgPSBjb250ZXh0LmNvbCxcbiAgICAgICAgICAgICAgICAgICAgICByb3cgPSBjb250ZXh0LnJvdztcbiAgICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IGdyaWQuZ2V0Q2VsbFJhbmdlKGNvbCwgcm93KTtcblxuICAgICAgICAgICAgICAgICAgaWYgKCgwLCB1dGlsc18xLmNlbGxJblJhbmdlKShyYW5nZSwgc3RhdGUuY29sLCBzdGF0ZS5yb3cpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9yZGVyID0gc3RhdGUub3JkZXI7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHZhciBjdHggPSBjb250ZXh0LmdldENvbnRleHQoKTtcbiAgICAgICAgICAgICAgICAgIHZhciBhcnJvd1NpemUgPSAoMCwgY2FudmFzZXNfMS5nZXRGb250U2l6ZSkoY3R4LCBmb250KS53aWR0aCAqIDEuMjtcbiAgICAgICAgICAgICAgICAgIHZhciB0cmFpbGluZ0ljb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IG9yZGVyICE9IG51bGwgPyBvcmRlciA9PT0gXCJhc2NcIiA/IFwiYXJyb3dfZG93bndhcmRcIiA6IFwiYXJyb3dfdXB3YXJkXCIgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBhcnJvd1NpemUsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBoZWxwZXIuZ2V0Q29sb3Ioc29ydEFycm93Q29sb3IgfHwgaGVscGVyLnRoZW1lLmhlYWRlci5zb3J0QXJyb3dDb2xvciwgY29sLCByb3csIGN0eCkgfHwgXCJyZ2JhKDAsIDAsIDAsIDAuMzgpXCJcbiAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgIGlmIChtdWx0aWxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmVzID0gdGV4dFZhbHVlLnJlcGxhY2UoL1xccj9cXG4vZywgXCJcXG5cIikucmVwbGFjZSgvXFxyL2csIFwiXFxuXCIpLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICAgICAgICAgICAgICBoZWxwZXIubXVsdGlsaW5lVGV4dChsaW5lcywgY29udGV4dCwge1xuICAgICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbjogdGV4dEFsaWduLFxuICAgICAgICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZTogdGV4dEJhc2VsaW5lLFxuICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICBmb250OiBmb250LFxuICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IHBhZGRpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgbGluZUhlaWdodDogbGluZUhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICBhdXRvV3JhcFRleHQ6IGF1dG9XcmFwVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICBsaW5lQ2xhbXA6IGxpbmVDbGFtcCxcbiAgICAgICAgICAgICAgICAgICAgICB0ZXh0T3ZlcmZsb3c6IHRleHRPdmVyZmxvdyxcbiAgICAgICAgICAgICAgICAgICAgICBpY29uczogaWNvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgdHJhaWxpbmdJY29uOiB0cmFpbGluZ0ljb25cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBoZWxwZXIudGV4dCh0ZXh0VmFsdWUsIGNvbnRleHQsIHtcbiAgICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ246IHRleHRBbGlnbixcbiAgICAgICAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmU6IHRleHRCYXNlbGluZSxcbiAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgZm9udDogZm9udCxcbiAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiBwYWRkaW5nLFxuICAgICAgICAgICAgICAgICAgICAgIHRleHRPdmVyZmxvdzogdGV4dE92ZXJmbG93LFxuICAgICAgICAgICAgICAgICAgICAgIGljb25zOiBpY29ucyxcbiAgICAgICAgICAgICAgICAgICAgICB0cmFpbGluZ0ljb246IHRyYWlsaW5nSWNvblxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gU29ydEhlYWRlcjtcbiAgICAgICAgICB9KEJhc2VIZWFkZXJfMS5CYXNlSGVhZGVyKTtcblxuICAgICAgICAgIGV4cG9ydHMuU29ydEhlYWRlciA9IFNvcnRIZWFkZXI7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vaGVhZGVycy5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vaGVhZGVycy5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gaGVhZGVyc0pzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgdmFyIF9fY3JlYXRlQmluZGluZyA9IHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcgfHwgKE9iamVjdC5jcmVhdGUgPyBmdW5jdGlvbiAobywgbSwgaywgazIpIHtcbiAgICAgICAgICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG5cbiAgICAgICAgICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICAgICAgICAgIGRlc2MgPSB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBtW2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbiAgICAgICAgICB9IDogZnVuY3Rpb24gKG8sIG0sIGssIGsyKSB7XG4gICAgICAgICAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgICAgICAgICAgb1trMl0gPSBtW2tdO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQgfHwgKE9iamVjdC5jcmVhdGUgPyBmdW5jdGlvbiAobywgdikge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7XG4gICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgIHZhbHVlOiB2XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IDogZnVuY3Rpb24gKG8sIHYpIHtcbiAgICAgICAgICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBfX2ltcG9ydFN0YXIgPSB0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgICAgICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgICAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSB7XG4gICAgICAgICAgICAgIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuc3R5bGUgPSBleHBvcnRzLnR5cGUgPSBleHBvcnRzLmFjdGlvbiA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBhY3Rpb24gPSBfX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9oZWFkZXIvYWN0aW9uICovXG4gICAgICAgICAgXCIuL2hlYWRlci9hY3Rpb24uanNcIikpO1xuXG4gICAgICAgICAgZXhwb3J0cy5hY3Rpb24gPSBhY3Rpb247XG5cbiAgICAgICAgICB2YXIgc3R5bGUgPSBfX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9oZWFkZXIvc3R5bGUgKi9cbiAgICAgICAgICBcIi4vaGVhZGVyL3N0eWxlLmpzXCIpKTtcblxuICAgICAgICAgIGV4cG9ydHMuc3R5bGUgPSBzdHlsZTtcblxuICAgICAgICAgIHZhciB0eXBlID0gX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vaGVhZGVyL3R5cGUgKi9cbiAgICAgICAgICBcIi4vaGVhZGVyL3R5cGUuanNcIikpO1xuXG4gICAgICAgICAgZXhwb3J0cy50eXBlID0gdHlwZTtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9pY29ucy5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2ljb25zLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gaWNvbnNKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAvKmVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSovXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5nZXQgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgdXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vaW50ZXJuYWwvdXRpbHMgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvdXRpbHMuanNcIik7XG5cbiAgICAgICAgICB2YXIgaWNvbnNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vcGx1Z2lucy9pY29ucyAqL1xuICAgICAgICAgIFwiLi9wbHVnaW5zL2ljb25zLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIGJ1aWx0aW5zID0ge1xuICAgICAgICAgICAgZ2V0IGFycm93X3Vwd2FyZCgpIHtcbiAgICAgICAgICAgICAgLy8gcmV0dXJuIHJlcXVpcmUoXCJjaGVldGFoLWdyaWQtaWNvbi1zdmctbG9hZGVyIW1hdGVyaWFsLWRlc2lnbi1pY29ucy9uYXZpZ2F0aW9uL3N2Zy9wcm9kdWN0aW9uL2ljX2Fycm93X3Vwd2FyZF80OHB4LnN2Z1wiKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkOiBcIk04IDI0bDIuODMgMi44M0wyMiAxNS42NlY0MGg0VjE1LjY2bDExLjE3IDExLjE3TDQwIDI0IDI0IDggOCAyNHpcIixcbiAgICAgICAgICAgICAgICB3aWR0aDogNDgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA0OFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0IGFycm93X2Rvd253YXJkKCkge1xuICAgICAgICAgICAgICAvLyByZXR1cm4gcmVxdWlyZShcImNoZWV0YWgtZ3JpZC1pY29uLXN2Zy1sb2FkZXIhbWF0ZXJpYWwtZGVzaWduLWljb25zL25hdmlnYXRpb24vc3ZnL3Byb2R1Y3Rpb24vaWNfYXJyb3dfZG93bndhcmRfNDhweC5zdmdcIik7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZDogXCJNNDAgMjRsLTIuODItMi44MkwyNiAzMi4zNFY4aC00djI0LjM0TDEwLjg0IDIxLjE2IDggMjRsMTYgMTYgMTYtMTZ6XCIsXG4gICAgICAgICAgICAgICAgd2lkdGg6IDQ4LFxuICAgICAgICAgICAgICAgIGhlaWdodDogNDhcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldCBlZGl0KCkge1xuICAgICAgICAgICAgICAvLyByZXR1cm4gcmVxdWlyZShcImNoZWV0YWgtZ3JpZC1pY29uLXN2Zy1sb2FkZXIhbWF0ZXJpYWwtZGVzaWduLWljb25zL2ltYWdlL3N2Zy9wcm9kdWN0aW9uL2ljX2VkaXRfNDhweC5zdmdcIik7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZDogXCJNNiAzNC41VjQyaDcuNWwyMi4xMy0yMi4xMy03LjUtNy41TDYgMzQuNXptMzUuNDEtMjAuNDFjLjc4LS43OC43OC0yLjA1IDAtMi44M2wtNC42Ny00LjY3Yy0uNzgtLjc4LTIuMDUtLjc4LTIuODMgMGwtMy42NiAzLjY2IDcuNSA3LjUgMy42Ni0zLjY2elwiLFxuICAgICAgICAgICAgICAgIHdpZHRoOiA0OCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDQ4XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXQgYWRkKCkge1xuICAgICAgICAgICAgICAvLyByZXR1cm4gcmVxdWlyZShcImNoZWV0YWgtZ3JpZC1pY29uLXN2Zy1sb2FkZXIhbWF0ZXJpYWwtZGVzaWduLWljb25zL2NvbnRlbnQvc3ZnL3Byb2R1Y3Rpb24vaWNfYWRkXzQ4cHguc3ZnXCIpO1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGQ6IFwiTTM4IDI2SDI2djEyaC00VjI2SDEwdi00aDEyVjEwaDR2MTJoMTJ2NHpcIixcbiAgICAgICAgICAgICAgICB3aWR0aDogNDgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA0OFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0IHN0YXIoKSB7XG4gICAgICAgICAgICAgIC8vIHJldHVybiByZXF1aXJlKFwiY2hlZXRhaC1ncmlkLWljb24tc3ZnLWxvYWRlciFtYXRlcmlhbC1kZXNpZ24taWNvbnMvdG9nZ2xlL3N2Zy9wcm9kdWN0aW9uL2ljX3N0YXJfMjRweC5zdmdcIik7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZDogXCJNMTIgMTcuMjdMMTguMTggMjFsLTEuNjQtNy4wM0wyMiA5LjI0bC03LjE5LS42MUwxMiAyIDkuMTkgOC42MyAyIDkuMjRsNS40NiA0LjczTDUuODIgMjF6XCIsXG4gICAgICAgICAgICAgICAgd2lkdGg6IDI0LFxuICAgICAgICAgICAgICAgIGhlaWdodDogMjRcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldCBzdGFyX2JvcmRlcigpIHtcbiAgICAgICAgICAgICAgLy8gcmV0dXJuIHJlcXVpcmUoXCJjaGVldGFoLWdyaWQtaWNvbi1zdmctbG9hZGVyIW1hdGVyaWFsLWRlc2lnbi1pY29ucy90b2dnbGUvc3ZnL3Byb2R1Y3Rpb24vaWNfc3Rhcl9ib3JkZXJfMjRweC5zdmdcIik7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZDogXCJNMjIgOS4yNGwtNy4xOS0uNjJMMTIgMiA5LjE5IDguNjMgMiA5LjI0bDUuNDYgNC43M0w1LjgyIDIxIDEyIDE3LjI3IDE4LjE4IDIxbC0xLjYzLTcuMDNMMjIgOS4yNHpNMTIgMTUuNGwtMy43NiAyLjI3IDEtNC4yOC0zLjMyLTIuODggNC4zOC0uMzhMMTIgNi4xbDEuNzEgNC4wNCA0LjM4LjM4LTMuMzIgMi44OCAxIDQuMjhMMTIgMTUuNHpcIixcbiAgICAgICAgICAgICAgICB3aWR0aDogMjQsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAyNFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0IHN0YXJfaGFsZigpIHtcbiAgICAgICAgICAgICAgLy8gcmV0dXJuIHJlcXVpcmUoXCJjaGVldGFoLWdyaWQtaWNvbi1zdmctbG9hZGVyIW1hdGVyaWFsLWRlc2lnbi1pY29ucy90b2dnbGUvc3ZnL3Byb2R1Y3Rpb24vaWNfc3Rhcl9oYWxmXzI0cHguc3ZnXCIpO1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGQ6IFwiTTIyIDkuMjRsLTcuMTktLjYyTDEyIDIgOS4xOSA4LjYzIDIgOS4yNGw1LjQ2IDQuNzNMNS44MiAyMSAxMiAxNy4yNyAxOC4xOCAyMWwtMS42My03LjAzTDIyIDkuMjR6TTEyIDE1LjRWNi4xbDEuNzEgNC4wNCA0LjM4LjM4LTMuMzIgMi44OCAxIDQuMjhMMTIgMTUuNHpcIixcbiAgICAgICAgICAgICAgICB3aWR0aDogMjQsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAyNFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0IGtleWJvYXJkX2Fycm93X2Rvd24oKSB7XG4gICAgICAgICAgICAgIC8vIHJldHVybiByZXF1aXJlKFwiY2hlZXRhaC1ncmlkLWljb24tc3ZnLWxvYWRlciFtYXRlcmlhbC1kZXNpZ24taWNvbnMvaGFyZHdhcmUvc3ZnL3Byb2R1Y3Rpb24vaWNfa2V5Ym9hcmRfYXJyb3dfZG93bl80OHB4LnN2Z1wiKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkOiBcIk0xNC44MyAxNi40MkwyNCAyNS41OWw5LjE3LTkuMTdMMzYgMTkuMjVsLTEyIDEyLTEyLTEyelwiLFxuICAgICAgICAgICAgICAgIHdpZHRoOiA0OCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDQ4XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXQga2V5Ym9hcmRfYXJyb3dfbGVmdCgpIHtcbiAgICAgICAgICAgICAgLy8gcmV0dXJuIHJlcXVpcmUoXCJjaGVldGFoLWdyaWQtaWNvbi1zdmctbG9hZGVyIW1hdGVyaWFsLWRlc2lnbi1pY29ucy9oYXJkd2FyZS9zdmcvcHJvZHVjdGlvbi9pY19rZXlib2FyZF9hcnJvd19sZWZ0XzQ4cHguc3ZnXCIpO1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGQ6IFwiTTMwLjgzIDMyLjY3bC05LjE3LTkuMTcgOS4xNy05LjE3TDI4IDExLjVsLTEyIDEyIDEyIDEyelwiLFxuICAgICAgICAgICAgICAgIHdpZHRoOiA0OCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDQ4XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXQga2V5Ym9hcmRfYXJyb3dfcmlnaHQoKSB7XG4gICAgICAgICAgICAgIC8vIHJldHVybiByZXF1aXJlKFwiY2hlZXRhaC1ncmlkLWljb24tc3ZnLWxvYWRlciFtYXRlcmlhbC1kZXNpZ24taWNvbnMvaGFyZHdhcmUvc3ZnL3Byb2R1Y3Rpb24vaWNfa2V5Ym9hcmRfYXJyb3dfcmlnaHRfNDhweC5zdmdcIik7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZDogXCJNMTcuMTcgMzIuOTJsOS4xNy05LjE3LTkuMTctOS4xN0wyMCAxMS43NWwxMiAxMi0xMiAxMnpcIixcbiAgICAgICAgICAgICAgICB3aWR0aDogNDgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA0OFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0IGtleWJvYXJkX2Fycm93X3VwKCkge1xuICAgICAgICAgICAgICAvLyByZXR1cm4gcmVxdWlyZShcImNoZWV0YWgtZ3JpZC1pY29uLXN2Zy1sb2FkZXIhbWF0ZXJpYWwtZGVzaWduLWljb25zL2hhcmR3YXJlL3N2Zy9wcm9kdWN0aW9uL2ljX2tleWJvYXJkX2Fycm93X3VwXzQ4cHguc3ZnXCIpO1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGQ6IFwiTTE0LjgzIDMwLjgzTDI0IDIxLjY2bDkuMTcgOS4xN0wzNiAyOCAyNCAxNiAxMiAyOHpcIixcbiAgICAgICAgICAgICAgICB3aWR0aDogNDgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA0OFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0IGNoZXZyb25fbGVmdCgpIHtcbiAgICAgICAgICAgICAgLy8gcmV0dXJuIHJlcXVpcmUoXCJjaGVldGFoLWdyaWQtaWNvbi1zdmctbG9hZGVyIW1hdGVyaWFsLWRlc2lnbi1pY29ucy9uYXZpZ2F0aW9uL3N2Zy9wcm9kdWN0aW9uL2ljX2NoZXZyb25fbGVmdF80OHB4LnN2Z1wiKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkOiBcIk0xNC44MyAzMC44M0wyNCAyMS42Nmw5LjE3IDkuMTdMMzYgMjggMjQgMTYgMTIgMjh6XCIsXG4gICAgICAgICAgICAgICAgd2lkdGg6IDQ4LFxuICAgICAgICAgICAgICAgIGhlaWdodDogNDhcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldCBjaGV2cm9uX3JpZ2h0KCkge1xuICAgICAgICAgICAgICAvLyByZXR1cm4gcmVxdWlyZShcImNoZWV0YWgtZ3JpZC1pY29uLXN2Zy1sb2FkZXIhbWF0ZXJpYWwtZGVzaWduLWljb25zL25hdmlnYXRpb24vc3ZnL3Byb2R1Y3Rpb24vaWNfY2hldnJvbl9yaWdodF80OHB4LnN2Z1wiKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkOiBcIk0yMCAxMmwtMi44MyAyLjgzTDI2LjM0IDI0bC05LjE3IDkuMTdMMjAgMzZsMTItMTJ6XCIsXG4gICAgICAgICAgICAgICAgd2lkdGg6IDQ4LFxuICAgICAgICAgICAgICAgIGhlaWdodDogNDhcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldCBleHBhbmRfbGVzcygpIHtcbiAgICAgICAgICAgICAgLy8gcmV0dXJuIHJlcXVpcmUoXCJjaGVldGFoLWdyaWQtaWNvbi1zdmctbG9hZGVyIW1hdGVyaWFsLWRlc2lnbi1pY29ucy9uYXZpZ2F0aW9uL3N2Zy9wcm9kdWN0aW9uL2ljX2V4cGFuZF9sZXNzXzQ4cHguc3ZnXCIpO1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGQ6IFwiTTI0IDE2TDEyIDI4bDIuODMgMi44M0wyNCAyMS42Nmw5LjE3IDkuMTdMMzYgMjh6XCIsXG4gICAgICAgICAgICAgICAgd2lkdGg6IDQ4LFxuICAgICAgICAgICAgICAgIGhlaWdodDogNDhcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldCBleHBhbmRfbW9yZSgpIHtcbiAgICAgICAgICAgICAgLy8gcmV0dXJuIHJlcXVpcmUoXCJjaGVldGFoLWdyaWQtaWNvbi1zdmctbG9hZGVyIW1hdGVyaWFsLWRlc2lnbi1pY29ucy9uYXZpZ2F0aW9uL3N2Zy9wcm9kdWN0aW9uL2ljX2V4cGFuZF9tb3JlXzQ4cHguc3ZnXCIpO1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGQ6IFwiTTMzLjE3IDE3LjE3TDI0IDI2LjM0bC05LjE3LTkuMTdMMTIgMjBsMTIgMTIgMTItMTJ6XCIsXG4gICAgICAgICAgICAgICAgd2lkdGg6IDQ4LFxuICAgICAgICAgICAgICAgIGhlaWdodDogNDhcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEuZXh0ZW5kKShidWlsdGlucywgaWNvbnNfMS5pY29ucyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5nZXQgPSBnZXQ7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vaW50ZXJuYWwvRXZlbnRIYW5kbGVyLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2ludGVybmFsL0V2ZW50SGFuZGxlci5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBpbnRlcm5hbEV2ZW50SGFuZGxlckpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuRXZlbnRIYW5kbGVyID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIHV0aWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL3V0aWxzICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL3V0aWxzLmpzXCIpO1xuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgICAgICAgICB2YXIgbmV4dElkID0gMTtcblxuICAgICAgICAgIHZhciBFdmVudEhhbmRsZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gRXZlbnRIYW5kbGVyKCkge1xuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRXZlbnRIYW5kbGVyKTtcblxuICAgICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKEV2ZW50SGFuZGxlciwgW3tcbiAgICAgICAgICAgICAga2V5OiBcIm9uXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbjcgPSBhcmd1bWVudHMubGVuZ3RoLCBvcHRpb25zID0gbmV3IEFycmF5KF9sZW43ID4gMyA/IF9sZW43IC0gMyA6IDApLCBfa2V5NyA9IDM7IF9rZXk3IDwgX2xlbjc7IF9rZXk3KyspIHtcbiAgICAgICAgICAgICAgICAgIG9wdGlvbnNbX2tleTcgLSAzXSA9IGFyZ3VtZW50c1tfa2V5N107XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lci5hcHBseSh0YXJnZXQsIFt0eXBlLCBsaXN0ZW5lcl0uY29uY2F0KG9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgb2JqID0ge1xuICAgICAgICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgICAgbGlzdGVuZXI6IGxpc3RlbmVyLFxuICAgICAgICAgICAgICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIGlkID0gbmV4dElkKys7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzW2lkXSA9IG9iajtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIm9uY2VcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uY2UodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpczEwMSA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfbGVuOCA9IGFyZ3VtZW50cy5sZW5ndGgsIG9wdGlvbnMgPSBuZXcgQXJyYXkoX2xlbjggPiAzID8gX2xlbjggLSAzIDogMCksIF9rZXk4ID0gMzsgX2tleTggPCBfbGVuODsgX2tleTgrKykge1xuICAgICAgICAgICAgICAgICAgb3B0aW9uc1tfa2V5OCAtIDNdID0gYXJndW1lbnRzW19rZXk4XTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgaWQgPSB0aGlzLm9uLmFwcGx5KHRoaXMsIFt0YXJnZXQsIHR5cGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzMTAxLm9mZihpZCk7XG5cbiAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9XS5jb25jYXQob3B0aW9ucykpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwidHJ5V2l0aE9mZkV2ZW50c1wiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdHJ5V2l0aE9mZkV2ZW50cyh0YXJnZXQsIHR5cGUsIGNhbGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGlzdCA9IFtdO1xuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICgwLCB1dGlsc18xLmVhY2gpKHRoaXMuX2xpc3RlbmVycywgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2JqLnRhcmdldCA9PT0gdGFyZ2V0ICYmIG9iai50eXBlID09PSB0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKG9iai50YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9vYmokdGFyZ2V0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAoX29iaiR0YXJnZXQgPSBvYmoudGFyZ2V0KS5yZW1vdmVFdmVudExpc3RlbmVyLmFwcGx5KF9vYmokdGFyZ2V0LCBbb2JqLnR5cGUsIG9iai5saXN0ZW5lcl0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShvYmoub3B0aW9ucykpKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICBsaXN0LnB1c2gob2JqKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBjYWxsKCk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgIGxpc3QuZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmoudGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgX29iaiR0YXJnZXQyO1xuXG4gICAgICAgICAgICAgICAgICAgICAgKF9vYmokdGFyZ2V0MiA9IG9iai50YXJnZXQpLmFkZEV2ZW50TGlzdGVuZXIuYXBwbHkoX29iaiR0YXJnZXQyLCBbb2JqLnR5cGUsIG9iai5saXN0ZW5lcl0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShvYmoub3B0aW9ucykpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJvZmZcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9mZihpZCkge1xuICAgICAgICAgICAgICAgIGlmIChpZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIG9iaiA9IHRoaXMuX2xpc3RlbmVyc1tpZF07XG5cbiAgICAgICAgICAgICAgICBpZiAoIW9iaikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9saXN0ZW5lcnNbaWRdO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9iai50YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgdmFyIF9vYmokdGFyZ2V0MztcblxuICAgICAgICAgICAgICAgICAgKF9vYmokdGFyZ2V0MyA9IG9iai50YXJnZXQpLnJlbW92ZUV2ZW50TGlzdGVuZXIuYXBwbHkoX29iaiR0YXJnZXQzLCBbb2JqLnR5cGUsIG9iai5saXN0ZW5lcl0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShvYmoub3B0aW9ucykpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZmlyZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZmlyZSh0YXJnZXQsIHR5cGUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfbGVuOSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjkgPiAyID8gX2xlbjkgLSAyIDogMCksIF9rZXk5ID0gMjsgX2tleTkgPCBfbGVuOTsgX2tleTkrKykge1xuICAgICAgICAgICAgICAgICAgYXJnc1tfa2V5OSAtIDJdID0gYXJndW1lbnRzW19rZXk5XTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAoMCwgdXRpbHNfMS5lYWNoKSh0aGlzLl9saXN0ZW5lcnMsIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICAgIGlmIChvYmoudGFyZ2V0ID09PSB0YXJnZXQgJiYgb2JqLnR5cGUgPT09IHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9vYmokbGlzdGVuZXI7XG5cbiAgICAgICAgICAgICAgICAgICAgKF9vYmokbGlzdGVuZXIgPSBvYmoubGlzdGVuZXIpLmNhbGwuYXBwbHkoX29iaiRsaXN0ZW5lciwgW29iai50YXJnZXRdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImhhc0xpc3RlbmVyXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNMaXN0ZW5lcih0YXJnZXQsIHR5cGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgKDAsIHV0aWxzXzEuZWFjaCkodGhpcy5fbGlzdGVuZXJzLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICAgICAgICBpZiAob2JqLnRhcmdldCA9PT0gdGFyZ2V0ICYmIG9iai50eXBlID09PSB0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY2xlYXJcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgICAgICAgICAgICgwLCB1dGlsc18xLmVhY2gpKHRoaXMuX2xpc3RlbmVycywgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICAgICAgaWYgKG9iai50YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX29iaiR0YXJnZXQ0O1xuXG4gICAgICAgICAgICAgICAgICAgIChfb2JqJHRhcmdldDQgPSBvYmoudGFyZ2V0KS5yZW1vdmVFdmVudExpc3RlbmVyLmFwcGx5KF9vYmokdGFyZ2V0NCwgW29iai50eXBlLCBvYmoubGlzdGVuZXJdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkob2JqLm9wdGlvbnMpKSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0ge307XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImRpc3Bvc2VcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhcigpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gRXZlbnRIYW5kbGVyO1xuICAgICAgICAgIH0oKTtcblxuICAgICAgICAgIGV4cG9ydHMuRXZlbnRIYW5kbGVyID0gRXZlbnRIYW5kbGVyO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2ludGVybmFsL0xSVUNhY2hlLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vaW50ZXJuYWwvTFJVQ2FjaGUuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBpbnRlcm5hbExSVUNhY2hlSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5MUlVDYWNoZSA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBMUlVDYWNoZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBMUlVDYWNoZShjYWNoZVNpemUpIHtcbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExSVUNhY2hlKTtcblxuICAgICAgICAgICAgICB0aGlzLl9saXN0ID0gW107XG4gICAgICAgICAgICAgIHRoaXMuX21hcCA9IHt9O1xuICAgICAgICAgICAgICB0aGlzLl9jYWNoZVNpemUgPSBjYWNoZVNpemUgfHwgNTA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhMUlVDYWNoZSwgW3tcbiAgICAgICAgICAgICAga2V5OiBcImdldFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWwgPSB0aGlzLl9tYXBba2V5XTtcblxuICAgICAgICAgICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBsaXN0ID0gdGhpcy5fbGlzdDtcbiAgICAgICAgICAgICAgICAgIHZhciBpZHggPSBsaXN0LmluZGV4T2Yoa2V5KTtcbiAgICAgICAgICAgICAgICAgIGxpc3Quc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICAgICAgICBsaXN0LnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJwdXRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHB1dChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpc3QgPSB0aGlzLl9saXN0O1xuICAgICAgICAgICAgICAgIHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cbiAgICAgICAgICAgICAgICBpZiAobWFwW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgIHZhciBpZHggPSBsaXN0LmluZGV4T2Yoa2V5KTtcbiAgICAgICAgICAgICAgICAgIGxpc3Quc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbWFwW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBsaXN0LnB1c2goa2V5KTtcblxuICAgICAgICAgICAgICAgIGlmIChsaXN0Lmxlbmd0aCA+IHRoaXMuX2NhY2hlU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgdmFyIHJlbUtleSA9IGxpc3Quc2hpZnQoKSB8fCBcIlwiO1xuICAgICAgICAgICAgICAgICAgZGVsZXRlIG1hcFtyZW1LZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gTFJVQ2FjaGU7XG4gICAgICAgICAgfSgpO1xuXG4gICAgICAgICAgZXhwb3J0cy5MUlVDYWNoZSA9IExSVUNhY2hlO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2ludGVybmFsL051bWJlck1hcC5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9pbnRlcm5hbC9OdW1iZXJNYXAuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gaW50ZXJuYWxOdW1iZXJNYXBKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLk51bWJlck1hcCA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBpbmRleEZpcnN0ID0gZnVuY3Rpb24gaW5kZXhGaXJzdChhcnIsIGVsbSkge1xuICAgICAgICAgICAgdmFyIGxvdyA9IDA7XG4gICAgICAgICAgICB2YXIgaGlnaCA9IGFyci5sZW5ndGggLSAxO1xuXG4gICAgICAgICAgICB3aGlsZSAobG93IDw9IGhpZ2gpIHtcbiAgICAgICAgICAgICAgdmFyIGkgPSBNYXRoLmZsb29yKChsb3cgKyBoaWdoKSAvIDIpO1xuXG4gICAgICAgICAgICAgIGlmIChhcnJbaV0gPT09IGVsbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFycltpXSA+IGVsbSkge1xuICAgICAgICAgICAgICAgIGhpZ2ggPSBpIC0gMTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb3cgPSBpICsgMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaGlnaCA8IDAgPyAwIDogaGlnaDtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdmFyIE51bWJlck1hcCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBOdW1iZXJNYXAoKSB7XG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOdW1iZXJNYXApO1xuXG4gICAgICAgICAgICAgIHRoaXMuX2tleXMgPSBbXTtcbiAgICAgICAgICAgICAgdGhpcy5fdmFscyA9IHt9O1xuICAgICAgICAgICAgICB0aGlzLl9zb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKE51bWJlck1hcCwgW3tcbiAgICAgICAgICAgICAga2V5OiBcInB1dFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcHV0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShrZXkgaW4gdGhpcy5fdmFscykpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2tleXMucHVzaChrZXkpO1xuXG4gICAgICAgICAgICAgICAgICB0aGlzLl9zb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl92YWxzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwicmVtb3ZlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUoa2V5KSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3ZhbHNba2V5XTtcblxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuX2tleXMuaW5kZXhPZihrZXkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX2tleXMuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3NvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJnZXRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsc1trZXldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJoYXNcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsc1trZXldICE9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImVhY2hcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVhY2goa2V5RnJvbSwga2V5VG8sIGZuKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleXMgPSB0aGlzLl9rZXlzO1xuICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fc29ydGVkKSB7XG4gICAgICAgICAgICAgICAgICBrZXlzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGEgPCBiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGEgPiBiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgdGhpcy5fc29ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gaW5kZXhGaXJzdChrZXlzLCBrZXlGcm9tKTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICAgICAgICAgICAgaWYgKGtleUZyb20gPD0ga2V5ICYmIGtleSA8PSBrZXlUbykge1xuICAgICAgICAgICAgICAgICAgICBmbih0aGlzLmdldChrZXkpLCBrZXkpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChrZXlUbyA8IGtleSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBOdW1iZXJNYXA7XG4gICAgICAgICAgfSgpO1xuXG4gICAgICAgICAgZXhwb3J0cy5OdW1iZXJNYXAgPSBOdW1iZXJNYXA7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vaW50ZXJuYWwvUmVjdC5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vaW50ZXJuYWwvUmVjdC5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gaW50ZXJuYWxSZWN0SnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5SZWN0ID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIFJlY3QgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gUmVjdChsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlY3QpO1xuXG4gICAgICAgICAgICAgIHRoaXMuX2xlZnQgPSBsZWZ0O1xuICAgICAgICAgICAgICB0aGlzLl90b3AgPSB0b3A7XG4gICAgICAgICAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKFJlY3QsIFt7XG4gICAgICAgICAgICAgIGtleTogXCJsZWZ0XCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9sZWZ0O1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChsZWZ0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5yaWdodDtcbiAgICAgICAgICAgICAgICB0aGlzLl9sZWZ0ID0gbGVmdDtcbiAgICAgICAgICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInRvcFwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdG9wO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh0b3ApIHtcbiAgICAgICAgICAgICAgICB2YXIgYm90dG9tID0gdGhpcy5ib3R0b207XG4gICAgICAgICAgICAgICAgdGhpcy5fdG9wID0gdG9wO1xuICAgICAgICAgICAgICAgIHRoaXMuYm90dG9tID0gYm90dG9tO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJ3aWR0aFwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2lkdGg7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgICAgICB0aGlzLl9yaWdodCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiaGVpZ2h0XCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGhlaWdodCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgICAgICB0aGlzLl9ib3R0b20gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInJpZ2h0XCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yaWdodCAhPT0gdW5kZWZpbmVkID8gdGhpcy5fcmlnaHQgOiB0aGlzLl9yaWdodCA9IHRoaXMubGVmdCArIHRoaXMud2lkdGg7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmlnaHQgPSByaWdodDtcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoID0gcmlnaHQgLSB0aGlzLmxlZnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImJvdHRvbVwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYm90dG9tICE9PSB1bmRlZmluZWQgPyB0aGlzLl9ib3R0b20gOiB0aGlzLl9ib3R0b20gPSB0aGlzLnRvcCArIHRoaXMuaGVpZ2h0O1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChib3R0b20pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ib3R0b20gPSBib3R0b207XG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBib3R0b20gLSB0aGlzLnRvcDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwib2Zmc2V0TGVmdFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb2Zmc2V0TGVmdChvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sZWZ0ICs9IG9mZnNldDtcbiAgICAgICAgICAgICAgICB0aGlzLl9yaWdodCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwib2Zmc2V0VG9wXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvZmZzZXRUb3Aob2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdG9wICs9IG9mZnNldDtcbiAgICAgICAgICAgICAgICB0aGlzLl9ib3R0b20gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNvcHlcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHkoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWN0KHRoaXMubGVmdCwgdGhpcy50b3AsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiaW50ZXJzZWN0aW9uXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbnRlcnNlY3Rpb24ocmVjdCkge1xuICAgICAgICAgICAgICAgIHZhciB4MCA9IE1hdGgubWF4KHRoaXMubGVmdCwgcmVjdC5sZWZ0KTtcbiAgICAgICAgICAgICAgICB2YXIgeDEgPSBNYXRoLm1pbih0aGlzLmxlZnQgKyB0aGlzLndpZHRoLCByZWN0LmxlZnQgKyByZWN0LndpZHRoKTtcblxuICAgICAgICAgICAgICAgIGlmICh4MCA8PSB4MSkge1xuICAgICAgICAgICAgICAgICAgdmFyIHkwID0gTWF0aC5tYXgodGhpcy50b3AsIHJlY3QudG9wKTtcbiAgICAgICAgICAgICAgICAgIHZhciB5MSA9IE1hdGgubWluKHRoaXMudG9wICsgdGhpcy5oZWlnaHQsIHJlY3QudG9wICsgcmVjdC5oZWlnaHQpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoeTAgPD0geTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlY3QuYm91bmRzKHgwLCB5MCwgeDEsIHkxKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY29udGFpbnNcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnRhaW5zKGFub3RoZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sZWZ0IDw9IGFub3RoZXIubGVmdCAmJiB0aGlzLmxlZnQgKyB0aGlzLndpZHRoID49IGFub3RoZXIubGVmdCArIGFub3RoZXIud2lkdGggJiYgdGhpcy50b3AgPD0gYW5vdGhlci50b3AgJiYgdGhpcy50b3AgKyB0aGlzLmhlaWdodCA+PSBhbm90aGVyLnRvcCArIGFub3RoZXIuaGVpZ2h0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJpblBvaW50XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpblBvaW50KHgsIHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sZWZ0IDw9IHggJiYgdGhpcy5sZWZ0ICsgdGhpcy53aWR0aCA+PSB4ICYmIHRoaXMudG9wIDw9IHkgJiYgdGhpcy50b3AgKyB0aGlzLmhlaWdodCA+PSB5O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSwgW3tcbiAgICAgICAgICAgICAga2V5OiBcImJvdW5kc1wiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYm91bmRzKGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmVjdChsZWZ0LCB0b3AsIHJpZ2h0IC0gbGVmdCwgYm90dG9tIC0gdG9wKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwibWF4XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBtYXgocmVjdDEsIHJlY3QyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlY3QuYm91bmRzKE1hdGgubWluKHJlY3QxLmxlZnQsIHJlY3QyLmxlZnQpLCBNYXRoLm1pbihyZWN0MS50b3AsIHJlY3QyLnRvcCksIE1hdGgubWF4KHJlY3QxLnJpZ2h0LCByZWN0Mi5yaWdodCksIE1hdGgubWF4KHJlY3QxLmJvdHRvbSwgcmVjdDIuYm90dG9tKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIFJlY3Q7XG4gICAgICAgICAgfSgpO1xuXG4gICAgICAgICAgZXhwb3J0cy5SZWN0ID0gUmVjdDtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9pbnRlcm5hbC9TY3JvbGxhYmxlLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9pbnRlcm5hbC9TY3JvbGxhYmxlLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBpbnRlcm5hbFNjcm9sbGFibGVKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIHZhciBfX2NyZWF0ZUJpbmRpbmcgPSB0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nIHx8IChPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24gKG8sIG0sIGssIGsyKSB7XG4gICAgICAgICAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgICAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuXG4gICAgICAgICAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgICAgICAgICBkZXNjID0ge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbVtrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG4gICAgICAgICAgfSA6IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICAgICAgICAgICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICAgICAgICAgIG9bazJdID0gbVtrXTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBfX3NldE1vZHVsZURlZmF1bHQgPSB0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0IHx8IChPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24gKG8sIHYpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwge1xuICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICB2YWx1ZTogdlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSA6IGZ1bmN0aW9uIChvLCB2KSB7XG4gICAgICAgICAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgX19pbXBvcnRTdGFyID0gdGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhciB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgICAgICAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICAgICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkge1xuICAgICAgICAgICAgICBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLlNjcm9sbGFibGUgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgc3R5bGUgPSBfX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9zdHlsZSAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC9zdHlsZS5qc1wiKSk7XG5cbiAgICAgICAgICB2YXIgRXZlbnRIYW5kbGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL0V2ZW50SGFuZGxlciAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC9FdmVudEhhbmRsZXIuanNcIik7XG5cbiAgICAgICAgICB2YXIgdXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vdXRpbHMgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvdXRpbHMuanNcIik7XG5cbiAgICAgICAgICB2YXIgTUFYX1NDUk9MTCA9IHV0aWxzXzEuYnJvd3Nlci5oZWlnaHRMaW1pdCAtIDEwMDA7XG5cbiAgICAgICAgICB2YXIgU2Nyb2xsYWJsZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBTY3JvbGxhYmxlKCkge1xuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2Nyb2xsYWJsZSk7XG5cbiAgICAgICAgICAgICAgdGhpcy5fcCA9IDE7XG4gICAgICAgICAgICAgIHRoaXMuX2hhbmRsZXIgPSBuZXcgRXZlbnRIYW5kbGVyXzEuRXZlbnRIYW5kbGVyKCk7XG4gICAgICAgICAgICAgIHRoaXMuX3Njcm9sbGFibGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXG4gICAgICAgICAgICAgIHRoaXMuX3Njcm9sbGFibGUuY2xhc3NMaXN0LmFkZChcImdyaWQtc2Nyb2xsYWJsZVwiKTtcblxuICAgICAgICAgICAgICB0aGlzLl9oZWlnaHQgPSAwO1xuICAgICAgICAgICAgICB0aGlzLl93aWR0aCA9IDA7XG4gICAgICAgICAgICAgIHRoaXMuX2VuZFBvaW50RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cbiAgICAgICAgICAgICAgdGhpcy5fZW5kUG9pbnRFbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJncmlkLXNjcm9sbC1lbmQtcG9pbnRcIik7XG5cbiAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG5cbiAgICAgICAgICAgICAgdGhpcy5fc2Nyb2xsYWJsZS5hcHBlbmRDaGlsZCh0aGlzLl9lbmRQb2ludEVsZW1lbnQpOyAvLyBjb25zdCBtb3VzZXdoZWVsZXZ0ID0gKC9GaXJlZm94L2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkgPyAnRE9NTW91c2VTY3JvbGwnIDogJ21vdXNld2hlZWwnOyAvL0ZGIGRvZXNuJ3QgcmVjb2duaXplIG1vdXNld2hlZWwgYXMgb2YgRkYzLnhcbiAgICAgICAgICAgICAgLy8gdGhpcy5faGFuZGxlci5vbih0aGlzLl9zY3JvbGxhYmxlLCBtb3VzZXdoZWVsZXZ0LCAoZXZ0KSA9PiB7XG4gICAgICAgICAgICAgIC8vIGNvbnN0IGRlbHRhID0gZXZ0LmRldGFpbCA/IGV2dC5kZXRhaWwgKiAoLTEyMCkgOiBldnQud2hlZWxEZWx0YTtcbiAgICAgICAgICAgICAgLy8gY29uc3QgcG9pbnQgPSBNYXRoLm1pbihNYXRoLmFicyhkZWx0YSkgLyAxMiwgdGhpcy5zY3JvbGxIZWlnaHQgLyA1KTtcbiAgICAgICAgICAgICAgLy8gdGhpcy5zY3JvbGxUb3AgKz0gZGVsdGEgPCAwID8gcG9pbnQgOiAtcG9pbnQ7XG4gICAgICAgICAgICAgIC8vIH0pO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhTY3JvbGxhYmxlLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiY2FsY1RvcFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY1RvcCh0b3ApIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVsYXRpdmVUb3AgPSB0b3AgLSB0aGlzLnNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2Nyb2xsYWJsZS5zY3JvbGxUb3AgKyByZWxhdGl2ZVRvcDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0RWxlbWVudFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RWxlbWVudCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2Nyb2xsYWJsZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwic2V0U2Nyb2xsU2l6ZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U2Nyb2xsU2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwic2Nyb2xsV2lkdGhcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dpZHRoO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh3aWR0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwic2Nyb2xsSGVpZ2h0XCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGhlaWdodCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJzY3JvbGxMZWZ0XCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLm1heChNYXRoLmNlaWwodGhpcy5fc2Nyb2xsYWJsZS5zY3JvbGxMZWZ0KSwgMCk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHNjcm9sbExlZnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zY3JvbGxhYmxlLnNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJzY3JvbGxUb3BcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KE1hdGguY2VpbCh0aGlzLl9zY3JvbGxhYmxlLnNjcm9sbFRvcCAvIHRoaXMuX3ApLCAwKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoc2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2Nyb2xsYWJsZS5zY3JvbGxUb3AgPSBzY3JvbGxUb3AgKiB0aGlzLl9wO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJvblNjcm9sbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25TY3JvbGwoZm4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyLm9uKHRoaXMuX3Njcm9sbGFibGUsIFwic2Nyb2xsXCIsIGZuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZGlzcG9zZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiX3VwZGF0ZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZSgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZG9tSGVpZ2h0O1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyRfc2Nyb2xsYWJsZSA9IHRoaXMuX3Njcm9sbGFibGUsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldEhlaWdodCA9IF90aGlzJF9zY3JvbGxhYmxlLm9mZnNldEhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0V2lkdGggPSBfdGhpcyRfc2Nyb2xsYWJsZS5vZmZzZXRXaWR0aDtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9oZWlnaHQgPiBNQVhfU0NST0xMKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgc2JTaXplID0gc3R5bGUuZ2V0U2Nyb2xsQmFyU2l6ZSgpO1xuICAgICAgICAgICAgICAgICAgdmFyIHZTY3JvbGxSYW5nZSA9IE1BWF9TQ1JPTEwgLSBvZmZzZXRIZWlnaHQgKyBzYlNpemU7XG4gICAgICAgICAgICAgICAgICB2YXIgclNjcm9sbFJhbmdlID0gdGhpcy5faGVpZ2h0IC0gb2Zmc2V0SGVpZ2h0ICsgc2JTaXplO1xuICAgICAgICAgICAgICAgICAgdGhpcy5fcCA9IHZTY3JvbGxSYW5nZSAvIHJTY3JvbGxSYW5nZTtcbiAgICAgICAgICAgICAgICAgIGRvbUhlaWdodCA9IE1BWF9TQ1JPTEw7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3AgPSAxO1xuICAgICAgICAgICAgICAgICAgZG9tSGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX2VuZFBvaW50RWxlbWVudC5zdHlsZS50b3AgPSBcIlwiLmNvbmNhdChkb21IZWlnaHQudG9GaXhlZCgpLCBcInB4XCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2VuZFBvaW50RWxlbWVudC5zdHlsZS5sZWZ0ID0gXCJcIi5jb25jYXQodGhpcy5fd2lkdGgudG9GaXhlZCgpLCBcInB4XCIpOyAvLyBTZXRzIHRoZSBtYXhpbXVtIHZhbHVlIHRvIHRoZSBzY3JvbGwgcG9zaXRpb25cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgY3VycmVudCBzY3JvbGwgcG9zaXRpb24gZXhjZWVkcyB0aGUgbWF4aW11bSB2YWx1ZS5cblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNjcm9sbFRvcCA+IHRoaXMuc2Nyb2xsSGVpZ2h0IC0gb2Zmc2V0SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbFRvcCA9IHRoaXMuc2Nyb2xsSGVpZ2h0IC0gb2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNjcm9sbExlZnQgPiB0aGlzLnNjcm9sbFdpZHRoIC0gb2Zmc2V0V2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsTGVmdCA9IHRoaXMuc2Nyb2xsV2lkdGggLSBvZmZzZXRXaWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIFNjcm9sbGFibGU7XG4gICAgICAgICAgfSgpO1xuXG4gICAgICAgICAgZXhwb3J0cy5TY3JvbGxhYmxlID0gU2Nyb2xsYWJsZTtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9pbnRlcm5hbC9hbmltYXRlLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9pbnRlcm5hbC9hbmltYXRlLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBpbnRlcm5hbEFuaW1hdGVKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLmFuaW1hdGUgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgdXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vdXRpbHMgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvdXRpbHMuanNcIik7XG5cbiAgICAgICAgICBmdW5jdGlvbiBjdWJpY0Jlemllcih4MiwgeTIsIHgzLCB5Mykge1xuICAgICAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgICAgICB2YXIgZXJyID0gMC4wMDAxO1xuICAgICAgICAgICAgeDIgKj0gMztcbiAgICAgICAgICAgIHkyICo9IDM7XG4gICAgICAgICAgICB4MyAqPSAzO1xuICAgICAgICAgICAgeTMgKj0gMztcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICB2YXIgcCwgYSwgYiwgYywgZCwgeCwgcztcblxuICAgICAgICAgICAgICBpZiAodCA8IDAgfHwgMSA8IHQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIi5jb25jYXQodCkpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcCA9IHN0ZXAgfHwgdDtcblxuICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgYSA9IDEgLSBwO1xuICAgICAgICAgICAgICAgIGIgPSBhICogYTtcbiAgICAgICAgICAgICAgICBjID0gcCAqIHA7XG4gICAgICAgICAgICAgICAgZCA9IGMgKiBwO1xuICAgICAgICAgICAgICAgIHggPSB4MiAqIGIgKiBwICsgeDMgKiBhICogYyArIGQ7XG4gICAgICAgICAgICAgICAgcyA9IHQgLSB4O1xuICAgICAgICAgICAgICAgIHAgKz0gcyAqIDAuNTtcbiAgICAgICAgICAgICAgfSB3aGlsZSAoZXJyIDwgTWF0aC5hYnMocykpO1xuXG4gICAgICAgICAgICAgIHN0ZXAgPSBwO1xuICAgICAgICAgICAgICByZXR1cm4geTIgKiBiICogcCArIHkzICogYSAqIGMgKyBkO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgRUFTSU5HUyA9IHtcbiAgICAgICAgICAgIGxpbmVhcjogZnVuY3Rpb24gbGluZWFyKHApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZWFzZUluOiBjdWJpY0JlemllcigwLjQyLCAwLjAsIDEuMCwgMS4wKSxcbiAgICAgICAgICAgIGVhc2VPdXQ6IGN1YmljQmV6aWVyKDAuMCwgMC4wLCAwLjU4LCAxLjApLFxuICAgICAgICAgICAgZWFzZUluT3V0OiBjdWJpY0JlemllcigwLjQyLCAwLjAsIDAuNTgsIDEuMClcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciByYWYgPSB1dGlsc18xLmlzTm9kZSA/IGZ1bmN0aW9uICgpIHt9IDogd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgIGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZm4sIDEpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBmdW5jdGlvbiBub3coKSB7XG4gICAgICAgICAgICByZXR1cm4gRGF0ZS5ub3coKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogPHByZT5cbiAgICAgICAgICAgKiBBbmltYXRlcy5cbiAgICAgICAgICAgKiA8L3ByZT5cbiAgICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb24gYW5pbWF0aW9uIHRpbWUuXG4gICAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gc3RlcCBzdGVwXG4gICAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbnxzdHJpbmd9IGVhc2luZyBlYXNpbmdcbiAgICAgICAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBEZWZlcnJlZCBvYmplY3QuXG4gICAgICAgICAgICovXG5cblxuICAgICAgICAgIGZ1bmN0aW9uIGFuaW1hdGUoZHVyYXRpb24sIHN0ZXAsIGVhc2luZykge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ZWRBdCA9IG5vdygpO1xuICAgICAgICAgICAgdmFyIGVhc2luZ0ZuID0gZWFzaW5nID09IG51bGwgPyBFQVNJTkdTLmVhc2VJbk91dCA6IHR5cGVvZiBlYXNpbmcgPT09IFwic3RyaW5nXCIgPyBFQVNJTkdTW2Vhc2luZ10gOiBlYXNpbmc7XG4gICAgICAgICAgICB2YXIgY2FuY2VsZWRGbGcgPSBmYWxzZTtcblxuICAgICAgICAgICAgdmFyIGNyZWF0ZUFuaW0gPSBmdW5jdGlvbiBjcmVhdGVBbmltKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICB2YXIgYW5pbSA9IGZ1bmN0aW9uIGFuaW0oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvaW50ID0gbm93KCkgLSBzdGFydGVkQXQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoY2FuY2VsZWRGbGcpIHtcbiAgICAgICAgICAgICAgICAgIC8vY2FuY2VsXG4gICAgICAgICAgICAgICAgICBpZiAocmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocG9pbnQgPj0gZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgIC8vZW5kXG4gICAgICAgICAgICAgICAgICBzdGVwKDEpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHN0ZXAoZWFzaW5nRm4ocG9pbnQgLyBkdXJhdGlvbikpO1xuICAgICAgICAgICAgICAgICAgcmFmKGFuaW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICByZXR1cm4gYW5pbTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBjYW5jZWwgPSBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgICAgICAgICAgIGNhbmNlbGVkRmxnID0gdHJ1ZTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgUHJvbWlzZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIHZhciBhbmltID0gY3JlYXRlQW5pbShyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgIHN0ZXAoMCk7XG4gICAgICAgICAgICAgICAgYW5pbSgpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmVzdWx0LmNhbmNlbCA9IGNhbmNlbDtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBhbmltID0gY3JlYXRlQW5pbShmdW5jdGlvbiAoKSB7fSwgZnVuY3Rpb24gKCkge30pO1xuICAgICAgICAgICAgICBzdGVwKDApO1xuICAgICAgICAgICAgICBhbmltKCk7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY2FuY2VsOiBjYW5jZWxcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRzLmFuaW1hdGUgPSBhbmltYXRlO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2ludGVybmFsL2NhbGMuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2ludGVybmFsL2NhbGMuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGludGVybmFsQ2FsY0pzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMudG9QeCA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi91dGlscyAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC91dGlscy5qc1wiKTtcblxuICAgICAgICAgIHZhciBUWVBFX1BBUkVOID0gMDtcbiAgICAgICAgICB2YXIgVFlQRV9VTklUID0gMTtcbiAgICAgICAgICB2YXIgVFlQRV9PUEVSQVRPUiA9IDI7XG4gICAgICAgICAgdmFyIFRZUEVfTlVNQkVSID0gMztcbiAgICAgICAgICB2YXIgTk9ERV9UWVBFX1VOSVQgPSAxMDtcbiAgICAgICAgICB2YXIgTk9ERV9UWVBFX0JJTkFSWV9FWFBSRVNTSU9OID0gMTE7XG4gICAgICAgICAgdmFyIE5PREVfVFlQRV9OVU1CRVIgPSAxMjtcbiAgICAgICAgICB2YXIgVEFCVUxBVElPTiA9IDB4MDk7XG4gICAgICAgICAgdmFyIENBUlJJQUdFX1JFVFVSTiA9IDB4MGQ7XG4gICAgICAgICAgdmFyIExJTkVfRkVFRCA9IDB4MGE7XG4gICAgICAgICAgdmFyIEZPUk1fRkVFRCA9IDB4MGM7XG4gICAgICAgICAgdmFyIFNQQUNFID0gMHgyMDtcbiAgICAgICAgICB2YXIgUEVSQ0VOVCA9IDB4MjU7XG4gICAgICAgICAgdmFyIEZVTExfU1RPUCA9IDB4MmU7XG4gICAgICAgICAgdmFyIERJR0lUXzAgPSAweDMwO1xuICAgICAgICAgIHZhciBESUdJVF85ID0gMHgzOTtcbiAgICAgICAgICB2YXIgTEFUSU5fQ0FQSVRBTF9BID0gMHg0MTtcbiAgICAgICAgICB2YXIgTEFUSU5fQ0FQSVRBTF9aID0gMHg1YTtcbiAgICAgICAgICB2YXIgTEFUSU5fU01BTExfQSA9IDB4NjE7XG4gICAgICAgICAgdmFyIExBVElOX1NNQUxMX1ogPSAweDdhO1xuXG4gICAgICAgICAgZnVuY3Rpb24gaXNVcHBlckxldHRlcihjcCkge1xuICAgICAgICAgICAgcmV0dXJuIGNwID49IExBVElOX0NBUElUQUxfQSAmJiBjcCA8PSBMQVRJTl9DQVBJVEFMX1o7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gaXNMb3dlckxldHRlcihjcCkge1xuICAgICAgICAgICAgcmV0dXJuIGNwID49IExBVElOX1NNQUxMX0EgJiYgY3AgPD0gTEFUSU5fU01BTExfWjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBpc0xldHRlcihjcCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzTG93ZXJMZXR0ZXIoY3ApIHx8IGlzVXBwZXJMZXR0ZXIoY3ApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGlzV2hpdGVzcGFjZShjcCkge1xuICAgICAgICAgICAgcmV0dXJuIGNwID09PSBUQUJVTEFUSU9OIHx8IGNwID09PSBMSU5FX0ZFRUQgfHwgY3AgPT09IEZPUk1fRkVFRCB8fCBjcCA9PT0gQ0FSUklBR0VfUkVUVVJOIHx8IGNwID09PSBTUEFDRTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBpc0RpZ2l0KGNwKSB7XG4gICAgICAgICAgICByZXR1cm4gY3AgPj0gRElHSVRfMCAmJiBjcCA8PSBESUdJVF85O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGlzRG90KGNwKSB7XG4gICAgICAgICAgICByZXR1cm4gY3AgPT09IEZVTExfU1RPUDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBpc1VuaXQoY3ApIHtcbiAgICAgICAgICAgIHJldHVybiBpc0xldHRlcihjcCkgfHwgY3AgPT09IFBFUkNFTlQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gY3JlYXRlRXJyb3IoY2FsYykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcImNhbGMgcGFyc2UgZXJyb3I6IFwiLmNvbmNhdChjYWxjKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIHRva2VuaXplXG4gICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNhbGMgY2FsYyBleHByZXNzaW9uXG4gICAgICAgICAgICogQHJldHVybnMge0FycmF5fSB0b2tlbnNcbiAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAqL1xuXG5cbiAgICAgICAgICBmdW5jdGlvbiB0b2tlbml6ZShjYWxjKSB7XG4gICAgICAgICAgICB2YXIgZXhwID0gY2FsYy5yZXBsYWNlKC9jYWxjXFwoL2csIFwiKFwiKS50cmltKCk7XG4gICAgICAgICAgICB2YXIgdG9rZW5zID0gW107XG4gICAgICAgICAgICB2YXIgbGVuID0gZXhwLmxlbmd0aDtcblxuICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbjsgaW5kZXgrKykge1xuICAgICAgICAgICAgICB2YXIgYyA9IGV4cFtpbmRleF07XG4gICAgICAgICAgICAgIHZhciBjcCA9IGMuY2hhckNvZGVBdCgwKTtcblxuICAgICAgICAgICAgICBpZiAoYyA9PT0gXCIoXCIgfHwgYyA9PT0gXCIpXCIpIHtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICB2YWx1ZTogYyxcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFRZUEVfUEFSRU5cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChjID09PSBcIipcIiB8fCBjID09PSBcIi9cIikge1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBjLFxuICAgICAgICAgICAgICAgICAgdHlwZTogVFlQRV9PUEVSQVRPUlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09IFwiK1wiIHx8IGMgPT09IFwiLVwiKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBwYXJzZVNpZ24oYywgaW5kZXggKyAxKSAtIDE7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNEaWdpdChjcCkgfHwgaXNEb3QoY3ApKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBwYXJzZU51bShjLCBpbmRleCArIDEpIC0gMTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc1doaXRlc3BhY2UoY3ApKSB7Ly8gc2tpcFxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZUVycm9yKGNhbGMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHBhcnNlU2lnbihzaWduLCBzdGFydCkge1xuICAgICAgICAgICAgICBpZiAoc3RhcnQgPCBsZW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgX2MzID0gZXhwW3N0YXJ0XTtcblxuICAgICAgICAgICAgICAgIHZhciBfY3AgPSBfYzMuY2hhckNvZGVBdCgwKTtcblxuICAgICAgICAgICAgICAgIGlmIChpc0RpZ2l0KF9jcCkgfHwgaXNEb3QoX2NwKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlTnVtKHNpZ24gKyBfYzMsIHN0YXJ0ICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICAgIHZhbHVlOiBzaWduLFxuICAgICAgICAgICAgICAgIHR5cGU6IFRZUEVfT1BFUkFUT1JcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJldHVybiBzdGFydDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gcGFyc2VOdW0obnVtLCBzdGFydCkge1xuICAgICAgICAgICAgICB2YXIgaW5kZXggPSBzdGFydDtcblxuICAgICAgICAgICAgICBmb3IgKDsgaW5kZXggPCBsZW47IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgX2M0ID0gZXhwW2luZGV4XTtcblxuICAgICAgICAgICAgICAgIHZhciBfY3AyID0gX2M0LmNoYXJDb2RlQXQoMCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNEaWdpdChfY3AyKSkge1xuICAgICAgICAgICAgICAgICAgbnVtICs9IF9jNDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKF9jNCA9PT0gXCIuXCIpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChudW0uaW5kZXhPZihcIi5cIikgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVFcnJvcihjYWxjKTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgbnVtICs9IF9jNDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzVW5pdChfY3AyKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlVW5pdChudW0sIF9jNCwgaW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKG51bSA9PT0gXCIuXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVFcnJvcihjYWxjKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogcGFyc2VGbG9hdChudW0pLFxuICAgICAgICAgICAgICAgIHR5cGU6IFRZUEVfTlVNQkVSXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHBhcnNlVW5pdChudW0sIHVuaXQsIHN0YXJ0KSB7XG4gICAgICAgICAgICAgIHZhciBpbmRleCA9IHN0YXJ0O1xuXG4gICAgICAgICAgICAgIGZvciAoOyBpbmRleCA8IGxlbjsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgIHZhciBfYzUgPSBleHBbaW5kZXhdO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9jcDMgPSBfYzUuY2hhckNvZGVBdCgwKTtcblxuICAgICAgICAgICAgICAgIGlmIChpc1VuaXQoX2NwMykpIHtcbiAgICAgICAgICAgICAgICAgIHVuaXQgKz0gX2M1O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHBhcnNlRmxvYXQobnVtKSxcbiAgICAgICAgICAgICAgICB1bml0OiB1bml0LFxuICAgICAgICAgICAgICAgIHR5cGU6IFRZUEVfVU5JVFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBQUkVDRURFTkNFID0ge1xuICAgICAgICAgICAgXCIqXCI6IDMsXG4gICAgICAgICAgICBcIi9cIjogMyxcbiAgICAgICAgICAgIFwiK1wiOiAyLFxuICAgICAgICAgICAgXCItXCI6IDJcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgZnVuY3Rpb24gbGV4KHRva2VucywgY2FsYykge1xuICAgICAgICAgICAgZnVuY3Rpb24gYnVpbGRCaW5hcnlFeHBOb2RlKHN0YWNrKSB7XG4gICAgICAgICAgICAgIHZhciByaWdodCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICB2YXIgb3AgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgdmFyIGxlZnQgPSBzdGFjay5wb3AoKTtcblxuICAgICAgICAgICAgICBpZiAoIWxlZnQgfHwgIWxlZnQubm9kZVR5cGUgfHwgIW9wIHx8IG9wLnR5cGUgIT09IFRZUEVfT1BFUkFUT1IgfHwgIXJpZ2h0IHx8ICFyaWdodC5ub2RlVHlwZSkge1xuICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZUVycm9yKGNhbGMpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBub2RlVHlwZTogTk9ERV9UWVBFX0JJTkFSWV9FWFBSRVNTSU9OLFxuICAgICAgICAgICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgICAgICAgICAgb3A6IG9wLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiByaWdodFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc3RhY2sgPSBbXTtcblxuICAgICAgICAgICAgd2hpbGUgKHRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgdmFyIHRva2VuID0gdG9rZW5zLnNoaWZ0KCk7XG5cbiAgICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRZUEVfUEFSRU4gJiYgdG9rZW4udmFsdWUgPT09IFwiKFwiKSB7XG4gICAgICAgICAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBkZWVwID0gMDtcbiAgICAgICAgICAgICAgICAgIHZhciBjbG9zZUluZGV4ID0gdXRpbHNfMS5hcnJheS5maW5kSW5kZXgodG9rZW5zLCBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodC50eXBlID09PSBUWVBFX1BBUkVOICYmIHQudmFsdWUgPT09IFwiKFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZGVlcCsrO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHQudHlwZSA9PT0gVFlQRV9QQVJFTiAmJiB0LnZhbHVlID09PSBcIilcIikge1xuICAgICAgICAgICAgICAgICAgICAgIGlmICghZGVlcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgZGVlcC0tO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChjbG9zZUluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVFcnJvcihjYWxjKTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChsZXgodG9rZW5zLnNwbGljZSgwLCBjbG9zZUluZGV4KSwgY2FsYykpO1xuICAgICAgICAgICAgICAgICAgdG9rZW5zLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0b2tlbi50eXBlID09PSBUWVBFX09QRVJBVE9SKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+PSAzKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgYmVmb3JlT3AgPSBzdGFja1tzdGFjay5sZW5ndGggLSAyXS52YWx1ZTtcblxuICAgICAgICAgICAgICAgICAgaWYgKFBSRUNFREVOQ0VbdG9rZW4udmFsdWVdIDw9IFBSRUNFREVOQ0VbYmVmb3JlT3BdKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goYnVpbGRCaW5hcnlFeHBOb2RlKHN0YWNrKSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gVFlQRV9VTklUKSB7XG4gICAgICAgICAgICAgICAgdmFyIG51bSA9IHRva2VuLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB1bml0ID0gdG9rZW4udW5pdDtcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIG5vZGVUeXBlOiBOT0RFX1RZUEVfVU5JVCxcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBudW0sXG4gICAgICAgICAgICAgICAgICB1bml0OiB1bml0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gVFlQRV9OVU1CRVIpIHtcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIG5vZGVUeXBlOiBOT0RFX1RZUEVfTlVNQkVSLFxuICAgICAgICAgICAgICAgICAgdmFsdWU6IHRva2VuLnZhbHVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgc3RhY2sucHVzaChidWlsZEJpbmFyeUV4cE5vZGUoc3RhY2spKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHN0YWNrWzBdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHBhcnNlKGNhbGNTdHIpIHtcbiAgICAgICAgICAgIHZhciB0b2tlbnMgPSB0b2tlbml6ZShjYWxjU3RyKTtcbiAgICAgICAgICAgIHJldHVybiBsZXgodG9rZW5zLCBjYWxjU3RyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBjYWxjTm9kZShub2RlLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTk9ERV9UWVBFX0JJTkFSWV9FWFBSRVNTSU9OKSB7XG4gICAgICAgICAgICAgIHZhciBsZWZ0ID0gY2FsY05vZGUobm9kZS5sZWZ0LCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgdmFyIHJpZ2h0ID0gY2FsY05vZGUobm9kZS5yaWdodCwgY29udGV4dCk7XG5cbiAgICAgICAgICAgICAgc3dpdGNoIChub2RlLm9wLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIitcIjpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0ICsgcmlnaHQ7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFwiLVwiOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgLSByaWdodDtcblxuICAgICAgICAgICAgICAgIGNhc2UgXCIqXCI6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCAqIHJpZ2h0O1xuXG4gICAgICAgICAgICAgICAgY2FzZSBcIi9cIjpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0IC8gcmlnaHQ7XG5cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC10ZW1wbGF0ZS1leHByZXNzaW9uc1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2FsYyBlcnJvci4gdW5rbm93biBvcGVyYXRvcjogXCIuY29uY2F0KG5vZGUub3AudmFsdWUpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09PSBOT0RFX1RZUEVfVU5JVCkge1xuICAgICAgICAgICAgICBzd2l0Y2ggKG5vZGUudW5pdCkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCIlXCI6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS52YWx1ZSAqIGNvbnRleHQuZnVsbCAvIDEwMDtcblxuICAgICAgICAgICAgICAgIGNhc2UgXCJlbVwiOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUudmFsdWUgKiBjb250ZXh0LmVtO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBcInB4XCI6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS52YWx1ZTtcblxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYWxjIGVycm9yLiB1bmtub3duIHVuaXQ6IFwiLmNvbmNhdChub2RlLnVuaXQpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09PSBOT0RFX1RZUEVfTlVNQkVSKSB7XG4gICAgICAgICAgICAgIHJldHVybiBub2RlLnZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYWxjIGVycm9yLlwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiB0b1B4SW50ZXJuYWwodmFsdWUsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBhc3QgPSBwYXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gY2FsY05vZGUoYXN0LCBjb250ZXh0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiB0b1B4KHZhbHVlLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0b1B4SW50ZXJuYWwodmFsdWUudHJpbSgpLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlIC0gMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRzLnRvUHggPSB0b1B4O1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2ludGVybmFsL2NhbnZhc2VzLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vaW50ZXJuYWwvY2FudmFzZXMuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBpbnRlcm5hbENhbnZhc2VzSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5jYWxjU3RhcnRQb3NpdGlvbiA9IGV4cG9ydHMuY2FsY0Jhc2VQb3NpdGlvbiA9IGV4cG9ydHMuZ2V0Rm9udFNpemUgPSB2b2lkIDA7XG4gICAgICAgICAgdmFyIGZvbnRTaXplQ2FjaGUgPSB7fTtcblxuICAgICAgICAgIGZ1bmN0aW9uIGdldEZvbnRTaXplKGN0eCwgZm9udCkge1xuICAgICAgICAgICAgdmFyIGZvbnROYW1lID0gZm9udCB8fCBjdHguZm9udDtcblxuICAgICAgICAgICAgaWYgKGZvbnRTaXplQ2FjaGVbZm9udE5hbWVdKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmb250U2l6ZUNhY2hlW2ZvbnROYW1lXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGJrID0gY3R4LmZvbnQ7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGN0eC5mb250ID0gZm9udE5hbWU7XG4gICAgICAgICAgICAgIHZhciBlbSA9IGN0eC5tZWFzdXJlVGV4dChcIuOBglwiKS53aWR0aDtcbiAgICAgICAgICAgICAgcmV0dXJuIGZvbnRTaXplQ2FjaGVbZm9udE5hbWVdID0ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiBlbSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGVtXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICBjdHguZm9udCA9IGJrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMuZ2V0Rm9udFNpemUgPSBnZXRGb250U2l6ZTtcblxuICAgICAgICAgIGZ1bmN0aW9uIGNhbGNCYXNlUG9zaXRpb24oY3R4LCByZWN0KSB7XG4gICAgICAgICAgICB2YXIgX3JlZjc4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fSxcbiAgICAgICAgICAgICAgICBfcmVmNzgkb2Zmc2V0ID0gX3JlZjc4Lm9mZnNldCxcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBfcmVmNzgkb2Zmc2V0ID09PSB2b2lkIDAgPyAwIDogX3JlZjc4JG9mZnNldCxcbiAgICAgICAgICAgICAgICBfcmVmNzgkcGFkZGluZyA9IF9yZWY3OC5wYWRkaW5nO1xuXG4gICAgICAgICAgICBfcmVmNzgkcGFkZGluZyA9IF9yZWY3OCRwYWRkaW5nID09PSB2b2lkIDAgPyB7fSA6IF9yZWY3OCRwYWRkaW5nO1xuICAgICAgICAgICAgdmFyIF9yZWY3OCRwYWRkaW5nJGxlZnQgPSBfcmVmNzgkcGFkZGluZy5sZWZ0LFxuICAgICAgICAgICAgICAgIHBhZGRpbmdMZWZ0ID0gX3JlZjc4JHBhZGRpbmckbGVmdCA9PT0gdm9pZCAwID8gMCA6IF9yZWY3OCRwYWRkaW5nJGxlZnQsXG4gICAgICAgICAgICAgICAgX3JlZjc4JHBhZGRpbmckcmlnaHQgPSBfcmVmNzgkcGFkZGluZy5yaWdodCxcbiAgICAgICAgICAgICAgICBwYWRkaW5nUmlnaHQgPSBfcmVmNzgkcGFkZGluZyRyaWdodCA9PT0gdm9pZCAwID8gMCA6IF9yZWY3OCRwYWRkaW5nJHJpZ2h0LFxuICAgICAgICAgICAgICAgIF9yZWY3OCRwYWRkaW5nJHRvcCA9IF9yZWY3OCRwYWRkaW5nLnRvcCxcbiAgICAgICAgICAgICAgICBwYWRkaW5nVG9wID0gX3JlZjc4JHBhZGRpbmckdG9wID09PSB2b2lkIDAgPyAwIDogX3JlZjc4JHBhZGRpbmckdG9wLFxuICAgICAgICAgICAgICAgIF9yZWY3OCRwYWRkaW5nJGJvdHRvbSA9IF9yZWY3OCRwYWRkaW5nLmJvdHRvbSxcbiAgICAgICAgICAgICAgICBwYWRkaW5nQm90dG9tID0gX3JlZjc4JHBhZGRpbmckYm90dG9tID09PSB2b2lkIDAgPyAwIDogX3JlZjc4JHBhZGRpbmckYm90dG9tO1xuICAgICAgICAgICAgcmV0dXJuIGNhbGNTdGFydFBvc2l0aW9uKGN0eCwgcmVjdCwgMCwgMCwge1xuICAgICAgICAgICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgICAgICAgICAgcGFkZGluZzoge1xuICAgICAgICAgICAgICAgIGxlZnQ6IHBhZGRpbmdMZWZ0LFxuICAgICAgICAgICAgICAgIHJpZ2h0OiBwYWRkaW5nUmlnaHQsXG4gICAgICAgICAgICAgICAgdG9wOiBwYWRkaW5nVG9wLFxuICAgICAgICAgICAgICAgIGJvdHRvbTogcGFkZGluZ0JvdHRvbVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRzLmNhbGNCYXNlUG9zaXRpb24gPSBjYWxjQmFzZVBvc2l0aW9uO1xuXG4gICAgICAgICAgZnVuY3Rpb24gY2FsY1N0YXJ0UG9zaXRpb24oY3R4LCByZWN0LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICB2YXIgX3JlZjc5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiB7fSxcbiAgICAgICAgICAgICAgICBfcmVmNzkkb2Zmc2V0ID0gX3JlZjc5Lm9mZnNldCxcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBfcmVmNzkkb2Zmc2V0ID09PSB2b2lkIDAgPyAwIDogX3JlZjc5JG9mZnNldCxcbiAgICAgICAgICAgICAgICBfcmVmNzkkcGFkZGluZyA9IF9yZWY3OS5wYWRkaW5nO1xuXG4gICAgICAgICAgICBfcmVmNzkkcGFkZGluZyA9IF9yZWY3OSRwYWRkaW5nID09PSB2b2lkIDAgPyB7fSA6IF9yZWY3OSRwYWRkaW5nO1xuICAgICAgICAgICAgdmFyIF9yZWY3OSRwYWRkaW5nJGxlZnQgPSBfcmVmNzkkcGFkZGluZy5sZWZ0LFxuICAgICAgICAgICAgICAgIHBhZGRpbmdMZWZ0ID0gX3JlZjc5JHBhZGRpbmckbGVmdCA9PT0gdm9pZCAwID8gMCA6IF9yZWY3OSRwYWRkaW5nJGxlZnQsXG4gICAgICAgICAgICAgICAgX3JlZjc5JHBhZGRpbmckcmlnaHQgPSBfcmVmNzkkcGFkZGluZy5yaWdodCxcbiAgICAgICAgICAgICAgICBwYWRkaW5nUmlnaHQgPSBfcmVmNzkkcGFkZGluZyRyaWdodCA9PT0gdm9pZCAwID8gMCA6IF9yZWY3OSRwYWRkaW5nJHJpZ2h0LFxuICAgICAgICAgICAgICAgIF9yZWY3OSRwYWRkaW5nJHRvcCA9IF9yZWY3OSRwYWRkaW5nLnRvcCxcbiAgICAgICAgICAgICAgICBwYWRkaW5nVG9wID0gX3JlZjc5JHBhZGRpbmckdG9wID09PSB2b2lkIDAgPyAwIDogX3JlZjc5JHBhZGRpbmckdG9wLFxuICAgICAgICAgICAgICAgIF9yZWY3OSRwYWRkaW5nJGJvdHRvbSA9IF9yZWY3OSRwYWRkaW5nLmJvdHRvbSxcbiAgICAgICAgICAgICAgICBwYWRkaW5nQm90dG9tID0gX3JlZjc5JHBhZGRpbmckYm90dG9tID09PSB2b2lkIDAgPyAwIDogX3JlZjc5JHBhZGRpbmckYm90dG9tO1xuICAgICAgICAgICAgdmFyIHRleHRBbGlnbiA9IGN0eC50ZXh0QWxpZ24gfHwgXCJsZWZ0XCI7XG4gICAgICAgICAgICB2YXIgdGV4dEJhc2VsaW5lID0gY3R4LnRleHRCYXNlbGluZSB8fCBcIm1pZGRsZVwiO1xuICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9IHRleHRBbGlnbjtcbiAgICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSB0ZXh0QmFzZWxpbmU7XG4gICAgICAgICAgICB2YXIgeCA9IHJlY3QubGVmdCArIG9mZnNldCArIHBhZGRpbmdMZWZ0O1xuXG4gICAgICAgICAgICBpZiAodGV4dEFsaWduID09PSBcInJpZ2h0XCIgfHwgdGV4dEFsaWduID09PSBcImVuZFwiKSB7XG4gICAgICAgICAgICAgIHggPSByZWN0LnJpZ2h0IC0gd2lkdGggLSBvZmZzZXQgLSBwYWRkaW5nUmlnaHQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRleHRBbGlnbiA9PT0gXCJjZW50ZXJcIikge1xuICAgICAgICAgICAgICB4ID0gcmVjdC5sZWZ0ICsgKHJlY3Qud2lkdGggLSB3aWR0aCArIHBhZGRpbmdMZWZ0IC0gcGFkZGluZ1JpZ2h0KSAvIDI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB5ID0gcmVjdC50b3AgKyBvZmZzZXQgKyBwYWRkaW5nVG9wO1xuXG4gICAgICAgICAgICBpZiAodGV4dEJhc2VsaW5lID09PSBcImJvdHRvbVwiIHx8IHRleHRCYXNlbGluZSA9PT0gXCJhbHBoYWJldGljXCIgfHwgdGV4dEJhc2VsaW5lID09PSBcImlkZW9ncmFwaGljXCIpIHtcbiAgICAgICAgICAgICAgeSA9IHJlY3QuYm90dG9tIC0gaGVpZ2h0IC0gb2Zmc2V0IC0gcGFkZGluZ0JvdHRvbTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGV4dEJhc2VsaW5lID09PSBcIm1pZGRsZVwiKSB7XG4gICAgICAgICAgICAgIHkgPSByZWN0LnRvcCArIChyZWN0LmhlaWdodCAtIGhlaWdodCArIHBhZGRpbmdUb3AgLSBwYWRkaW5nQm90dG9tKSAvIDI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgIHk6IHlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5jYWxjU3RhcnRQb3NpdGlvbiA9IGNhbGNTdGFydFBvc2l0aW9uO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2ludGVybmFsL2NvbG9yLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vaW50ZXJuYWwvY29sb3IuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBpbnRlcm5hbENvbG9ySnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5jb2xvclRvUkdCID0gdm9pZCAwO1xuICAgICAgICAgIHZhciByZ2JNYXAgPSB7fTtcblxuICAgICAgICAgIGZ1bmN0aW9uIHN0eWxlQ29sb3JUb1JHQihjb2xvcikge1xuICAgICAgICAgICAgdmFyIGR1bW15ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IGR1bW15LnN0eWxlO1xuICAgICAgICAgICAgc3R5bGUuY29sb3IgPSBjb2xvcjtcbiAgICAgICAgICAgIHN0eWxlLnBvc2l0aW9uID0gXCJmaXhlZFwiO1xuICAgICAgICAgICAgc3R5bGUuaGVpZ2h0ID0gXCIxcHhcIjtcbiAgICAgICAgICAgIHN0eWxlLndpZHRoID0gXCIxcHhcIjtcbiAgICAgICAgICAgIHN0eWxlLm9wYWNpdHkgPSBcIjBcIjtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZHVtbXkpO1xuXG4gICAgICAgICAgICB2YXIgX2dldENvbXB1dGVkU3R5bGUgPSAoZG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgd2luZG93KS5nZXRDb21wdXRlZFN0eWxlKGR1bW15LCBcIlwiKSxcbiAgICAgICAgICAgICAgICBzdHlsZUNvbG9yID0gX2dldENvbXB1dGVkU3R5bGUuY29sb3I7XG5cbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZHVtbXkpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbG9yVG9SR0IwKHN0eWxlQ29sb3IgfHwgXCJcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gaGV4VG9OdW0oaGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoaGV4LCAxNik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gY3JlYXRlUkdCKHIsIGcsIGIpIHtcbiAgICAgICAgICAgIHZhciBhID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAxO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgcjogcixcbiAgICAgICAgICAgICAgZzogZyxcbiAgICAgICAgICAgICAgYjogYixcbiAgICAgICAgICAgICAgYTogYVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiB0cmlwbGVIZXhUb1JHQihfcmVmODApIHtcbiAgICAgICAgICAgIHZhciByID0gX3JlZjgwWzFdLFxuICAgICAgICAgICAgICAgIGcgPSBfcmVmODBbMl0sXG4gICAgICAgICAgICAgICAgYiA9IF9yZWY4MFszXTtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVSR0IoaGV4VG9OdW0ociArIHIpLCBoZXhUb051bShnICsgZyksIGhleFRvTnVtKGIgKyBiKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gc2V4dHVwbGVIZXhUb1JHQihfcmVmODEpIHtcbiAgICAgICAgICAgIHZhciByMSA9IF9yZWY4MVsxXSxcbiAgICAgICAgICAgICAgICByMiA9IF9yZWY4MVsyXSxcbiAgICAgICAgICAgICAgICBnMSA9IF9yZWY4MVszXSxcbiAgICAgICAgICAgICAgICBnMiA9IF9yZWY4MVs0XSxcbiAgICAgICAgICAgICAgICBiMSA9IF9yZWY4MVs1XSxcbiAgICAgICAgICAgICAgICBiMiA9IF9yZWY4MVs2XTtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVSR0IoaGV4VG9OdW0ocjEgKyByMiksIGhleFRvTnVtKGcxICsgZzIpLCBoZXhUb051bShiMSArIGIyKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gdGVzdFJHQihfcmVmODIpIHtcbiAgICAgICAgICAgIHZhciByID0gX3JlZjgyLnIsXG4gICAgICAgICAgICAgICAgZyA9IF9yZWY4Mi5nLFxuICAgICAgICAgICAgICAgIGIgPSBfcmVmODIuYixcbiAgICAgICAgICAgICAgICBhID0gX3JlZjgyLmE7XG4gICAgICAgICAgICByZXR1cm4gMCA8PSByICYmIHIgPD0gMjU1ICYmIDAgPD0gZyAmJiBnIDw9IDI1NSAmJiAwIDw9IGIgJiYgYiA8PSAyNTUgJiYgMCA8PSBhICYmIGEgPD0gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiByYXRlVG9CeXRlKHIpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwociAqIDI1NSAvIDEwMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG51bWJlclBhdHRlcm4gPSAvKCg/OlxcK3wtKT8oPzpcXGQrKD86XFwuXFxkKyk/fFxcLlxcZCspKS8uc291cmNlO1xuICAgICAgICAgIHZhciBwZXJjZW50UGF0dGVybiA9IFwiXCIuY29uY2F0KG51bWJlclBhdHRlcm4sIFwiJVwiKTtcbiAgICAgICAgICB2YXIgbWF5YmVQZXJjZW50UGF0dGVybiA9IFwiXCIuY29uY2F0KG51bWJlclBhdHRlcm4sIFwiKCU/KVwiKTtcblxuICAgICAgICAgIGZ1bmN0aW9uIGJ1aWxkUmdiV2l0aENvbW1hUmVnRXhwKGJ5dGVQYXR0ZXJuKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChcIl5yZ2JhP1xcXFwoXFxcXHMqXCIuY29uY2F0KGJ5dGVQYXR0ZXJuLCBcIlxcXFxzKixcXFxccypcIikuY29uY2F0KGJ5dGVQYXR0ZXJuLCBcIlxcXFxzKixcXFxccypcIikuY29uY2F0KGJ5dGVQYXR0ZXJuLCBcIlxcXFxzKlxcXFwpJFwiKSwgXCJpXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGJ1aWxkUmdiTHY0UmVnRXhwKGJ5dGVQYXR0ZXJuKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChcIl5yZ2JhP1xcXFwoXFxcXHMqXCIuY29uY2F0KGJ5dGVQYXR0ZXJuLCBcIlxcXFxzK1wiKS5jb25jYXQoYnl0ZVBhdHRlcm4sIFwiXFxcXHMrXCIpLmNvbmNhdChieXRlUGF0dGVybiwgXCJcXFxccypcXFxcKSRcIiksIFwiaVwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBidWlsZFJnYmFXaXRoQ29tbWFSZWdFeHAoYnl0ZVBhdHRlcm4sIGFscGhhUGF0dGVybikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoXCJecmdiYT9cXFxcKFxcXFxzKlwiLmNvbmNhdChieXRlUGF0dGVybiwgXCJcXFxccyosXFxcXHMqXCIpLmNvbmNhdChieXRlUGF0dGVybiwgXCJcXFxccyosXFxcXHMqXCIpLmNvbmNhdChieXRlUGF0dGVybiwgXCJcXFxccyosXFxcXHMqXCIpLmNvbmNhdChhbHBoYVBhdHRlcm4sIFwiXFxcXHMqXFxcXCkkXCIpLCBcImlcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gYnVpbGRSZ2JhTHY0UmVnRXhwKGJ5dGVQYXR0ZXJuLCBhbHBoYVBhdHRlcm4pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKFwiXnJnYmE/XFxcXChcXFxccypcIi5jb25jYXQoYnl0ZVBhdHRlcm4sIFwiXFxcXHMrXCIpLmNvbmNhdChieXRlUGF0dGVybiwgXCJcXFxccytcIikuY29uY2F0KGJ5dGVQYXR0ZXJuLCBcIlxcXFxzKi9cXFxccypcIikuY29uY2F0KGFscGhhUGF0dGVybiwgXCJcXFxccypcXFxcKSRcIiksIFwiaVwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBjb2xvclRvUkdCMChjb2xvcikge1xuICAgICAgICAgICAgaWYgKC9eI1swLTlhLWZdezN9JC9pLmV4ZWMoY29sb3IpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cmlwbGVIZXhUb1JHQihjb2xvcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICgvXiNbMC05YS1mXXs2fSQvaS5leGVjKGNvbG9yKSkge1xuICAgICAgICAgICAgICByZXR1cm4gc2V4dHVwbGVIZXhUb1JHQihjb2xvcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZXQgPSBidWlsZFJnYldpdGhDb21tYVJlZ0V4cChudW1iZXJQYXR0ZXJuKS5leGVjKGNvbG9yKSB8fCBidWlsZFJnYkx2NFJlZ0V4cChudW1iZXJQYXR0ZXJuKS5leGVjKGNvbG9yKTtcblxuICAgICAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgICAgICB2YXIgcmdiID0gY3JlYXRlUkdCKE51bWJlcihyZXRbMV0pLCBOdW1iZXIocmV0WzJdKSwgTnVtYmVyKHJldFszXSkpO1xuXG4gICAgICAgICAgICAgIGlmICh0ZXN0UkdCKHJnYikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmdiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldCA9IGJ1aWxkUmdiV2l0aENvbW1hUmVnRXhwKHBlcmNlbnRQYXR0ZXJuKS5leGVjKGNvbG9yKSB8fCBidWlsZFJnYkx2NFJlZ0V4cChwZXJjZW50UGF0dGVybikuZXhlYyhjb2xvcik7XG5cbiAgICAgICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICAgICAgdmFyIF9yZ2IgPSBjcmVhdGVSR0IocmF0ZVRvQnl0ZShOdW1iZXIocmV0WzFdKSksIHJhdGVUb0J5dGUoTnVtYmVyKHJldFsyXSkpLCByYXRlVG9CeXRlKE51bWJlcihyZXRbM10pKSk7XG5cbiAgICAgICAgICAgICAgaWYgKHRlc3RSR0IoX3JnYikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3JnYjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXQgPSBidWlsZFJnYmFXaXRoQ29tbWFSZWdFeHAobnVtYmVyUGF0dGVybiwgbWF5YmVQZXJjZW50UGF0dGVybikuZXhlYyhjb2xvcikgfHwgYnVpbGRSZ2JhTHY0UmVnRXhwKG51bWJlclBhdHRlcm4sIG1heWJlUGVyY2VudFBhdHRlcm4pLmV4ZWMoY29sb3IpO1xuXG4gICAgICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgICAgIHZhciBfcmdiMiA9IGNyZWF0ZVJHQihOdW1iZXIocmV0WzFdKSwgTnVtYmVyKHJldFsyXSksIE51bWJlcihyZXRbM10pLCBOdW1iZXIocmV0WzRdKSAvIChyZXRbNV1cbiAgICAgICAgICAgICAgLyogJSAqL1xuICAgICAgICAgICAgICA/IDEwMCA6IDEpKTtcblxuICAgICAgICAgICAgICBpZiAodGVzdFJHQihfcmdiMikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3JnYjI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0ID0gYnVpbGRSZ2JhV2l0aENvbW1hUmVnRXhwKHBlcmNlbnRQYXR0ZXJuLCBtYXliZVBlcmNlbnRQYXR0ZXJuKS5leGVjKGNvbG9yKSB8fCBidWlsZFJnYmFMdjRSZWdFeHAocGVyY2VudFBhdHRlcm4sIG1heWJlUGVyY2VudFBhdHRlcm4pLmV4ZWMoY29sb3IpO1xuXG4gICAgICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgICAgIHZhciBfcmdiMyA9IGNyZWF0ZVJHQihyYXRlVG9CeXRlKE51bWJlcihyZXRbMV0pKSwgcmF0ZVRvQnl0ZShOdW1iZXIocmV0WzJdKSksIHJhdGVUb0J5dGUoTnVtYmVyKHJldFszXSkpLCBOdW1iZXIocmV0WzRdKSAvIChyZXRbNV1cbiAgICAgICAgICAgICAgLyogJSAqL1xuICAgICAgICAgICAgICA/IDEwMCA6IDEpKTtcblxuICAgICAgICAgICAgICBpZiAodGVzdFJHQihfcmdiMykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3JnYjM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gY29sb3JUb1JHQihjb2xvcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb2xvciAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlUkdCKDAsIDAsIDAsIDApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb2xvciA9IGNvbG9yLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuXG4gICAgICAgICAgICBpZiAocmdiTWFwW2NvbG9yXSkge1xuICAgICAgICAgICAgICByZXR1cm4gcmdiTWFwW2NvbG9yXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNvbG9yVG9SR0IwKGNvbG9yKSB8fCAocmdiTWFwW2NvbG9yXSA9IHN0eWxlQ29sb3JUb1JHQihjb2xvcikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMuY29sb3JUb1JHQiA9IGNvbG9yVG9SR0I7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vaW50ZXJuYWwvZG9tLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2ludGVybmFsL2RvbS5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBpbnRlcm5hbERvbUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuZmluZE5leHRTaWJsaW5nRm9jdXNhYmxlID0gZXhwb3J0cy5maW5kUHJldlNpYmxpbmdGb2N1c2FibGUgPSBleHBvcnRzLmlzRm9jdXNhYmxlID0gZXhwb3J0cy5lbmFibGVGb2N1cyA9IGV4cG9ydHMuZGlzYWJsZUZvY3VzID0gZXhwb3J0cy5hcHBlbmRIdG1sID0gZXhwb3J0cy50b05vZGVMaXN0ID0gZXhwb3J0cy5lbXB0eSA9IGV4cG9ydHMuY3JlYXRlRWxlbWVudCA9IHZvaWQgMDtcblxuICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodGFnTmFtZSkge1xuICAgICAgICAgICAgdmFyIF9yZWY4MyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge30sXG4gICAgICAgICAgICAgICAgY2xhc3NMaXN0ID0gX3JlZjgzLmNsYXNzTGlzdCxcbiAgICAgICAgICAgICAgICB0ZXh0ID0gX3JlZjgzLnRleHQsXG4gICAgICAgICAgICAgICAgaHRtbCA9IF9yZWY4My5odG1sO1xuXG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG5cbiAgICAgICAgICAgIGlmIChjbGFzc0xpc3QpIHtcbiAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2xhc3NMaXN0KSkge1xuICAgICAgICAgICAgICAgIHZhciBfZWxlbWVudCRjbGFzc0xpc3Q7XG5cbiAgICAgICAgICAgICAgICAoX2VsZW1lbnQkY2xhc3NMaXN0ID0gZWxlbWVudC5jbGFzc0xpc3QpLmFkZC5hcHBseShfZWxlbWVudCRjbGFzc0xpc3QsIF90b0NvbnN1bWFibGVBcnJheShjbGFzc0xpc3QpKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xhc3NMaXN0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGV4dCkge1xuICAgICAgICAgICAgICBlbGVtZW50LnRleHRDb250ZW50ID0gdGV4dDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaHRtbCkge1xuICAgICAgICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9IGh0bWw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMuY3JlYXRlRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQ7XG5cbiAgICAgICAgICBmdW5jdGlvbiBlbXB0eShkb20pIHtcbiAgICAgICAgICAgIHZhciBjO1xuXG4gICAgICAgICAgICB3aGlsZSAoYyA9IGRvbS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgIGRvbS5yZW1vdmVDaGlsZChjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRzLmVtcHR5ID0gZW1wdHk7XG5cbiAgICAgICAgICBmdW5jdGlvbiBpc05vZGUoYXJnKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgcmV0dXJuICEhKGFyZy5ub2RlVHlwZSAmJiBhcmcubm9kZU5hbWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHRvTm9kZShhcmcpIHtcbiAgICAgICAgICAgIGlmIChpc05vZGUoYXJnKSkge1xuICAgICAgICAgICAgICByZXR1cm4gYXJnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZG9tID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgICAgICAgIGh0bWw6IGFyZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZG9tLmNoaWxkTm9kZXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHRvTm9kZUxpc3QoYXJnKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgYXJnLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaC5hcHBseShyZXN1bHQsIF90b0NvbnN1bWFibGVBcnJheSh0b05vZGVMaXN0KGUpKSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRvTm9kZShhcmcpO1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkobm9kZSkgPyBub2RlIDogW25vZGVdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMudG9Ob2RlTGlzdCA9IHRvTm9kZUxpc3Q7XG5cbiAgICAgICAgICBmdW5jdGlvbiBhcHBlbmRIdG1sKGRvbSwgaW5uZXIpIHtcbiAgICAgICAgICAgIHRvTm9kZUxpc3QoaW5uZXIpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgZG9tLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5hcHBlbmRIdG1sID0gYXBwZW5kSHRtbDtcblxuICAgICAgICAgIGZ1bmN0aW9uIGRpc2FibGVGb2N1cyhlbCkge1xuICAgICAgICAgICAgZWwuZGF0YXNldC5kaXNhYmxlQmVmb3JlVGFiSW5kZXggPSBcIlwiLmNvbmNhdChlbC50YWJJbmRleCk7XG4gICAgICAgICAgICBlbC50YWJJbmRleCA9IC0xO1xuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZWwuY2hpbGRyZW4sIDApLmZvckVhY2goZGlzYWJsZUZvY3VzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRzLmRpc2FibGVGb2N1cyA9IGRpc2FibGVGb2N1cztcblxuICAgICAgICAgIGZ1bmN0aW9uIGVuYWJsZUZvY3VzKGVsKSB7XG4gICAgICAgICAgICBpZiAoXCJkaXNhYmxlQmVmb3JlVGFiSW5kZXhcIiBpbiBlbC5kYXRhc2V0KSB7XG4gICAgICAgICAgICAgIGVsLnRhYkluZGV4ID0gTnVtYmVyKGVsLmRhdGFzZXQuZGlzYWJsZUJlZm9yZVRhYkluZGV4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZWwuY2hpbGRyZW4sIDApLmZvckVhY2goZW5hYmxlRm9jdXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMuZW5hYmxlRm9jdXMgPSBlbmFibGVGb2N1cztcblxuICAgICAgICAgIGZ1bmN0aW9uIGlzRm9jdXNhYmxlKGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gZWwudGFiSW5kZXggIT0gbnVsbCAmJiBlbC50YWJJbmRleCA+IC0xO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMuaXNGb2N1c2FibGUgPSBpc0ZvY3VzYWJsZTtcblxuICAgICAgICAgIGZ1bmN0aW9uIGZpbmRQcmV2U2libGluZ0ZvY3VzYWJsZShlbCkge1xuICAgICAgICAgICAgdmFyIG4gPSBlbC5wcmV2aW91c1NpYmxpbmc7XG5cbiAgICAgICAgICAgIHdoaWxlIChuICYmICFpc0ZvY3VzYWJsZShuKSkge1xuICAgICAgICAgICAgICBuID0gbi5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMuZmluZFByZXZTaWJsaW5nRm9jdXNhYmxlID0gZmluZFByZXZTaWJsaW5nRm9jdXNhYmxlO1xuXG4gICAgICAgICAgZnVuY3Rpb24gZmluZE5leHRTaWJsaW5nRm9jdXNhYmxlKGVsKSB7XG4gICAgICAgICAgICB2YXIgbiA9IGVsLm5leHRTaWJsaW5nO1xuXG4gICAgICAgICAgICB3aGlsZSAobiAmJiAhaXNGb2N1c2FibGUobikpIHtcbiAgICAgICAgICAgICAgbiA9IG4ubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMuZmluZE5leHRTaWJsaW5nRm9jdXNhYmxlID0gZmluZE5leHRTaWJsaW5nRm9jdXNhYmxlO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2ludGVybmFsL2ZvbnRzLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vaW50ZXJuYWwvZm9udHMuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBpbnRlcm5hbEZvbnRzSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5sb2FkID0gZXhwb3J0cy5jaGVjayA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi91dGlscyAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC91dGlscy5qc1wiKTtcblxuICAgICAgICAgIHZhciBsb2FkcyA9IHt9O1xuICAgICAgICAgIHZhciBsb2FkO1xuICAgICAgICAgIGV4cG9ydHMubG9hZCA9IGxvYWQ7XG4gICAgICAgICAgdmFyIGNoZWNrO1xuICAgICAgICAgIGV4cG9ydHMuY2hlY2sgPSBjaGVjaztcblxuICAgICAgICAgIGlmICh1dGlsc18xLmlzTm9kZSkge1xuICAgICAgICAgICAgZXhwb3J0cy5sb2FkID0gbG9hZCA9IGZ1bmN0aW9uIGxvYWQoX2ZvbnQsIF90ZXN0U3RyLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZXhwb3J0cy5jaGVjayA9IGNoZWNrID0gZnVuY3Rpb24gY2hlY2soKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICB2YXIgZm9udEZhY2VTZXQgPSBkb2N1bWVudC5mb250cztcbiAgICAgICAgICAgIHZhciBsZWdhY3kgPSAhZm9udEZhY2VTZXQ7XG4gICAgICAgICAgICBleHBvcnRzLmxvYWQgPSBsb2FkID0gbGVnYWN5ID8gZnVuY3Rpb24gKGZvbnQsIHRlc3RTdHIsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIC8vZm9yIGxlZ2FjeShJRSlcbiAgICAgICAgICAgICAgaWYgKGxvYWRzW1wiXCIuY29uY2F0KGZvbnQsIFwiIEAgXCIpLmNvbmNhdCh0ZXN0U3RyKV0pIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXZhci1yZXF1aXJlc1xuXG5cbiAgICAgICAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgICAgLyohIC4vbGVnYWN5L2ZvbnR3YXRjaC9Gb250V2F0Y2hSdW5uZXIgKi9cbiAgICAgICAgICAgICAgXCIuL2ludGVybmFsL2xlZ2FjeS9mb250d2F0Y2gvRm9udFdhdGNoUnVubmVyLmpzXCIpLmxvYWQoZm9udCwgdGVzdFN0ciwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGxvYWRzW1wiXCIuY29uY2F0KGZvbnQsIFwiIEAgXCIpLmNvbmNhdCh0ZXN0U3RyKV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBsb2Fkc1tcIlwiLmNvbmNhdChmb250LCBcIiBAIFwiKS5jb25jYXQodGVzdFN0cildID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gOiBmdW5jdGlvbiAoZm9udCwgX3Rlc3RTdHIsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIGlmIChsb2Fkcy5hbGwgfHwgbG9hZHNbZm9udF0pIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGZvbnRGYWNlU2V0LnJlYWR5LnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGxvYWRzLmFsbCA9IHRydWU7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBmb250RmFjZVNldC5sb2FkKGZvbnQpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGxvYWRzW2ZvbnRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmNoZWNrID0gY2hlY2sgPSBsZWdhY3kgPyBmdW5jdGlvbiAoZm9udCwgdGVzdFN0cikge1xuICAgICAgICAgICAgICAvL2ZvciBsZWdhY3koSUUpXG4gICAgICAgICAgICAgIGlmIChsb2Fkc1tcIlwiLmNvbmNhdChmb250LCBcIiBAIFwiKS5jb25jYXQodGVzdFN0cildKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBsb2FkKGZvbnQsIHRlc3RTdHIsIGZ1bmN0aW9uICgpIHt9KTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSA6IGZ1bmN0aW9uIChmb250LCB0ZXN0U3RyKSB7XG4gICAgICAgICAgICAgIGlmIChsb2Fkcy5hbGwgfHwgbG9hZHNbZm9udF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghZm9udEZhY2VTZXQuY2hlY2soZm9udCkpIHtcbiAgICAgICAgICAgICAgICBsb2FkKGZvbnQsIHRlc3RTdHIsIGZ1bmN0aW9uICgpIHt9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKiovXG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vaW50ZXJuYWwvaGlEUEkuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9pbnRlcm5hbC9oaURQSS5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGludGVybmFsSGlEUElKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLnRyYW5zZm9ybSA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBFdmVudEhhbmRsZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vRXZlbnRIYW5kbGVyICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL0V2ZW50SGFuZGxlci5qc1wiKTtcblxuICAgICAgICAgIHZhciB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi91dGlscyAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC91dGlscy5qc1wiKTtcblxuICAgICAgICAgIHZhciBoYW5kbGVyID0gbmV3IEV2ZW50SGFuZGxlcl8xLkV2ZW50SGFuZGxlcigpO1xuICAgICAgICAgIHZhciByYXRpbyA9IDE7XG5cbiAgICAgICAgICBmdW5jdGlvbiBzZXRSYXRpbygpIHtcbiAgICAgICAgICAgIGlmICh1dGlsc18xLmlzTm9kZSkge1xuICAgICAgICAgICAgICByYXRpbyA9IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByYXRpbyA9IE1hdGguY2VpbCh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKTtcblxuICAgICAgICAgICAgICBpZiAocmF0aW8gPiAxICYmIHJhdGlvICUgMiAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHJhdGlvICs9IDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZXRSYXRpbygpO1xuXG4gICAgICAgICAgaWYgKCF1dGlsc18xLmlzTm9kZSkge1xuICAgICAgICAgICAgaGFuZGxlci5vbih3aW5kb3csIFwicmVzaXplXCIsIHNldFJhdGlvKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiB0cmFuc2Zvcm0oY2FudmFzKSB7XG4gICAgICAgICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgICAgIHZhciBnZXRBdHRyaWJ1dGUgPSBjYW52YXMuZ2V0QXR0cmlidXRlLFxuICAgICAgICAgICAgICAgIHNldEF0dHJpYnV0ZSA9IGNhbnZhcy5zZXRBdHRyaWJ1dGU7XG5cbiAgICAgICAgICAgIGNhbnZhcy5nZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gZ2V0QXR0cmlidXRlLmNhbGwodGhpcywgbmFtZSk7XG5cbiAgICAgICAgICAgICAgaWYgKG5hbWUgPT09IFwid2lkdGhcIiB8fCBuYW1lID09PSBcImhlaWdodFwiKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gXCJcIi5jb25jYXQoTnVtYmVyKHJlc3VsdCkgLyByYXRpbyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY2FudmFzLnNldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWwpIHtcbiAgICAgICAgICAgICAgdmFyIHdoID0gbmFtZSA9PT0gXCJ3aWR0aFwiIHx8IG5hbWUgPT09IFwiaGVpZ2h0XCI7XG5cbiAgICAgICAgICAgICAgaWYgKHdoKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gXCJcIi5jb25jYXQoTnVtYmVyKHZhbCkgKiByYXRpbyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gc2V0QXR0cmlidXRlLmNhbGwodGhpcywgbmFtZSwgdmFsKTtcblxuICAgICAgICAgICAgICBpZiAod2gpIHtcbiAgICAgICAgICAgICAgICBjdHguc2NhbGUocmF0aW8sIHJhdGlvKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2FudmFzLCBcIndpZHRoXCIsIHtcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bWJlcihjYW52YXMuZ2V0QXR0cmlidXRlKFwid2lkdGhcIikpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWwpIHtcbiAgICAgICAgICAgICAgICBjYW52YXMuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgXCJcIi5jb25jYXQoTWF0aC5mbG9vcih2YWwpKSk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2FudmFzLCBcImhlaWdodFwiLCB7XG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOdW1iZXIoY2FudmFzLmdldEF0dHJpYnV0ZShcImhlaWdodFwiKSk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbCkge1xuICAgICAgICAgICAgICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgXCJcIi5jb25jYXQoTWF0aC5mbG9vcih2YWwpKSk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgZHJhd0ltYWdlID0gY3R4LmRyYXdJbWFnZTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcblxuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZSA9IGZ1bmN0aW9uIChpbWcpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbjEwID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMTAgPiAxID8gX2xlbjEwIC0gMSA6IDApLCBfa2V5MTAgPSAxOyBfa2V5MTAgPCBfbGVuMTA7IF9rZXkxMCsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfa2V5MTAgLSAxXSA9IGFyZ3VtZW50c1tfa2V5MTBdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGltZyAhPT0gY2FudmFzIHx8IHJhdGlvID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRyYXdJbWFnZS5jYWxsLmFwcGx5KGRyYXdJbWFnZSwgW3RoaXMsIGltZ10uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRoaXMuc2F2ZSgpO1xuXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2FsZSgxIC8gcmF0aW8sIDEgLyByYXRpbyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPiA0KSB7XG4gICAgICAgICAgICAgICAgICBhcmdzWzRdICo9IHJhdGlvO1xuICAgICAgICAgICAgICAgICAgYXJnc1s1XSAqPSByYXRpbztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgYXJnc1swXSAqPSByYXRpbztcbiAgICAgICAgICAgICAgICAgIGFyZ3NbMV0gKj0gcmF0aW87XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRyYXdJbWFnZS5jYWxsLmFwcGx5KGRyYXdJbWFnZSwgW3RoaXMsIGltZ10uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRzLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9pbnRlcm5hbC9pY29ucy5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2ludGVybmFsL2ljb25zLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gaW50ZXJuYWxJY29uc0pzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuaWNvblByb3BLZXlzID0gZXhwb3J0cy50b05vcm1hbGl6ZUFycmF5ID0gZXhwb3J0cy5nZXRJY29uUHJvcHMgPSB2b2lkIDA7XG4gICAgICAgICAgdmFyIElDT05fUFJPUF9LRVlTID0gW1wiY29udGVudFwiLCBcImZvbnRcIiwgXCJjb2xvclwiLCBcImNsYXNzTmFtZVwiLCBcInRhZ05hbWVcIiwgXCJpc0xpZ2FcIiwgXCJ3aWR0aFwiLCBcInNyY1wiLCBcInN2Z1wiLCBcIm5hbWVcIiwgXCJwYXRoXCIsIFwib2Zmc2V0VG9wXCIsIFwib2Zmc2V0TGVmdFwiXTtcblxuICAgICAgICAgIGZ1bmN0aW9uIHF1b3RlKG5hbWUpIHtcbiAgICAgICAgICAgIHZhciBxdW90ZWQgPSBbXTtcbiAgICAgICAgICAgIHZhciBzcGxpdCA9IG5hbWUuc3BsaXQoLyxcXHMqLyk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3BsaXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIHBhcnQgPSBzcGxpdFtpXS5yZXBsYWNlKC9bJ1wiXS9nLCBcIlwiKTtcblxuICAgICAgICAgICAgICBpZiAocGFydC5pbmRleE9mKFwiIFwiKSA9PT0gLTEgJiYgIS9eXFxkLy50ZXN0KHBhcnQpKSB7XG4gICAgICAgICAgICAgICAgcXVvdGVkLnB1c2gocGFydCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcXVvdGVkLnB1c2goXCInXCIuY29uY2F0KHBhcnQsIFwiJ1wiKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHF1b3RlZC5qb2luKFwiLFwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZG9tcyA9IHt9O1xuICAgICAgICAgIHZhciBwcm9wcyA9IHt9O1xuXG4gICAgICAgICAgZnVuY3Rpb24gZ2V0SWNvblByb3BzKHRhZ05hbWUsIGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgdmFyIHRhZ1Byb3BzID0gcHJvcHNbdGFnTmFtZV0gfHwgKHByb3BzW3RhZ05hbWVdID0ge30pO1xuXG4gICAgICAgICAgICBpZiAodGFnUHJvcHNbY2xhc3NOYW1lXSkge1xuICAgICAgICAgICAgICByZXR1cm4gdGFnUHJvcHNbY2xhc3NOYW1lXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRvbSA9IGRvbXNbdGFnTmFtZV0gfHwgKGRvbXNbdGFnTmFtZV0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpKTsgLy8gYGNsYXNzTGlzdC5hZGQoKWAgY2Fubm90IGJlIHVzZWQgYmVjYXVzZSBpdCBtYXkgYmUgc2VwYXJhdGVkIGJ5IHNwYWNlcy5cblxuICAgICAgICAgICAgZG9tLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICAgICAgICAgIGRvbS5jbGFzc0xpc3QuYWRkKFwiY2hlZXRhaC1ncmlkLWljb25cIik7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRvbSk7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHZhciBiZWZvcmVTdHlsZSA9IChkb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3cpLmdldENvbXB1dGVkU3R5bGUoZG9tLCBcIjo6YmVmb3JlXCIpO1xuICAgICAgICAgICAgICB2YXIgY29udGVudCA9IGJlZm9yZVN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCJjb250ZW50XCIpO1xuXG4gICAgICAgICAgICAgIGlmIChjb250ZW50Lmxlbmd0aCA+PSAzICYmIChjb250ZW50WzBdID09PSAnXCInIHx8IGNvbnRlbnRbMF0gPT09IFwiJ1wiKSkge1xuICAgICAgICAgICAgICAgIGlmIChjb250ZW50WzBdID09PSBjb250ZW50W2NvbnRlbnQubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50LnNsaWNlKDEsIC0xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgZm9udCA9IGJlZm9yZVN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCJmb250XCIpO1xuXG4gICAgICAgICAgICAgIGlmICghZm9udCkge1xuICAgICAgICAgICAgICAgIGZvbnQgPSBcIlwiLmNvbmNhdChiZWZvcmVTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKFwiZm9udC1zdHlsZVwiKSwgXCIgXCIpLmNvbmNhdChiZWZvcmVTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKFwiZm9udC12YXJpYW50XCIpLCBcIiBcIikuY29uY2F0KGJlZm9yZVN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCJmb250LXdlaWdodFwiKSwgXCIgXCIpLmNvbmNhdChiZWZvcmVTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKFwiZm9udC1zaXplXCIpLCBcIi9cIikuY29uY2F0KGJlZm9yZVN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCJsaW5lLWhlaWdodFwiKSwgXCIgXCIpLmNvbmNhdChxdW90ZShiZWZvcmVTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKFwiZm9udC1mYW1pbHlcIikpKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBjb2xvciA9IGJlZm9yZVN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCJjb2xvclwiKTtcbiAgICAgICAgICAgICAgdmFyIHdpZHRoID0gZG9tLmNsaWVudFdpZHRoO1xuICAgICAgICAgICAgICB2YXIgaXNMaWdhID0gKGJlZm9yZVN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCJmb250LWZlYXR1cmUtc2V0dGluZ3NcIikgfHwgXCJcIikuaW5kZXhPZihcImxpZ2FcIikgPiAtMTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRhZ1Byb3BzW2NsYXNzTmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgY29udGVudDogY29udGVudCxcbiAgICAgICAgICAgICAgICBmb250OiBmb250LFxuICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgICAgaXNMaWdhOiBpc0xpZ2FcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZG9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRzLmdldEljb25Qcm9wcyA9IGdldEljb25Qcm9wcztcblxuICAgICAgICAgIGZ1bmN0aW9uIHRvUHJvcEFycmF5KHByb3AsIGNvdW50KSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3ApKSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5wdXNoLmFwcGx5KHJlc3VsdCwgX3RvQ29uc3VtYWJsZUFycmF5KHByb3ApKTtcblxuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gcHJvcC5sZW5ndGg7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobnVsbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IGNvdW50OyBfaTMrKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHByb3ApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gdG9TaW1wbGVBcnJheShpY29uUHJvcHMpIHtcbiAgICAgICAgICAgIGlmICghaWNvblByb3BzKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpY29uUHJvcHM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaWNvblByb3BzKSkge1xuICAgICAgICAgICAgICByZXR1cm4gaWNvblByb3BzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgd29ya0RhdGEgPSB7fTtcbiAgICAgICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgICAgICBJQ09OX1BST1BfS0VZUy5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgIHZhciBwcm9wID0gaWNvblByb3BzW2tdO1xuXG4gICAgICAgICAgICAgIGlmIChwcm9wKSB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgIGNvdW50ID0gTWF0aC5tYXgoY291bnQsIHByb3AubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY291bnQgPSBNYXRoLm1heChjb3VudCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIElDT05fUFJPUF9LRVlTLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgdmFyIGFyciA9IHRvUHJvcEFycmF5KGljb25Qcm9wc1trXSwgY291bnQpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXG4gICAgICAgICAgICAgIHdvcmtEYXRhW2tdID0gYXJyO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgICAgICAgIHZhciBfbG9vcDYgPSBmdW5jdGlvbiBfbG9vcDYoaSkge1xuICAgICAgICAgICAgICB2YXIgZGF0YSA9IHt9O1xuICAgICAgICAgICAgICBJQ09OX1BST1BfS0VZUy5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICB2YXIgdmFsID0gd29ya0RhdGFba11baV07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5cbiAgICAgICAgICAgICAgICBkYXRhW2tdID0gdmFsO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZGF0YSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgX2xvb3A2KGkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZShpY29uUHJvcHMpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0ge307XG5cbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gaWNvblByb3BzKSB7XG4gICAgICAgICAgICAgIGlmIChrID09PSBcImNsYXNzTmFtZVwiKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoaXNJY29uS2V5KGspKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICBkYXRhW2tdID0gaWNvblByb3BzW2tdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpY29uUHJvcHMuY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICAgIHZhciBwcm9wID0gZ2V0SWNvblByb3BzKGljb25Qcm9wcy50YWdOYW1lIHx8IFwiaVwiLCBpY29uUHJvcHMuY2xhc3NOYW1lKTtcblxuICAgICAgICAgICAgICBmb3IgKHZhciBfazIgaW4gcHJvcCkge1xuICAgICAgICAgICAgICAgIGlmIChpc0ljb25LZXkoX2syKSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGljb25Qcm9wc1tfazJdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtfazJdID0gcHJvcFtfazJdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiB0b05vcm1hbGl6ZUFycmF5KGljb25Qcm9wcykge1xuICAgICAgICAgICAgdmFyIGljb25zID0gdG9TaW1wbGVBcnJheShpY29uUHJvcHMpO1xuXG4gICAgICAgICAgICBpZiAoIWljb25zKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpY29ucztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGljb25zLm1hcChmdW5jdGlvbiAoaWNvbikge1xuICAgICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplKGljb24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy50b05vcm1hbGl6ZUFycmF5ID0gdG9Ob3JtYWxpemVBcnJheTtcbiAgICAgICAgICBleHBvcnRzLmljb25Qcm9wS2V5cyA9IElDT05fUFJPUF9LRVlTO1xuXG4gICAgICAgICAgZnVuY3Rpb24gaXNJY29uS2V5KGspIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICByZXR1cm4gSUNPTl9QUk9QX0tFWVMuaW5kZXhPZihrKSA+PSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKioqL1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2ludGVybmFsL2ltZ3MuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2ludGVybmFsL2ltZ3MuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGludGVybmFsSW1nc0pzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuZ2V0Q2FjaGVPckxvYWQgPSBleHBvcnRzLmxvYWRJbWFnZSA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBMUlVDYWNoZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9MUlVDYWNoZSAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC9MUlVDYWNoZS5qc1wiKTtcblxuICAgICAgICAgIHZhciB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi91dGlscyAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC91dGlscy5qc1wiKTtcblxuICAgICAgICAgIHZhciBhbGxDYWNoZSA9IHt9O1xuXG4gICAgICAgICAgZnVuY3Rpb24gbG9hZEltYWdlKHNyYykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBQcm9taXNlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJQcm9taXNlIGlzIG5vdCBsb2FkZWQuIGxvYWQgUHJvbWlzZSBiZWZvcmUgdGhpcyBwcm9jZXNzLlwiKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0aGVuOiBmdW5jdGlvbiB0aGVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoaW1nKTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpbWcub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIHVybCA9IHNyYy5sZW5ndGggPiAyMDAgPyBcIlwiLmNvbmNhdChzcmMuc2xpY2UoMCwgMjAwKSwgXCIuLi5cIikgOiBzcmM7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihcImNhbm5vdCBsb2FkOiBcIi5jb25jYXQodXJsKSk7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklNQUdFIExPQUQgRVJST1I6IFwiLmNvbmNhdCh1cmwpKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGltZy5zcmMgPSBzcmM7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMubG9hZEltYWdlID0gbG9hZEltYWdlO1xuXG4gICAgICAgICAgZnVuY3Rpb24gZ2V0Q2FjaGVPckxvYWQwKGNhY2hlLCBzcmMpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbHNfMS50aGVuKShzcmMsIGZ1bmN0aW9uIChzcmMpIHtcbiAgICAgICAgICAgICAgdmFyIGMgPSBjYWNoZS5nZXQoc3JjKTtcblxuICAgICAgICAgICAgICBpZiAoYykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGxvYWRJbWFnZShzcmMpLnRoZW4oZnVuY3Rpb24gKGltZykge1xuICAgICAgICAgICAgICAgIGNhY2hlLnB1dChzcmMsIGltZyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGltZztcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGNhY2hlLnB1dChzcmMsIHJlc3VsdCk7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBnZXRDYWNoZU9yTG9hZChjYWNoZU5hbWUsIGNhY2hlU2l6ZSwgc3JjKSB7XG4gICAgICAgICAgICB2YXIgY2FjaGUgPSBhbGxDYWNoZVtjYWNoZU5hbWVdIHx8IChhbGxDYWNoZVtjYWNoZU5hbWVdID0gbmV3IExSVUNhY2hlXzEuTFJVQ2FjaGUoY2FjaGVTaXplKSk7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q2FjaGVPckxvYWQwKGNhY2hlLCBzcmMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMuZ2V0Q2FjaGVPckxvYWQgPSBnZXRDYWNoZU9yTG9hZDtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9pbnRlcm5hbC9sZWdhY3kvY2FudmFzL1BhdGgyRFNoaW0uanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vaW50ZXJuYWwvbGVnYWN5L2NhbnZhcy9QYXRoMkRTaGltLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGludGVybmFsTGVnYWN5Q2FudmFzUGF0aDJEU2hpbUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuUGF0aDJEU2hpbSA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBQYXRoQ29tbWFuZHNQYXJzZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vUGF0aENvbW1hbmRzUGFyc2VyICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL2xlZ2FjeS9jYW52YXMvUGF0aENvbW1hbmRzUGFyc2VyLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIHBhcnNlciA9IG5ldyBQYXRoQ29tbWFuZHNQYXJzZXJfMS5QYXRoQ29tbWFuZHNQYXJzZXIoKTtcblxuICAgICAgICAgIHZhciBQYXRoMkRTaGltID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIFBhdGgyRFNoaW0oYXJnKSB7XG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQYXRoMkRTaGltKTtcblxuICAgICAgICAgICAgICB0aGlzLl9vcHMgPSBbXTtcblxuICAgICAgICAgICAgICBpZiAoYXJnID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyZyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIC8vIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb3BzID0gcGFyc2VyLnBhcnNlKGFyZyk7IC8vIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBcdHRocm93IGU7XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFyZy5oYXNPd25Qcm9wZXJ0eShcIl9vcHNcIikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vcHMgPSBfdG9Db25zdW1hYmxlQXJyYXkoYXJnLl9vcHMpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yOiBcIi5jb25jYXQoX3R5cGVvZihhcmcpLCBcIiBpcyBub3QgYSB2YWxpZCBhcmd1bWVudCB0byBQYXRoXCIpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoUGF0aDJEU2hpbSwgW3tcbiAgICAgICAgICAgICAga2V5OiBcImFyY1wiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYXJjKCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9sZW4xMSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjExKSwgX2tleTExID0gMDsgX2tleTExIDwgX2xlbjExOyBfa2V5MTErKykge1xuICAgICAgICAgICAgICAgICAgYXJnc1tfa2V5MTFdID0gYXJndW1lbnRzW19rZXkxMV07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fb3BzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgb3A6IFwiYXJjXCIsXG4gICAgICAgICAgICAgICAgICBhcmdzOiBhcmdzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImFyY1RvXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhcmNUbygpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfbGVuMTIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4xMiksIF9rZXkxMiA9IDA7IF9rZXkxMiA8IF9sZW4xMjsgX2tleTEyKyspIHtcbiAgICAgICAgICAgICAgICAgIGFyZ3NbX2tleTEyXSA9IGFyZ3VtZW50c1tfa2V5MTJdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX29wcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIG9wOiBcImFyY1RvXCIsXG4gICAgICAgICAgICAgICAgICBhcmdzOiBhcmdzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImJlemllckN1cnZlVG9cIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGJlemllckN1cnZlVG8oKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbjEzID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMTMpLCBfa2V5MTMgPSAwOyBfa2V5MTMgPCBfbGVuMTM7IF9rZXkxMysrKSB7XG4gICAgICAgICAgICAgICAgICBhcmdzW19rZXkxM10gPSBhcmd1bWVudHNbX2tleTEzXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9vcHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICBvcDogXCJiZXppZXJDdXJ2ZVRvXCIsXG4gICAgICAgICAgICAgICAgICBhcmdzOiBhcmdzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNsb3NlUGF0aFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2VQYXRoKCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9sZW4xNCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjE0KSwgX2tleTE0ID0gMDsgX2tleTE0IDwgX2xlbjE0OyBfa2V5MTQrKykge1xuICAgICAgICAgICAgICAgICAgYXJnc1tfa2V5MTRdID0gYXJndW1lbnRzW19rZXkxNF07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fb3BzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgb3A6IFwiY2xvc2VQYXRoXCIsXG4gICAgICAgICAgICAgICAgICBhcmdzOiBhcmdzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImVsbGlwc2VcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVsbGlwc2UoKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbjE1ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMTUpLCBfa2V5MTUgPSAwOyBfa2V5MTUgPCBfbGVuMTU7IF9rZXkxNSsrKSB7XG4gICAgICAgICAgICAgICAgICBhcmdzW19rZXkxNV0gPSBhcmd1bWVudHNbX2tleTE1XTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9vcHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICBvcDogXCJlbGxpcHNlXCIsXG4gICAgICAgICAgICAgICAgICBhcmdzOiBhcmdzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImxpbmVUb1wiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbGluZVRvKCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9sZW4xNiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjE2KSwgX2tleTE2ID0gMDsgX2tleTE2IDwgX2xlbjE2OyBfa2V5MTYrKykge1xuICAgICAgICAgICAgICAgICAgYXJnc1tfa2V5MTZdID0gYXJndW1lbnRzW19rZXkxNl07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fb3BzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgb3A6IFwibGluZVRvXCIsXG4gICAgICAgICAgICAgICAgICBhcmdzOiBhcmdzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIm1vdmVUb1wiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZVRvKCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9sZW4xNyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjE3KSwgX2tleTE3ID0gMDsgX2tleTE3IDwgX2xlbjE3OyBfa2V5MTcrKykge1xuICAgICAgICAgICAgICAgICAgYXJnc1tfa2V5MTddID0gYXJndW1lbnRzW19rZXkxN107XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fb3BzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgb3A6IFwibW92ZVRvXCIsXG4gICAgICAgICAgICAgICAgICBhcmdzOiBhcmdzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInF1YWRyYXRpY0N1cnZlVG9cIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHF1YWRyYXRpY0N1cnZlVG8oKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbjE4ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMTgpLCBfa2V5MTggPSAwOyBfa2V5MTggPCBfbGVuMTg7IF9rZXkxOCsrKSB7XG4gICAgICAgICAgICAgICAgICBhcmdzW19rZXkxOF0gPSBhcmd1bWVudHNbX2tleTE4XTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9vcHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICBvcDogXCJxdWFkcmF0aWNDdXJ2ZVRvXCIsXG4gICAgICAgICAgICAgICAgICBhcmdzOiBhcmdzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInJlY3RcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlY3QoKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbjE5ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMTkpLCBfa2V5MTkgPSAwOyBfa2V5MTkgPCBfbGVuMTk7IF9rZXkxOSsrKSB7XG4gICAgICAgICAgICAgICAgICBhcmdzW19rZXkxOV0gPSBhcmd1bWVudHNbX2tleTE5XTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9vcHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICBvcDogXCJyZWN0XCIsXG4gICAgICAgICAgICAgICAgICBhcmdzOiBhcmdzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInJvdW5kUmVjdFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcm91bmRSZWN0KF94LCBfeSwgX3csIF9oLCBfcmFkaWkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gUGF0aDJEU2hpbTtcbiAgICAgICAgICB9KCk7XG5cbiAgICAgICAgICBleHBvcnRzLlBhdGgyRFNoaW0gPSBQYXRoMkRTaGltO1xuICAgICAgICAgIHZhciBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgPSB3aW5kb3cuQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEO1xuICAgICAgICAgIHZhciBvcmlnaW5hbEZpbGwgPSBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLmZpbGw7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5cbiAgICAgICAgICBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMxMDIgPSB0aGlzO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBfbGVuMjAgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yMCksIF9rZXkyMCA9IDA7IF9rZXkyMCA8IF9sZW4yMDsgX2tleTIwKyspIHtcbiAgICAgICAgICAgICAgYXJnc1tfa2V5MjBdID0gYXJndW1lbnRzW19rZXkyMF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhcmdzWzBdIGluc3RhbmNlb2YgUGF0aDJEU2hpbSkge1xuICAgICAgICAgICAgICB2YXIgcGF0aCA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgIHRoaXMuYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgICAgICAgcGF0aC5fb3BzLmZvckVhY2goZnVuY3Rpb24gKG9wKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZuID0gX3RoaXMxMDJbb3Aub3BdO1xuICAgICAgICAgICAgICAgIGZuLmFwcGx5KF90aGlzMTAyLCBvcC5hcmdzKTtcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgb3JpZ2luYWxGaWxsLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MsIDEpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG9yaWdpbmFsRmlsbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIC8qKiovXG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vaW50ZXJuYWwvbGVnYWN5L2NhbnZhcy9QYXRoQ29tbWFuZHMuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9pbnRlcm5hbC9sZWdhY3kvY2FudmFzL1BhdGhDb21tYW5kcy5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGludGVybmFsTGVnYWN5Q2FudmFzUGF0aENvbW1hbmRzSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5QYXRoQ29tbWFuZHMgPSB2b2lkIDA7XG4gICAgICAgICAgLyplc2xpbnQgbmV3LWNhcDogXCJvZmZcIiovXG5cbiAgICAgICAgICBmdW5jdGlvbiBtYWcodikge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh2WzBdLCAyKSArIE1hdGgucG93KHZbMV0sIDIpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBkb3QodSwgdikge1xuICAgICAgICAgICAgcmV0dXJuIHVbMF0gKiB2WzBdICsgdVsxXSAqIHZbMV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gcmF0aW8odSwgdikge1xuICAgICAgICAgICAgcmV0dXJuIGRvdCh1LCB2KSAvIChtYWcodSkgKiBtYWcodikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGNsYW1wKHZhbHVlLCBtaW4sIG1heCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHZhbHVlLCBtaW4pLCBtYXgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGFuZ2xlKHUsIHYpIHtcbiAgICAgICAgICAgIHZhciBzaWduID0gMS4wO1xuXG4gICAgICAgICAgICBpZiAodVswXSAqIHZbMV0gLSB1WzFdICogdlswXSA8IDApIHtcbiAgICAgICAgICAgICAgc2lnbiA9IC0xLjA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzaWduICogTWF0aC5hY29zKGNsYW1wKHJhdGlvKHUsIHYpLCAtMSwgMSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHJvdENsb2Nrd2lzZSh2LCBhbmdsZSkge1xuICAgICAgICAgICAgdmFyIGNvc3QgPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICAgICAgICB2YXIgc2ludCA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICAgICAgICAgIHJldHVybiBbY29zdCAqIHZbMF0gKyBzaW50ICogdlsxXSwgLTEgKiBzaW50ICogdlswXSArIGNvc3QgKiB2WzFdXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiByb3RDb3VudGVyQ2xvY2t3aXNlKHYsIGFuZ2xlKSB7XG4gICAgICAgICAgICB2YXIgY29zdCA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICAgICAgICAgIHZhciBzaW50ID0gTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgICAgICAgcmV0dXJuIFtjb3N0ICogdlswXSAtIHNpbnQgKiB2WzFdLCBzaW50ICogdlswXSArIGNvc3QgKiB2WzFdXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBtaWRQb2ludCh1LCB2KSB7XG4gICAgICAgICAgICByZXR1cm4gWyh1WzBdIC0gdlswXSkgLyAyLjAsICh1WzFdIC0gdlsxXSkgLyAyLjBdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIG1lYW5WZWModSwgdikge1xuICAgICAgICAgICAgcmV0dXJuIFsodVswXSArIHZbMF0pIC8gMi4wLCAodVsxXSArIHZbMV0pIC8gMi4wXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBwb2ludE11bCh1LCB2KSB7XG4gICAgICAgICAgICByZXR1cm4gW3VbMF0gKiB2WzBdLCB1WzFdICogdlsxXV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gc2NhbGUoYywgdikge1xuICAgICAgICAgICAgcmV0dXJuIFtjICogdlswXSwgYyAqIHZbMV1dO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHN1bSh1LCB2KSB7XG4gICAgICAgICAgICByZXR1cm4gW3VbMF0gKyB2WzBdLCB1WzFdICsgdlsxXV07XG4gICAgICAgICAgfSAvLyBDb252ZXJ0IGFuIFNWRyBlbGxpcHRpY2FsIGFyYyB0byBhIHNlcmllcyBvZiBjYW52YXMgY29tbWFuZHMuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyB4MSwgeTEsIHgyLCB5Mjogc3RhcnQgYW5kIHN0b3AgY29vcmRpbmF0ZXMgb2YgdGhlIGVsbGlwc2UuXG4gICAgICAgICAgLy8gcngsIHJ5OiByYWRpaSBvZiB0aGUgZWxsaXBzZS5cbiAgICAgICAgICAvLyBwaGk6IHJvdGF0aW9uIG9mIHRoZSBlbGxpcHNlLlxuICAgICAgICAgIC8vIGZBOiBsYXJnZSBhcmMgZmxhZy5cbiAgICAgICAgICAvLyBmUzogc3dlZXAgZmxhZy5cblxuXG4gICAgICAgICAgZnVuY3Rpb24gZWxsaXBzZUZyb21FbGxpcHRpY2FsQXJjKGN0eCwgeDEsIHkxLCByeCwgcnksIHBoaSwgZkEsIGZTLCB4MiwgeTIpIHtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgZnJvbSBlbmRwb2ludCB0byBjZW50ZXIgcGFyYW1ldHJpemF0aW9uLCBhcyBkZXRhaWxlZCBpbjpcbiAgICAgICAgICAgIC8vICAgaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL2ltcGxub3RlLmh0bWwjQXJjSW1wbGVtZW50YXRpb25Ob3Rlc1xuICAgICAgICAgICAgaWYgKHJ4ID09PSAwIHx8IHJ5ID09PSAwKSB7XG4gICAgICAgICAgICAgIGN0eC5saW5lVG8oeDIsIHgxKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwaGkgKj0gTWF0aC5QSSAvIDE4MC4wO1xuICAgICAgICAgICAgcnggPSBNYXRoLmFicyhyeCk7XG4gICAgICAgICAgICByeSA9IE1hdGguYWJzKHJ5KTtcbiAgICAgICAgICAgIHZhciB4UHJpbWUgPSByb3RDbG9ja3dpc2UobWlkUG9pbnQoW3gxLCB5MV0sIFt4MiwgeTJdKSwgcGhpKTsgLy8gRi42LjUuMVxuXG4gICAgICAgICAgICB2YXIgeFByaW1lMiA9IHBvaW50TXVsKHhQcmltZSwgeFByaW1lKTtcbiAgICAgICAgICAgIHZhciByeDIgPSBNYXRoLnBvdyhyeCwgMik7XG4gICAgICAgICAgICB2YXIgcnkyID0gTWF0aC5wb3cocnksIDIpO1xuICAgICAgICAgICAgdmFyIGxhbWJkYSA9IE1hdGguc3FydCh4UHJpbWUyWzBdIC8gcngyICsgeFByaW1lMlsxXSAvIHJ5Mik7XG5cbiAgICAgICAgICAgIGlmIChsYW1iZGEgPiAxKSB7XG4gICAgICAgICAgICAgIHJ4ICo9IGxhbWJkYTtcbiAgICAgICAgICAgICAgcnkgKj0gbGFtYmRhO1xuICAgICAgICAgICAgICByeDIgPSBNYXRoLnBvdyhyeCwgMik7XG4gICAgICAgICAgICAgIHJ5MiA9IE1hdGgucG93KHJ5LCAyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGZhY3RvciA9IE1hdGguc3FydChNYXRoLmFicyhyeDIgKiByeTIgLSByeDIgKiB4UHJpbWUyWzFdIC0gcnkyICogeFByaW1lMlswXSkgLyAocngyICogeFByaW1lMlsxXSArIHJ5MiAqIHhQcmltZTJbMF0pKTtcblxuICAgICAgICAgICAgaWYgKGZBID09PSBmUykge1xuICAgICAgICAgICAgICBmYWN0b3IgKj0gLTEuMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGNQcmltZSA9IHNjYWxlKGZhY3RvciwgW3J4ICogeFByaW1lWzFdIC8gcnksIC1yeSAqIHhQcmltZVswXSAvIHJ4XSk7IC8vIEYuNi41LjJcblxuICAgICAgICAgICAgdmFyIGMgPSBzdW0ocm90Q291bnRlckNsb2Nrd2lzZShjUHJpbWUsIHBoaSksIG1lYW5WZWMoW3gxLCB5MV0sIFt4MiwgeTJdKSk7IC8vIEYuNi41LjNcblxuICAgICAgICAgICAgdmFyIHgxVW5pdFZlY3RvciA9IFsoeFByaW1lWzBdIC0gY1ByaW1lWzBdKSAvIHJ4LCAoeFByaW1lWzFdIC0gY1ByaW1lWzFdKSAvIHJ5XTtcbiAgICAgICAgICAgIHZhciB4MlVuaXRWZWN0b3IgPSBbKC0xLjAgKiB4UHJpbWVbMF0gLSBjUHJpbWVbMF0pIC8gcngsICgtMS4wICogeFByaW1lWzFdIC0gY1ByaW1lWzFdKSAvIHJ5XTtcbiAgICAgICAgICAgIHZhciB0aGV0YSA9IGFuZ2xlKFsxLCAwXSwgeDFVbml0VmVjdG9yKTsgLy8gRi42LjUuNVxuXG4gICAgICAgICAgICB2YXIgZGVsdGFUaGV0YSA9IGFuZ2xlKHgxVW5pdFZlY3RvciwgeDJVbml0VmVjdG9yKTsgLy8gRi42LjUuNlxuXG4gICAgICAgICAgICB2YXIgc3RhcnQgPSB0aGV0YTtcbiAgICAgICAgICAgIHZhciBlbmQgPSB0aGV0YSArIGRlbHRhVGhldGE7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShjWzBdLCBjWzFdKTtcbiAgICAgICAgICAgIGN0eC5yb3RhdGUocGhpKTtcbiAgICAgICAgICAgIGN0eC5zY2FsZShyeCwgcnkpO1xuICAgICAgICAgICAgY3R4LmFyYygwLCAwLCAxLCBzdGFydCwgZW5kLCAhZlMpO1xuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgUGF0aENvbW1hbmRzID0gZnVuY3Rpb24gUGF0aENvbW1hbmRzKGN0eCkge1xuICAgICAgICAgICAgdmFyIF90aGlzMTAzID0gdGhpcztcblxuICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBhdGhDb21tYW5kcyk7XG5cbiAgICAgICAgICAgIHZhciBsTXg7XG4gICAgICAgICAgICB2YXIgbE15O1xuICAgICAgICAgICAgdmFyIGx4ID0gMDtcbiAgICAgICAgICAgIHZhciBseSA9IDA7XG4gICAgICAgICAgICB2YXIgcmVmbGVjdGVkO1xuICAgICAgICAgICAgdmFyIGxhc3RDb21tYW5kID0gXCJcIjtcblxuICAgICAgICAgICAgZnVuY3Rpb24gbWFrZVJlZmxlY3RlZCgpIHtcbiAgICAgICAgICAgICAgaWYgKFwiQ2NTc1FxVHRcIi5pbmRleE9mKGxhc3RDb21tYW5kKSA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgeDogbHgsXG4gICAgICAgICAgICAgICAgICB5OiBseVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gcmVmbGVjdGVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLk0gPSBmdW5jdGlvbiAocHgsIHB5KSB7XG4gICAgICAgICAgICAgIGN0eC5tb3ZlVG8ocHgsIHB5KTtcbiAgICAgICAgICAgICAgbE14ID0gcHg7XG4gICAgICAgICAgICAgIGxNeSA9IHB5O1xuICAgICAgICAgICAgICBseCA9IHB4O1xuICAgICAgICAgICAgICBseSA9IHB5O1xuICAgICAgICAgICAgICBsYXN0Q29tbWFuZCA9IFwiTVwiO1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMxMDM7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLm0gPSBmdW5jdGlvbiAocHgsIHB5KSB7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczEwMy5NKHB4ICsgbHgsIHB5ICsgbHkpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5MID0gZnVuY3Rpb24gKHB4LCBweSkge1xuICAgICAgICAgICAgICBjdHgubGluZVRvKHB4LCBweSk7XG4gICAgICAgICAgICAgIGx4ID0gcHg7XG4gICAgICAgICAgICAgIGx5ID0gcHk7XG4gICAgICAgICAgICAgIGxhc3RDb21tYW5kID0gXCJMXCI7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczEwMztcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMubCA9IGZ1bmN0aW9uIChweCwgcHkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMTAzLkwocHggKyBseCwgcHkgKyBseSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLkggPSBmdW5jdGlvbiAocHgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMTAzLkwocHgsIGx5KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuaCA9IGZ1bmN0aW9uIChweCkge1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMxMDMuSChweCArIGx4KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuViA9IGZ1bmN0aW9uIChweSkge1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMxMDMuTChseCwgcHkpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy52ID0gZnVuY3Rpb24gKHB5KSB7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczEwMy5WKHB5ICsgbHkpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5aID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgIGx4ID0gbE14O1xuICAgICAgICAgICAgICBseSA9IGxNeTtcbiAgICAgICAgICAgICAgbGFzdENvbW1hbmQgPSBcIlpcIjtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMTAzO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy56ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMxMDMuWigpO1xuICAgICAgICAgICAgfTsgLy9DIHgxIHkxLCB4MiB5MiwgeCB5IChvciBjIGR4MSBkeTEsIGR4MiBkeTIsIGR4IGR5KVxuXG5cbiAgICAgICAgICAgIHRoaXMuQyA9IGZ1bmN0aW9uIChjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCBweCwgcHkpIHtcbiAgICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgcHgsIHB5KTtcbiAgICAgICAgICAgICAgbHggPSBweDtcbiAgICAgICAgICAgICAgbHkgPSBweTtcbiAgICAgICAgICAgICAgcmVmbGVjdGVkID0ge1xuICAgICAgICAgICAgICAgIHg6IDIgKiBweCAtIGNwMngsXG4gICAgICAgICAgICAgICAgeTogMiAqIHB5IC0gY3AyeVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBsYXN0Q29tbWFuZCA9IFwiQ1wiO1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMxMDM7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLmMgPSBmdW5jdGlvbiAoY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgcHgsIHB5KSB7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczEwMy5DKGNwMXggKyBseCwgY3AxeSArIGx5LCBjcDJ4ICsgbHgsIGNwMnkgKyBseSwgcHggKyBseCwgcHkgKyBseSk7XG4gICAgICAgICAgICB9OyAvL1MgeDIgeTIsIHggeSAob3IgcyBkeDIgZHkyLCBkeCBkeSlcblxuXG4gICAgICAgICAgICB0aGlzLlMgPSBmdW5jdGlvbiAoY3B4LCBjcHksIHB4LCBweSkge1xuICAgICAgICAgICAgICB2YXIgX21ha2VSZWZsZWN0ZWQgPSBtYWtlUmVmbGVjdGVkKCksXG4gICAgICAgICAgICAgICAgICBjcDF4ID0gX21ha2VSZWZsZWN0ZWQueCxcbiAgICAgICAgICAgICAgICAgIGNwMXkgPSBfbWFrZVJlZmxlY3RlZC55O1xuXG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczEwMy5DKGNwMXgsIGNwMXksIGNweCwgY3B5LCBweCwgcHkpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5zID0gZnVuY3Rpb24gKGNweCwgY3B5LCBweCwgcHkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMTAzLlMoY3B4ICsgbHgsIGNweSArIGx5LCBweCArIGx4LCBweSArIGx5KTtcbiAgICAgICAgICAgIH07IC8vUSB4MSB5MSwgeCB5IChvciBxIGR4MSBkeTEsIGR4IGR5KVxuXG5cbiAgICAgICAgICAgIHRoaXMuUSA9IGZ1bmN0aW9uIChjcHgsIGNweSwgcHgsIHB5KSB7XG4gICAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKGNweCwgY3B5LCBweCwgcHkpO1xuICAgICAgICAgICAgICBseCA9IHB4O1xuICAgICAgICAgICAgICBseSA9IHB5O1xuICAgICAgICAgICAgICByZWZsZWN0ZWQgPSB7XG4gICAgICAgICAgICAgICAgeDogMiAqIHB4IC0gY3B4LFxuICAgICAgICAgICAgICAgIHk6IDIgKiBweSAtIGNweVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBsYXN0Q29tbWFuZCA9IFwiUVwiO1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMxMDM7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLnEgPSBmdW5jdGlvbiAoY3B4LCBjcHksIHB4LCBweSkge1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMxMDMuUShjcHggKyBseCwgY3B5ICsgbHksIHB4ICsgbHgsIHB5ICsgbHkpO1xuICAgICAgICAgICAgfTsgLy9UIHggeSAob3IgdCBkeCBkeSlcblxuXG4gICAgICAgICAgICB0aGlzLlQgPSBmdW5jdGlvbiAocHgsIHB5KSB7XG4gICAgICAgICAgICAgIHZhciBfbWFrZVJlZmxlY3RlZDIgPSBtYWtlUmVmbGVjdGVkKCksXG4gICAgICAgICAgICAgICAgICBjcHggPSBfbWFrZVJlZmxlY3RlZDIueCxcbiAgICAgICAgICAgICAgICAgIGNweSA9IF9tYWtlUmVmbGVjdGVkMi55O1xuXG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczEwMy5RKGNweCwgY3B5LCBweCwgcHkpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy50ID0gZnVuY3Rpb24gKHB4LCBweSkge1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMxMDMuVChweCArIGx4LCBweSArIGx5KTtcbiAgICAgICAgICAgIH07IC8vQSByeCByeSB4LWF4aXMtcm90YXRpb24gbGFyZ2UtYXJjLWZsYWcgc3dlZXAtZmxhZyB4IHlcblxuXG4gICAgICAgICAgICB0aGlzLkEgPSBmdW5jdGlvbiAocngsIHJ5LCB4QXhpc1JvdGF0aW9uLCBsYXJnZUFyY0ZsYWcsIHN3ZWVwRmxhZywgcHgsIHB5KSB7XG4gICAgICAgICAgICAgIHZhciB4MSA9IGx4O1xuICAgICAgICAgICAgICB2YXIgeTEgPSBseTtcbiAgICAgICAgICAgICAgZWxsaXBzZUZyb21FbGxpcHRpY2FsQXJjKGN0eCwgeDEsIHkxLCByeCwgcnksIHhBeGlzUm90YXRpb24sIGxhcmdlQXJjRmxhZywgc3dlZXBGbGFnLCBweCwgcHkpO1xuICAgICAgICAgICAgICBseCA9IHB4O1xuICAgICAgICAgICAgICBseSA9IHB5O1xuICAgICAgICAgICAgICBsYXN0Q29tbWFuZCA9IFwiQVwiO1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMxMDM7XG4gICAgICAgICAgICB9OyAvL2EgcnggcnkgeC1heGlzLXJvdGF0aW9uIGxhcmdlLWFyYy1mbGFnIHN3ZWVwLWZsYWcgZHggZHlcblxuXG4gICAgICAgICAgICB0aGlzLmEgPSBmdW5jdGlvbiAocngsIHJ5LCB4QXhpc1JvdGF0aW9uLCBsYXJnZUFyY0ZsYWcsIHN3ZWVwRmxhZywgcHgsIHB5KSB7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczEwMy5BKHJ4LCByeSwgeEF4aXNSb3RhdGlvbiwgbGFyZ2VBcmNGbGFnLCBzd2VlcEZsYWcsIHB4ICsgbHgsIHB5ICsgbHkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgZXhwb3J0cy5QYXRoQ29tbWFuZHMgPSBQYXRoQ29tbWFuZHM7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vaW50ZXJuYWwvbGVnYWN5L2NhbnZhcy9QYXRoQ29tbWFuZHNQYXJzZXIuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9pbnRlcm5hbC9sZWdhY3kvY2FudmFzL1BhdGhDb21tYW5kc1BhcnNlci5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGludGVybmFsTGVnYWN5Q2FudmFzUGF0aENvbW1hbmRzUGFyc2VySnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5QYXRoQ29tbWFuZHNQYXJzZXIgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgUGF0aENvbW1hbmRzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL1BhdGhDb21tYW5kcyAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC9sZWdhY3kvY2FudmFzL1BhdGhDb21tYW5kcy5qc1wiKTtcblxuICAgICAgICAgIGZ1bmN0aW9uIHBhdGhUb2tlbnMoZCkge1xuICAgICAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgICAgICAgIHZhciBzID0gXCJcIjtcblxuICAgICAgICAgICAgICAgIHdoaWxlIChkLmxlbmd0aCA+IGlkeCkge1xuICAgICAgICAgICAgICAgICAgdmFyIGMgPSBkW2lkeF07XG4gICAgICAgICAgICAgICAgICBpZHgrKztcblxuICAgICAgICAgICAgICAgICAgaWYgKFwiICxcXG5cXHJcXHRcIi5pbmRleE9mKGMpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBcIi4rLTEyMzQ1Njc4OTBcIi5pbmRleE9mKGMpID4gLTEgPyBcIm51bVwiIDogXCJzdHJcIjtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJzdHJcIikge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZHgtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKFwiLStcIi5pbmRleE9mKGMpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAocykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWR4LS07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gXCIuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAocy5pbmRleE9mKFwiLlwiKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZHgtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHMgKz0gYztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcyB8fCBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGNvbW1hbmQoYnVpbGRlciwgY21kLCBhcmdzUHJvdmlkZXIpIHtcbiAgICAgICAgICAgIGlmIChjbWQudG9VcHBlckNhc2UoKSA9PT0gXCJNXCIgfHwgY21kLnRvVXBwZXJDYXNlKCkgPT09IFwiTFwiIHx8IGNtZC50b1VwcGVyQ2FzZSgpID09PSBcIlRcIikge1xuICAgICAgICAgICAgICBidWlsZGVyLmNvbW1hbmQoY21kLCBhcmdzUHJvdmlkZXIubmV4dCgpLCBhcmdzUHJvdmlkZXIubmV4dCgpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGNtZCA9PT0gXCJNXCIgPyBcIkxcIiA6IGNtZCA9PT0gXCJtXCIgPyBcImxcIiA6IGNtZDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY21kLnRvVXBwZXJDYXNlKCkgPT09IFwiSFwiIHx8IGNtZC50b1VwcGVyQ2FzZSgpID09PSBcIlZcIikge1xuICAgICAgICAgICAgICBidWlsZGVyLmNvbW1hbmQoY21kLCBhcmdzUHJvdmlkZXIubmV4dCgpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGNtZDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY21kLnRvVXBwZXJDYXNlKCkgPT09IFwiWlwiKSB7XG4gICAgICAgICAgICAgIGJ1aWxkZXIuY29tbWFuZChjbWQpO1xuICAgICAgICAgICAgICByZXR1cm4gY21kO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjbWQudG9VcHBlckNhc2UoKSA9PT0gXCJDXCIpIHtcbiAgICAgICAgICAgICAgYnVpbGRlci5jb21tYW5kKGNtZCwgYXJnc1Byb3ZpZGVyLm5leHQoKSwgYXJnc1Byb3ZpZGVyLm5leHQoKSwgYXJnc1Byb3ZpZGVyLm5leHQoKSwgYXJnc1Byb3ZpZGVyLm5leHQoKSwgYXJnc1Byb3ZpZGVyLm5leHQoKSwgYXJnc1Byb3ZpZGVyLm5leHQoKSk7XG4gICAgICAgICAgICAgIHJldHVybiBjbWQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNtZC50b1VwcGVyQ2FzZSgpID09PSBcIlNcIiB8fCBjbWQudG9VcHBlckNhc2UoKSA9PT0gXCJRXCIpIHtcbiAgICAgICAgICAgICAgYnVpbGRlci5jb21tYW5kKGNtZCwgYXJnc1Byb3ZpZGVyLm5leHQoKSwgYXJnc1Byb3ZpZGVyLm5leHQoKSwgYXJnc1Byb3ZpZGVyLm5leHQoKSwgYXJnc1Byb3ZpZGVyLm5leHQoKSk7XG4gICAgICAgICAgICAgIHJldHVybiBjbWQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNtZC50b1VwcGVyQ2FzZSgpID09PSBcIkFcIikge1xuICAgICAgICAgICAgICBidWlsZGVyLmNvbW1hbmQoY21kLCBhcmdzUHJvdmlkZXIubmV4dCgpLCBhcmdzUHJvdmlkZXIubmV4dCgpLCBhcmdzUHJvdmlkZXIubmV4dCgpLCBhcmdzUHJvdmlkZXIubmV4dCgpLCBhcmdzUHJvdmlkZXIubmV4dCgpLCBhcmdzUHJvdmlkZXIubmV4dCgpLCBhcmdzUHJvdmlkZXIubmV4dCgpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGNtZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2phL2RvY3MvV2ViL1NWRy9UdXRvcmlhbC9QYXRoc1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJ1bnN1cHBvcnRlZDpcIi5jb25jYXQoY21kKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBQYXRoQ29tbWFuZHNQYXJzZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gUGF0aENvbW1hbmRzUGFyc2VyKCkge1xuICAgICAgICAgICAgICB2YXIgX3RoaXMxMDQgPSB0aGlzO1xuXG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQYXRoQ29tbWFuZHNQYXJzZXIpO1xuXG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgIHRoaXMuX29wcyA9IFtdO1xuICAgICAgICAgICAgICB0aGlzLl9jb21tYW5kcyA9IG5ldyBQYXRoQ29tbWFuZHNfMS5QYXRoQ29tbWFuZHModGhpcyk7XG5cbiAgICAgICAgICAgICAgdmFyIGJ1aWxkUHVzaCA9IGZ1bmN0aW9uIGJ1aWxkUHVzaChvcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbjIxID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMjEpLCBfa2V5MjEgPSAwOyBfa2V5MjEgPCBfbGVuMjE7IF9rZXkyMSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgYXJnc1tfa2V5MjFdID0gYXJndW1lbnRzW19rZXkyMV07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBfdGhpczEwNC5fb3BzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgIG9wOiBvcCxcbiAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBhcmdzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgdGhpcy5tb3ZlVG8gPSBidWlsZFB1c2goXCJtb3ZlVG9cIik7XG4gICAgICAgICAgICAgIHRoaXMubGluZVRvID0gYnVpbGRQdXNoKFwibGluZVRvXCIpO1xuICAgICAgICAgICAgICB0aGlzLmNsb3NlUGF0aCA9IGJ1aWxkUHVzaChcImNsb3NlUGF0aFwiKTtcbiAgICAgICAgICAgICAgdGhpcy5iZXppZXJDdXJ2ZVRvID0gYnVpbGRQdXNoKFwiYmV6aWVyQ3VydmVUb1wiKTtcbiAgICAgICAgICAgICAgdGhpcy5xdWFkcmF0aWNDdXJ2ZVRvID0gYnVpbGRQdXNoKFwicXVhZHJhdGljQ3VydmVUb1wiKTtcbiAgICAgICAgICAgICAgdGhpcy5zYXZlID0gYnVpbGRQdXNoKFwic2F2ZVwiKTtcbiAgICAgICAgICAgICAgdGhpcy50cmFuc2xhdGUgPSBidWlsZFB1c2goXCJ0cmFuc2xhdGVcIik7XG4gICAgICAgICAgICAgIHRoaXMucm90YXRlID0gYnVpbGRQdXNoKFwicm90YXRlXCIpO1xuICAgICAgICAgICAgICB0aGlzLnNjYWxlID0gYnVpbGRQdXNoKFwic2NhbGVcIik7XG4gICAgICAgICAgICAgIHRoaXMuYXJjID0gYnVpbGRQdXNoKFwiYXJjXCIpO1xuICAgICAgICAgICAgICB0aGlzLnJlc3RvcmUgPSBidWlsZFB1c2goXCJyZXN0b3JlXCIpO1xuICAgICAgICAgICAgICB0aGlzLmFyY1RvID0gYnVpbGRQdXNoKFwiYXJjVG9cIik7XG4gICAgICAgICAgICAgIHRoaXMuZWxsaXBzZSA9IGJ1aWxkUHVzaChcImVsbGlwc2VcIik7XG4gICAgICAgICAgICAgIHRoaXMucmVjdCA9IGJ1aWxkUHVzaChcInJlY3RcIik7XG4gICAgICAgICAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKFBhdGhDb21tYW5kc1BhcnNlciwgW3tcbiAgICAgICAgICAgICAga2V5OiBcImNvbW1hbmRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbW1hbmQobmFtZSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9sZW4yMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIyID4gMSA/IF9sZW4yMiAtIDEgOiAwKSwgX2tleTIyID0gMTsgX2tleTIyIDwgX2xlbjIyOyBfa2V5MjIrKykge1xuICAgICAgICAgICAgICAgICAgYXJnc1tfa2V5MjIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5MjJdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgdmFyIG51bUFyZ3MgPSBhcmdzIHx8IFtdO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICBudW1BcmdzW2ldIC09IDA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGNvbW1hbmQgPSB0aGlzLl9jb21tYW5kc1tuYW1lXTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcblxuICAgICAgICAgICAgICAgIGNvbW1hbmQuYXBwbHkodGhpcywgbnVtQXJncyk7XG4gICAgICAgICAgICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwicGFyc2VcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlKGQpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMxMDUgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgdmFyIG9wcyA9IHRoaXMuX29wcyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciB0b2tlbnMgPSBwYXRoVG9rZW5zKGQpO1xuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjbWQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdWJzZXF1ZW50Q29tbWFuZCA9IFwiWlwiO1xuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChjbWQgPSB0b2tlbnMubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc05hTihOdW1iZXIoY21kKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmc3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJnc1Byb3ZpZGVyID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY21kO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5zLm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNlcXVlbnRDb21tYW5kID0gY29tbWFuZChfdGhpczEwNSwgc3Vic2VxdWVudENvbW1hbmQsIGFyZ3NQcm92aWRlcikgfHwgXCJaXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzZXF1ZW50Q29tbWFuZCA9IGNvbW1hbmQoX3RoaXMxMDUsIGNtZCwgdG9rZW5zKSB8fCBcIlpcIjtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJFcnJvcjogXCIuY29uY2F0KGQpKTtcbiAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gUGF0aENvbW1hbmRzUGFyc2VyO1xuICAgICAgICAgIH0oKTtcblxuICAgICAgICAgIGV4cG9ydHMuUGF0aENvbW1hbmRzUGFyc2VyID0gUGF0aENvbW1hbmRzUGFyc2VyO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2ludGVybmFsL2xlZ2FjeS9mb250d2F0Y2gvRm9udFJ1bGVyLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vaW50ZXJuYWwvbGVnYWN5L2ZvbnR3YXRjaC9Gb250UnVsZXIuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBpbnRlcm5hbExlZ2FjeUZvbnR3YXRjaEZvbnRSdWxlckpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiOyAvL3NlZSBodHRwczovL2dpdGh1Yi5jb20vdHlwZWtpdC93ZWJmb250bG9hZGVyXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5Gb250UnVsZXIgPSB2b2lkIDA7XG5cbiAgICAgICAgICBmdW5jdGlvbiBjb21wdXRlU3R5bGUoZm9udCkge1xuICAgICAgICAgICAgcmV0dXJuIFt7XG4gICAgICAgICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIixcbiAgICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICAgICAgdG9wOiBcIi05OTk5cHhcIixcbiAgICAgICAgICAgICAgbGVmdDogXCItOTk5OXB4XCIsXG4gICAgICAgICAgICAgIHdpZHRoOiBcImF1dG9cIixcbiAgICAgICAgICAgICAgaGVpZ2h0OiBcImF1dG9cIixcbiAgICAgICAgICAgICAgbWFyZ2luOiBcIjBcIixcbiAgICAgICAgICAgICAgcGFkZGluZzogXCIwXCIsXG4gICAgICAgICAgICAgIFwid2hpdGUtc3BhY2VcIjogXCJub3dyYXBcIixcbiAgICAgICAgICAgICAgZm9udDogZm9udFxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBcImZvbnQtdmFyaWFudFwiOiBcIm5vcm1hbFwiLFxuICAgICAgICAgICAgICBcImZvbnQtc2l6ZVwiOiBcIjMwMHB4XCIsXG4gICAgICAgICAgICAgIFwiZm9udC1zdHlsZVwiOiBcIm5vcm1hbFwiLFxuICAgICAgICAgICAgICBcImZvbnQtd2VpZ2h0XCI6IFwiNDAwXCIsXG4gICAgICAgICAgICAgIFwibGluZS1oZWlnaHRcIjogXCJub3JtYWxcIlxuICAgICAgICAgICAgfV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIEZvbnRSdWxlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBGb250UnVsZXIoZm9udCwgdGVzdFN0cikge1xuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRm9udFJ1bGVyKTtcblxuICAgICAgICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgICAgICAgZS50ZXh0Q29udGVudCA9IHRlc3RTdHIgfHwgXCJCRVNic3d5XCI7XG4gICAgICAgICAgICAgIGNvbXB1dGVTdHlsZShmb250KS5mb3JFYWNoKGZ1bmN0aW9uIChzdHlsZSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgaW4gc3R5bGUpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXG4gICAgICAgICAgICAgICAgICBlLnN0eWxlW2tleV0gPSBzdHlsZVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZSk7XG4gICAgICAgICAgICAgIHRoaXMuZWxfID0gZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKEZvbnRSdWxlciwgW3tcbiAgICAgICAgICAgICAga2V5OiBcImdldFdpZHRoXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRXaWR0aCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbF8ub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInJlbW92ZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGhpcy5lbF8pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBGb250UnVsZXI7XG4gICAgICAgICAgfSgpO1xuXG4gICAgICAgICAgZXhwb3J0cy5Gb250UnVsZXIgPSBGb250UnVsZXI7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vaW50ZXJuYWwvbGVnYWN5L2ZvbnR3YXRjaC9Gb250V2F0Y2hSdW5uZXIuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9pbnRlcm5hbC9sZWdhY3kvZm9udHdhdGNoL0ZvbnRXYXRjaFJ1bm5lci5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGludGVybmFsTGVnYWN5Rm9udHdhdGNoRm9udFdhdGNoUnVubmVySnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7IC8vc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90eXBla2l0L3dlYmZvbnRsb2FkZXJcbiAgICAgICAgICAvL2h0dHA6Ly9kZWZnaGkxOTc3Lmh0bWwueGRvbWFpbi5qcC90ZWNoL2NhbnZhc01lbW8vY2FudmFzTWVtby5odG1cblxuICAgICAgICAgIHZhciBGb250UnVsZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vRm9udFJ1bGVyICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL2xlZ2FjeS9mb250d2F0Y2gvRm9udFJ1bGVyLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIExhc3RSZXNvcnRGb250cyA9IHtcbiAgICAgICAgICAgIFNFUklGOiBcInNlcmlmXCIsXG4gICAgICAgICAgICBTQU5TX1NFUklGOiBcInNhbnMtc2VyaWZcIlxuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIHdhdGNoUnVubmVycyA9IHt9O1xuXG4gICAgICAgICAgdmFyIEZvbnRXYXRjaFJ1bm5lciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBGb250V2F0Y2hSdW5uZXIoZm9udCwgdGVzdFN0cikge1xuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRm9udFdhdGNoUnVubmVyKTtcblxuICAgICAgICAgICAgICB0aGlzLmFjdGl2ZUNhbGxiYWNrcyA9IFtdO1xuICAgICAgICAgICAgICB0aGlzLmluYWN0aXZlQ2FsbGJhY2tzID0gW107XG4gICAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gbnVsbDtcbiAgICAgICAgICAgICAgdGhpcy5sYXN0UmVzb3J0V2lkdGhzXyA9IHt9O1xuICAgICAgICAgICAgICB0aGlzLmZvbnRSdWxlckFfID0gbmV3IEZvbnRSdWxlcl8xLkZvbnRSdWxlcihcIlwiLmNvbmNhdChmb250LCBcIixcIikuY29uY2F0KExhc3RSZXNvcnRGb250cy5TRVJJRiksIHRlc3RTdHIpO1xuICAgICAgICAgICAgICB0aGlzLmZvbnRSdWxlckJfID0gbmV3IEZvbnRSdWxlcl8xLkZvbnRSdWxlcihcIlwiLmNvbmNhdChmb250LCBcIixcIikuY29uY2F0KExhc3RSZXNvcnRGb250cy5TQU5TX1NFUklGKSwgdGVzdFN0cik7XG4gICAgICAgICAgICAgIHZhciBsYXN0UmVzb3J0UnVsZXJBID0gbmV3IEZvbnRSdWxlcl8xLkZvbnRSdWxlcihcIjRweCBcIi5jb25jYXQoTGFzdFJlc29ydEZvbnRzLlNFUklGKSwgdGVzdFN0cik7XG4gICAgICAgICAgICAgIHZhciBsYXN0UmVzb3J0UnVsZXJCID0gbmV3IEZvbnRSdWxlcl8xLkZvbnRSdWxlcihcIjRweCBcIi5jb25jYXQoTGFzdFJlc29ydEZvbnRzLlNBTlNfU0VSSUYpLCB0ZXN0U3RyKTsgLy9zdGFydFxuXG4gICAgICAgICAgICAgIHRoaXMubGFzdFJlc29ydFdpZHRoc19bTGFzdFJlc29ydEZvbnRzLlNFUklGXSA9IGxhc3RSZXNvcnRSdWxlckEuZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgICAgdGhpcy5sYXN0UmVzb3J0V2lkdGhzX1tMYXN0UmVzb3J0Rm9udHMuU0FOU19TRVJJRl0gPSBsYXN0UmVzb3J0UnVsZXJCLmdldFdpZHRoKCk7XG4gICAgICAgICAgICAgIGxhc3RSZXNvcnRSdWxlckEucmVtb3ZlKCk7XG4gICAgICAgICAgICAgIGxhc3RSZXNvcnRSdWxlckIucmVtb3ZlKCk7XG4gICAgICAgICAgICAgIHRoaXMuc3RhcnRlZF8gPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICB0aGlzLmNoZWNrXygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoRm9udFdhdGNoUnVubmVyLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwidGhlblwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdGhlbihhY3RpdmVDYWxsYmFjaywgaW5hY3RpdmVDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdHVzICE9PSBcIm5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlQ2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGluYWN0aXZlQ2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVDYWxsYmFja3MucHVzaChhY3RpdmVDYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICB0aGlzLmluYWN0aXZlQ2FsbGJhY2tzLnB1c2goaW5hY3RpdmVDYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjaGVja19cIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrXygpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMxMDYgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoQSA9IHRoaXMuZm9udFJ1bGVyQV8uZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGhCID0gdGhpcy5mb250UnVsZXJCXy5nZXRXaWR0aCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNGYWxsYmFja0ZvbnRfKHdpZHRoQSwgd2lkdGhCKSB8fCB0aGlzLmlzTGFzdFJlc29ydEZvbnRfKHdpZHRoQSwgd2lkdGhCKSkge1xuICAgICAgICAgICAgICAgICAgaWYgKERhdGUubm93KCkgLSB0aGlzLnN0YXJ0ZWRfID49IDMwMDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGltZW91dFxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0xhc3RSZXNvcnRGb250Xyh3aWR0aEEsIHdpZHRoQikpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmlzaF8odGhpcy5hY3RpdmVDYWxsYmFja3MpO1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gXCJva1wiO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmluaXNoXyh0aGlzLmluYWN0aXZlQ2FsbGJhY2tzKTtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXR1cyA9IFwibmdcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgX3RoaXMxMDYuY2hlY2tfKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIDUwKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGhpcy5maW5pc2hfKHRoaXMuYWN0aXZlQ2FsbGJhY2tzKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gXCJva1wiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiaXNGYWxsYmFja0ZvbnRfXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc0ZhbGxiYWNrRm9udF8oYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndpZHRoTWF0Y2hlc18oYSwgTGFzdFJlc29ydEZvbnRzLlNFUklGKSAmJiB0aGlzLndpZHRoTWF0Y2hlc18oYiwgTGFzdFJlc29ydEZvbnRzLlNBTlNfU0VSSUYpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJ3aWR0aHNNYXRjaExhc3RSZXNvcnRXaWR0aHNfXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB3aWR0aHNNYXRjaExhc3RSZXNvcnRXaWR0aHNfKGEsIGIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBmb250IGluIExhc3RSZXNvcnRGb250cykge1xuICAgICAgICAgICAgICAgICAgaWYgKExhc3RSZXNvcnRGb250cy5oYXNPd25Qcm9wZXJ0eShmb250KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy53aWR0aE1hdGNoZXNfKGEsIExhc3RSZXNvcnRGb250c1tmb250XSkgJiYgdGhpcy53aWR0aE1hdGNoZXNfKGIsIExhc3RSZXNvcnRGb250c1tmb250XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwid2lkdGhNYXRjaGVzX1wiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gd2lkdGhNYXRjaGVzXyh3aWR0aCwgbGFzdFJlc29ydEZvbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2lkdGggPT09IHRoaXMubGFzdFJlc29ydFdpZHRoc19bbGFzdFJlc29ydEZvbnRdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJpc0xhc3RSZXNvcnRGb250X1wiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNMYXN0UmVzb3J0Rm9udF8oYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBoYXNXZWJLaXRGYWxsYmFja0J1ZygpICYmIHRoaXMud2lkdGhzTWF0Y2hMYXN0UmVzb3J0V2lkdGhzXyhhLCBiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZmluaXNoX1wiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZmluaXNoXyhjYWxsYmFja3MpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMxMDcgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICBfdGhpczEwNy5mb250UnVsZXJBXy5yZW1vdmUoKTtcblxuICAgICAgICAgICAgICAgICAgX3RoaXMxMDcuZm9udFJ1bGVyQl8ucmVtb3ZlKCk7XG5cbiAgICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2IoKTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSwgW3tcbiAgICAgICAgICAgICAga2V5OiBcImxvYWRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWQoZm9udCwgdGVzdFN0ciwgYWN0aXZlQ2FsbGJhY2ssIGluYWN0aXZlQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB2YXIgYyA9IHdhdGNoUnVubmVyc1tmb250XSB8fCAod2F0Y2hSdW5uZXJzW2ZvbnRdID0ge30pO1xuICAgICAgICAgICAgICAgIHRlc3RTdHIgKz0gXCJcIjtcbiAgICAgICAgICAgICAgICB2YXIgcnVubmVyO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNbdGVzdFN0cl0pIHtcbiAgICAgICAgICAgICAgICAgIHJ1bm5lciA9IGNbdGVzdFN0cl07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJ1bm5lciA9IGNbdGVzdFN0cl0gPSBuZXcgRm9udFdhdGNoUnVubmVyKGZvbnQsIHRlc3RTdHIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJ1bm5lci50aGVuKGFjdGl2ZUNhbGxiYWNrLCBpbmFjdGl2ZUNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gRm9udFdhdGNoUnVubmVyO1xuICAgICAgICAgIH0oKTtcblxuICAgICAgICAgIHZhciBIQVNfV0VCS0lUX0ZBTExCQUNLX0JVRyA9IG51bGw7XG5cbiAgICAgICAgICBmdW5jdGlvbiBoYXNXZWJLaXRGYWxsYmFja0J1ZygpIHtcbiAgICAgICAgICAgIGlmIChIQVNfV0VCS0lUX0ZBTExCQUNLX0JVRyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSAvQXBwbGVXZWJLaXRcXC8oWzAtOV0rKSg/OlxcLihbMC05XSspKS8uZXhlYyh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgICAgICAgICAgIEhBU19XRUJLSVRfRkFMTEJBQ0tfQlVHID0gISFtYXRjaCAmJiAocGFyc2VJbnQobWF0Y2hbMV0sIDEwKSA8IDUzNiB8fCBwYXJzZUludChtYXRjaFsxXSwgMTApID09PSA1MzYgJiYgcGFyc2VJbnQobWF0Y2hbMl0sIDEwKSA8PSAxMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBIQVNfV0VCS0lUX0ZBTExCQUNLX0JVRztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IEZvbnRXYXRjaFJ1bm5lcjtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9pbnRlcm5hbC9tZW51LWl0ZW1zLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9pbnRlcm5hbC9tZW51LWl0ZW1zLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBpbnRlcm5hbE1lbnVJdGVtc0pzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMubm9ybWFsaXplVG9GbiA9IGV4cG9ydHMubm9ybWFsaXplID0gdm9pZCAwO1xuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gICAgICAgICAgZnVuY3Rpb24gZXh0ZW5kKGEsIGIpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICB2YXIgbyA9IHt9O1xuXG4gICAgICAgICAgICBmb3IgKHZhciBrIGluIGEpIHtcbiAgICAgICAgICAgICAgb1trXSA9IGFba107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIF9rMyBpbiBiKSB7XG4gICAgICAgICAgICAgIG9bX2szXSA9IGJbX2szXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIE5vcm1hbGl6ZSB0aGUgZ2l2ZW4gbWVudSBvcHRpb25zLlxuICAgICAgICAgICAqIEBwYXJhbSB7Kn0gb3B0aW9ucyBtZW51IG9wdGlvbnMgdG8gZ2l2ZW5cbiAgICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXl9IE5vcm1hbGl6ZWQgb3B0aW9uc1xuICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICovXG5cblxuICAgICAgICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZShvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zKSkge1xuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5tYXAoIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4dGVuZChlLCB7XG4gICAgICAgICAgICAgICAgICBsYWJlbDogZS5jYXB0aW9uIHx8IGUubGFiZWxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplKEpTT04ucGFyc2Uob3B0aW9ucykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGssXG4gICAgICAgICAgICAgICAgbGFiZWw6IG9wdGlvbnNba11cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5ub3JtYWxpemUgPSBub3JtYWxpemU7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogTm9ybWFsaXplIHRoZSBnaXZlbiBtZW51IG9wdGlvbnMuXG4gICAgICAgICAgICogQHBhcmFtIHsqfSBvcHRpb25zIG1lbnUgb3B0aW9ucyB0byBnaXZlblxuICAgICAgICAgICAqIEByZXR1cm5zIHtBcnJheX0gTm9ybWFsaXplZCBvcHRpb25zXG4gICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgKi9cblxuICAgICAgICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVRvRm4ob3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplKG9wdGlvbnMocmVjb3JkKSk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBub3JtYWxpemUob3B0aW9ucyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMubm9ybWFsaXplVG9GbiA9IG5vcm1hbGl6ZVRvRm47XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vaW50ZXJuYWwvcGFzdGUtdXRpbHMuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9pbnRlcm5hbC9wYXN0ZS11dGlscy5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGludGVybmFsUGFzdGVVdGlsc0pzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMucGFyc2VQYXN0ZVJhbmdlQm94VmFsdWVzID0gZXhwb3J0cy5ub3JtYWxpemVQYXN0ZVZhbHVlID0gdm9pZCAwO1xuXG4gICAgICAgICAgZnVuY3Rpb24gbm9ybWFsaXplUGFzdGVWYWx1ZSh0ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGV4dFt0ZXh0Lmxlbmd0aCAtIDFdICE9PSBcIlxcblwiID8gdGV4dCA6IHRleHRbdGV4dC5sZW5ndGggLSAyXSA9PT0gXCJcXHJcIiA/IHRleHQuc2xpY2UoMCwgLTIpIDogdGV4dC5zbGljZSgwLCAtMSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5ub3JtYWxpemVQYXN0ZVZhbHVlID0gbm9ybWFsaXplUGFzdGVWYWx1ZTtcblxuICAgICAgICAgIGZ1bmN0aW9uIHBhcnNlUGFzdGVSYW5nZUJveFZhbHVlcyh2YWx1ZSwgb3B0aW9uKSB7XG4gICAgICAgICAgICB2YXIgbm9ybWFsaXplZFZhbHVlID0gbm9ybWFsaXplUGFzdGVWYWx1ZSh2YWx1ZSk7XG5cbiAgICAgICAgICAgIHZhciBfcGFyc2VWYWx1ZXMgPSBwYXJzZVZhbHVlcyhub3JtYWxpemVkVmFsdWUsIG9wdGlvbiksXG4gICAgICAgICAgICAgICAgdmFsdWVzID0gX3BhcnNlVmFsdWVzLnZhbHVlcyxcbiAgICAgICAgICAgICAgICBjb2xDb3VudCA9IF9wYXJzZVZhbHVlcy5jb2xDb3VudDtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgY29sQ291bnQ6IGNvbENvdW50LFxuICAgICAgICAgICAgICByb3dDb3VudDogdmFsdWVzLmxlbmd0aCxcbiAgICAgICAgICAgICAgZ2V0Q2VsbFZhbHVlOiBmdW5jdGlvbiBnZXRDZWxsVmFsdWUob2Zmc2V0Q29sLCBvZmZzZXRSb3cpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHZhbHVlc1tvZmZzZXRSb3ddKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Fbb2Zmc2V0Q29sXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCJcIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRzLnBhcnNlUGFzdGVSYW5nZUJveFZhbHVlcyA9IHBhcnNlUGFzdGVSYW5nZUJveFZhbHVlcztcblxuICAgICAgICAgIGZ1bmN0aW9uIHBhcnNlVmFsdWVzKHRleHQsIF9yZWY4NCkge1xuICAgICAgICAgICAgdmFyIHRyaW1PblBhc3RlID0gX3JlZjg0LnRyaW1PblBhc3RlO1xuICAgICAgICAgICAgdmFyIGxlbiA9IHRleHQubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGFkanVzdENlbGwgPSB0cmltT25QYXN0ZSA/IGZ1bmN0aW9uIChjZWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjZWxsLnRyaW0oKTtcbiAgICAgICAgICAgIH0gOiBmdW5jdGlvbiAoY2VsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gY2VsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgY29sQ291bnQgPSAxO1xuICAgICAgICAgICAgdmFyIGxpbmUgPSBbXTtcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBbbGluZV07XG4gICAgICAgICAgICB2YXIgY2VsbCA9IFwiXCI7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW47IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgdmFyIGNoYXIgPSB0ZXh0W2luZGV4XTtcblxuICAgICAgICAgICAgICBpZiAoY2hhciA9PT0gXCJcXHRcIikge1xuICAgICAgICAgICAgICAgIGxpbmUucHVzaChhZGp1c3RDZWxsKGNlbGwpKTtcbiAgICAgICAgICAgICAgICBjZWxsID0gXCJcIjtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChjaGFyID09PSBcIlxcblwiKSB7XG4gICAgICAgICAgICAgICAgLy8gRW5kIG9mIGxpbmVcbiAgICAgICAgICAgICAgICBjZWxsID0gYWRqdXN0Q2VsbChjZWxsKTtcblxuICAgICAgICAgICAgICAgIGlmIChjZWxsW2NlbGwubGVuZ3RoIC0gMV0gPT09IFwiXFxyXCIpIHtcbiAgICAgICAgICAgICAgICAgIGNlbGwgPSBjZWxsLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsaW5lLnB1c2goY2VsbCk7XG4gICAgICAgICAgICAgICAgY29sQ291bnQgPSBNYXRoLm1heChjb2xDb3VudCwgbGluZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGxpbmUgPSBbXTtcbiAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaChsaW5lKTtcbiAgICAgICAgICAgICAgICBjZWxsID0gXCJcIjtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChjaGFyID09PSAnXCInICYmICFjZWxsLnRyaW0oKSkge1xuICAgICAgICAgICAgICAgIHZhciBxdW90ZWQgPSBwcm9jZXNzUXVvdGVkQ2VsbChpbmRleCArIDEpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHF1b3RlZCkge1xuICAgICAgICAgICAgICAgICAgY2VsbCA9IHF1b3RlZC5jZWxsO1xuICAgICAgICAgICAgICAgICAgaW5kZXggPSBxdW90ZWQubmV4dCAtIDE7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjZWxsICs9IGNoYXI7XG4gICAgICAgICAgICB9IC8vIEVuZCBvZiB0ZXh0XG5cblxuICAgICAgICAgICAgbGluZS5wdXNoKGFkanVzdENlbGwoY2VsbCkpO1xuICAgICAgICAgICAgY29sQ291bnQgPSBNYXRoLm1heChjb2xDb3VudCwgbGluZS5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdmFsdWVzOiB2YWx1ZXMsXG4gICAgICAgICAgICAgIGNvbENvdW50OiBjb2xDb3VudFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gcHJvY2Vzc1F1b3RlZENlbGwoc3RhcnQpIHtcbiAgICAgICAgICAgICAgdmFyIGNlbGwgPSBcIlwiO1xuICAgICAgICAgICAgICB2YXIgaW5kZXggPSBzdGFydDtcblxuICAgICAgICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgX2NoYXIgPSB0ZXh0W2luZGV4XTtcblxuICAgICAgICAgICAgICAgIGlmIChfY2hhciAhPT0gJ1wiJykge1xuICAgICAgICAgICAgICAgICAgY2VsbCArPSBfY2hhcjtcbiAgICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGV4dFtpbmRleCArIDFdID09PSAnXCInKSB7XG4gICAgICAgICAgICAgICAgICAvLyBFc2NhcGVcbiAgICAgICAgICAgICAgICAgIGNlbGwgKz0gJ1wiJztcbiAgICAgICAgICAgICAgICAgIGluZGV4ICs9IDI7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9IC8vIE1heWJlIGVuZCBxdW90ZVxuXG5cbiAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IGluZGV4ICsgMTtcblxuICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0IDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgYyA9IHRleHRbbmV4dF07XG5cbiAgICAgICAgICAgICAgICAgIGlmIChjLnRyaW0oKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBOb3QgcXVvdGVkLiBlLmcuIFwiQVwiQlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IFwiXFx0XCIgfHwgYyA9PT0gXCJcXG5cIikge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH0gLy8gQWxsb3cgc3BhY2VzXG5cblxuICAgICAgICAgICAgICAgICAgbmV4dCsrO1xuICAgICAgICAgICAgICAgIH0gLy8gRW5kIHF1b3RlXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICBjZWxsOiBjZWxsLFxuICAgICAgICAgICAgICAgICAgbmV4dDogbmV4dFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqKi9cblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9pbnRlcm5hbC9wYXRoMkRNYW5hZ2VyLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9pbnRlcm5hbC9wYXRoMkRNYW5hZ2VyLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBpbnRlcm5hbFBhdGgyRE1hbmFnZXJKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLmZpbGwgPSBleHBvcnRzLmdldFBhdGgyRCA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi91dGlscyAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC91dGlscy5qc1wiKTtcblxuICAgICAgICAgIGZ1bmN0aW9uIGdldFBhdGgyRCgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgUGF0aDJEICE9PSBcInVuZGVmaW5lZFwiICYmICF1dGlsc18xLmJyb3dzZXIuRWRnZSkge1xuICAgICAgICAgICAgICByZXR1cm4gUGF0aDJEO1xuICAgICAgICAgICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXZhci1yZXF1aXJlc1xuXG5cbiAgICAgICAgICAgIHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIC4vbGVnYWN5L2NhbnZhcy9QYXRoMkRTaGltICovXG4gICAgICAgICAgICBcIi4vaW50ZXJuYWwvbGVnYWN5L2NhbnZhcy9QYXRoMkRTaGltLmpzXCIpLlBhdGgyRFNoaW07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5nZXRQYXRoMkQgPSBnZXRQYXRoMkQ7XG5cbiAgICAgICAgICBmdW5jdGlvbiBmaWxsKHBhdGhNb2R1bGUsIGN0eCwgeCwgeSwgdywgaCkge1xuICAgICAgICAgICAgY3R4LnNhdmUoKTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdmFyIHdpZHRoID0gcGF0aE1vZHVsZS53aWR0aCxcbiAgICAgICAgICAgICAgICAgIGhlaWdodCA9IHBhdGhNb2R1bGUuaGVpZ2h0O1xuICAgICAgICAgICAgICB2YXIgdXBzaWRlRG93biA9IHBhdGhNb2R1bGUudWQsXG4gICAgICAgICAgICAgICAgICBfcGF0aE1vZHVsZSR4ID0gcGF0aE1vZHVsZS54LFxuICAgICAgICAgICAgICAgICAgb2Zmc2V0WCA9IF9wYXRoTW9kdWxlJHggPT09IHZvaWQgMCA/IDAgOiBfcGF0aE1vZHVsZSR4LFxuICAgICAgICAgICAgICAgICAgX3BhdGhNb2R1bGUkeSA9IHBhdGhNb2R1bGUueSxcbiAgICAgICAgICAgICAgICAgIG9mZnNldFkgPSBfcGF0aE1vZHVsZSR5ID09PSB2b2lkIDAgPyAwIDogX3BhdGhNb2R1bGUkeTtcbiAgICAgICAgICAgICAgdyA9IHcgfHwgd2lkdGg7XG4gICAgICAgICAgICAgIGggPSBoIHx8IGhlaWdodDtcbiAgICAgICAgICAgICAgdmFyIHhyYXRlID0gdyAvIHdpZHRoO1xuICAgICAgICAgICAgICB2YXIgeXJhdGUgPSBoIC8gKHVwc2lkZURvd24gPyAtaGVpZ2h0IDogaGVpZ2h0KTtcbiAgICAgICAgICAgICAgeCA9IHggfHwgMDtcbiAgICAgICAgICAgICAgeSA9IHVwc2lkZURvd24gPyAoeSB8fCAwKSArIC1oZWlnaHQgKiB5cmF0ZSA6IHkgfHwgMDtcbiAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICAgICAgICAgICAgY3R4LnNjYWxlKHhyYXRlLCB5cmF0ZSk7XG5cbiAgICAgICAgICAgICAgaWYgKG9mZnNldFggIT09IDAgfHwgb2Zmc2V0WSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUob2Zmc2V0WCwgb2Zmc2V0WSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgX1BhdGgyRCA9IGdldFBhdGgyRCgpO1xuXG4gICAgICAgICAgICAgIHZhciBwYXRoMmQgPSBwYXRoTW9kdWxlLnBhdGgyZCA9IHBhdGhNb2R1bGUucGF0aDJkIHx8IG5ldyBfUGF0aDJEKHBhdGhNb2R1bGUuZCk7XG4gICAgICAgICAgICAgIGN0eC5maWxsKHBhdGgyZCk7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMuZmlsbCA9IGZpbGw7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vaW50ZXJuYWwvc29ydC5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vaW50ZXJuYWwvc29ydC5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gaW50ZXJuYWxTb3J0SnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5zb3J0UHJvbWlzZSA9IGV4cG9ydHMuc29ydCA9IGV4cG9ydHMuc29ydEFycmF5ID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIHV0aWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL3V0aWxzICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL3V0aWxzLmpzXCIpO1xuXG4gICAgICAgICAgZnVuY3Rpb24gY3JlYXRlQXJyYXkoZ2V0LCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBhcnJheSA9IG5ldyBBcnJheShsZW5ndGgpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGFycmF5W2ldID0gZ2V0KGkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gY3JlYXRlQXJyYXlQcm9taXNlKGdldCwgZ2V0RmllbGQsIGxlbmd0aCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICAgIHZhciBwbGlzdCA9IFtdO1xuICAgICAgICAgICAgICB2YXIgYXJyYXkgPSBuZXcgQXJyYXkobGVuZ3RoKTtcblxuICAgICAgICAgICAgICB2YXIgX2xvb3A3ID0gZnVuY3Rpb24gX2xvb3A3KGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IGdldChpKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVjb3JkID0ge1xuICAgICAgICAgICAgICAgICAgdjogZGF0YSxcbiAgICAgICAgICAgICAgICAgIGY6IGRhdGFcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGFycmF5W2ldID0gcmVjb3JkO1xuXG4gICAgICAgICAgICAgICAgaWYgKCgwLCB1dGlsc18xLmlzUHJvbWlzZSkoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgIHBsaXN0LnB1c2goZGF0YS50aGVuKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY29yZC52ID0gdjtcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkLmYgPSB2O1xuICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgX2xvb3A3KGkpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgUHJvbWlzZS5hbGwocGxpc3QpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRGaWVsZCA9PSBudWxsID8gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICBhcnJheSA6IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgc2V0QXJyYXlGaWVsZChhcnJheSwgZ2V0RmllbGQpO1xuICAgICAgICAgICAgICB9KS50aGVuKHJlc29sdmUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gc2V0QXJyYXlGaWVsZChhcnJheSwgZ2V0RmllbGQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICAgICAgICB2YXIgcGxpc3QgPSBbXTtcblxuICAgICAgICAgICAgICB2YXIgX2xvb3A4ID0gZnVuY3Rpb24gX2xvb3A4KGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVjb3JkID0gYXJyYXlbaV07XG4gICAgICAgICAgICAgICAgdmFyIGYgPSBnZXRGaWVsZChyZWNvcmQudik7XG5cbiAgICAgICAgICAgICAgICBpZiAoKDAsIHV0aWxzXzEuaXNQcm9taXNlKShmKSkge1xuICAgICAgICAgICAgICAgICAgcGxpc3QucHVzaChmLnRoZW4oZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkLmYgPSB2O1xuICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZWNvcmQuZiA9IGY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBfbG9vcDgoaSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBQcm9taXNlLmFsbChwbGlzdCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoYXJyYXkpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHNvcnRBcnJheShhcnJheSwgY29tcGFyZSkge1xuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNvcnQuY2FsbChhcnJheSwgY29tcGFyZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5zb3J0QXJyYXkgPSBzb3J0QXJyYXk7XG5cbiAgICAgICAgICBmdW5jdGlvbiBzb3J0KGdldCwgc2V0LCBsZW5ndGgsIGNvbXBhcmUsIGdldEZpZWxkKSB7XG4gICAgICAgICAgICB2YXIgb2xkID0gY3JlYXRlQXJyYXkoZ2V0LCBsZW5ndGgpO1xuXG4gICAgICAgICAgICBpZiAoZ2V0RmllbGQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBvbGQuc29ydChmdW5jdGlvbiAocjEsIHIyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmUoZ2V0RmllbGQocjEpLCBnZXRGaWVsZChyMikpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG9sZC5zb3J0KGNvbXBhcmUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHNldChpLCBvbGRbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMuc29ydCA9IHNvcnQ7XG5cbiAgICAgICAgICBmdW5jdGlvbiBzb3J0UHJvbWlzZShnZXQsIHNldCwgbGVuZ3RoLCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgIGNvbXBhcmUsIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgZ2V0RmllbGQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgUHJvbWlzZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQXJyYXlQcm9taXNlKGdldCwgZ2V0RmllbGQsIGxlbmd0aCkudGhlbihmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICAgICAgICAgICAgICBhcnJheS5zb3J0KGZ1bmN0aW9uIChyMSwgcjIpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wYXJlKHIxLmYsIHIyLmYpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgc2V0KGksIGFycmF5W2ldLnYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzb3J0KGdldCwgc2V0LCBsZW5ndGgsIGNvbXBhcmUsIGdldEZpZWxkKTtcbiAgICAgICAgICAgICAgdmFyIGR1bW15UHJvbWlzZSA9IHtcbiAgICAgICAgICAgICAgICB0aGVuOiBmdW5jdGlvbiB0aGVuKGZuKSB7XG4gICAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGR1bW15UHJvbWlzZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNhdGNoOiBmdW5jdGlvbiBfY2F0Y2goKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZHVtbXlQcm9taXNlO1xuICAgICAgICAgICAgICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcblxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICByZXR1cm4gZHVtbXlQcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMuc29ydFByb21pc2UgPSBzb3J0UHJvbWlzZTtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9pbnRlcm5hbC9zdHlsZS5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2ludGVybmFsL3N0eWxlLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gaW50ZXJuYWxTdHlsZUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuZ2V0U2Nyb2xsQmFyU2l6ZSA9IGV4cG9ydHMuaW5pdERvY3VtZW50ID0gdm9pZCAwO1xuXG4gICAgICAgICAgZnVuY3Rpb24gZ2V0U2Nyb2xsQmFyV2lkdGgoKSB7XG4gICAgICAgICAgICB2YXIgd3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICB2YXIgaW5uZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgdmFyIHdyYXBwZXJTdHlsZSA9IHdyYXBwZXIuc3R5bGU7XG4gICAgICAgICAgICB3cmFwcGVyU3R5bGUucG9zaXRpb24gPSBcImZpeGVkXCI7XG4gICAgICAgICAgICB3cmFwcGVyU3R5bGUuaGVpZ2h0ID0gXCI1MHB4XCI7XG4gICAgICAgICAgICB3cmFwcGVyU3R5bGUud2lkdGggPSBcIjUwcHhcIjtcbiAgICAgICAgICAgIHdyYXBwZXJTdHlsZS5vdmVyZmxvdyA9IFwic2Nyb2xsXCI7XG4gICAgICAgICAgICB3cmFwcGVyU3R5bGUub3BhY2l0eSA9IFwiMFwiO1xuICAgICAgICAgICAgd3JhcHBlclN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IGlubmVyLnN0eWxlO1xuICAgICAgICAgICAgc3R5bGUuaGVpZ2h0ID0gXCIxMDAlXCI7XG4gICAgICAgICAgICBzdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xuICAgICAgICAgICAgaW5uZXIudGV4dENvbnRlbnQgPSBcInhcIjtcbiAgICAgICAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQoaW5uZXIpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh3cmFwcGVyKTtcbiAgICAgICAgICAgIHZhciB3cmFwcGVyV2lkdGggPSB3cmFwcGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuICAgICAgICAgICAgdmFyIGlubmVyV2lkdGggPSBpbm5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQod3JhcHBlcik7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5jZWlsKHdyYXBwZXJXaWR0aCAtIGlubmVyV2lkdGgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBTQ1JPTExCQVJfU0laRTtcblxuICAgICAgICAgIGZ1bmN0aW9uIGluaXREb2N1bWVudEludGVybmFsKCkge1xuICAgICAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISBAL2ludGVybmFsL3N0eWxlLmNzcyAqL1xuICAgICAgICAgICAgXCIuLi9zcmMvanMvaW50ZXJuYWwvc3R5bGUuY3NzXCIpO1xuXG4gICAgICAgICAgICBTQ1JPTExCQVJfU0laRSA9IGdldFNjcm9sbEJhcldpZHRoKCkgfHwgMTA7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgICAgICAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwidGV4dC9jc3NcIik7XG4gICAgICAgICAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLW5hbWVcIiwgXCJjaGVldGFoLWdyaWRcIik7XG4gICAgICAgICAgICBzdHlsZS5pbm5lckhUTUwgPSBcIlxcbi5jaGVldGFoLWdyaWQgLmdyaWQtc2Nyb2xsLWVuZC1wb2ludCB7XFxuXFx0d2lkdGg6IFwiLmNvbmNhdChTQ1JPTExCQVJfU0laRSwgXCJweDtcXG5cXHRoZWlnaHQ6IFwiKS5jb25jYXQoU0NST0xMQkFSX1NJWkUsIFwicHg7XFxufVxcbi5jaGVldGFoLWdyaWQgPiBjYW52YXMge1xcblxcdHdpZHRoOiAtd2Via2l0LWNhbGMoMTAwJSAtIFwiKS5jb25jYXQoU0NST0xMQkFSX1NJWkUsIFwicHgpO1xcblxcdHdpZHRoOiBjYWxjKDEwMCUgLSBcIikuY29uY2F0KFNDUk9MTEJBUl9TSVpFLCBcInB4KTtcXG5cXHRoZWlnaHQ6IC13ZWJraXQtY2FsYygxMDAlIC0gXCIpLmNvbmNhdChTQ1JPTExCQVJfU0laRSwgXCJweCk7XFxuXFx0aGVpZ2h0OiBjYWxjKDEwMCUgLSBcIikuY29uY2F0KFNDUk9MTEJBUl9TSVpFLCBcInB4KTtcXG59XFxuXFx0XFx0XCIpO1xuICAgICAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGluaXREb2N1bWVudFZhciA9IGluaXREb2N1bWVudEludGVybmFsO1xuXG4gICAgICAgICAgZnVuY3Rpb24gaW5pdERvY3VtZW50KCkge1xuICAgICAgICAgICAgaW5pdERvY3VtZW50VmFyKCk7XG4gICAgICAgICAgICBpbml0RG9jdW1lbnRWYXIgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5pbml0RG9jdW1lbnQgPSBpbml0RG9jdW1lbnQ7XG5cbiAgICAgICAgICBmdW5jdGlvbiBnZXRTY3JvbGxCYXJTaXplKCkge1xuICAgICAgICAgICAgcmV0dXJuIFNDUk9MTEJBUl9TSVpFO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMuZ2V0U2Nyb2xsQmFyU2l6ZSA9IGdldFNjcm9sbEJhclNpemU7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vaW50ZXJuYWwvc3ltYm9sTWFuYWdlci5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vaW50ZXJuYWwvc3ltYm9sTWFuYWdlci5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gaW50ZXJuYWxTeW1ib2xNYW5hZ2VySnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovXG5cbiAgICAgICAgICAoZnVuY3Rpb24gKGdsb2JhbCkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGV4cG9ydHMuZ2V0Q2hlY2tIZWFkZXJTdGF0ZUlkID0gZXhwb3J0cy5nZXRJbmxpbmVNZW51RWRpdG9yU3RhdGVJZCA9IGV4cG9ydHMuZ2V0SW5saW5lSW5wdXRFZGl0b3JTdGF0ZUlkID0gZXhwb3J0cy5nZXRTbWFsbERpYWxvZ0lucHV0RWRpdG9yU3RhdGVJZCA9IGV4cG9ydHMuZ2V0VHJlZUNvbHVtblN0YXRlSWQgPSBleHBvcnRzLmdldEJyYW5jaEdyYXBoQ29sdW1uU3RhdGVJZCA9IGV4cG9ydHMuZ2V0Q29sdW1uRmFkZWluU3RhdGVJZCA9IGV4cG9ydHMuZ2V0QnV0dG9uQ29sdW1uU3RhdGVJZCA9IGV4cG9ydHMuZ2V0UmFkaW9Db2x1bW5TdGF0ZUlkID0gZXhwb3J0cy5nZXRDaGVja0NvbHVtblN0YXRlSWQgPSBleHBvcnRzLmdldFByb3RlY3RlZFN5bWJvbCA9IGV4cG9ydHMuZ2V0ID0gdm9pZCAwO1xuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuXG4gICAgICAgICAgICB2YXIgdXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi91dGlscyAqL1xuICAgICAgICAgICAgXCIuL2ludGVybmFsL3V0aWxzLmpzXCIpO1xuXG4gICAgICAgICAgICB2YXIgX1N5bWJvbCA9IHV0aWxzXzEuaXNOb2RlID8gZ2xvYmFsLlN5bWJvbCA6IHdpbmRvdy5TeW1ib2wgPyB3aW5kb3cuU3ltYm9sIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBmdW5jdGlvbiByYW5kb20oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGMgPSBcImFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OVwiO1xuICAgICAgICAgICAgICAgIHZhciBjbCA9IGMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhciByID0gXCJcIjtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgICAgICAgICAgICAgciArPSBjW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNsKV07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiI1wiLmNvbmNhdChuYW1lLCBcIl9cIikuY29uY2F0KHJhbmRvbSgpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiI19cIi5jb25jYXQocmFuZG9tKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0oKTtcblxuICAgICAgICAgICAgdmFyIG1lbSA9IHt9O1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBnZXQobmFtZSkge1xuICAgICAgICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZW1bbmFtZV0gPyBtZW1bbmFtZV0gOiBtZW1bbmFtZV0gPSBfU3ltYm9sKG5hbWUpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBfU3ltYm9sKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXhwb3J0cy5nZXQgPSBnZXQ7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldFByb3RlY3RlZFN5bWJvbCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldChcInByb3RlY3RlZFwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXhwb3J0cy5nZXRQcm90ZWN0ZWRTeW1ib2wgPSBnZXRQcm90ZWN0ZWRTeW1ib2w7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldENoZWNrQ29sdW1uU3RhdGVJZCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldChcImNoa2NvbC5zdGF0ZUlEXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBleHBvcnRzLmdldENoZWNrQ29sdW1uU3RhdGVJZCA9IGdldENoZWNrQ29sdW1uU3RhdGVJZDtcblxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0UmFkaW9Db2x1bW5TdGF0ZUlkKCkge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0KFwicmRjb2wuc3RhdGVJRFwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXhwb3J0cy5nZXRSYWRpb0NvbHVtblN0YXRlSWQgPSBnZXRSYWRpb0NvbHVtblN0YXRlSWQ7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldEJ1dHRvbkNvbHVtblN0YXRlSWQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBnZXQoXCJidG5jb2wuc3RhdGVJRFwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXhwb3J0cy5nZXRCdXR0b25Db2x1bW5TdGF0ZUlkID0gZ2V0QnV0dG9uQ29sdW1uU3RhdGVJZDtcblxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0Q29sdW1uRmFkZWluU3RhdGVJZCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldChcImNvbC5mYWRlaW5fc3RhdGVJRFwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXhwb3J0cy5nZXRDb2x1bW5GYWRlaW5TdGF0ZUlkID0gZ2V0Q29sdW1uRmFkZWluU3RhdGVJZDtcblxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0QnJhbmNoR3JhcGhDb2x1bW5TdGF0ZUlkKCkge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0KFwiYnJhbmNoX2dyYXBoX2NvbC5zdGF0ZUlEXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBleHBvcnRzLmdldEJyYW5jaEdyYXBoQ29sdW1uU3RhdGVJZCA9IGdldEJyYW5jaEdyYXBoQ29sdW1uU3RhdGVJZDtcblxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0VHJlZUNvbHVtblN0YXRlSWQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBnZXQoXCJ0cmVlX2NvbC5zdGF0ZUlEXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBleHBvcnRzLmdldFRyZWVDb2x1bW5TdGF0ZUlkID0gZ2V0VHJlZUNvbHVtblN0YXRlSWQ7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldFNtYWxsRGlhbG9nSW5wdXRFZGl0b3JTdGF0ZUlkKCkge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0KFwic21hbGxfZGlhbG9nX2lucHV0X2VkaXRvci5zdGF0ZUlEXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBleHBvcnRzLmdldFNtYWxsRGlhbG9nSW5wdXRFZGl0b3JTdGF0ZUlkID0gZ2V0U21hbGxEaWFsb2dJbnB1dEVkaXRvclN0YXRlSWQ7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldElubGluZUlucHV0RWRpdG9yU3RhdGVJZCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldChcImlubGluZV9pbnB1dF9lZGl0b3Iuc3RhdGVJRFwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXhwb3J0cy5nZXRJbmxpbmVJbnB1dEVkaXRvclN0YXRlSWQgPSBnZXRJbmxpbmVJbnB1dEVkaXRvclN0YXRlSWQ7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldElubGluZU1lbnVFZGl0b3JTdGF0ZUlkKCkge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0KFwiaW5saW5lX21lbnVfZWRpdG9yLnN0YXRlSURcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV4cG9ydHMuZ2V0SW5saW5lTWVudUVkaXRvclN0YXRlSWQgPSBnZXRJbmxpbmVNZW51RWRpdG9yU3RhdGVJZDtcblxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0Q2hlY2tIZWFkZXJTdGF0ZUlkKCkge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0KFwiY2hlY2tfaGVhZGVyLnN0YXRlSURcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV4cG9ydHMuZ2V0Q2hlY2tIZWFkZXJTdGF0ZUlkID0gZ2V0Q2hlY2tIZWFkZXJTdGF0ZUlkO1xuICAgICAgICAgICAgLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovXG4gICAgICAgICAgfSkuY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLy4uLy4uL25vZGVfbW9kdWxlcy93ZWJwYWNrL2J1aWxkaW4vZ2xvYmFsLmpzICovXG4gICAgICAgICAgXCIuLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2dsb2JhbC5qc1wiKSk7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vaW50ZXJuYWwvdXRpbHMuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9pbnRlcm5hbC91dGlscy5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGludGVybmFsVXRpbHNKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLmVtcHR5Rm4gPSBleHBvcnRzLnN0eWxlID0gZXhwb3J0cy5ldmVudCA9IGV4cG9ydHMuc3RyID0gZXhwb3J0cy5vYmogPSBleHBvcnRzLmJyb3dzZXIgPSBleHBvcnRzLmNlbGxJblJhbmdlID0gZXhwb3J0cy5jZWxsRXF1YWxzID0gZXhwb3J0cy5hcnJheSA9IGV4cG9ydHMudGhlbiA9IGV4cG9ydHMuZ2V0SWdub3JlQ2FzZSA9IGV4cG9ydHMuZ2V0T3JBcHBseSA9IGV4cG9ydHMuYXBwbHlDaGFpblNhZmUgPSBleHBvcnRzLmdldENoYWluU2FmZSA9IGV4cG9ydHMuaXNEZXNjZW5kYW50RWxlbWVudCA9IGV4cG9ydHMuaXNOb2RlID0gZXhwb3J0cy5pc1Byb21pc2UgPSBleHBvcnRzLmV4dGVuZCA9IGV4cG9ydHMuZGVmYXVsdHMgPSBleHBvcnRzLm9taXQgPSBleHBvcnRzLmVhY2ggPSB2b2lkIDA7XG4gICAgICAgICAgdmFyIGlzTm9kZSA9IHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIHdpbmRvdy53aW5kb3cgPT09IFwidW5kZWZpbmVkXCI7XG4gICAgICAgICAgZXhwb3J0cy5pc05vZGUgPSBpc05vZGU7XG4gICAgICAgICAgdmFyIGFycmF5RmluZDtcbiAgICAgICAgICB2YXIgYXJyYXlGaW5kSW5kZXg7XG4gICAgICAgICAgdmFyIGFycmF5ID0ge1xuICAgICAgICAgICAgZ2V0IGZpbmQoKSB7XG4gICAgICAgICAgICAgIGlmIChhcnJheUZpbmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXlGaW5kO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKEFycmF5LnByb3RvdHlwZS5maW5kKSB7XG4gICAgICAgICAgICAgICAgYXJyYXlGaW5kID0gZnVuY3Rpb24gYXJyYXlGaW5kKGFyciwgcHJlZGljYXRlKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmZpbmQuY2FsbChhcnIsIHByZWRpY2F0ZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcnJheUZpbmQgPSBmdW5jdGlvbiBhcnJheUZpbmQoYXJyLCBwcmVkaWNhdGUpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGFycmF5LmZpbmRJbmRleChhcnIsIHByZWRpY2F0ZSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXggPj0gMCA/IGFycltpbmRleF0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBhcnJheUZpbmQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXQgZmluZEluZGV4KCkge1xuICAgICAgICAgICAgICBpZiAoYXJyYXlGaW5kSW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXlGaW5kSW5kZXg7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoQXJyYXkucHJvdG90eXBlLmZpbmRJbmRleCkge1xuICAgICAgICAgICAgICAgIGFycmF5RmluZEluZGV4ID0gZnVuY3Rpb24gYXJyYXlGaW5kSW5kZXgoYXJyLCBwcmVkaWNhdGUpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4LmNhbGwoYXJyLCBwcmVkaWNhdGUpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXJyYXlGaW5kSW5kZXggPSBmdW5jdGlvbiBhcnJheUZpbmRJbmRleChhcnIsIHByZWRpY2F0ZSkge1xuICAgICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGFyci5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXJyW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGksIGFycikpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBhcnJheUZpbmRJbmRleDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH07XG4gICAgICAgICAgZXhwb3J0cy5hcnJheSA9IGFycmF5O1xuXG4gICAgICAgICAgZnVuY3Rpb24gYW5hbHl6ZVVzZXJBZ2VudCgpIHtcbiAgICAgICAgICAgIGlmIChpc05vZGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBJRTogZmFsc2UsXG4gICAgICAgICAgICAgICAgRWRnZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgQ2hyb21lOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBGaXJlZm94OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBTYWZhcmk6IGZhbHNlXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgdWEgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIElFOiAhIS8obXNpZXx0cmlkZW50KS8uZXhlYyh1YSksXG4gICAgICAgICAgICAgICAgRWRnZTogdWEuaW5kZXhPZihcImVkZ2VcIikgPiAtMSxcbiAgICAgICAgICAgICAgICBDaHJvbWU6IHVhLmluZGV4T2YoXCJjaHJvbWVcIikgPiAtMSAmJiB1YS5pbmRleE9mKFwiZWRnZVwiKSA9PT0gLTEsXG4gICAgICAgICAgICAgICAgRmlyZWZveDogdWEuaW5kZXhPZihcImZpcmVmb3hcIikgPiAtMSxcbiAgICAgICAgICAgICAgICBTYWZhcmk6IHVhLmluZGV4T2YoXCJzYWZhcmlcIikgPiAtMSAmJiB1YS5pbmRleE9mKFwiZWRnZVwiKSA9PT0gLTFcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX2FuYWx5emVVc2VyQWdlbnQgPSBhbmFseXplVXNlckFnZW50KCksXG4gICAgICAgICAgICAgIElFID0gX2FuYWx5emVVc2VyQWdlbnQuSUUsXG4gICAgICAgICAgICAgIENocm9tZSA9IF9hbmFseXplVXNlckFnZW50LkNocm9tZSxcbiAgICAgICAgICAgICAgRmlyZWZveCA9IF9hbmFseXplVXNlckFnZW50LkZpcmVmb3gsXG4gICAgICAgICAgICAgIEVkZ2UgPSBfYW5hbHl6ZVVzZXJBZ2VudC5FZGdlLFxuICAgICAgICAgICAgICBTYWZhcmkgPSBfYW5hbHl6ZVVzZXJBZ2VudC5TYWZhcmk7XG5cbiAgICAgICAgICBmdW5jdGlvbiBzZXRSZWFkb25seShvYmosIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBuYW1lLCB7XG4gICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXG5cbiAgICAgICAgICBmdW5jdGlvbiBlYWNoKG9iaiwgZm4pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgZm4ob2JqW2tleV0sIGtleSwgb2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRzLmVhY2ggPSBlYWNoOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXG4gICAgICAgICAgZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqID09PSBPYmplY3Qob2JqKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBvbWl0KHNvdXJjZSwgb21pdHMpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcblxuICAgICAgICAgICAgdmFyIF9sb29wOSA9IGZ1bmN0aW9uIF9sb29wOShrZXkpIHtcbiAgICAgICAgICAgICAgaWYgKG9taXRzLmluZGV4T2Yoa2V5KSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXN1bHQsIGtleSwge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsKSB7XG4gICAgICAgICAgICAgICAgICBzb3VyY2Vba2V5XSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgICB2YXIgX3JldDIgPSBfbG9vcDkoa2V5KTtcblxuICAgICAgICAgICAgICBpZiAoX3JldDIgPT09IFwiY29udGludWVcIikgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5vbWl0ID0gb21pdDtcblxuICAgICAgICAgIGZ1bmN0aW9uIGRlZmF1bHRzKHNvdXJjZSwgZGVmcykge1xuICAgICAgICAgICAgdmFyIGtleXMgPSBbXTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcblxuICAgICAgICAgICAgdmFyIF9sb29wMTAgPSBmdW5jdGlvbiBfbG9vcDEwKGtleSkge1xuICAgICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3VsdCwga2V5LCB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgdmFsID0gc291cmNlW2tleV07XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdmFsID09PSB1bmRlZmluZWQgPyBkZWZzW2tleV0gOiB2YWw7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWwpIHtcbiAgICAgICAgICAgICAgICAgIHNvdXJjZVtrZXldID0gdmFsO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICAgIF9sb29wMTAoa2V5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIF9sb29wMTEgPSBmdW5jdGlvbiBfbG9vcDExKF9rZXkyMykge1xuICAgICAgICAgICAgICBpZiAoa2V5cy5pbmRleE9mKF9rZXkyMykgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzdWx0LCBfa2V5MjMsIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBzb3VyY2VbX2tleTIzXTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB2YWwgPT09IHVuZGVmaW5lZCA/IGRlZnNbX2tleTIzXSA6IHZhbDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbCkge1xuICAgICAgICAgICAgICAgICAgc291cmNlW19rZXkyM10gPSB2YWw7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZvciAodmFyIF9rZXkyMyBpbiBkZWZzKSB7XG4gICAgICAgICAgICAgIHZhciBfcmV0MyA9IF9sb29wMTEoX2tleTIzKTtcblxuICAgICAgICAgICAgICBpZiAoX3JldDMgPT09IFwiY29udGludWVcIikgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuXG4gICAgICAgICAgZnVuY3Rpb24gZXh0ZW5kKCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gICAgICAgICAgICBmb3IgKHZhciBfbGVuMjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yMyksIF9rZXkyNCA9IDA7IF9rZXkyNCA8IF9sZW4yMzsgX2tleTI0KyspIHtcbiAgICAgICAgICAgICAgYXJnc1tfa2V5MjRdID0gYXJndW1lbnRzW19rZXkyNF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFyZ3MuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgICAgICAgIHZhciBfbG9vcDEyID0gZnVuY3Rpb24gX2xvb3AxMihrZXkpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzdWx0LCBrZXksIHtcbiAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc291cmNlW2tleV07XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZVtrZXldID0gdmFsO1xuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICAgICAgX2xvb3AxMihrZXkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5leHRlbmQgPSBleHRlbmQ7XG5cbiAgICAgICAgICBmdW5jdGlvbiBpc0Rlc2NlbmRhbnRFbGVtZW50KHJvb3QsIHRhcmdldCkge1xuICAgICAgICAgICAgd2hpbGUgKHRhcmdldC5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICAgIHZhciBwID0gdGFyZ2V0LnBhcmVudEVsZW1lbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKHJvb3QgPT09IHApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRhcmdldCA9IHA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRzLmlzRGVzY2VuZGFudEVsZW1lbnQgPSBpc0Rlc2NlbmRhbnRFbGVtZW50O1xuICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cblxuICAgICAgICAgIGZ1bmN0aW9uIGFwcGx5Q2hhaW5TYWZlKG9iaiwgZm4pIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IG9iajtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAoYXJndW1lbnRzLmxlbmd0aCA8PSAyID8gMCA6IGFyZ3VtZW50cy5sZW5ndGggLSAyKSAmJiB2YWx1ZSAhPSBudWxsOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBmbih2YWx1ZSwgaSArIDIgPCAyIHx8IGFyZ3VtZW50cy5sZW5ndGggPD0gaSArIDIgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbaSArIDJdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMuYXBwbHlDaGFpblNhZmUgPSBhcHBseUNoYWluU2FmZTtcblxuICAgICAgICAgIGZ1bmN0aW9uIGdldENoYWluU2FmZShvYmopIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9sZW4yNCA9IGFyZ3VtZW50cy5sZW5ndGgsIG5hbWVzID0gbmV3IEFycmF5KF9sZW4yNCA+IDEgPyBfbGVuMjQgLSAxIDogMCksIF9rZXkyNSA9IDE7IF9rZXkyNSA8IF9sZW4yNDsgX2tleTI1KyspIHtcbiAgICAgICAgICAgICAgbmFtZXNbX2tleTI1IC0gMV0gPSBhcmd1bWVudHNbX2tleTI1XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGFwcGx5Q2hhaW5TYWZlLmFwcGx5KHZvaWQgMCwgW29iaiwgZnVuY3Rpb24gKHZhbCwgbmFtZSkge1xuICAgICAgICAgICAgICByZXR1cm4gdmFsW25hbWVdO1xuICAgICAgICAgICAgfV0uY29uY2F0KG5hbWVzKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5nZXRDaGFpblNhZmUgPSBnZXRDaGFpblNhZmU7XG5cbiAgICAgICAgICBmdW5jdGlvbiBnZXRPckFwcGx5KHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbjI1ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMjUgPiAxID8gX2xlbjI1IC0gMSA6IDApLCBfa2V5MjYgPSAxOyBfa2V5MjYgPCBfbGVuMjU7IF9rZXkyNisrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfa2V5MjYgLSAxXSA9IGFyZ3VtZW50c1tfa2V5MjZdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmFwcGx5KHZvaWQgMCwgYXJncyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5nZXRPckFwcGx5ID0gZ2V0T3JBcHBseTtcbiAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cblxuICAgICAgICAgIGZ1bmN0aW9uIGVuZHNXaXRoKHN0ciwgc2VhcmNoU3RyaW5nLCBwb3NpdGlvbikge1xuICAgICAgICAgICAgdmFyIHN1YmplY3RTdHJpbmcgPSBzdHIudG9TdHJpbmcoKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwb3NpdGlvbiAhPT0gXCJudW1iZXJcIiB8fCAhaXNGaW5pdGUocG9zaXRpb24pIHx8IE1hdGguZmxvb3IocG9zaXRpb24pICE9PSBwb3NpdGlvbiB8fCBwb3NpdGlvbiA+IHN1YmplY3RTdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHBvc2l0aW9uID0gc3ViamVjdFN0cmluZy5sZW5ndGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBvc2l0aW9uIC09IHNlYXJjaFN0cmluZy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgbGFzdEluZGV4ID0gc3ViamVjdFN0cmluZy5sYXN0SW5kZXhPZihzZWFyY2hTdHJpbmcsIHBvc2l0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiBsYXN0SW5kZXggIT09IC0xICYmIGxhc3RJbmRleCA9PT0gcG9zaXRpb247XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gZ2VuQ2hhcnMocykge1xuICAgICAgICAgICAgLy8gU3Vycm9nYXRlIENvZGUgUG9pbnRcbiAgICAgICAgICAgIC8vIFtcXHVEODAwLVxcdURCRkZdXG4gICAgICAgICAgICAvLyBWYXJpYXRpb24gU2VsZWN0b3JzXG4gICAgICAgICAgICAvLyBGVlMgW1xcdTE4MEItXFx1MTgwRF1cbiAgICAgICAgICAgIC8vIFZTMe+9nlZTMTYgW1xcdUZFMDAtXFx1RkUwRl1cbiAgICAgICAgICAgIC8vIFZTMTfvvZ5WUzI1NiBcXHVEQjQwW1xcdUREMDAtXFx1RERFRl1cbiAgICAgICAgICAgIHZhciByZSA9IC8oW1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXXxcXHJcXG58W15cXHVEODAwLVxcdURGRkZdKShbXFx1MTgwQi1cXHUxODBEXXxbXFx1RkUwMC1cXHVGRTBGXXxcXHVEQjQwW1xcdUREMDAtXFx1RERFRl0pPy9nO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gcmUuZXhlYyhzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzICE9PSBudWxsID8gcmVzWzBdIDogbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBnZW5Xb3JkcyhzKSB7XG4gICAgICAgICAgICB2YXIgcmUgPSAvWyEtfl0rfFteIS1+XFxzXSt8XFxzKy9nO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gcmUuZXhlYyhzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzICE9PSBudWxsID8gcmVzWzBdIDogbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBpc1Byb21pc2UoZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4oZGF0YSAmJiB0eXBlb2YgZGF0YS50aGVuID09PSBcImZ1bmN0aW9uXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMuaXNQcm9taXNlID0gaXNQcm9taXNlO1xuXG4gICAgICAgICAgZnVuY3Rpb24gdGhlbihyZXN1bHQsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNQcm9taXNlKHJlc3VsdCkgPyByZXN1bHQudGhlbihmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2socik7XG4gICAgICAgICAgICB9KSA6IGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy50aGVuID0gdGhlbjtcblxuICAgICAgICAgIGZ1bmN0aW9uIGdldE1vdXNlQnV0dG9ucyhlKSB7XG4gICAgICAgICAgICBpZiAoZS5idXR0b25zICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGUuYnV0dG9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qZm9yIGxlZ2FjeSovXG5cblxuICAgICAgICAgICAgaWYgKGUud2hpY2ggIT0gbnVsbCkge1xuICAgICAgICAgICAgICBpZiAoZS53aGljaCA9PT0gMykge1xuICAgICAgICAgICAgICAgIC8vcmlnaHQ/XG4gICAgICAgICAgICAgICAgcmV0dXJuIDQ7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoZS53aGljaCA9PT0gMikge1xuICAgICAgICAgICAgICAgIC8vbWlkZGxlP1xuICAgICAgICAgICAgICAgIHJldHVybiA0O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGUud2hpY2g7IC8vbGVmdCBvciBub1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZS5idXR0b24gPT09IDAgfHwgZS5idXR0b24gPT09IDEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIDE7IC8vY2FuZGlkYXRlIGxlZnRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGUuYnV0dG9uID09PSAyKSB7XG4gICAgICAgICAgICAgIHJldHVybiAyOyAvLyByaWdodFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gMDsgLy9ubyBvciBtaWRkbGU/XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gZ2V0S2V5Q29kZShlKSB7XG4gICAgICAgICAgICByZXR1cm4gZS5rZXlDb2RlIHx8IGUud2hpY2g7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gaXNUb3VjaEV2ZW50KGUpIHtcbiAgICAgICAgICAgIHJldHVybiAhIWUuY2hhbmdlZFRvdWNoZXM7XG4gICAgICAgICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXG5cbiAgICAgICAgICBmdW5jdGlvbiBnZXRJZ25vcmVDYXNlKG9iaiwgbmFtZSkge1xuICAgICAgICAgICAgaWYgKG9ialtuYW1lXSkge1xuICAgICAgICAgICAgICByZXR1cm4gb2JqW25hbWVdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbCA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgICAgaWYgKG9ialtsXSkge1xuICAgICAgICAgICAgICByZXR1cm4gb2JqW2xdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgICAgaWYgKG9ialt1XSkge1xuICAgICAgICAgICAgICByZXR1cm4gb2JqW3VdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBrIGluIG9iaikge1xuICAgICAgICAgICAgICBpZiAoay50b0xvd2VyQ2FzZSgpID09PSBsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9ialtrXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMuZ2V0SWdub3JlQ2FzZSA9IGdldElnbm9yZUNhc2U7XG5cbiAgICAgICAgICBmdW5jdGlvbiBjYW5jZWwoZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiB0b0JveEFycmF5KG9iaikge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFtvYmpcbiAgICAgICAgICAgICAgLyp0b3AqL1xuICAgICAgICAgICAgICAsIG9ialxuICAgICAgICAgICAgICAvKnJpZ2h0Ki9cbiAgICAgICAgICAgICAgLCBvYmpcbiAgICAgICAgICAgICAgLypib3R0b20qL1xuICAgICAgICAgICAgICAsIG9ialxuICAgICAgICAgICAgICAvKmxlZnQqL1xuICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob2JqLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgICByZXR1cm4gW29ialswXVxuICAgICAgICAgICAgICAvKnRvcCovXG4gICAgICAgICAgICAgICwgb2JqWzFdXG4gICAgICAgICAgICAgIC8qcmlnaHQqL1xuICAgICAgICAgICAgICAsIG9ialsyXVxuICAgICAgICAgICAgICAvKmJvdHRvbSovXG4gICAgICAgICAgICAgICwgb2JqWzFdXG4gICAgICAgICAgICAgIC8qbGVmdCovXG4gICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvYmoubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBbb2JqWzBdXG4gICAgICAgICAgICAgIC8qdG9wKi9cbiAgICAgICAgICAgICAgLCBvYmpbMV1cbiAgICAgICAgICAgICAgLypyaWdodCovXG4gICAgICAgICAgICAgICwgb2JqWzBdXG4gICAgICAgICAgICAgIC8qYm90dG9tKi9cbiAgICAgICAgICAgICAgLCBvYmpbMV1cbiAgICAgICAgICAgICAgLypsZWZ0Ki9cbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9iai5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFtvYmpbMF1cbiAgICAgICAgICAgICAgLyp0b3AqL1xuICAgICAgICAgICAgICAsIG9ialswXVxuICAgICAgICAgICAgICAvKnJpZ2h0Ki9cbiAgICAgICAgICAgICAgLCBvYmpbMF1cbiAgICAgICAgICAgICAgLypib3R0b20qL1xuICAgICAgICAgICAgICAsIG9ialswXVxuICAgICAgICAgICAgICAvKmxlZnQqL1xuICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGNlbGxFcXVhbHMoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEuY29sID09PSBiLmNvbCAmJiBhLnJvdyA9PT0gYi5yb3c7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5jZWxsRXF1YWxzID0gY2VsbEVxdWFscztcblxuICAgICAgICAgIGZ1bmN0aW9uIGNlbGxJblJhbmdlKHJhbmdlLCBjb2wsIHJvdykge1xuICAgICAgICAgICAgcmV0dXJuIHJhbmdlLnN0YXJ0LmNvbCA8PSBjb2wgJiYgY29sIDw9IHJhbmdlLmVuZC5jb2wgJiYgcmFuZ2Uuc3RhcnQucm93IDw9IHJvdyAmJiByb3cgPD0gcmFuZ2UuZW5kLnJvdztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRzLmNlbGxJblJhbmdlID0gY2VsbEluUmFuZ2U7XG4gICAgICAgICAgZXhwb3J0cy5icm93c2VyID0ge1xuICAgICAgICAgICAgSUU6IElFLFxuICAgICAgICAgICAgRWRnZTogRWRnZSxcbiAgICAgICAgICAgIENocm9tZTogQ2hyb21lLFxuICAgICAgICAgICAgRmlyZWZveDogRmlyZWZveCxcbiAgICAgICAgICAgIFNhZmFyaTogU2FmYXJpLFxuICAgICAgICAgICAgLy8gQ2hyb21lIDE2Nzc3MjE2IChvbmwgQ2hyb21lIDMzNTU0NDMxKVxuICAgICAgICAgICAgLy8gRmlyZUZveCAxNzg5NTU4OFxuICAgICAgICAgICAgLy8gSUUgMTA3Mzc0MzNcbiAgICAgICAgICAgIGhlaWdodExpbWl0OiBDaHJvbWUgPyAxNjc3NzIxNiA6IEZpcmVmb3ggPyAxNzg5NTU4OCA6IDEwNzM3NDMzIC8vIGRlZmF1bHQgSUUgbGltaXRcblxuICAgICAgICAgIH07XG4gICAgICAgICAgZXhwb3J0cy5vYmogPSB7XG4gICAgICAgICAgICBzZXRSZWFkb25seTogc2V0UmVhZG9ubHksXG4gICAgICAgICAgICBpc09iamVjdDogaXNPYmplY3RcbiAgICAgICAgICB9O1xuICAgICAgICAgIGV4cG9ydHMuc3RyID0ge1xuICAgICAgICAgICAgZW5kc1dpdGg6IGVuZHNXaXRoLFxuICAgICAgICAgICAgZ2VuQ2hhcnM6IGdlbkNoYXJzLFxuICAgICAgICAgICAgZ2VuV29yZHM6IGdlbldvcmRzXG4gICAgICAgICAgfTtcbiAgICAgICAgICBleHBvcnRzLmV2ZW50ID0ge1xuICAgICAgICAgICAgZ2V0TW91c2VCdXR0b25zOiBnZXRNb3VzZUJ1dHRvbnMsXG4gICAgICAgICAgICBnZXRLZXlDb2RlOiBnZXRLZXlDb2RlLFxuICAgICAgICAgICAgaXNUb3VjaEV2ZW50OiBpc1RvdWNoRXZlbnQsXG4gICAgICAgICAgICBjYW5jZWw6IGNhbmNlbFxuICAgICAgICAgIH07XG4gICAgICAgICAgZXhwb3J0cy5zdHlsZSA9IHtcbiAgICAgICAgICAgIHRvQm94QXJyYXk6IHRvQm94QXJyYXlcbiAgICAgICAgICB9O1xuICAgICAgICAgIGV4cG9ydHMuZW1wdHlGbiA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9saXN0LWdyaWQvTEdfRVZFTlRfVFlQRS5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2xpc3QtZ3JpZC9MR19FVkVOVF9UWVBFLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gbGlzdEdyaWRMR19FVkVOVF9UWVBFSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5MR19FVkVOVF9UWVBFID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIERHX0VWRU5UX1RZUEVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uL2NvcmUvREdfRVZFTlRfVFlQRSAqL1xuICAgICAgICAgIFwiLi9jb3JlL0RHX0VWRU5UX1RZUEUuanNcIik7XG5cbiAgICAgICAgICB2YXIgdXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uL2ludGVybmFsL3V0aWxzICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL3V0aWxzLmpzXCIpO1xuXG4gICAgICAgICAgZXhwb3J0cy5MR19FVkVOVF9UWVBFID0gKDAsIHV0aWxzXzEuZXh0ZW5kKShER19FVkVOVF9UWVBFXzEuREdfRVZFTlRfVFlQRSwge1xuICAgICAgICAgICAgQkVGT1JFX0NIQU5HRV9WQUxVRTogXCJiZWZvcmVfY2hhbmdlX3ZhbHVlXCIsXG4gICAgICAgICAgICBDSEFOR0VEX1ZBTFVFOiBcImNoYW5nZWRfdmFsdWVcIixcbiAgICAgICAgICAgIENIQU5HRURfSEVBREVSX1ZBTFVFOiBcImNoYW5nZWRfaGVhZGVyX3ZhbHVlXCIsXG4gICAgICAgICAgICBSRUpFQ1RFRF9QQVNURV9WQUxVRVM6IFwicmVqZWN0ZWRfcGFzdGVfdmFsdWVzXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9saXN0LWdyaWQvbGF5b3V0LW1hcC9pbmRleC5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2xpc3QtZ3JpZC9sYXlvdXQtbWFwL2luZGV4LmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gbGlzdEdyaWRMYXlvdXRNYXBJbmRleEpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuTXVsdGlMYXlvdXRNYXAgPSBleHBvcnRzLlNpbXBsZUhlYWRlckxheW91dE1hcCA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBzaW1wbGVfaGVhZGVyX2xheW91dF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9pbnRlcm5hbC9zaW1wbGUtaGVhZGVyLWxheW91dCAqL1xuICAgICAgICAgIFwiLi9saXN0LWdyaWQvbGF5b3V0LW1hcC9pbnRlcm5hbC9zaW1wbGUtaGVhZGVyLWxheW91dC5qc1wiKTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNpbXBsZUhlYWRlckxheW91dE1hcFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzaW1wbGVfaGVhZGVyX2xheW91dF8xLlNpbXBsZUhlYWRlckxheW91dE1hcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBtdWx0aV9sYXlvdXRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vaW50ZXJuYWwvbXVsdGktbGF5b3V0ICovXG4gICAgICAgICAgXCIuL2xpc3QtZ3JpZC9sYXlvdXQtbWFwL2ludGVybmFsL211bHRpLWxheW91dC5qc1wiKTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk11bHRpTGF5b3V0TWFwXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG11bHRpX2xheW91dF8xLk11bHRpTGF5b3V0TWFwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2xpc3QtZ3JpZC9sYXlvdXQtbWFwL2ludGVybmFsL211bHRpLWxheW91dC5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9saXN0LWdyaWQvbGF5b3V0LW1hcC9pbnRlcm5hbC9tdWx0aS1sYXlvdXQuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gbGlzdEdyaWRMYXlvdXRNYXBJbnRlcm5hbE11bHRpTGF5b3V0SnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICB2YXIgX19jcmVhdGVCaW5kaW5nID0gdGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZyB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICAgICAgICAgICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcblxuICAgICAgICAgICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgICAgICAgICAgZGVzYyA9IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ba107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xuICAgICAgICAgIH0gOiBmdW5jdGlvbiAobywgbSwgaywgazIpIHtcbiAgICAgICAgICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgICAgICAgICBvW2syXSA9IG1ba107XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gdGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCB2KSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHtcbiAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gOiBmdW5jdGlvbiAobywgdikge1xuICAgICAgICAgICAgb1tcImRlZmF1bHRcIl0gPSB2O1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIF9faW1wb3J0U3RhciA9IHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgICAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIHtcbiAgICAgICAgICAgICAgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5NdWx0aUxheW91dE1hcCA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBjb2x1bW5zID0gX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uLy4uL2NvbHVtbnMgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy5qc1wiKSk7XG5cbiAgICAgICAgICB2YXIgaGVhZGVyQWN0aW9uID0gX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uLy4uL2hlYWRlci9hY3Rpb24gKi9cbiAgICAgICAgICBcIi4vaGVhZGVyL2FjdGlvbi5qc1wiKSk7XG5cbiAgICAgICAgICB2YXIgaGVhZGVyVHlwZSA9IF9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi8uLi9oZWFkZXIvdHlwZSAqL1xuICAgICAgICAgIFwiLi9oZWFkZXIvdHlwZS5qc1wiKSk7XG5cbiAgICAgICAgICB2YXIgdXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vdXRpbHMgKi9cbiAgICAgICAgICBcIi4vbGlzdC1ncmlkL2xheW91dC1tYXAvaW50ZXJuYWwvdXRpbHMuanNcIik7XG5cbiAgICAgICAgICBmdW5jdGlvbiBub3JtYWxpemVMYXlvdXQobGF5b3V0KSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShsYXlvdXQpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaGVhZGVyOiBsYXlvdXQsXG4gICAgICAgICAgICAgICAgYm9keTogbGF5b3V0XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBsYXlvdXQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHNlcUlkID0gMDtcblxuICAgICAgICAgIHZhciBMYXlvdXRPYmplY3RHcmlkID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIExheW91dE9iamVjdEdyaWQobGF5b3V0LCB0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgICAgdmFyIF90aGlzMTA4ID0gdGhpcztcblxuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGF5b3V0T2JqZWN0R3JpZCk7XG5cbiAgICAgICAgICAgICAgdGhpcy5vYmplY3RzID0gW107XG4gICAgICAgICAgICAgIHRoaXMub2JqZWN0R3JpZCA9IFtdO1xuICAgICAgICAgICAgICB0aGlzLm9iamVjdE1hcCA9IHt9O1xuICAgICAgICAgICAgICB0aGlzLmNvbHVtbkNvdW50ID0gMDtcbiAgICAgICAgICAgICAgdGhpcy5jb2x1bW5XaWR0aHMgPSBbXTtcbiAgICAgICAgICAgICAgbGF5b3V0LmZvckVhY2goZnVuY3Rpb24gKHJvd0xheW91dCwgcm93KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbCA9IDA7XG4gICAgICAgICAgICAgICAgcm93TGF5b3V0LmZvckVhY2goZnVuY3Rpb24gKGNlbGwpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG5cbiAgICAgICAgICAgICAgICAgIHZhciBpZCA9IHNlcUlkKys7XG4gICAgICAgICAgICAgICAgICB2YXIgb2JqID0gdHJhbnNmb3JtKGNlbGwsIGlkKTtcblxuICAgICAgICAgICAgICAgICAgX3RoaXMxMDgub2JqZWN0cy5wdXNoKG9iaik7XG5cbiAgICAgICAgICAgICAgICAgIF90aGlzMTA4Lm9iamVjdE1hcFtpZF0gPSBvYmo7XG4gICAgICAgICAgICAgICAgICBjb2wgPSBfdGhpczEwOC5fZmluZFN0YXJ0Q2VsbChjb2wsIHJvdyk7XG4gICAgICAgICAgICAgICAgICB2YXIgcm93U3BhbiA9IE51bWJlcigoX2EgPSBjZWxsLnJvd1NwYW4pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDEpO1xuICAgICAgICAgICAgICAgICAgdmFyIGNvbFNwYW4gPSBOdW1iZXIoKF9iID0gY2VsbC5jb2xTcGFuKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAxKTtcbiAgICAgICAgICAgICAgICAgIHZhciBlbmRSb3cgPSByb3cgKyByb3dTcGFuO1xuICAgICAgICAgICAgICAgICAgdmFyIGVuZENvbCA9IGNvbCArIGNvbFNwYW47XG5cbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIHJvd0luZGV4ID0gcm93OyByb3dJbmRleCA8IGVuZFJvdzsgcm93SW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb2JqZWN0R3JpZFJvdyA9IF90aGlzMTA4Ll9nZXRPYmplY3RHcmlkUm93KHJvd0luZGV4KTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBjb2xJbmRleCA9IGNvbDsgY29sSW5kZXggPCBlbmRDb2w7IGNvbEluZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICBvYmplY3RHcmlkUm93W2NvbEluZGV4XSA9IG9iajtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBpZiAoY29sU3BhbiA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpczEwOC5fc2V0V2lkdGhEYXRhSWZBYnNlbnQoY29sLCBjZWxsKTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgX3RoaXMxMDguX3VzZUNvbHVtbkluZGV4KGVuZENvbCAtIDEpO1xuXG4gICAgICAgICAgICAgICAgICBjb2wgPSBlbmRDb2w7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoTGF5b3V0T2JqZWN0R3JpZCwgW3tcbiAgICAgICAgICAgICAga2V5OiBcInJvd0NvdW50XCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9iamVjdEdyaWQubGVuZ3RoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJfZmluZFN0YXJ0Q2VsbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmRTdGFydENlbGwoY29sLCByb3cpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2JqZWN0R3JpZFJvdyA9IHRoaXMuX2dldE9iamVjdEdyaWRSb3cocm93KTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gY29sOyBpbmRleCA8IG9iamVjdEdyaWRSb3cubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIW9iamVjdEdyaWRSb3dbaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0R3JpZFJvdy5sZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIl9nZXRPYmplY3RHcmlkUm93XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0T2JqZWN0R3JpZFJvdyhyb3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vYmplY3RHcmlkW3Jvd10gfHwgKHRoaXMub2JqZWN0R3JpZFtyb3ddID0gW10pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJfdXNlQ29sdW1uSW5kZXhcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91c2VDb2x1bW5JbmRleChjb2wpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb2x1bW5Db3VudCA+IGNvbCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uQ291bnQgPSBjb2wgKyAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJfc2V0V2lkdGhEYXRhSWZBYnNlbnRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRXaWR0aERhdGFJZkFic2VudChjb2wsIGNlbGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29sdW1uV2lkdGhzW2NvbF0pIHtcbiAgICAgICAgICAgICAgICAgIGlmIChjZWxsLndpZHRoICE9IG51bGwgfHwgY2VsbC5tYXhXaWR0aCAhPSBudWxsIHx8IGNlbGwubWluV2lkdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbldpZHRoc1tjb2xdID0ge1xuICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjZWxsLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgIG1heFdpZHRoOiBjZWxsLm1heFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgIG1pbldpZHRoOiBjZWxsLm1pbldpZHRoXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBMYXlvdXRPYmplY3RHcmlkO1xuICAgICAgICAgIH0oKTtcblxuICAgICAgICAgIHZhciBNdWx0aUxheW91dE1hcCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBNdWx0aUxheW91dE1hcChsYXlvdXQpIHtcbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE11bHRpTGF5b3V0TWFwKTtcblxuICAgICAgICAgICAgICB0aGlzLl9jb2x1bW5XaWR0aHMgPSBbXTtcbiAgICAgICAgICAgICAgdGhpcy5fZW1wdHlEYXRhQ2FjaGUgPSBuZXcgdXRpbHNfMS5FbXB0eURhdGFDYWNoZSgpO1xuICAgICAgICAgICAgICB2YXIgaGJMYXlvdXV0ID0gbm9ybWFsaXplTGF5b3V0KGxheW91dCk7XG4gICAgICAgICAgICAgIHZhciBoZWFkZXIgPSB0aGlzLl9oZWFkZXIgPSBuZXcgTGF5b3V0T2JqZWN0R3JpZChoYkxheW91dXQuaGVhZGVyLCBmdW5jdGlvbiAoaGQsIGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgIGNhcHRpb246IGhkLmNhcHRpb24sXG4gICAgICAgICAgICAgICAgICBmaWVsZDogaGQuaGVhZGVyRmllbGQgfHwgaGQuZmllbGQsXG4gICAgICAgICAgICAgICAgICBoZWFkZXJJY29uOiBoZC5oZWFkZXJJY29uLFxuICAgICAgICAgICAgICAgICAgc3R5bGU6IGhkLmhlYWRlclN0eWxlLFxuICAgICAgICAgICAgICAgICAgaGVhZGVyVHlwZTogaGVhZGVyVHlwZS5vZkNlbGwoaGQpLFxuICAgICAgICAgICAgICAgICAgYWN0aW9uOiBoZWFkZXJBY3Rpb24ub2ZDZWxsKGhkKSxcbiAgICAgICAgICAgICAgICAgIGRlZmluZTogaGRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgdmFyIGJvZHkgPSB0aGlzLl9ib2R5ID0gbmV3IExheW91dE9iamVjdEdyaWQoaGJMYXlvdXV0LmJvZHksIGZ1bmN0aW9uIChjb2xEZWYsIGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgIGZpZWxkOiBjb2xEZWYuZmllbGQsXG4gICAgICAgICAgICAgICAgICB3aWR0aDogY29sRGVmLndpZHRoLFxuICAgICAgICAgICAgICAgICAgbWluV2lkdGg6IGNvbERlZi5taW5XaWR0aCxcbiAgICAgICAgICAgICAgICAgIG1heFdpZHRoOiBjb2xEZWYubWF4V2lkdGgsXG4gICAgICAgICAgICAgICAgICBpY29uOiBjb2xEZWYuaWNvbixcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNvbERlZi5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgY29sdW1uVHlwZTogY29sdW1ucy50eXBlLm9mKGNvbERlZi5jb2x1bW5UeXBlKSxcbiAgICAgICAgICAgICAgICAgIGFjdGlvbjogY29sdW1ucy5hY3Rpb24ub2YoY29sRGVmLmFjdGlvbiksXG4gICAgICAgICAgICAgICAgICBzdHlsZTogY29sRGVmLnN0eWxlLFxuICAgICAgICAgICAgICAgICAgZGVmaW5lOiBjb2xEZWZcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgdmFyIGNvbHVtbkNvdW50ID0gdGhpcy5fY29sdW1uQ291bnQgPSBNYXRoLm1heChoZWFkZXIuY29sdW1uQ291bnQsIGJvZHkuY29sdW1uQ291bnQpO1xuXG4gICAgICAgICAgICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IGNvbHVtbkNvdW50OyBjb2wrKykge1xuICAgICAgICAgICAgICAgIHZhciB3aWR0aERlZiA9IGhlYWRlci5jb2x1bW5XaWR0aHNbY29sXSB8fCBib2R5LmNvbHVtbldpZHRoc1tjb2xdIHx8IHt9O1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbHVtbldpZHRoc1tjb2xdID0gd2lkdGhEZWY7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKE11bHRpTGF5b3V0TWFwLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiY29sdW1uV2lkdGhzXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb2x1bW5XaWR0aHM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImhlYWRlclJvd0NvdW50XCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9oZWFkZXIucm93Q291bnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImJvZHlSb3dDb3VudFwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYm9keS5yb3dDb3VudDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY29sQ291bnRcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbHVtbkNvdW50O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJoZWFkZXJPYmplY3RzXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9oZWFkZXIub2JqZWN0cztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY29sdW1uT2JqZWN0c1wiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYm9keS5vYmplY3RzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJnZXRDZWxsSWRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldENlbGxJZChjb2wsIHJvdykge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhlYWRlclJvd0NvdW50IDw9IHJvdykge1xuICAgICAgICAgICAgICAgICAgdmFyIGJvZHlSb3cgPSByb3cgLSB0aGlzLmhlYWRlclJvd0NvdW50O1xuICAgICAgICAgICAgICAgICAgdmFyIGJvZHlMYXlvdXRSb3cgPSBib2R5Um93ICUgdGhpcy5ib2R5Um93Q291bnQ7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5fYm9keS5vYmplY3RHcmlkW2JvZHlMYXlvdXRSb3ddKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbY29sXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmlkO1xuICAgICAgICAgICAgICAgIH0gLy9pbiBoZWFkZXJcblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIChfZCA9IChfYyA9IHRoaXMuX2hlYWRlci5vYmplY3RHcmlkW3Jvd10pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY1tjb2xdKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuaWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImdldEhlYWRlclwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SGVhZGVyKGNvbCwgcm93KSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkID0gdGhpcy5nZXRDZWxsSWQoY29sLCByb3cpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9oZWFkZXIub2JqZWN0TWFwW2lkXSB8fCB0aGlzLl9lbXB0eURhdGFDYWNoZS5nZXRIZWFkZXIoY29sLCByb3cpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJnZXRCb2R5XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCb2R5KGNvbCwgcm93KSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkID0gdGhpcy5nZXRDZWxsSWQoY29sLCByb3cpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ib2R5Lm9iamVjdE1hcFtpZF0gfHwgdGhpcy5fZW1wdHlEYXRhQ2FjaGUuZ2V0Qm9keShjb2wsIHJvdyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImdldEJvZHlMYXlvdXRSYW5nZUJ5SWRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJvZHlMYXlvdXRSYW5nZUJ5SWQoaWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCB0aGlzLmJvZHlSb3dDb3VudDsgcm93KyspIHtcbiAgICAgICAgICAgICAgICAgIHZhciBvYmplY3RHcmlkUm93ID0gdGhpcy5fYm9keS5vYmplY3RHcmlkW3Jvd107XG5cbiAgICAgICAgICAgICAgICAgIGlmICghb2JqZWN0R3JpZFJvdykge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgdGhpcy5jb2xDb3VudDsgY29sKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlkID09PSAoKF9hID0gb2JqZWN0R3JpZFJvd1tjb2xdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldENlbGxSYW5nZSh0aGlzLl9ib2R5LCBjb2wsIHJvdywgMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW4gbm90IGZvdW5kIGJvZHkgbGF5b3V0IEBpZD1cIi5jb25jYXQoaWQpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0Q2VsbFJhbmdlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDZWxsUmFuZ2UoY29sLCByb3cpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oZWFkZXJSb3dDb3VudCA8PSByb3cpIHtcbiAgICAgICAgICAgICAgICAgIHZhciByZWNvcmRJbmRleCA9IHRoaXMuZ2V0UmVjb3JkSW5kZXhCeVJvdyhyb3cpO1xuICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0Um93ID0gdGhpcy5nZXRSZWNvcmRTdGFydFJvd0J5UmVjb3JkSW5kZXgocmVjb3JkSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgdmFyIGJvZHlSb3cgPSByb3cgLSB0aGlzLmhlYWRlclJvd0NvdW50O1xuICAgICAgICAgICAgICAgICAgdmFyIGJvZHlMYXlvdXRSb3cgPSBib2R5Um93ICUgdGhpcy5ib2R5Um93Q291bnQ7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Q2VsbFJhbmdlKHRoaXMuX2JvZHksIGNvbCwgYm9keUxheW91dFJvdywgc3RhcnRSb3cpO1xuICAgICAgICAgICAgICAgIH0gLy9pbiBoZWFkZXJcblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldENlbGxSYW5nZSh0aGlzLl9oZWFkZXIsIGNvbCwgcm93LCAwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0UmVjb3JkSW5kZXhCeVJvd1wiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UmVjb3JkSW5kZXhCeVJvdyhyb3cpIHtcbiAgICAgICAgICAgICAgICBpZiAocm93IDwgdGhpcy5oZWFkZXJSb3dDb3VudCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB2YXIgYm9keVJvdyA9IHJvdyAtIHRoaXMuaGVhZGVyUm93Q291bnQ7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihib2R5Um93IC8gdGhpcy5ib2R5Um93Q291bnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0UmVjb3JkU3RhcnRSb3dCeVJlY29yZEluZGV4XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRSZWNvcmRTdGFydFJvd0J5UmVjb3JkSW5kZXgoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oZWFkZXJSb3dDb3VudCArIGluZGV4ICogdGhpcy5ib2R5Um93Q291bnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIl9nZXRDZWxsUmFuZ2VcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRDZWxsUmFuZ2UoIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgIGxheW91dCwgY29sLCBsYXlvdXRSb3csIG9mZnNldFJvdykge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qLCBfaztcblxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgICAgICAgICBjb2w6IGNvbCxcbiAgICAgICAgICAgICAgICAgICAgcm93OiBsYXlvdXRSb3cgKyBvZmZzZXRSb3dcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBlbmQ6IHtcbiAgICAgICAgICAgICAgICAgICAgY29sOiBjb2wsXG4gICAgICAgICAgICAgICAgICAgIHJvdzogbGF5b3V0Um93ICsgb2Zmc2V0Um93XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgb2JqZWN0R3JpZCA9IGxheW91dC5vYmplY3RHcmlkO1xuICAgICAgICAgICAgICAgIHZhciBpZCA9IChfYiA9IChfYSA9IG9iamVjdEdyaWRbbGF5b3V0Um93XSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2NvbF0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5pZDtcblxuICAgICAgICAgICAgICAgIGlmIChpZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGMgPSBjb2wgLSAxOyBjID49IDA7IGMtLSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGlkICE9PSAoKF9kID0gKF9jID0gb2JqZWN0R3JpZFtsYXlvdXRSb3ddKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NbY10pID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5pZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5jb2wgPSBjO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9jNiA9IGNvbCArIDE7IF9jNiA8IGxheW91dC5jb2x1bW5Db3VudDsgX2M2KyspIHtcbiAgICAgICAgICAgICAgICAgIGlmIChpZCAhPT0gKChfZiA9IChfZSA9IG9iamVjdEdyaWRbbGF5b3V0Um93XSkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lW19jNl0pID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5pZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5lbmQuY29sID0gX2M2O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAodmFyIHIgPSBsYXlvdXRSb3cgLSAxOyByID49IDA7IHItLSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGlkICE9PSAoKF9oID0gKF9nID0gb2JqZWN0R3JpZFtyXSkgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nW2NvbF0pID09PSBudWxsIHx8IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaC5pZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5yb3cgPSByICsgb2Zmc2V0Um93O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9yMiA9IGxheW91dFJvdyArIDE7IF9yMiA8IGxheW91dC5yb3dDb3VudDsgX3IyKyspIHtcbiAgICAgICAgICAgICAgICAgIGlmIChpZCAhPT0gKChfayA9IChfaiA9IG9iamVjdEdyaWRbX3IyXSkgPT09IG51bGwgfHwgX2ogPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9qW2NvbF0pID09PSBudWxsIHx8IF9rID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfay5pZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5lbmQucm93ID0gX3IyICsgb2Zmc2V0Um93O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIE11bHRpTGF5b3V0TWFwO1xuICAgICAgICAgIH0oKTtcblxuICAgICAgICAgIGV4cG9ydHMuTXVsdGlMYXlvdXRNYXAgPSBNdWx0aUxheW91dE1hcDtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9saXN0LWdyaWQvbGF5b3V0LW1hcC9pbnRlcm5hbC9zaW1wbGUtaGVhZGVyLWxheW91dC5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2xpc3QtZ3JpZC9sYXlvdXQtbWFwL2ludGVybmFsL3NpbXBsZS1oZWFkZXItbGF5b3V0LmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gbGlzdEdyaWRMYXlvdXRNYXBJbnRlcm5hbFNpbXBsZUhlYWRlckxheW91dEpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgdmFyIF9fY3JlYXRlQmluZGluZyA9IHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcgfHwgKE9iamVjdC5jcmVhdGUgPyBmdW5jdGlvbiAobywgbSwgaywgazIpIHtcbiAgICAgICAgICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG5cbiAgICAgICAgICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICAgICAgICAgIGRlc2MgPSB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBtW2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbiAgICAgICAgICB9IDogZnVuY3Rpb24gKG8sIG0sIGssIGsyKSB7XG4gICAgICAgICAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgICAgICAgICAgb1trMl0gPSBtW2tdO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQgfHwgKE9iamVjdC5jcmVhdGUgPyBmdW5jdGlvbiAobywgdikge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7XG4gICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgIHZhbHVlOiB2XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IDogZnVuY3Rpb24gKG8sIHYpIHtcbiAgICAgICAgICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBfX2ltcG9ydFN0YXIgPSB0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgICAgICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgICAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSB7XG4gICAgICAgICAgICAgIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuU2ltcGxlSGVhZGVyTGF5b3V0TWFwID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIGNvbHVtbnMgPSBfX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vLi4vY29sdW1ucyAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zLmpzXCIpKTtcblxuICAgICAgICAgIHZhciBoZWFkZXJBY3Rpb24gPSBfX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vLi4vaGVhZGVyL2FjdGlvbiAqL1xuICAgICAgICAgIFwiLi9oZWFkZXIvYWN0aW9uLmpzXCIpKTtcblxuICAgICAgICAgIHZhciBoZWFkZXJUeXBlID0gX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uLy4uL2hlYWRlci90eXBlICovXG4gICAgICAgICAgXCIuL2hlYWRlci90eXBlLmpzXCIpKTtcblxuICAgICAgICAgIHZhciB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi91dGlscyAqL1xuICAgICAgICAgIFwiLi9saXN0LWdyaWQvbGF5b3V0LW1hcC9pbnRlcm5hbC91dGlscy5qc1wiKTtcblxuICAgICAgICAgIHZhciBzZXFJZCA9IDA7XG5cbiAgICAgICAgICB2YXIgU2ltcGxlSGVhZGVyTGF5b3V0TWFwID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIFNpbXBsZUhlYWRlckxheW91dE1hcChoZWFkZXIpIHtcbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNpbXBsZUhlYWRlckxheW91dE1hcCk7XG5cbiAgICAgICAgICAgICAgdGhpcy5ib2R5Um93Q291bnQgPSAxO1xuICAgICAgICAgICAgICB0aGlzLl9lbXB0eURhdGFDYWNoZSA9IG5ldyB1dGlsc18xLkVtcHR5RGF0YUNhY2hlKCk7XG4gICAgICAgICAgICAgIHRoaXMuX2NvbHVtbnMgPSBbXTtcbiAgICAgICAgICAgICAgdGhpcy5faGVhZGVyQ2VsbElkcyA9IFtdO1xuICAgICAgICAgICAgICB0aGlzLl9oZWFkZXJPYmplY3RzID0gdGhpcy5fYWRkSGVhZGVycygwLCBoZWFkZXIsIFtdKTtcbiAgICAgICAgICAgICAgdGhpcy5faGVhZGVyT2JqZWN0TWFwID0gdGhpcy5faGVhZGVyT2JqZWN0cy5yZWR1Y2UoZnVuY3Rpb24gKG8sIGUpIHtcbiAgICAgICAgICAgICAgICBvW2UuaWRdID0gZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgICAgICAgfSwge30pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoU2ltcGxlSGVhZGVyTGF5b3V0TWFwLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiY29sdW1uV2lkdGhzXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb2x1bW5zO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJoZWFkZXJSb3dDb3VudFwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faGVhZGVyQ2VsbElkcy5sZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNvbENvdW50XCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb2x1bW5zLmxlbmd0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiaGVhZGVyT2JqZWN0c1wiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faGVhZGVyT2JqZWN0cztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY29sdW1uT2JqZWN0c1wiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY29sdW1ucztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0Q2VsbElkXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDZWxsSWQoY29sLCByb3cpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oZWFkZXJSb3dDb3VudCA8PSByb3cpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb2x1bW5zW2NvbF0uaWQ7XG4gICAgICAgICAgICAgICAgfSAvL2luIGhlYWRlclxuXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faGVhZGVyQ2VsbElkc1tyb3ddW2NvbF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImdldEhlYWRlclwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SGVhZGVyKGNvbCwgcm93KSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkID0gdGhpcy5nZXRDZWxsSWQoY29sLCByb3cpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9oZWFkZXJPYmplY3RNYXBbaWRdIHx8IHRoaXMuX2VtcHR5RGF0YUNhY2hlLmdldEhlYWRlcihjb2wsIHJvdyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImdldEJvZHlcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJvZHkoY29sLCBfcm93KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbHVtbnNbY29sXSB8fCB0aGlzLl9lbXB0eURhdGFDYWNoZS5nZXRCb2R5KGNvbCwgMCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImdldEJvZHlMYXlvdXRSYW5nZUJ5SWRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJvZHlMYXlvdXRSYW5nZUJ5SWQoaWQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCB0aGlzLmNvbENvdW50OyBjb2wrKykge1xuICAgICAgICAgICAgICAgICAgaWYgKGlkID09PSB0aGlzLl9jb2x1bW5zW2NvbF0uaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sOiBjb2wsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3c6IDBcbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIGVuZDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sOiBjb2wsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3c6IDBcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2FuIG5vdCBmb3VuZCBib2R5IGxheW91dCBAaWQ9XCIuY29uY2F0KGlkKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImdldENlbGxSYW5nZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2VsbFJhbmdlKGNvbCwgcm93KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbDogY29sLFxuICAgICAgICAgICAgICAgICAgICByb3c6IHJvd1xuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIGVuZDoge1xuICAgICAgICAgICAgICAgICAgICBjb2w6IGNvbCxcbiAgICAgICAgICAgICAgICAgICAgcm93OiByb3dcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaGVhZGVyUm93Q291bnQgPD0gcm93KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH0gLy9pbiBoZWFkZXJcblxuXG4gICAgICAgICAgICAgICAgdmFyIGlkID0gdGhpcy5nZXRDZWxsSWQoY29sLCByb3cpO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYyA9IGNvbCAtIDE7IGMgPj0gMDsgYy0tKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaWQgIT09IHRoaXMuZ2V0Q2VsbElkKGMsIHJvdykpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5jb2wgPSBjO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9jNyA9IGNvbCArIDE7IF9jNyA8IHRoaXMuY29sQ291bnQ7IF9jNysrKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaWQgIT09IHRoaXMuZ2V0Q2VsbElkKF9jNywgcm93KSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgcmVzdWx0LmVuZC5jb2wgPSBfYzc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgciA9IHJvdyAtIDE7IHIgPj0gMDsgci0tKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaWQgIT09IHRoaXMuZ2V0Q2VsbElkKGNvbCwgcikpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5yb3cgPSByO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9yMyA9IHJvdyArIDE7IF9yMyA8IHRoaXMuaGVhZGVyUm93Q291bnQ7IF9yMysrKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaWQgIT09IHRoaXMuZ2V0Q2VsbElkKGNvbCwgX3IzKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgcmVzdWx0LmVuZC5yb3cgPSBfcjM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0UmVjb3JkSW5kZXhCeVJvd1wiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UmVjb3JkSW5kZXhCeVJvdyhyb3cpIHtcbiAgICAgICAgICAgICAgICBpZiAocm93IDwgdGhpcy5oZWFkZXJSb3dDb3VudCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcm93IC0gdGhpcy5oZWFkZXJSb3dDb3VudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImdldFJlY29yZFN0YXJ0Um93QnlSZWNvcmRJbmRleFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UmVjb3JkU3RhcnRSb3dCeVJlY29yZEluZGV4KGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGVhZGVyUm93Q291bnQgKyBpbmRleDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiX2FkZEhlYWRlcnNcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGRIZWFkZXJzKHJvdywgaGVhZGVyLCByb290cykge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpczEwOSA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgdmFyIHJvd0NlbGxzID0gdGhpcy5faGVhZGVyQ2VsbElkc1tyb3ddIHx8IHRoaXMuX25ld1Jvdyhyb3cpO1xuXG4gICAgICAgICAgICAgICAgaGVhZGVyLmZvckVhY2goZnVuY3Rpb24gKGhkKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY29sID0gX3RoaXMxMDkuX2NvbHVtbnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgdmFyIGlkID0gc2VxSWQrKztcbiAgICAgICAgICAgICAgICAgIHZhciBjZWxsID0ge1xuICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgICAgIGNhcHRpb246IGhkLmNhcHRpb24sXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiBoZC5oZWFkZXJGaWVsZCB8fCBoZC5maWVsZCxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVySWNvbjogaGQuaGVhZGVySWNvbixcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IGhkLmhlYWRlclN0eWxlLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJUeXBlOiBoZWFkZXJUeXBlLm9mQ2VsbChoZCksXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogaGVhZGVyQWN0aW9uLm9mQ2VsbChoZCksXG4gICAgICAgICAgICAgICAgICAgIGRlZmluZTogaGRcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICByZXN1bHRzW2lkXSA9IGNlbGw7XG4gICAgICAgICAgICAgICAgICByb3dDZWxsc1tjb2xdID0gaWQ7XG5cbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIHIgPSByb3cgLSAxOyByID49IDA7IHItLSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpczEwOS5faGVhZGVyQ2VsbElkc1tyXVtjb2xdID0gcm9vdHNbcl07XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGlmIChoZC5jb2x1bW5zKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzMTA5Ll9hZGRIZWFkZXJzKHJvdyArIDEsIGhkLmNvbHVtbnMsIFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkocm9vdHMpLCBbaWRdKSkuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzLnB1c2goYyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbERlZiA9IGhkO1xuXG4gICAgICAgICAgICAgICAgICAgIF90aGlzMTA5Ll9jb2x1bW5zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgIGlkOiBzZXFJZCsrLFxuICAgICAgICAgICAgICAgICAgICAgIGZpZWxkOiBjb2xEZWYuZmllbGQsXG4gICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGNvbERlZi53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICBtaW5XaWR0aDogY29sRGVmLm1pbldpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgIG1heFdpZHRoOiBjb2xEZWYubWF4V2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgaWNvbjogY29sRGVmLmljb24sXG4gICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY29sRGVmLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgY29sdW1uVHlwZTogY29sdW1ucy50eXBlLm9mKGNvbERlZi5jb2x1bW5UeXBlKSxcbiAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IGNvbHVtbnMuYWN0aW9uLm9mKGNvbERlZi5hY3Rpb24pLFxuICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBjb2xEZWYuc3R5bGUsXG4gICAgICAgICAgICAgICAgICAgICAgZGVmaW5lOiBjb2xEZWZcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX3I0ID0gcm93ICsgMTsgX3I0IDwgX3RoaXMxMDkuX2hlYWRlckNlbGxJZHMubGVuZ3RoOyBfcjQrKykge1xuICAgICAgICAgICAgICAgICAgICAgIF90aGlzMTA5Ll9oZWFkZXJDZWxsSWRzW19yNF1bY29sXSA9IGlkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIl9uZXdSb3dcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9uZXdSb3cocm93KSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1JvdyA9IHRoaXMuX2hlYWRlckNlbGxJZHNbcm93XSA9IFtdO1xuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9jb2x1bW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld1JvdztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcHJldiA9IHRoaXMuX2hlYWRlckNlbGxJZHNbcm93IC0gMV07XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBwcmV2Lmxlbmd0aDsgY29sKyspIHtcbiAgICAgICAgICAgICAgICAgIG5ld1Jvd1tjb2xdID0gcHJldltjb2xdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBuZXdSb3c7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIFNpbXBsZUhlYWRlckxheW91dE1hcDtcbiAgICAgICAgICB9KCk7XG5cbiAgICAgICAgICBleHBvcnRzLlNpbXBsZUhlYWRlckxheW91dE1hcCA9IFNpbXBsZUhlYWRlckxheW91dE1hcDtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9saXN0LWdyaWQvbGF5b3V0LW1hcC9pbnRlcm5hbC91dGlscy5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2xpc3QtZ3JpZC9sYXlvdXQtbWFwL2ludGVybmFsL3V0aWxzLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gbGlzdEdyaWRMYXlvdXRNYXBJbnRlcm5hbFV0aWxzSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICB2YXIgX19jcmVhdGVCaW5kaW5nID0gdGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZyB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICAgICAgICAgICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcblxuICAgICAgICAgICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgICAgICAgICAgZGVzYyA9IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ba107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xuICAgICAgICAgIH0gOiBmdW5jdGlvbiAobywgbSwgaywgazIpIHtcbiAgICAgICAgICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgICAgICAgICBvW2syXSA9IG1ba107XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gdGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCB2KSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHtcbiAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gOiBmdW5jdGlvbiAobywgdikge1xuICAgICAgICAgICAgb1tcImRlZmF1bHRcIl0gPSB2O1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIF9faW1wb3J0U3RhciA9IHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgICAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIHtcbiAgICAgICAgICAgICAgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5FbXB0eURhdGFDYWNoZSA9IGV4cG9ydHMubmV3RW1wdHlDb2x1bW5EYXRhID0gZXhwb3J0cy5uZXdFbXB0eUhlYWRlckRhdGEgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgY29sdW1ucyA9IF9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi8uLi9jb2x1bW5zICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMuanNcIikpO1xuXG4gICAgICAgICAgdmFyIGhlYWRlclR5cGUgPSBfX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vLi4vaGVhZGVyL3R5cGUgKi9cbiAgICAgICAgICBcIi4vaGVhZGVyL3R5cGUuanNcIikpO1xuXG4gICAgICAgICAgdmFyIHNlcUlkID0gLTE7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5cbiAgICAgICAgICBmdW5jdGlvbiBuZXdFbXB0eUhlYWRlckRhdGEoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBpZDogc2VxSWQtLSxcbiAgICAgICAgICAgICAgZGVmaW5lOiB7fSxcbiAgICAgICAgICAgICAgaGVhZGVyVHlwZTogaGVhZGVyVHlwZS5vZihudWxsKSAvLyBkZWZhdWx0XG5cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5uZXdFbXB0eUhlYWRlckRhdGEgPSBuZXdFbXB0eUhlYWRlckRhdGE7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5cbiAgICAgICAgICBmdW5jdGlvbiBuZXdFbXB0eUNvbHVtbkRhdGEoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBpZDogc2VxSWQtLSxcbiAgICAgICAgICAgICAgZGVmaW5lOiB7fSxcbiAgICAgICAgICAgICAgY29sdW1uVHlwZTogY29sdW1ucy50eXBlLm9mKG51bGwpLFxuICAgICAgICAgICAgICBzdHlsZTogbnVsbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRzLm5ld0VtcHR5Q29sdW1uRGF0YSA9IG5ld0VtcHR5Q29sdW1uRGF0YTtcblxuICAgICAgICAgIHZhciBFbXB0eURhdGFDYWNoZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBFbXB0eURhdGFDYWNoZSgpIHtcbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVtcHR5RGF0YUNhY2hlKTtcblxuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICB0aGlzLmhlYWRlcnMgPSBbXTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcblxuICAgICAgICAgICAgICB0aGlzLmNvbHVtbnMgPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKEVtcHR5RGF0YUNhY2hlLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0SGVhZGVyXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRIZWFkZXIoY29sLCByb3cpIHtcbiAgICAgICAgICAgICAgICB2YXIgcm93cyA9IHRoaXMuaGVhZGVyc1tyb3ddIHx8ICh0aGlzLmhlYWRlcnNbcm93XSA9IFtdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcm93c1tjb2xdIHx8IChyb3dzW2NvbF0gPSBuZXdFbXB0eUhlYWRlckRhdGEoKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImdldEJvZHlcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJvZHkoY29sLCByb3cpIHtcbiAgICAgICAgICAgICAgICB2YXIgcm93cyA9IHRoaXMuY29sdW1uc1tyb3ddIHx8ICh0aGlzLmNvbHVtbnNbcm93XSA9IFtdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcm93c1tjb2xdIHx8IChyb3dzW2NvbF0gPSBuZXdFbXB0eUNvbHVtbkRhdGEoKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIEVtcHR5RGF0YUNhY2hlO1xuICAgICAgICAgIH0oKTtcblxuICAgICAgICAgIGV4cG9ydHMuRW1wdHlEYXRhQ2FjaGUgPSBFbXB0eURhdGFDYWNoZTtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9tYWluLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9tYWluLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBtYWluSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICB2YXIgX19jcmVhdGVCaW5kaW5nID0gdGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZyB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICAgICAgICAgICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcblxuICAgICAgICAgICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgICAgICAgICAgZGVzYyA9IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ba107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xuICAgICAgICAgIH0gOiBmdW5jdGlvbiAobywgbSwgaywgazIpIHtcbiAgICAgICAgICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgICAgICAgICBvW2syXSA9IG1ba107XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gdGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCB2KSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHtcbiAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gOiBmdW5jdGlvbiAobywgdikge1xuICAgICAgICAgICAgb1tcImRlZmF1bHRcIl0gPSB2O1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIF9faW1wb3J0U3RhciA9IHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgICAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIHtcbiAgICAgICAgICAgICAgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5yZWdpc3RlciA9IGV4cG9ydHMuZ2V0SWNvbnMgPSBleHBvcnRzLkdyaWRDYW52YXNIZWxwZXIgPSBleHBvcnRzLmRhdGEgPSBleHBvcnRzLnRoZW1lcyA9IGV4cG9ydHMuaGVhZGVycyA9IGV4cG9ydHMuY29sdW1ucyA9IGV4cG9ydHMuTGlzdEdyaWQgPSBleHBvcnRzLnRvb2xzID0gZXhwb3J0cy5jb3JlID0gZXhwb3J0cy5fZ2V0SW50ZXJuYWwgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgY29sdW1ucyA9IF9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL2NvbHVtbnMgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy5qc1wiKSk7XG5cbiAgICAgICAgICBleHBvcnRzLmNvbHVtbnMgPSBjb2x1bW5zO1xuXG4gICAgICAgICAgdmFyIGNvcmUgPSBfX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9jb3JlICovXG4gICAgICAgICAgXCIuL2NvcmUuanNcIikpO1xuXG4gICAgICAgICAgZXhwb3J0cy5jb3JlID0gY29yZTtcblxuICAgICAgICAgIHZhciBkYXRhID0gX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vZGF0YSAqL1xuICAgICAgICAgIFwiLi9kYXRhLmpzXCIpKTtcblxuICAgICAgICAgIGV4cG9ydHMuZGF0YSA9IGRhdGE7XG5cbiAgICAgICAgICB2YXIgaGVhZGVycyA9IF9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL2hlYWRlcnMgKi9cbiAgICAgICAgICBcIi4vaGVhZGVycy5qc1wiKSk7XG5cbiAgICAgICAgICBleHBvcnRzLmhlYWRlcnMgPSBoZWFkZXJzO1xuXG4gICAgICAgICAgdmFyIGljb25zID0gX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vaWNvbnMgKi9cbiAgICAgICAgICBcIi4vaWNvbnMuanNcIikpO1xuXG4gICAgICAgICAgdmFyIHJlZ2lzdGVyID0gX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vcmVnaXN0ZXIgKi9cbiAgICAgICAgICBcIi4vcmVnaXN0ZXIuanNcIikpO1xuXG4gICAgICAgICAgZXhwb3J0cy5yZWdpc3RlciA9IHJlZ2lzdGVyO1xuXG4gICAgICAgICAgdmFyIHRoZW1lcyA9IF9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL3RoZW1lcyAqL1xuICAgICAgICAgIFwiLi90aGVtZXMuanNcIikpO1xuXG4gICAgICAgICAgZXhwb3J0cy50aGVtZXMgPSB0aGVtZXM7XG5cbiAgICAgICAgICB2YXIgdG9vbHMgPSBfX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi90b29scyAqL1xuICAgICAgICAgIFwiLi90b29scy5qc1wiKSk7XG5cbiAgICAgICAgICBleHBvcnRzLnRvb2xzID0gdG9vbHM7XG5cbiAgICAgICAgICB2YXIgTGlzdEdyaWRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vTGlzdEdyaWQgKi9cbiAgICAgICAgICBcIi4vTGlzdEdyaWQuanNcIik7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJMaXN0R3JpZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBMaXN0R3JpZF8xLkxpc3RHcmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIEdyaWRDYW52YXNIZWxwZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vR3JpZENhbnZhc0hlbHBlciAqL1xuICAgICAgICAgIFwiLi9HcmlkQ2FudmFzSGVscGVyLmpzXCIpO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiR3JpZENhbnZhc0hlbHBlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBHcmlkQ2FudmFzSGVscGVyXzEuR3JpZENhbnZhc0hlbHBlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBnZXRfaW50ZXJuYWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vZ2V0LWludGVybmFsICovXG4gICAgICAgICAgXCIuL2dldC1pbnRlcm5hbC5qc1wiKTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9nZXRJbnRlcm5hbFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBnZXRfaW50ZXJuYWxfMS5nZXRJbnRlcm5hbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICAvKiogQHByaXZhdGUgKi9cblxuICAgICAgICAgIGZ1bmN0aW9uIGdldEljb25zKCkge1xuICAgICAgICAgICAgcmV0dXJuIGljb25zLmdldCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMuZ2V0SWNvbnMgPSBnZXRJY29uczsgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuXG4gICAgICAgICAgZXhwb3J0cy5kZWZhdWx0ID0ge1xuICAgICAgICAgICAgY29yZTogY29yZSxcbiAgICAgICAgICAgIHRvb2xzOiB0b29scyxcbiAgICAgICAgICAgIC8vIGltcGwgR3JpZHNcbiAgICAgICAgICAgIExpc3RHcmlkOiBMaXN0R3JpZF8xLkxpc3RHcmlkLFxuICAgICAgICAgICAgLy8gb2JqZWN0c1xuICAgICAgICAgICAgY29sdW1uczogY29sdW1ucyxcbiAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICAgICAgICB0aGVtZXM6IHRoZW1lcyxcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICAvLyBoZWxwZXJcbiAgICAgICAgICAgIEdyaWRDYW52YXNIZWxwZXI6IEdyaWRDYW52YXNIZWxwZXJfMS5HcmlkQ2FudmFzSGVscGVyLFxuICAgICAgICAgICAgLy9wbHVnaW4gcmVnaXN0ZXJzXG4gICAgICAgICAgICByZWdpc3RlcjogcmVnaXN0ZXIsXG5cbiAgICAgICAgICAgIGdldCBpY29ucygpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldEljb25zKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoZW1lcywgXCJkZWZhdWx0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGVtZXMuZ2V0RGVmYXVsdCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGRlZmF1bHRUaGVtZSkge1xuICAgICAgICAgICAgICB0aGVtZXMuc2V0RGVmYXVsdChkZWZhdWx0VGhlbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoZW1lcywgXCJjaG9pY2VzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGVtZXMuZ2V0Q2hvaWNlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL3BsdWdpbnMvaWNvbnMuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL3BsdWdpbnMvaWNvbnMuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIHBsdWdpbnNJY29uc0pzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuaWNvbnMgPSB2b2lkIDA7XG4gICAgICAgICAgZXhwb3J0cy5pY29ucyA9IHt9O1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL3BsdWdpbnMvdGhlbWVzLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vcGx1Z2lucy90aGVtZXMuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBwbHVnaW5zVGhlbWVzSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy50aGVtZXMgPSB2b2lkIDA7XG4gICAgICAgICAgZXhwb3J0cy50aGVtZXMgPSB7fTtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9yZWdpc3Rlci5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL3JlZ2lzdGVyLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gcmVnaXN0ZXJKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLmljb25zID0gZXhwb3J0cy5pY29uID0gZXhwb3J0cy50aGVtZSA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBpY29uc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9wbHVnaW5zL2ljb25zICovXG4gICAgICAgICAgXCIuL3BsdWdpbnMvaWNvbnMuanNcIik7XG5cbiAgICAgICAgICB2YXIgdGhlbWVzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL3BsdWdpbnMvdGhlbWVzICovXG4gICAgICAgICAgXCIuL3BsdWdpbnMvdGhlbWVzLmpzXCIpO1xuXG4gICAgICAgICAgZnVuY3Rpb24gcmVnaXN0ZXIob2JqLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIG9sZCA9IG9ialtuYW1lXTtcbiAgICAgICAgICAgIG9ialtuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIG9sZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiByZWdpc3RlcnMob2JqLCB2YWx1ZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gdmFsdWVzKSB7XG4gICAgICAgICAgICAgIG9ialtrXSA9IHZhbHVlc1trXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiB0aGVtZShuYW1lLCB0aGVtZSkge1xuICAgICAgICAgICAgaWYgKHRoZW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlZ2lzdGVyKHRoZW1lc18xLnRoZW1lcywgbmFtZSwgdGhlbWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoZW1lc18xLnRoZW1lc1tuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRzLnRoZW1lID0gdGhlbWU7XG5cbiAgICAgICAgICBmdW5jdGlvbiBpY29uKG5hbWUsIGljb24pIHtcbiAgICAgICAgICAgIGlmIChpY29uICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlZ2lzdGVyKGljb25zXzEuaWNvbnMsIG5hbWUsIGljb24pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGljb25zXzEuaWNvbnNbbmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5pY29uID0gaWNvbjtcblxuICAgICAgICAgIGZ1bmN0aW9uIGljb25zKGljb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVnaXN0ZXJzKGljb25zXzEuaWNvbnMsIGljb25zKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRzLmljb25zID0gaWNvbnM7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vdGhlbWVzLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL3RoZW1lcy5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiB0aGVtZXNKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIHZhciBfX2ltcG9ydERlZmF1bHQgPSB0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0IHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgICAgICAgIHJldHVybiBtb2QgJiYgbW9kLl9fZXNNb2R1bGUgPyBtb2QgOiB7XG4gICAgICAgICAgICAgIFwiZGVmYXVsdFwiOiBtb2RcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLmdldENob2ljZXMgPSBleHBvcnRzLnNldERlZmF1bHQgPSBleHBvcnRzLmdldERlZmF1bHQgPSBleHBvcnRzLm9mID0gZXhwb3J0cy50aGVtZSA9IGV4cG9ydHMuTUFURVJJQUxfREVTSUdOID0gZXhwb3J0cy5CQVNJQyA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9pbnRlcm5hbC91dGlscyAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC91dGlscy5qc1wiKTtcblxuICAgICAgICAgIHZhciB0aGVtZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi90aGVtZXMvdGhlbWUgKi9cbiAgICAgICAgICBcIi4vdGhlbWVzL3RoZW1lLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIEJBU0lDXzEgPSBfX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi90aGVtZXMvQkFTSUMgKi9cbiAgICAgICAgICBcIi4vdGhlbWVzL0JBU0lDLmpzXCIpKTtcblxuICAgICAgICAgIHZhciBNQVRFUklBTF9ERVNJR05fMSA9IF9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL3RoZW1lcy9NQVRFUklBTF9ERVNJR04gKi9cbiAgICAgICAgICBcIi4vdGhlbWVzL01BVEVSSUFMX0RFU0lHTi5qc1wiKSk7XG5cbiAgICAgICAgICB2YXIgdGhlbWVzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL3BsdWdpbnMvdGhlbWVzICovXG4gICAgICAgICAgXCIuL3BsdWdpbnMvdGhlbWVzLmpzXCIpO1xuXG4gICAgICAgICAgZXhwb3J0cy5CQVNJQyA9IG5ldyB0aGVtZV8xLlRoZW1lKEJBU0lDXzEuZGVmYXVsdCk7XG4gICAgICAgICAgZXhwb3J0cy5NQVRFUklBTF9ERVNJR04gPSBuZXcgdGhlbWVfMS5UaGVtZShNQVRFUklBTF9ERVNJR05fMS5kZWZhdWx0KTtcbiAgICAgICAgICB2YXIgYnVpbHRpbiA9IHtcbiAgICAgICAgICAgIEJBU0lDOiBleHBvcnRzLkJBU0lDLFxuICAgICAgICAgICAgTUFURVJJQUxfREVTSUdOOiBleHBvcnRzLk1BVEVSSUFMX0RFU0lHTlxuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIGRlZlRoZW1lID0gZXhwb3J0cy5NQVRFUklBTF9ERVNJR047XG4gICAgICAgICAgZXhwb3J0cy50aGVtZSA9IHtcbiAgICAgICAgICAgIFRoZW1lOiB0aGVtZV8xLlRoZW1lXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGZ1bmN0aW9uIG9mKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgIHZhciB0ID0gKDAsIHV0aWxzXzEuZ2V0SWdub3JlQ2FzZSkoZ2V0Q2hvaWNlcygpLCB2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgaWYgKHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiB0aGVtZV8xLlRoZW1lKSB7XG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGVtZV8xLlRoZW1lKHZhbHVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRzLm9mID0gb2Y7XG5cbiAgICAgICAgICBmdW5jdGlvbiBnZXREZWZhdWx0KCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlZlRoZW1lO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMuZ2V0RGVmYXVsdCA9IGdldERlZmF1bHQ7XG5cbiAgICAgICAgICBmdW5jdGlvbiBzZXREZWZhdWx0KGRlZmF1bHRUaGVtZSkge1xuICAgICAgICAgICAgZGVmVGhlbWUgPSBvZihkZWZhdWx0VGhlbWUpIHx8IGRlZlRoZW1lO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMuc2V0RGVmYXVsdCA9IHNldERlZmF1bHQ7XG5cbiAgICAgICAgICBmdW5jdGlvbiBnZXRDaG9pY2VzKCkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLmV4dGVuZCkoYnVpbHRpbiwgdGhlbWVzXzEudGhlbWVzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRzLmdldENob2ljZXMgPSBnZXRDaG9pY2VzO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL3RoZW1lcy9CQVNJQy5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi90aGVtZXMvQkFTSUMuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gdGhlbWVzQkFTSUNKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAvKmVzbGludCBuby1iaXR3aXNlOjAqL1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgZnVuY3Rpb24gREVGQVVMVF9CR19DT0xPUihhcmdzKSB7XG4gICAgICAgICAgICB2YXIgcm93ID0gYXJncy5yb3csXG4gICAgICAgICAgICAgICAgZ3JpZCA9IGFyZ3MuZ3JpZDtcblxuICAgICAgICAgICAgaWYgKHJvdyA8IGdyaWQuZnJvemVuUm93Q291bnQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFwiI0ZGRlwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBncmlkLmdldFJlY29yZEluZGV4QnlSb3cocm93KTtcblxuICAgICAgICAgICAgaWYgKCEoaW5kZXggJiAxKSkge1xuICAgICAgICAgICAgICByZXR1cm4gXCIjRkZGXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gXCIjRjZGNkY2XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGNhY2hlTGluZWFyR3JhZGllbnQgPSB7fTtcblxuICAgICAgICAgIGZ1bmN0aW9uIGdldExpbmVhckdyYWRpZW50KGNvbnRleHQsIGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbSwgY29sb3JTdG9wcykge1xuICAgICAgICAgICAgdmFyIHN0b3A7XG4gICAgICAgICAgICB2YXIgc3RvcHNLZXkgPSBbXTtcblxuICAgICAgICAgICAgZm9yIChzdG9wIGluIGNvbG9yU3RvcHMpIHtcbiAgICAgICAgICAgICAgc3RvcHNLZXkucHVzaChcIlwiLmNvbmNhdChzdG9wLCBcIkBcIikuY29uY2F0KGNvbG9yU3RvcHNbc3RvcF0pKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGtleSA9IFwiXCIuY29uY2F0KGxlZnQsIFwiL1wiKS5jb25jYXQodG9wLCBcIi9cIikuY29uY2F0KHJpZ2h0LCBcIi9cIikuY29uY2F0KGJvdHRvbSwgXCIvXCIpLmNvbmNhdChzdG9wc0tleS5qb2luKFwiLFwiKSk7XG4gICAgICAgICAgICB2YXIgcmV0ID0gY2FjaGVMaW5lYXJHcmFkaWVudFtrZXldO1xuXG4gICAgICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBncmFkID0gY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudChsZWZ0LCB0b3AsIGxlZnQsIGJvdHRvbSk7XG5cbiAgICAgICAgICAgIGZvciAoc3RvcCBpbiBjb2xvclN0b3BzKSB7XG4gICAgICAgICAgICAgIGdyYWQuYWRkQ29sb3JTdG9wKE51bWJlcihzdG9wKSwgY29sb3JTdG9wc1tzdG9wXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjYWNoZUxpbmVhckdyYWRpZW50W2tleV0gPSBncmFkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIEZST1pFTl9ST1dTX0JHX0NPTE9SKGFyZ3MpIHtcbiAgICAgICAgICAgIHZhciBjb2wgPSBhcmdzLmNvbCxcbiAgICAgICAgICAgICAgICBncmlkID0gYXJncy5ncmlkLFxuICAgICAgICAgICAgICAgIGZyb3plblJvd0NvdW50ID0gYXJncy5ncmlkLmZyb3plblJvd0NvdW50LFxuICAgICAgICAgICAgICAgIGNvbnRleHQgPSBhcmdzLmNvbnRleHQ7XG5cbiAgICAgICAgICAgIHZhciBfZ3JpZCRnZXRDZWxsUmVsYXRpdmUgPSBncmlkLmdldENlbGxSZWxhdGl2ZVJlY3QoY29sLCAwKSxcbiAgICAgICAgICAgICAgICBsZWZ0ID0gX2dyaWQkZ2V0Q2VsbFJlbGF0aXZlLmxlZnQsXG4gICAgICAgICAgICAgICAgdG9wID0gX2dyaWQkZ2V0Q2VsbFJlbGF0aXZlLnRvcDtcblxuICAgICAgICAgICAgdmFyIF9ncmlkJGdldENlbGxSZWxhdGl2ZTIgPSBncmlkLmdldENlbGxSZWxhdGl2ZVJlY3QoY29sLCBmcm96ZW5Sb3dDb3VudCAtIDEpLFxuICAgICAgICAgICAgICAgIGJvdHRvbSA9IF9ncmlkJGdldENlbGxSZWxhdGl2ZTIuYm90dG9tO1xuXG4gICAgICAgICAgICByZXR1cm4gZ2V0TGluZWFyR3JhZGllbnQoY29udGV4dCwgbGVmdCwgdG9wLCBsZWZ0LCBib3R0b20sIHtcbiAgICAgICAgICAgICAgMDogXCIjRkZGXCIsXG4gICAgICAgICAgICAgIDE6IFwiI0QzRDNEM1wiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogYmFzaWMgdGhlbWVcbiAgICAgICAgICAgKiBAbmFtZSBCQVNJQ1xuICAgICAgICAgICAqIEBtZW1iZXJvZiBjaGVldGFoR3JpZC50aGVtZXMuY2hvaWNlc1xuICAgICAgICAgICAqL1xuXG5cbiAgICAgICAgICBleHBvcnRzLmRlZmF1bHQgPSB7XG4gICAgICAgICAgICBjb2xvcjogXCIjMDAwXCIsXG4gICAgICAgICAgICAvLyBmcm96ZW5Sb3dzQ29sb3I6ICcjMDAwJyxcbiAgICAgICAgICAgIGRlZmF1bHRCZ0NvbG9yOiBERUZBVUxUX0JHX0NPTE9SLFxuICAgICAgICAgICAgZnJvemVuUm93c0JnQ29sb3I6IEZST1pFTl9ST1dTX0JHX0NPTE9SLFxuICAgICAgICAgICAgc2VsZWN0aW9uQmdDb2xvcjogXCIjQ0NFMEZGXCIsXG4gICAgICAgICAgICBib3JkZXJDb2xvcjogXCIjMDAwXCIsXG4gICAgICAgICAgICAvLyBmcm96ZW5Sb3dzQm9yZGVyQ29sb3I6ICcjMDAwJyxcbiAgICAgICAgICAgIGhpZ2hsaWdodEJvcmRlckNvbG9yOiBcIiM1RTlFRDZcIixcbiAgICAgICAgICAgIGNoZWNrYm94OiB7XG4gICAgICAgICAgICAgIHVuY2hlY2tCZ0NvbG9yOiBcIiNGRkZcIixcbiAgICAgICAgICAgICAgY2hlY2tCZ0NvbG9yOiBcInJnYig3NiwgNzMsIDcyKVwiLFxuICAgICAgICAgICAgICBib3JkZXJDb2xvcjogXCIjMDAwXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByYWRpb0J1dHRvbjoge1xuICAgICAgICAgICAgICBjaGVja0NvbG9yOiBcInJnYig3NiwgNzMsIDcyKVwiLFxuICAgICAgICAgICAgICBjaGVja0JvcmRlckNvbG9yOiBcIiMwMDBcIixcbiAgICAgICAgICAgICAgdW5jaGVja0JvcmRlckNvbG9yOiBcIiMwMDBcIixcbiAgICAgICAgICAgICAgdW5jaGVja0JnQ29sb3I6IFwiI0ZGRlwiLFxuICAgICAgICAgICAgICBjaGVja0JnQ29sb3I6IFwiI0ZGRlwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYnV0dG9uOiB7XG4gICAgICAgICAgICAgIGNvbG9yOiBcIiNGRkZcIixcbiAgICAgICAgICAgICAgYmdDb2xvcjogXCIjMjE5NkYzXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoZWFkZXI6IHtcbiAgICAgICAgICAgICAgc29ydEFycm93Q29sb3I6IFwicmdiYSgwLCAwLCAwLCAwLjM4KVwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5kaWNhdG9yczoge1xuICAgICAgICAgICAgICB0b3BMZWZ0Q29sb3I6IFwiIzAwMFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdW5kZXJsYXlCYWNrZ3JvdW5kQ29sb3I6IFwiI0Y2RjZGNlwiXG4gICAgICAgICAgfTtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi90aGVtZXMvTUFURVJJQUxfREVTSUdOLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi90aGVtZXMvTUFURVJJQUxfREVTSUdOLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiB0aGVtZXNNQVRFUklBTF9ERVNJR05Kcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAvKmVzbGludCBuby1iaXR3aXNlOjAqL1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgZnVuY3Rpb24gRlJPWkVOX1JPV1NfQk9SREVSX0NPTE9SKGFyZ3MpIHtcbiAgICAgICAgICAgIHZhciByb3cgPSBhcmdzLnJvdyxcbiAgICAgICAgICAgICAgICBmcm96ZW5Sb3dDb3VudCA9IGFyZ3MuZ3JpZC5mcm96ZW5Sb3dDb3VudDtcblxuICAgICAgICAgICAgaWYgKGZyb3plblJvd0NvdW50IC0gMSA9PT0gcm93KSB7XG4gICAgICAgICAgICAgIHJldHVybiBbXCIjZjJmMmYyXCIsIFwiI2YyZjJmMlwiLCBcIiNjY2M3YzdcIiwgXCIjZjJmMmYyXCJdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFtcIiNmMmYyZjJcIl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gQk9SREVSX0NPTE9SKGFyZ3MpIHtcbiAgICAgICAgICAgIHZhciBjb2wgPSBhcmdzLmNvbCxcbiAgICAgICAgICAgICAgICByb3cgPSBhcmdzLnJvdyxcbiAgICAgICAgICAgICAgICBncmlkID0gYXJncy5ncmlkO1xuICAgICAgICAgICAgdmFyIGNvbENvdW50ID0gZ3JpZC5jb2xDb3VudCxcbiAgICAgICAgICAgICAgICBmcm96ZW5Db2xDb3VudCA9IGdyaWQuZnJvemVuQ29sQ291bnQsXG4gICAgICAgICAgICAgICAgcmVjb3JkUm93Q291bnQgPSBncmlkLnJlY29yZFJvd0NvdW50O1xuICAgICAgICAgICAgdmFyIHRvcCA9IFwiI2NjYzdjN1wiO1xuICAgICAgICAgICAgdmFyIGJvdHRvbSA9IFwiI2NjYzdjN1wiO1xuXG4gICAgICAgICAgICBpZiAocmVjb3JkUm93Q291bnQgPiAxKSB7XG4gICAgICAgICAgICAgIHZhciBzdGFydFJvdyA9IGdyaWQuZ2V0UmVjb3JkU3RhcnRSb3dCeVJlY29yZEluZGV4KGdyaWQuZ2V0UmVjb3JkSW5kZXhCeVJvdyhyb3cpKTtcbiAgICAgICAgICAgICAgdmFyIGVuZFJvdyA9IHN0YXJ0Um93ICsgcmVjb3JkUm93Q291bnQgLSAxO1xuXG4gICAgICAgICAgICAgIGlmIChzdGFydFJvdyAhPT0gcm93KSB7XG4gICAgICAgICAgICAgICAgdG9wID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChlbmRSb3cgIT09IHJvdykge1xuICAgICAgICAgICAgICAgIGJvdHRvbSA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGZyb3plbkNvbENvdW50IC0gMSA9PT0gY29sKSB7XG4gICAgICAgICAgICAgIHJldHVybiBbdG9wLCBcIiNmMmYyZjJcIiwgYm90dG9tLCBudWxsXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvbENvdW50IC0gMSA9PT0gY29sKSB7XG4gICAgICAgICAgICAgIHJldHVybiBbdG9wLCBcIiNmMmYyZjJcIiwgYm90dG9tLCBudWxsXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIFt0b3AsIG51bGwsIGJvdHRvbSwgbnVsbF07XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIG1hdGVyaWFsIGRlc2lnbiB0aGVtZVxuICAgICAgICAgICAqIEBuYW1lIE1BVEVSSUFMX0RFU0lHTlxuICAgICAgICAgICAqIEBtZW1iZXJvZiBjaGVldGFoR3JpZC50aGVtZXMuY2hvaWNlc1xuICAgICAgICAgICAqL1xuXG5cbiAgICAgICAgICBleHBvcnRzLmRlZmF1bHQgPSB7XG4gICAgICAgICAgICBjb2xvcjogXCJyZ2JhKDAsIDAsIDAsIDAuODcpXCIsXG4gICAgICAgICAgICBmcm96ZW5Sb3dzQ29sb3I6IFwicmdiYSgwLCAwLCAwLCAwLjU0KVwiLFxuICAgICAgICAgICAgZGVmYXVsdEJnQ29sb3I6IFwiI0ZGRlwiLFxuICAgICAgICAgICAgLy8gZnJvemVuUm93c0JnQ29sb3I6ICcjRkZGJyxcbiAgICAgICAgICAgIHNlbGVjdGlvbkJnQ29sb3I6IFwiI0NDRTBGRlwiLFxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6IEJPUkRFUl9DT0xPUixcbiAgICAgICAgICAgIGZyb3plblJvd3NCb3JkZXJDb2xvcjogRlJPWkVOX1JPV1NfQk9SREVSX0NPTE9SLFxuICAgICAgICAgICAgaGlnaGxpZ2h0Qm9yZGVyQ29sb3I6IFwiIzVFOUVENlwiLFxuICAgICAgICAgICAgY2hlY2tib3g6IHtcbiAgICAgICAgICAgICAgLy8gdW5jaGVja0JnQ29sb3I6ICcjRkZGJyxcbiAgICAgICAgICAgICAgY2hlY2tCZ0NvbG9yOiBcInJnYig3NiwgNzMsIDcyKVwiLFxuICAgICAgICAgICAgICBib3JkZXJDb2xvcjogXCJyZ2JhKDAsIDAsIDAsIDAuMjYpXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByYWRpb0J1dHRvbjoge1xuICAgICAgICAgICAgICBjaGVja0NvbG9yOiBcInJnYig3NiwgNzMsIDcyKVwiLFxuICAgICAgICAgICAgICBjaGVja0JvcmRlckNvbG9yOiBcInJnYig3NiwgNzMsIDcyKVwiLFxuICAgICAgICAgICAgICB1bmNoZWNrQm9yZGVyQ29sb3I6IFwicmdiKDE4OSwgMTg5LCAxODkpXCIgLy8gdW5jaGVja0JnQ29sb3I6IFwiI0ZGRlwiLFxuICAgICAgICAgICAgICAvLyBjaGVja0JnQ29sb3I6IFwiI0ZGRlwiLFxuXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYnV0dG9uOiB7XG4gICAgICAgICAgICAgIGNvbG9yOiBcIiNGRkZcIixcbiAgICAgICAgICAgICAgYmdDb2xvcjogXCIjMjE5NkYzXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoZWFkZXI6IHtcbiAgICAgICAgICAgICAgc29ydEFycm93Q29sb3I6IFwicmdiYSgwLCAwLCAwLCAwLjM4KVwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5kaWNhdG9yczoge1xuICAgICAgICAgICAgICB0b3BMZWZ0Q29sb3I6IFwiI2NjYzdjN1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdW5kZXJsYXlCYWNrZ3JvdW5kQ29sb3I6IFwiI0ZGRlwiXG4gICAgICAgICAgfTtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi90aGVtZXMvdGhlbWUuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vdGhlbWVzL3RoZW1lLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIHRoZW1lc1RoZW1lSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5UaGVtZSA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vaW50ZXJuYWwvdXRpbHMgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvdXRpbHMuanNcIik7XG5cbiAgICAgICAgICB2YXIgc3ltYm9sTWFuYWdlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vaW50ZXJuYWwvc3ltYm9sTWFuYWdlciAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC9zeW1ib2xNYW5hZ2VyLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIFRyZWVDb2x1bW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uL2NvbHVtbnMvdHlwZS9UcmVlQ29sdW1uICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvdHlwZS9UcmVlQ29sdW1uLmpzXCIpOyAvL3ByaXZhdGUgc3ltYm9sXG5cblxuICAgICAgICAgIHZhciBfID0gKDAsIHN5bWJvbE1hbmFnZXJfMS5nZXQpKCk7XG5cbiAgICAgICAgICBmdW5jdGlvbiBnZXRQcm9wKG9iaiwgc3VwZXJPYmosIG5hbWVzLCBkZWZOYW1lcywgY29udmVydEZvclN1cGVyLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9ICgwLCB1dGlsc18xLmdldENoYWluU2FmZSkuYXBwbHkodm9pZCAwLCBbb2JqXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KG5hbWVzKSkpIHx8ICgwLCB1dGlsc18xLmdldENoYWluU2FmZSkuYXBwbHkodm9pZCAwLCBbc3VwZXJPYmpdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkobmFtZXMpKSk7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZGVmTmFtZXMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlIHx8IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGdldENoYWluU2FmZVdpdGhDb252ZXJ0ID0gY29udmVydEZvclN1cGVyID8gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICBmb3IgKHZhciBfbGVuMjYgPSBhcmd1bWVudHMubGVuZ3RoLCBuYW1lcyA9IG5ldyBBcnJheShfbGVuMjYgPiAxID8gX2xlbjI2IC0gMSA6IDApLCBfa2V5MjcgPSAxOyBfa2V5MjcgPCBfbGVuMjY7IF9rZXkyNysrKSB7XG4gICAgICAgICAgICAgICAgbmFtZXNbX2tleTI3IC0gMV0gPSBhcmd1bWVudHNbX2tleTI3XTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9ICgwLCB1dGlsc18xLmdldENoYWluU2FmZSkuYXBwbHkodm9pZCAwLCBbb2JqXS5jb25jYXQobmFtZXMpKTtcblxuICAgICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRGb3JTdXBlcih2YWx1ZSk7XG4gICAgICAgICAgICB9IDogdXRpbHNfMS5nZXRDaGFpblNhZmU7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q2hhaW5TYWZlV2l0aENvbnZlcnQuYXBwbHkodm9pZCAwLCBbb2JqXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGRlZk5hbWVzKSkpIHx8IGdldENoYWluU2FmZVdpdGhDb252ZXJ0LmFwcGx5KHZvaWQgMCwgW3N1cGVyT2JqXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGRlZk5hbWVzKSkpIHx8IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgVGhlbWUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gVGhlbWUob2JqLCBzdXBlclRoZW1lKSB7XG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUaGVtZSk7XG5cbiAgICAgICAgICAgICAgdGhpcy5fY2hlY2tib3ggPSBudWxsO1xuICAgICAgICAgICAgICB0aGlzLl9yYWRpb0J1dHRvbiA9IG51bGw7XG4gICAgICAgICAgICAgIHRoaXMuX2J1dHRvbiA9IG51bGw7XG4gICAgICAgICAgICAgIHRoaXMuX3RyZWUgPSBudWxsO1xuICAgICAgICAgICAgICB0aGlzLl9oZWFkZXIgPSBudWxsO1xuICAgICAgICAgICAgICB0aGlzLl9tZXNzYWdlcyA9IG51bGw7XG4gICAgICAgICAgICAgIHRoaXMuX2luZGljYXRvcnMgPSBudWxsO1xuICAgICAgICAgICAgICB0aGlzW19dID0ge1xuICAgICAgICAgICAgICAgIG9iajogb2JqLFxuICAgICAgICAgICAgICAgIHN1cGVyVGhlbWU6IHN1cGVyVGhlbWVcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKFRoZW1lLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiZm9udFwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMkXzMgPSB0aGlzW19dLFxuICAgICAgICAgICAgICAgICAgICBvYmogPSBfdGhpcyRfMy5vYmosXG4gICAgICAgICAgICAgICAgICAgIHN1cGVyVGhlbWUgPSBfdGhpcyRfMy5zdXBlclRoZW1lO1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRQcm9wKG9iaiwgc3VwZXJUaGVtZSwgW1wiZm9udFwiXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInVuZGVybGF5QmFja2dyb3VuZENvbG9yXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyRfNCA9IHRoaXNbX10sXG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IF90aGlzJF80Lm9iaixcbiAgICAgICAgICAgICAgICAgICAgc3VwZXJUaGVtZSA9IF90aGlzJF80LnN1cGVyVGhlbWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFByb3Aob2JqLCBzdXBlclRoZW1lLCBbXCJ1bmRlcmxheUJhY2tncm91bmRDb2xvclwiXSk7XG4gICAgICAgICAgICAgIH0gLy8gY29sb3JcblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY29sb3JcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzJF81ID0gdGhpc1tfXSxcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gX3RoaXMkXzUub2JqLFxuICAgICAgICAgICAgICAgICAgICBzdXBlclRoZW1lID0gX3RoaXMkXzUuc3VwZXJUaGVtZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0UHJvcChvYmosIHN1cGVyVGhlbWUsIFtcImNvbG9yXCJdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZnJvemVuUm93c0NvbG9yXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyRfNiA9IHRoaXNbX10sXG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IF90aGlzJF82Lm9iaixcbiAgICAgICAgICAgICAgICAgICAgc3VwZXJUaGVtZSA9IF90aGlzJF82LnN1cGVyVGhlbWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFByb3Aob2JqLCBzdXBlclRoZW1lLCBbXCJmcm96ZW5Sb3dzQ29sb3JcIl0sIFtcImNvbG9yXCJdKTtcbiAgICAgICAgICAgICAgfSAvLyBiYWNrZ3JvdW5kXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImRlZmF1bHRCZ0NvbG9yXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyRfNyA9IHRoaXNbX10sXG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IF90aGlzJF83Lm9iaixcbiAgICAgICAgICAgICAgICAgICAgc3VwZXJUaGVtZSA9IF90aGlzJF83LnN1cGVyVGhlbWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFByb3Aob2JqLCBzdXBlclRoZW1lLCBbXCJkZWZhdWx0QmdDb2xvclwiXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImZyb3plblJvd3NCZ0NvbG9yXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyRfOCA9IHRoaXNbX10sXG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IF90aGlzJF84Lm9iaixcbiAgICAgICAgICAgICAgICAgICAgc3VwZXJUaGVtZSA9IF90aGlzJF84LnN1cGVyVGhlbWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFByb3Aob2JqLCBzdXBlclRoZW1lLCBbXCJmcm96ZW5Sb3dzQmdDb2xvclwiXSwgW1wiZGVmYXVsdEJnQ29sb3JcIl0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJzZWxlY3Rpb25CZ0NvbG9yXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyRfOSA9IHRoaXNbX10sXG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IF90aGlzJF85Lm9iaixcbiAgICAgICAgICAgICAgICAgICAgc3VwZXJUaGVtZSA9IF90aGlzJF85LnN1cGVyVGhlbWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFByb3Aob2JqLCBzdXBlclRoZW1lLCBbXCJzZWxlY3Rpb25CZ0NvbG9yXCJdLCBbXCJkZWZhdWx0QmdDb2xvclwiXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImhpZ2hsaWdodEJnQ29sb3JcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzMTEwID0gdGhpcztcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc1Byb3BlcnR5KFtcImhpZ2hsaWdodEJnQ29sb3JcIl0pKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgX3RoaXMkXzEwID0gdGhpc1tfXSxcbiAgICAgICAgICAgICAgICAgICAgICBvYmogPSBfdGhpcyRfMTAub2JqLFxuICAgICAgICAgICAgICAgICAgICAgIHN1cGVyVGhlbWUgPSBfdGhpcyRfMTAuc3VwZXJUaGVtZTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRQcm9wKG9iaiwgc3VwZXJUaGVtZSwgW1wiaGlnaGxpZ2h0QmdDb2xvclwiXSk7XG4gICAgICAgICAgICAgICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBjb2xvciA9IGFyZ3Mucm93IDwgYXJncy5ncmlkLmZyb3plblJvd0NvdW50ID8gX3RoaXMxMTAuZnJvemVuUm93c0JnQ29sb3IgOiBfdGhpczExMC5kZWZhdWx0QmdDb2xvcjtcblxuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb2xvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2xvcihhcmdzKTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbG9yO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH0gLy8gYm9yZGVyXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImJvcmRlckNvbG9yXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyRfMTEgPSB0aGlzW19dLFxuICAgICAgICAgICAgICAgICAgICBvYmogPSBfdGhpcyRfMTEub2JqLFxuICAgICAgICAgICAgICAgICAgICBzdXBlclRoZW1lID0gX3RoaXMkXzExLnN1cGVyVGhlbWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFByb3Aob2JqLCBzdXBlclRoZW1lLCBbXCJib3JkZXJDb2xvclwiXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImZyb3plblJvd3NCb3JkZXJDb2xvclwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMkXzEyID0gdGhpc1tfXSxcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gX3RoaXMkXzEyLm9iaixcbiAgICAgICAgICAgICAgICAgICAgc3VwZXJUaGVtZSA9IF90aGlzJF8xMi5zdXBlclRoZW1lO1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRQcm9wKG9iaiwgc3VwZXJUaGVtZSwgW1wiZnJvemVuUm93c0JvcmRlckNvbG9yXCJdLCBbXCJib3JkZXJDb2xvclwiXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImhpZ2hsaWdodEJvcmRlckNvbG9yXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyRfMTMgPSB0aGlzW19dLFxuICAgICAgICAgICAgICAgICAgICBvYmogPSBfdGhpcyRfMTMub2JqLFxuICAgICAgICAgICAgICAgICAgICBzdXBlclRoZW1lID0gX3RoaXMkXzEzLnN1cGVyVGhlbWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFByb3Aob2JqLCBzdXBlclRoZW1lLCBbXCJoaWdobGlnaHRCb3JkZXJDb2xvclwiXSwgW1wiYm9yZGVyQ29sb3JcIl0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjaGVja2JveFwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMkXzE0ID0gdGhpc1tfXSxcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gX3RoaXMkXzE0Lm9iaixcbiAgICAgICAgICAgICAgICAgICAgc3VwZXJUaGVtZSA9IF90aGlzJF8xNC5zdXBlclRoZW1lO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jaGVja2JveCB8fCAodGhpcy5fY2hlY2tib3ggPSB7XG4gICAgICAgICAgICAgICAgICBnZXQgdW5jaGVja0JnQ29sb3IoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRDaGVja2JveFByb3AoXCJ1bmNoZWNrQmdDb2xvclwiLCBbXCJkZWZhdWx0QmdDb2xvclwiXSk7XG4gICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICBnZXQgY2hlY2tCZ0NvbG9yKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Q2hlY2tib3hQcm9wKFwiY2hlY2tCZ0NvbG9yXCIsIFtcImJvcmRlckNvbG9yXCJdLCBjb2xvcnNUb0NvbG9yLCBcIiMwMDBcIik7XG4gICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICBnZXQgYm9yZGVyQ29sb3IoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRDaGVja2JveFByb3AoXCJib3JkZXJDb2xvclwiLCBbXCJib3JkZXJDb2xvclwiXSwgY29sb3JzVG9Db2xvciwgXCIjMDAwXCIpO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXRDaGVja2JveFByb3AocHJvcCwgZGVmTmFtZXMsIGNvbnZlcnRGb3JTdXBlciwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0UHJvcChvYmosIHN1cGVyVGhlbWUsIFtcImNoZWNrYm94XCIsIHByb3BdLCBkZWZOYW1lcywgY29udmVydEZvclN1cGVyLCBkZWZhdWx0VmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwicmFkaW9CdXR0b25cIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzJF8xNSA9IHRoaXNbX10sXG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IF90aGlzJF8xNS5vYmosXG4gICAgICAgICAgICAgICAgICAgIHN1cGVyVGhlbWUgPSBfdGhpcyRfMTUuc3VwZXJUaGVtZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmFkaW9CdXR0b24gfHwgKHRoaXMuX3JhZGlvQnV0dG9uID0ge1xuICAgICAgICAgICAgICAgICAgZ2V0IGNoZWNrQ29sb3IoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRSYWRpb0J1dHRvblByb3AoXCJjaGVja0NvbG9yXCIsIFtcImNvbG9yXCJdKTtcbiAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgIGdldCB1bmNoZWNrQm9yZGVyQ29sb3IoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRSYWRpb0J1dHRvblByb3AoXCJ1bmNoZWNrQm9yZGVyQ29sb3JcIiwgW1wiYm9yZGVyQ29sb3JcIl0sIGNvbG9yc1RvQ29sb3IsIFwiIzAwMFwiKTtcbiAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgIGdldCBjaGVja0JvcmRlckNvbG9yKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0UmFkaW9CdXR0b25Qcm9wKFwiY2hlY2tCb3JkZXJDb2xvclwiLCBbXCJib3JkZXJDb2xvclwiXSwgY29sb3JzVG9Db2xvciwgXCIjMDAwXCIpO1xuICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgZ2V0IHVuY2hlY2tCZ0NvbG9yKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0UmFkaW9CdXR0b25Qcm9wKFwidW5jaGVja0JnQ29sb3JcIiwgW1wiZGVmYXVsdEJnQ29sb3JcIl0pO1xuICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgZ2V0IGNoZWNrQmdDb2xvcigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldFJhZGlvQnV0dG9uUHJvcChcImNoZWNrQmdDb2xvclwiLCBbXCJkZWZhdWx0QmdDb2xvclwiXSk7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdldFJhZGlvQnV0dG9uUHJvcChwcm9wLCBkZWZOYW1lcywgY29udmVydEZvclN1cGVyLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRQcm9wKG9iaiwgc3VwZXJUaGVtZSwgW1wicmFkaW9CdXR0b25cIiwgcHJvcF0sIGRlZk5hbWVzLCBjb252ZXJ0Rm9yU3VwZXIsIGRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJidXR0b25cIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzJF8xNiA9IHRoaXNbX10sXG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IF90aGlzJF8xNi5vYmosXG4gICAgICAgICAgICAgICAgICAgIHN1cGVyVGhlbWUgPSBfdGhpcyRfMTYuc3VwZXJUaGVtZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYnV0dG9uIHx8ICh0aGlzLl9idXR0b24gPSB7XG4gICAgICAgICAgICAgICAgICBnZXQgY29sb3IoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRCdXR0b25Qcm9wKFwiY29sb3JcIiwgW1wiY29sb3JcIl0pO1xuICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgZ2V0IGJnQ29sb3IoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRCdXR0b25Qcm9wKFwiYmdDb2xvclwiLCBbXCJkZWZhdWx0QmdDb2xvclwiXSk7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdldEJ1dHRvblByb3AocHJvcCwgZGVmTmFtZXMpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRQcm9wKG9iaiwgc3VwZXJUaGVtZSwgW1wiYnV0dG9uXCIsIHByb3BdLCBkZWZOYW1lcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJ0cmVlXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyRfMTcgPSB0aGlzW19dLFxuICAgICAgICAgICAgICAgICAgICBvYmogPSBfdGhpcyRfMTcub2JqLFxuICAgICAgICAgICAgICAgICAgICBzdXBlclRoZW1lID0gX3RoaXMkXzE3LnN1cGVyVGhlbWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyZWUgfHwgKHRoaXMuX3RyZWUgPSB7XG4gICAgICAgICAgICAgICAgICBnZXQgbGluZVN0eWxlKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0VHJlZVByb3AoXCJsaW5lU3R5bGVcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFwic29saWRcIik7XG4gICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICBnZXQgbGluZUNvbG9yKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0VHJlZVByb3AoXCJsaW5lQ29sb3JcIiwgW1wiYm9yZGVyQ29sb3JcIl0sIGNvbG9yc1RvQ29sb3IsIFwiIzAwMDBcIik7XG4gICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICBnZXQgbGluZVdpZHRoKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0VHJlZVByb3AoXCJsaW5lV2lkdGhcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIDEpO1xuICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgZ2V0IHRyZWVJY29uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0VHJlZVByb3AoXCJ0cmVlSWNvblwiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjg1ID0gKDAsIFRyZWVDb2x1bW5fMS5nZXRUcmVlTm9kZUluZm9BdCkoYXJncyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGhhc0NoaWxkcmVuID0gX3JlZjg1Lmhhc0NoaWxkcmVuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlVHlwZSA9IF9yZWY4NS5ub2RlVHlwZTtcblxuICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNDaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZXhwYW5kX21vcmVcIjtcbiAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZVR5cGUgPT09IFwiYnJhbmNoXCIgPyBcImNoZXZyb25fcmlnaHRcIiA6IFwibm9uZVwiO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2V0VHJlZVByb3AocHJvcCwgZGVmTmFtZXMsIGNvbnZlcnRGb3JTdXBlciwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0UHJvcChvYmosIHN1cGVyVGhlbWUsIFtcInRyZWVcIiwgcHJvcF0sIGRlZk5hbWVzLCBjb252ZXJ0Rm9yU3VwZXIsIGRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJoZWFkZXJcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzJF8xOCA9IHRoaXNbX10sXG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IF90aGlzJF8xOC5vYmosXG4gICAgICAgICAgICAgICAgICAgIHN1cGVyVGhlbWUgPSBfdGhpcyRfMTguc3VwZXJUaGVtZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faGVhZGVyIHx8ICh0aGlzLl9oZWFkZXIgPSB7XG4gICAgICAgICAgICAgICAgICBnZXQgc29ydEFycm93Q29sb3IoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRQcm9wKG9iaiwgc3VwZXJUaGVtZSwgW1wiaGVhZGVyXCIsIFwic29ydEFycm93Q29sb3JcIl0sIFtcImNvbG9yXCJdKTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJtZXNzYWdlc1wiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMkXzE5ID0gdGhpc1tfXSxcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gX3RoaXMkXzE5Lm9iaixcbiAgICAgICAgICAgICAgICAgICAgc3VwZXJUaGVtZSA9IF90aGlzJF8xOS5zdXBlclRoZW1lO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tZXNzYWdlcyB8fCAodGhpcy5fbWVzc2FnZXMgPSB7XG4gICAgICAgICAgICAgICAgICBnZXQgaW5mb0JnQ29sb3IoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRNZXNzYWdlUHJvcChcImluZm9CZ0NvbG9yXCIpO1xuICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgZ2V0IGVycm9yQmdDb2xvcigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldE1lc3NhZ2VQcm9wKFwiZXJyb3JCZ0NvbG9yXCIpO1xuICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgZ2V0IHdhcm5CZ0NvbG9yKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0TWVzc2FnZVByb3AoXCJ3YXJuQmdDb2xvclwiKTtcbiAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgIGdldCBib3hXaWR0aCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldE1lc3NhZ2VQcm9wKFwiYm94V2lkdGhcIik7XG4gICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICBnZXQgbWFya0hlaWdodCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldE1lc3NhZ2VQcm9wKFwibWFya0hlaWdodFwiKTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2V0TWVzc2FnZVByb3AocHJvcCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldFByb3Aob2JqLCBzdXBlclRoZW1lLCBbXCJtZXNzYWdlc1wiLCBwcm9wXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJpbmRpY2F0b3JzXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyRfMjAgPSB0aGlzW19dLFxuICAgICAgICAgICAgICAgICAgICBvYmogPSBfdGhpcyRfMjAub2JqLFxuICAgICAgICAgICAgICAgICAgICBzdXBlclRoZW1lID0gX3RoaXMkXzIwLnN1cGVyVGhlbWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2luZGljYXRvcnMgfHwgKHRoaXMuX2luZGljYXRvcnMgPSB7XG4gICAgICAgICAgICAgICAgICBnZXQgdG9wTGVmdENvbG9yKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0SW5kaWNhdG9yc1Byb3AoXCJ0b3BMZWZ0Q29sb3JcIiwgW1wiYm9yZGVyQ29sb3JcIl0sIGNvbG9yc1RvQ29sb3IsIFwiIzAwMFwiKTtcbiAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgIGdldCB0b3BMZWZ0U2l6ZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEluZGljYXRvcnNQcm9wKFwidG9wTGVmdFNpemVcIik7XG4gICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICBnZXQgdG9wUmlnaHRDb2xvcigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEluZGljYXRvcnNQcm9wKFwidG9wUmlnaHRDb2xvclwiLCBbXCJib3JkZXJDb2xvclwiXSwgY29sb3JzVG9Db2xvciwgXCIjMDAwXCIpO1xuICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgZ2V0IHRvcFJpZ2h0U2l6ZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEluZGljYXRvcnNQcm9wKFwidG9wUmlnaHRTaXplXCIpO1xuICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgZ2V0IGJvdHRvbVJpZ2h0Q29sb3IoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRJbmRpY2F0b3JzUHJvcChcImJvdHRvbVJpZ2h0Q29sb3JcIiwgW1wiYm9yZGVyQ29sb3JcIl0sIGNvbG9yc1RvQ29sb3IsIFwiIzAwMFwiKTtcbiAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgIGdldCBib3R0b21SaWdodFNpemUoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRJbmRpY2F0b3JzUHJvcChcImJvdHRvbVJpZ2h0U2l6ZVwiKTtcbiAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgIGdldCBib3R0b21MZWZ0Q29sb3IoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRJbmRpY2F0b3JzUHJvcChcImJvdHRvbUxlZnRDb2xvclwiLCBbXCJib3JkZXJDb2xvclwiXSwgY29sb3JzVG9Db2xvciwgXCIjMDAwXCIpO1xuICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgZ2V0IGJvdHRvbUxlZnRTaXplKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0SW5kaWNhdG9yc1Byb3AoXCJib3R0b21MZWZ0U2l6ZVwiKTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2V0SW5kaWNhdG9yc1Byb3AocHJvcCwgZGVmTmFtZXMsIGNvbnZlcnRGb3JTdXBlciwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0UHJvcChvYmosIHN1cGVyVGhlbWUsIFtcImluZGljYXRvcnNcIiwgcHJvcF0sIGRlZk5hbWVzLCBjb252ZXJ0Rm9yU3VwZXIsIGRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJoYXNQcm9wZXJ0eVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaGFzUHJvcGVydHkobmFtZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMkXzIxID0gdGhpc1tfXSxcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gX3RoaXMkXzIxLm9iaixcbiAgICAgICAgICAgICAgICAgICAgc3VwZXJUaGVtZSA9IF90aGlzJF8yMS5zdXBlclRoZW1lO1xuICAgICAgICAgICAgICAgIHJldHVybiBoYXNUaGVtZVByb3BlcnR5KG9iaiwgbmFtZXMpIHx8IGhhc1RoZW1lUHJvcGVydHkoc3VwZXJUaGVtZSwgbmFtZXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJleHRlbmRzXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZXh0ZW5kcyhvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRoZW1lKG9iaiwgdGhpcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIFRoZW1lO1xuICAgICAgICAgIH0oKTtcblxuICAgICAgICAgIGV4cG9ydHMuVGhlbWUgPSBUaGVtZTtcblxuICAgICAgICAgIGZ1bmN0aW9uIGhhc1RoZW1lUHJvcGVydHkob2JqLCBuYW1lcykge1xuICAgICAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIFRoZW1lKSB7XG4gICAgICAgICAgICAgIHJldHVybiBvYmouaGFzUHJvcGVydHkobmFtZXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgdmFyIG8gPSBvYmo7XG5cbiAgICAgICAgICAgICAgaWYgKCFvKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IG5hbWVzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gbmFtZXNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIG8gPSBvW25hbWVdO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFvKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuICEhbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBjb2xvcnNUb0NvbG9yKGNvbG9ycykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb2xvcnMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFyZykge1xuICAgICAgICAgICAgICAgIHZhciB2YWwgPSBjb2xvcnMoYXJnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsID8gY29sb3JzQXJyYXlUb0NvbG9yKHZhbCkgOiB2YWw7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjb2xvcnNBcnJheVRvQ29sb3IoY29sb3JzKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gY29sb3JzQXJyYXlUb0NvbG9yKCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuICAgICAgICAgICAgY29sb3JzKSB7XG4gICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShjb2xvcnMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbG9ycztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBjb2xvcnMuZmluZChCb29sZWFuKSB8fCB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKiovXG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vdG9vbHMuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi90b29scy5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIHRvb2xzSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICB2YXIgX19jcmVhdGVCaW5kaW5nID0gdGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZyB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICAgICAgICAgICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcblxuICAgICAgICAgICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgICAgICAgICAgZGVzYyA9IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ba107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xuICAgICAgICAgIH0gOiBmdW5jdGlvbiAobywgbSwgaywgazIpIHtcbiAgICAgICAgICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgICAgICAgICBvW2syXSA9IG1ba107XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gdGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCB2KSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHtcbiAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gOiBmdW5jdGlvbiAobywgdikge1xuICAgICAgICAgICAgb1tcImRlZmF1bHRcIl0gPSB2O1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIF9faW1wb3J0U3RhciA9IHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgICAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIHtcbiAgICAgICAgICAgICAgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5jYW52YXNoZWxwZXIgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgY2FudmFzaGVscGVyID0gX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vdG9vbHMvY2FudmFzaGVscGVyICovXG4gICAgICAgICAgXCIuL3Rvb2xzL2NhbnZhc2hlbHBlci5qc1wiKSk7XG5cbiAgICAgICAgICBleHBvcnRzLmNhbnZhc2hlbHBlciA9IGNhbnZhc2hlbHBlcjtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi90b29scy9jYW52YXNoZWxwZXIuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vdG9vbHMvY2FudmFzaGVscGVyLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIHRvb2xzQ2FudmFzaGVscGVySnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5kcmF3QnV0dG9uID0gZXhwb3J0cy5kcmF3UmFkaW9CdXR0b24gPSBleHBvcnRzLmRyYXdDaGVja2JveCA9IGV4cG9ydHMubWVhc3VyZVJhZGlvQnV0dG9uID0gZXhwb3J0cy5tZWFzdXJlQ2hlY2tib3ggPSBleHBvcnRzLmRyYXdJbmxpbmVJbWFnZVJlY3QgPSBleHBvcnRzLmZpbGxUZXh0UmVjdCA9IGV4cG9ydHMuc3Ryb2tlQ2lyY2xlID0gZXhwb3J0cy5maWxsQ2lyY2xlID0gZXhwb3J0cy5zdHJva2VSb3VuZFJlY3QgPSBleHBvcnRzLmZpbGxSb3VuZFJlY3QgPSBleHBvcnRzLnJvdW5kUmVjdCA9IGV4cG9ydHMuc3Ryb2tlQ29sb3JzUmVjdCA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBjYW52YXNlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vaW50ZXJuYWwvY2FudmFzZXMgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvY2FudmFzZXMuanNcIik7XG5cbiAgICAgICAgICB2YXIgY2VpbCA9IE1hdGguY2VpbCxcbiAgICAgICAgICAgICAgUEkgPSBNYXRoLlBJO1xuXG4gICAgICAgICAgZnVuY3Rpb24gc3Ryb2tlQ29sb3JzUmVjdChjdHgsIGJvcmRlckNvbG9ycywgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBzdHJva2VSZWN0TGluZXMocG9zaXRpb25zKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9yZGVyQ29sb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbG9yID0gYm9yZGVyQ29sb3JzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBfcHJlQ29sb3IgPSBib3JkZXJDb2xvcnNbaSAtIDFdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoX3ByZUNvbG9yICE9PSBjb2xvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3ByZUNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gX3ByZUNvbG9yO1xuICAgICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3MxID0gcG9zaXRpb25zW2ldO1xuICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8ocG9zMS54LCBwb3MxLnkpO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICB2YXIgcG9zMiA9IHBvc2l0aW9uc1tpICsgMV07XG4gICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHBvczIueCwgcG9zMi55KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYgKF9wcmVDb2xvcikge1xuICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBfcHJlQ29sb3I7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgcHJlQ29sb3IgPSBib3JkZXJDb2xvcnNbYm9yZGVyQ29sb3JzLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgICAgIGlmIChwcmVDb2xvcikge1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHByZUNvbG9yO1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYm9yZGVyQ29sb3JzWzBdID09PSBib3JkZXJDb2xvcnNbMV0gJiYgYm9yZGVyQ29sb3JzWzBdID09PSBib3JkZXJDb2xvcnNbMl0gJiYgYm9yZGVyQ29sb3JzWzBdID09PSBib3JkZXJDb2xvcnNbM10pIHtcbiAgICAgICAgICAgICAgaWYgKGJvcmRlckNvbG9yc1swXSkge1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGJvcmRlckNvbG9yc1swXTtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlUmVjdChsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdHJva2VSZWN0TGluZXMoW3tcbiAgICAgICAgICAgICAgICB4OiBsZWZ0LFxuICAgICAgICAgICAgICAgIHk6IHRvcFxuICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgeDogbGVmdCArIHdpZHRoLFxuICAgICAgICAgICAgICAgIHk6IHRvcFxuICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgeDogbGVmdCArIHdpZHRoLFxuICAgICAgICAgICAgICAgIHk6IHRvcCArIGhlaWdodFxuICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgeDogbGVmdCxcbiAgICAgICAgICAgICAgICB5OiB0b3AgKyBoZWlnaHRcbiAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHg6IGxlZnQsXG4gICAgICAgICAgICAgICAgeTogdG9wXG4gICAgICAgICAgICAgIH1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRzLnN0cm9rZUNvbG9yc1JlY3QgPSBzdHJva2VDb2xvcnNSZWN0O1xuXG4gICAgICAgICAgZnVuY3Rpb24gcm91bmRSZWN0KGN0eCwgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMpIHtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5hcmMobGVmdCArIHJhZGl1cywgdG9wICsgcmFkaXVzLCByYWRpdXMsIC1QSSwgLTAuNSAqIFBJLCBmYWxzZSk7XG4gICAgICAgICAgICBjdHguYXJjKGxlZnQgKyB3aWR0aCAtIHJhZGl1cywgdG9wICsgcmFkaXVzLCByYWRpdXMsIC0wLjUgKiBQSSwgMCwgZmFsc2UpO1xuICAgICAgICAgICAgY3R4LmFyYyhsZWZ0ICsgd2lkdGggLSByYWRpdXMsIHRvcCArIGhlaWdodCAtIHJhZGl1cywgcmFkaXVzLCAwLCAwLjUgKiBQSSwgZmFsc2UpO1xuICAgICAgICAgICAgY3R4LmFyYyhsZWZ0ICsgcmFkaXVzLCB0b3AgKyBoZWlnaHQgLSByYWRpdXMsIHJhZGl1cywgMC41ICogUEksIFBJLCBmYWxzZSk7XG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5yb3VuZFJlY3QgPSByb3VuZFJlY3Q7XG5cbiAgICAgICAgICBmdW5jdGlvbiBmaWxsUm91bmRSZWN0KGN0eCwgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMpIHtcbiAgICAgICAgICAgIHJvdW5kUmVjdChjdHgsIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCwgcmFkaXVzKTtcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5maWxsUm91bmRSZWN0ID0gZmlsbFJvdW5kUmVjdDtcblxuICAgICAgICAgIGZ1bmN0aW9uIHN0cm9rZVJvdW5kUmVjdChjdHgsIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCwgcmFkaXVzKSB7XG4gICAgICAgICAgICByb3VuZFJlY3QoY3R4LCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQsIHJhZGl1cyk7XG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5zdHJva2VSb3VuZFJlY3QgPSBzdHJva2VSb3VuZFJlY3Q7XG5cbiAgICAgICAgICBmdW5jdGlvbiBmaWxsQ2lyY2xlKGN0eCwgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICB2YXIgbWluID0gTWF0aC5taW4od2lkdGgsIGhlaWdodCkgLyAyO1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4LmFyYyhsZWZ0ICsgbWluLCB0b3AgKyBtaW4sIG1pbiwgMCwgMiAqIE1hdGguUEkpO1xuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRzLmZpbGxDaXJjbGUgPSBmaWxsQ2lyY2xlO1xuXG4gICAgICAgICAgZnVuY3Rpb24gc3Ryb2tlQ2lyY2xlKGN0eCwgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICB2YXIgbWluID0gTWF0aC5taW4od2lkdGgsIGhlaWdodCkgLyAyO1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4LmFyYyhsZWZ0ICsgbWluLCB0b3AgKyBtaW4sIG1pbiwgMCwgMiAqIE1hdGguUEkpO1xuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMuc3Ryb2tlQ2lyY2xlID0gc3Ryb2tlQ2lyY2xlO1xuXG4gICAgICAgICAgZnVuY3Rpb24gZmlsbFRleHRSZWN0KGN0eCwgdGV4dCwgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICB2YXIgX3JlZjg2ID0gYXJndW1lbnRzLmxlbmd0aCA+IDYgJiYgYXJndW1lbnRzWzZdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNl0gOiB7fSxcbiAgICAgICAgICAgICAgICBfcmVmODYkb2Zmc2V0ID0gX3JlZjg2Lm9mZnNldCxcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBfcmVmODYkb2Zmc2V0ID09PSB2b2lkIDAgPyAyIDogX3JlZjg2JG9mZnNldCxcbiAgICAgICAgICAgICAgICBwYWRkaW5nID0gX3JlZjg2LnBhZGRpbmc7XG5cbiAgICAgICAgICAgIHZhciByZWN0ID0ge1xuICAgICAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICAgICAgcmlnaHQ6IGxlZnQgKyB3aWR0aCxcbiAgICAgICAgICAgICAgYm90dG9tOiB0b3AgKyBoZWlnaHRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgIGN0eC5yZWN0KHJlY3QubGVmdCwgcmVjdC50b3AsIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTsgLy9jbGlwXG5cbiAgICAgICAgICAgICAgY3R4LmNsaXAoKTsgLy/mloflrZfmj4/nlLtcblxuICAgICAgICAgICAgICB2YXIgcG9zID0gKDAsIGNhbnZhc2VzXzEuY2FsY0Jhc2VQb3NpdGlvbikoY3R4LCByZWN0LCB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgICAgICAgICAgcGFkZGluZzogcGFkZGluZ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KHRleHQsIHBvcy54LCBwb3MueSk7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMuZmlsbFRleHRSZWN0ID0gZmlsbFRleHRSZWN0O1xuXG4gICAgICAgICAgZnVuY3Rpb24gZHJhd0lubGluZUltYWdlUmVjdChjdHgsIGltYWdlLCBzcmNMZWZ0LCBzcmNUb3AsIHNyY1dpZHRoLCBzcmNIZWlnaHQsIGRlc3RXaWR0aCwgZGVzdEhlaWdodCwgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICB2YXIgX3JlZjg3ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEyICYmIGFyZ3VtZW50c1sxMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxMl0gOiB7fSxcbiAgICAgICAgICAgICAgICBfcmVmODckb2Zmc2V0ID0gX3JlZjg3Lm9mZnNldCxcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBfcmVmODckb2Zmc2V0ID09PSB2b2lkIDAgPyAyIDogX3JlZjg3JG9mZnNldCxcbiAgICAgICAgICAgICAgICBwYWRkaW5nID0gX3JlZjg3LnBhZGRpbmc7XG5cbiAgICAgICAgICAgIHZhciByZWN0ID0ge1xuICAgICAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICAgICAgcmlnaHQ6IGxlZnQgKyB3aWR0aCxcbiAgICAgICAgICAgICAgYm90dG9tOiB0b3AgKyBoZWlnaHRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgIGN0eC5yZWN0KHJlY3QubGVmdCwgcmVjdC50b3AsIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTsgLy9jbGlwXG5cbiAgICAgICAgICAgICAgY3R4LmNsaXAoKTsgLy/mloflrZfmj4/nlLtcblxuICAgICAgICAgICAgICB2YXIgcG9zID0gKDAsIGNhbnZhc2VzXzEuY2FsY1N0YXJ0UG9zaXRpb24pKGN0eCwgcmVjdCwgZGVzdFdpZHRoLCBkZXN0SGVpZ2h0LCB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgICAgICAgICAgcGFkZGluZzogcGFkZGluZ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShpbWFnZSwgc3JjTGVmdCwgc3JjVG9wLCBzcmNXaWR0aCwgc3JjSGVpZ2h0LCBwb3MueCwgcG9zLnksIGRlc3RXaWR0aCwgZGVzdEhlaWdodCk7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMuZHJhd0lubGluZUltYWdlUmVjdCA9IGRyYXdJbmxpbmVJbWFnZVJlY3Q7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogUmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgd2lkdGggb2YgdGhlIGNoZWNrYm94LlxuICAgICAgICAgICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IGNhbnZhcyBjb250ZXh0XG4gICAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgY29udGFpbmluZyB0aGUgd2lkdGggb2YgdGhlIGNoZWNrYm94XG4gICAgICAgICAgICogQG1lbWJlcm9mIGNoZWV0YWhHcmlkLnRvb2xzLmNhbnZhc2hlbHBlclxuICAgICAgICAgICAqL1xuXG4gICAgICAgICAgZnVuY3Rpb24gbWVhc3VyZUNoZWNrYm94KGN0eCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgd2lkdGg6ICgwLCBjYW52YXNlc18xLmdldEZvbnRTaXplKShjdHgsIG51bGwpLndpZHRoXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMubWVhc3VyZUNoZWNrYm94ID0gbWVhc3VyZUNoZWNrYm94O1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHdpZHRoIG9mIHRoZSByYWRpbyBidXR0b24uXG4gICAgICAgICAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggY2FudmFzIGNvbnRleHRcbiAgICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCBjb250YWluaW5nIHRoZSB3aWR0aCBvZiB0aGUgcmFkaW8gYnV0dG9uXG4gICAgICAgICAgICogQG1lbWJlcm9mIGNoZWV0YWhHcmlkLnRvb2xzLmNhbnZhc2hlbHBlclxuICAgICAgICAgICAqL1xuXG4gICAgICAgICAgZnVuY3Rpb24gbWVhc3VyZVJhZGlvQnV0dG9uKGN0eCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgd2lkdGg6ICgwLCBjYW52YXNlc18xLmdldEZvbnRTaXplKShjdHgsIG51bGwpLndpZHRoXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMubWVhc3VyZVJhZGlvQnV0dG9uID0gbWVhc3VyZVJhZGlvQnV0dG9uO1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIGRyYXcgQ2hlY2tib3hcbiAgICAgICAgICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBjYW52YXMgY29udGV4dFxuICAgICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geCBUaGUgeCBjb29yZGluYXRlIHdoZXJlIHRvIHN0YXJ0IGRyYXdpbmcgdGhlIGNoZWNrYm94IChyZWxhdGl2ZSB0byB0aGUgY2FudmFzKVxuICAgICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geSBUaGUgeSBjb29yZGluYXRlIHdoZXJlIHRvIHN0YXJ0IGRyYXdpbmcgdGhlIGNoZWNrYm94IChyZWxhdGl2ZSB0byB0aGUgY2FudmFzKVxuICAgICAgICAgICAqIEBwYXJhbSAge2Jvb2xlYW58bnVtYmVyfSBjaGVjayBjaGVja2JveCBjaGVjayBzdGF0dXNcbiAgICAgICAgICAgKiBAcGFyYW0gIHtvYmplY3R9IG9wdGlvbiBvcHRpb25cbiAgICAgICAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAgICAgICAqIEBtZW1iZXJvZiBjaGVldGFoR3JpZC50b29scy5jYW52YXNoZWxwZXJcbiAgICAgICAgICAgKi9cblxuICAgICAgICAgIGZ1bmN0aW9uIGRyYXdDaGVja2JveChjdHgsIHgsIHksIGNoZWNrKSB7XG4gICAgICAgICAgICB2YXIgX3JlZjg4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiB7fSxcbiAgICAgICAgICAgICAgICBfcmVmODgkdW5jaGVja0JnQ29sb3IgPSBfcmVmODgudW5jaGVja0JnQ29sb3IsXG4gICAgICAgICAgICAgICAgdW5jaGVja0JnQ29sb3IgPSBfcmVmODgkdW5jaGVja0JnQ29sb3IgPT09IHZvaWQgMCA/IFwiI0ZGRlwiIDogX3JlZjg4JHVuY2hlY2tCZ0NvbG9yLFxuICAgICAgICAgICAgICAgIF9yZWY4OCRjaGVja0JnQ29sb3IgPSBfcmVmODguY2hlY2tCZ0NvbG9yLFxuICAgICAgICAgICAgICAgIGNoZWNrQmdDb2xvciA9IF9yZWY4OCRjaGVja0JnQ29sb3IgPT09IHZvaWQgMCA/IFwicmdiKDc2LCA3MywgNzIpXCIgOiBfcmVmODgkY2hlY2tCZ0NvbG9yLFxuICAgICAgICAgICAgICAgIF9yZWY4OCRib3JkZXJDb2xvciA9IF9yZWY4OC5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgICBib3JkZXJDb2xvciA9IF9yZWY4OCRib3JkZXJDb2xvciA9PT0gdm9pZCAwID8gXCIjMDAwXCIgOiBfcmVmODgkYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICAgICAgX3JlZjg4JGJveFNpemUgPSBfcmVmODguYm94U2l6ZSxcbiAgICAgICAgICAgICAgICBib3hTaXplID0gX3JlZjg4JGJveFNpemUgPT09IHZvaWQgMCA/IG1lYXN1cmVDaGVja2JveChjdHgpLndpZHRoIDogX3JlZjg4JGJveFNpemU7XG5cbiAgICAgICAgICAgIHZhciBjaGVja1BvaW50ID0gdHlwZW9mIGNoZWNrID09PSBcIm51bWJlclwiID8gY2hlY2sgPiAxID8gMSA6IGNoZWNrIDogMTtcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBjaGVjayA/IGNoZWNrQmdDb2xvciA6IHVuY2hlY2tCZ0NvbG9yO1xuICAgICAgICAgICAgICB2YXIgbGVmdFggPSBjZWlsKHgpO1xuICAgICAgICAgICAgICB2YXIgdG9wWSA9IGNlaWwoeSk7XG4gICAgICAgICAgICAgIHZhciBzaXplID0gY2VpbChib3hTaXplKTtcbiAgICAgICAgICAgICAgZmlsbFJvdW5kUmVjdChjdHgsIGxlZnRYIC0gMSwgdG9wWSAtIDEsIHNpemUgKyAxLCBzaXplICsgMSwgYm94U2l6ZSAvIDUpO1xuICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gMTtcbiAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gYm9yZGVyQ29sb3I7XG4gICAgICAgICAgICAgIHN0cm9rZVJvdW5kUmVjdChjdHgsIGxlZnRYIC0gMC41LCB0b3BZIC0gMC41LCBzaXplLCBzaXplLCBib3hTaXplIC8gNSk7XG5cbiAgICAgICAgICAgICAgaWYgKGNoZWNrKSB7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGNlaWwoYm94U2l6ZSAvIDEwKTtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB1bmNoZWNrQmdDb2xvcjtcbiAgICAgICAgICAgICAgICB2YXIgbGVmdFdpZHRoID0gYm94U2l6ZSAvIDQ7XG4gICAgICAgICAgICAgICAgdmFyIHJpZ2h0V2lkdGggPSBib3hTaXplIC8gMiAqIDAuOTtcbiAgICAgICAgICAgICAgICB2YXIgbGVmdExlZnRQb3MgPSB4ICsgYm94U2l6ZSAqIDAuMjtcbiAgICAgICAgICAgICAgICB2YXIgbGVmdFRvcFBvcyA9IHkgKyBib3hTaXplIC8gMjtcblxuICAgICAgICAgICAgICAgIGlmIChjaGVja1BvaW50IDwgMC41KSB7XG4gICAgICAgICAgICAgICAgICBsZWZ0V2lkdGggKj0gY2hlY2tQb2ludCAqIDI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8obGVmdExlZnRQb3MsIGxlZnRUb3BQb3MpO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8obGVmdExlZnRQb3MgKyBsZWZ0V2lkdGgsIGxlZnRUb3BQb3MgKyBsZWZ0V2lkdGgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrUG9pbnQgPiAwLjUpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChjaGVja1BvaW50IDwgMSkge1xuICAgICAgICAgICAgICAgICAgICByaWdodFdpZHRoICo9IChjaGVja1BvaW50IC0gMC41KSAqIDI7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8obGVmdExlZnRQb3MgKyBsZWZ0V2lkdGggKyByaWdodFdpZHRoLCBsZWZ0VG9wUG9zICsgbGVmdFdpZHRoIC0gcmlnaHRXaWR0aCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMuZHJhd0NoZWNrYm94ID0gZHJhd0NoZWNrYm94O1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIGRyYXcgUmFkaW8gYnV0dG9uXG4gICAgICAgICAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggY2FudmFzIGNvbnRleHRcbiAgICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHggVGhlIHggY29vcmRpbmF0ZSB3aGVyZSB0byBzdGFydCBkcmF3aW5nIHRoZSByYWRpbyBidXR0b24gKHJlbGF0aXZlIHRvIHRoZSBjYW52YXMpXG4gICAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB5IFRoZSB5IGNvb3JkaW5hdGUgd2hlcmUgdG8gc3RhcnQgZHJhd2luZyB0aGUgcmFkaW8gYnV0dG9uIChyZWxhdGl2ZSB0byB0aGUgY2FudmFzKVxuICAgICAgICAgICAqIEBwYXJhbSAge2Jvb2xlYW58bnVtYmVyfSBjaGVjayByYWRpbyBidXR0b24gY2hlY2sgc3RhdHVzXG4gICAgICAgICAgICogQHBhcmFtICB7b2JqZWN0fSBvcHRpb24gb3B0aW9uXG4gICAgICAgICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgICAgICAgKiBAbWVtYmVyb2YgY2hlZXRhaEdyaWQudG9vbHMuY2FudmFzaGVscGVyXG4gICAgICAgICAgICovXG5cbiAgICAgICAgICBmdW5jdGlvbiBkcmF3UmFkaW9CdXR0b24oY3R4LCB4LCB5LCBjaGVjaykge1xuICAgICAgICAgICAgdmFyIF9yZWY4OSA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDoge30sXG4gICAgICAgICAgICAgICAgX3JlZjg5JGNoZWNrQ29sb3IgPSBfcmVmODkuY2hlY2tDb2xvcixcbiAgICAgICAgICAgICAgICBjaGVja0NvbG9yID0gX3JlZjg5JGNoZWNrQ29sb3IgPT09IHZvaWQgMCA/IFwicmdiKDc2LCA3MywgNzIpXCIgOiBfcmVmODkkY2hlY2tDb2xvcixcbiAgICAgICAgICAgICAgICBfcmVmODkkYm9yZGVyQ29sb3IgPSBfcmVmODkuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICAgICAgYm9yZGVyQ29sb3IgPSBfcmVmODkkYm9yZGVyQ29sb3IgPT09IHZvaWQgMCA/IFwiIzAwMFwiIDogX3JlZjg5JGJvcmRlckNvbG9yLFxuICAgICAgICAgICAgICAgIF9yZWY4OSRiZ0NvbG9yID0gX3JlZjg5LmJnQ29sb3IsXG4gICAgICAgICAgICAgICAgYmdDb2xvciA9IF9yZWY4OSRiZ0NvbG9yID09PSB2b2lkIDAgPyBcIiNGRkZcIiA6IF9yZWY4OSRiZ0NvbG9yLFxuICAgICAgICAgICAgICAgIF9yZWY4OSRib3hTaXplID0gX3JlZjg5LmJveFNpemUsXG4gICAgICAgICAgICAgICAgYm94U2l6ZSA9IF9yZWY4OSRib3hTaXplID09PSB2b2lkIDAgPyBtZWFzdXJlUmFkaW9CdXR0b24oY3R4KS53aWR0aCA6IF9yZWY4OSRib3hTaXplO1xuXG4gICAgICAgICAgICB2YXIgcmF0aW8gPSB0eXBlb2YgY2hlY2sgPT09IFwibnVtYmVyXCIgPyBjaGVjayA+IDEgPyAxIDogY2hlY2sgOiAxO1xuICAgICAgICAgICAgY3R4LnNhdmUoKTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGJnQ29sb3I7XG4gICAgICAgICAgICAgIHZhciBsZWZ0WCA9IGNlaWwoeCk7XG4gICAgICAgICAgICAgIHZhciB0b3BZID0gY2VpbCh5KTtcbiAgICAgICAgICAgICAgdmFyIHNpemUgPSBjZWlsKGJveFNpemUpO1xuICAgICAgICAgICAgICBmaWxsQ2lyY2xlKGN0eCwgbGVmdFggLSAxLCB0b3BZIC0gMSwgc2l6ZSArIDEsIHNpemUgKyAxKTtcbiAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDE7XG4gICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGJvcmRlckNvbG9yO1xuICAgICAgICAgICAgICBzdHJva2VDaXJjbGUoY3R4LCBsZWZ0WCAtIDAuNSwgdG9wWSAtIDAuNSwgc2l6ZSwgc2l6ZSk7XG5cbiAgICAgICAgICAgICAgaWYgKGNoZWNrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoZWNrU2l6ZSA9IHNpemUgKiByYXRpbyAvIDI7XG4gICAgICAgICAgICAgICAgdmFyIHBhZGRpbmcgPSAoc2l6ZSAtIGNoZWNrU2l6ZSkgLyAyO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBjaGVja0NvbG9yO1xuICAgICAgICAgICAgICAgIGZpbGxDaXJjbGUoY3R4LCBjZWlsKChsZWZ0WCAtIDAuNSArIHBhZGRpbmcpICogMTAwKSAvIDEwMCwgY2VpbCgodG9wWSAtIDAuNSArIHBhZGRpbmcpICogMTAwKSAvIDEwMCwgY2VpbChjaGVja1NpemUgKiAxMDApIC8gMTAwLCBjZWlsKGNoZWNrU2l6ZSAqIDEwMCkgLyAxMDApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMuZHJhd1JhZGlvQnV0dG9uID0gZHJhd1JhZGlvQnV0dG9uO1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIGRyYXcgQnV0dG9uXG4gICAgICAgICAgICovXG5cbiAgICAgICAgICBmdW5jdGlvbiBkcmF3QnV0dG9uKGN0eCwgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiB7fTtcbiAgICAgICAgICAgIHZhciBfb3B0aW9uJGJhY2tncm91bmRDb2wgPSBvcHRpb24uYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvciA9IF9vcHRpb24kYmFja2dyb3VuZENvbCA9PT0gdm9pZCAwID8gXCIjRkZGXCIgOiBfb3B0aW9uJGJhY2tncm91bmRDb2wsXG4gICAgICAgICAgICAgICAgX29wdGlvbiRiZ0NvbG9yID0gb3B0aW9uLmJnQ29sb3IsXG4gICAgICAgICAgICAgICAgYmdDb2xvciA9IF9vcHRpb24kYmdDb2xvciA9PT0gdm9pZCAwID8gYmFja2dyb3VuZENvbG9yIDogX29wdGlvbiRiZ0NvbG9yLFxuICAgICAgICAgICAgICAgIF9vcHRpb24kcmFkaXVzID0gb3B0aW9uLnJhZGl1cyxcbiAgICAgICAgICAgICAgICByYWRpdXMgPSBfb3B0aW9uJHJhZGl1cyA9PT0gdm9pZCAwID8gNCA6IF9vcHRpb24kcmFkaXVzLFxuICAgICAgICAgICAgICAgIF9vcHRpb24kc2hhZG93ID0gb3B0aW9uLnNoYWRvdyxcbiAgICAgICAgICAgICAgICBzaGFkb3cgPSBfb3B0aW9uJHNoYWRvdyA9PT0gdm9pZCAwID8ge30gOiBfb3B0aW9uJHNoYWRvdztcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBiZ0NvbG9yO1xuXG4gICAgICAgICAgICAgIGlmIChzaGFkb3cpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3NoYWRvdyRjb2xvciA9IHNoYWRvdy5jb2xvcixcbiAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBfc2hhZG93JGNvbG9yID09PSB2b2lkIDAgPyBcInJnYmEoMCwgMCwgMCwgMC4yNClcIiA6IF9zaGFkb3ckY29sb3IsXG4gICAgICAgICAgICAgICAgICAgIF9zaGFkb3ckYmx1ciA9IHNoYWRvdy5ibHVyLFxuICAgICAgICAgICAgICAgICAgICBibHVyID0gX3NoYWRvdyRibHVyID09PSB2b2lkIDAgPyAxIDogX3NoYWRvdyRibHVyLFxuICAgICAgICAgICAgICAgICAgICBfc2hhZG93JG9mZnNldFggPSBzaGFkb3cub2Zmc2V0WCxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0WCA9IF9zaGFkb3ckb2Zmc2V0WCA9PT0gdm9pZCAwID8gMCA6IF9zaGFkb3ckb2Zmc2V0WCxcbiAgICAgICAgICAgICAgICAgICAgX3NoYWRvdyRvZmZzZXRZID0gc2hhZG93Lm9mZnNldFksXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFkgPSBfc2hhZG93JG9mZnNldFkgPT09IHZvaWQgMCA/IDIgOiBfc2hhZG93JG9mZnNldFksXG4gICAgICAgICAgICAgICAgICAgIF9zaGFkb3ckb2Zmc2V0ID0gc2hhZG93Lm9mZnNldDtcbiAgICAgICAgICAgICAgICBfc2hhZG93JG9mZnNldCA9IF9zaGFkb3ckb2Zmc2V0ID09PSB2b2lkIDAgPyB7fSA6IF9zaGFkb3ckb2Zmc2V0O1xuICAgICAgICAgICAgICAgIHZhciBfc2hhZG93JG9mZnNldCR4ID0gX3NoYWRvdyRvZmZzZXQueCxcbiAgICAgICAgICAgICAgICAgICAgb3ggPSBfc2hhZG93JG9mZnNldCR4ID09PSB2b2lkIDAgPyBvZmZzZXRYIDogX3NoYWRvdyRvZmZzZXQkeCxcbiAgICAgICAgICAgICAgICAgICAgX3NoYWRvdyRvZmZzZXQkeSA9IF9zaGFkb3ckb2Zmc2V0LnksXG4gICAgICAgICAgICAgICAgICAgIG95ID0gX3NoYWRvdyRvZmZzZXQkeSA9PT0gdm9pZCAwID8gb2Zmc2V0WSA6IF9zaGFkb3ckb2Zmc2V0JHk7XG4gICAgICAgICAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gY29sb3I7XG4gICAgICAgICAgICAgICAgY3R4LnNoYWRvd0JsdXIgPSBibHVyOyAvL+OBvOOBi+OBl1xuXG4gICAgICAgICAgICAgICAgY3R4LnNoYWRvd09mZnNldFggPSBveDtcbiAgICAgICAgICAgICAgICBjdHguc2hhZG93T2Zmc2V0WSA9IG95O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZmlsbFJvdW5kUmVjdChjdHgsIGNlaWwobGVmdCksIGNlaWwodG9wKSwgY2VpbCh3aWR0aCksIGNlaWwoaGVpZ2h0KSwgcmFkaXVzKTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5kcmF3QnV0dG9uID0gZHJhd0J1dHRvbjtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi90b29sdGlwL0Jhc2VUb29sdGlwLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi90b29sdGlwL0Jhc2VUb29sdGlwLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiB0b29sdGlwQmFzZVRvb2x0aXBKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLkJhc2VUb29sdGlwID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIEJhc2VUb29sdGlwID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIEJhc2VUb29sdGlwKGdyaWQpIHtcbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJhc2VUb29sdGlwKTtcblxuICAgICAgICAgICAgICB0aGlzLl9ncmlkID0gZ3JpZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKEJhc2VUb29sdGlwLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiZGlzcG9zZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRldGFjaFRvb2x0aXBFbGVtZW50KCk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdG9vbHRpcEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXBFbGVtZW50LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwRWxlbWVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiX2dldFRvb2x0aXBFbGVtZW50XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0VG9vbHRpcEVsZW1lbnQoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Rvb2x0aXBFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdG9vbHRpcEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Rvb2x0aXBFbGVtZW50ID0gdGhpcy5jcmVhdGVUb29sdGlwRWxlbWVudEludGVybmFsKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImF0dGFjaFRvb2x0aXBFbGVtZW50XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRhY2hUb29sdGlwRWxlbWVudChjb2wsIHJvdywgY29udGVudCkge1xuICAgICAgICAgICAgICAgIHZhciB0b29sdGlwRWxlbWVudCA9IHRoaXMuX2dldFRvb2x0aXBFbGVtZW50KCk7XG5cbiAgICAgICAgICAgICAgICB0b29sdGlwRWxlbWVudC5hdHRhY2godGhpcy5fZ3JpZCwgY29sLCByb3csIGNvbnRlbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJtb3ZlVG9vbHRpcEVsZW1lbnRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1vdmVUb29sdGlwRWxlbWVudChjb2wsIHJvdykge1xuICAgICAgICAgICAgICAgIHZhciB0b29sdGlwRWxlbWVudCA9IHRoaXMuX2dldFRvb2x0aXBFbGVtZW50KCk7XG5cbiAgICAgICAgICAgICAgICB0b29sdGlwRWxlbWVudC5tb3ZlKHRoaXMuX2dyaWQsIGNvbCwgcm93KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZGV0YWNoVG9vbHRpcEVsZW1lbnRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRldGFjaFRvb2x0aXBFbGVtZW50KCkge1xuICAgICAgICAgICAgICAgIHZhciB0b29sdGlwRWxlbWVudCA9IHRoaXMuX2dldFRvb2x0aXBFbGVtZW50KCk7XG5cbiAgICAgICAgICAgICAgICB0b29sdGlwRWxlbWVudC5fZGV0YWNoKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIEJhc2VUb29sdGlwO1xuICAgICAgICAgIH0oKTtcblxuICAgICAgICAgIGV4cG9ydHMuQmFzZVRvb2x0aXAgPSBCYXNlVG9vbHRpcDtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi90b29sdGlwL1Rvb2x0aXAuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vdG9vbHRpcC9Ub29sdGlwLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIHRvb2x0aXBUb29sdGlwSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5Ub29sdGlwID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIEJhc2VUb29sdGlwXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL0Jhc2VUb29sdGlwICovXG4gICAgICAgICAgXCIuL3Rvb2x0aXAvQmFzZVRvb2x0aXAuanNcIik7XG5cbiAgICAgICAgICB2YXIgVG9vbHRpcEVsZW1lbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vaW50ZXJuYWwvVG9vbHRpcEVsZW1lbnQgKi9cbiAgICAgICAgICBcIi4vdG9vbHRpcC9pbnRlcm5hbC9Ub29sdGlwRWxlbWVudC5qc1wiKTtcblxuICAgICAgICAgIHZhciBUb29sdGlwID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZVRvb2x0aXBfMSRCYXNlVG8pIHtcbiAgICAgICAgICAgIF9pbmhlcml0cyhUb29sdGlwLCBfQmFzZVRvb2x0aXBfMSRCYXNlVG8pO1xuXG4gICAgICAgICAgICB2YXIgX3N1cGVyNzUgPSBfY3JlYXRlU3VwZXIoVG9vbHRpcCk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIFRvb2x0aXAoKSB7XG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUb29sdGlwKTtcblxuICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyNzUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKFRvb2x0aXAsIFt7XG4gICAgICAgICAgICAgIGtleTogXCJjcmVhdGVUb29sdGlwRWxlbWVudEludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVUb29sdGlwRWxlbWVudEludGVybmFsKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVG9vbHRpcEVsZW1lbnRfMS5Ub29sdGlwRWxlbWVudCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBUb29sdGlwO1xuICAgICAgICAgIH0oQmFzZVRvb2x0aXBfMS5CYXNlVG9vbHRpcCk7XG5cbiAgICAgICAgICBleHBvcnRzLlRvb2x0aXAgPSBUb29sdGlwO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL3Rvb2x0aXAvVG9vbHRpcEhhbmRsZXIuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL3Rvb2x0aXAvVG9vbHRpcEhhbmRsZXIuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIHRvb2x0aXBUb29sdGlwSGFuZGxlckpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuVG9vbHRpcEhhbmRsZXIgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgTEdfRVZFTlRfVFlQRV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vbGlzdC1ncmlkL0xHX0VWRU5UX1RZUEUgKi9cbiAgICAgICAgICBcIi4vbGlzdC1ncmlkL0xHX0VWRU5UX1RZUEUuanNcIik7XG5cbiAgICAgICAgICB2YXIgVG9vbHRpcF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9Ub29sdGlwICovXG4gICAgICAgICAgXCIuL3Rvb2x0aXAvVG9vbHRpcC5qc1wiKTtcblxuICAgICAgICAgIHZhciB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vaW50ZXJuYWwvdXRpbHMgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvdXRpbHMuanNcIik7XG5cbiAgICAgICAgICB2YXIgVE9PTFRJUF9JTlNUQU5DRV9GQUNUT1JZID0ge1xuICAgICAgICAgICAgXCJvdmVyZmxvdy10ZXh0XCI6IGZ1bmN0aW9uIG92ZXJmbG93VGV4dChncmlkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgVG9vbHRpcF8xLlRvb2x0aXAoZ3JpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGZ1bmN0aW9uIGdldFRvb2x0aXBJbnN0YW5jZUluZm8oIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgZ3JpZCwgY29sLCByb3cpIHtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBvdmVyZmxvdyB0ZXh0IHRvb2x0aXBcbiAgICAgICAgICAgIHZhciBvdmVyZmxvd1RleHQgPSBncmlkLmdldENlbGxPdmVyZmxvd1RleHQoY29sLCByb3cpO1xuXG4gICAgICAgICAgICBpZiAob3ZlcmZsb3dUZXh0KSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJvdmVyZmxvdy10ZXh0XCIsXG4gICAgICAgICAgICAgICAgY29udGVudDogb3ZlcmZsb3dUZXh0XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBUb29sdGlwSGFuZGxlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBUb29sdGlwSGFuZGxlcihncmlkKSB7XG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUb29sdGlwSGFuZGxlcik7XG5cbiAgICAgICAgICAgICAgdGhpcy5fZ3JpZCA9IGdyaWQ7XG4gICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXBJbnN0YW5jZXMgPSB7fTtcblxuICAgICAgICAgICAgICB0aGlzLl9iaW5kR3JpZEV2ZW50KGdyaWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoVG9vbHRpcEhhbmRsZXIsIFt7XG4gICAgICAgICAgICAgIGtleTogXCJkaXNwb3NlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgICAgICAgICAgIHZhciB0b29sdGlwSW5zdGFuY2VzID0gdGhpcy5fdG9vbHRpcEluc3RhbmNlcztcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgaW4gdG9vbHRpcEluc3RhbmNlcykge1xuICAgICAgICAgICAgICAgICAgdG9vbHRpcEluc3RhbmNlc1trXS5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgfSAvLyBAdHMtZXhwZWN0LWVycm9yIC0tIGlnbm9yZVxuXG5cbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fdG9vbHRpcEluc3RhbmNlcztcbiAgICAgICAgICAgICAgICB0aGlzLl9hdHRhY2hJbmZvID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiX2F0dGFjaFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2F0dGFjaChjb2wsIHJvdykge1xuICAgICAgICAgICAgICAgIHZhciBpbmZvID0gdGhpcy5fYXR0YWNoSW5mbztcblxuICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZUluZm8gPSB0aGlzLl9nZXRUb29sdGlwSW5zdGFuY2VJbmZvKGNvbCwgcm93KTtcblxuICAgICAgICAgICAgICAgIGlmIChpbmZvICYmICghaW5zdGFuY2VJbmZvIHx8IGluZm8uaW5zdGFuY2UgIT09IGluc3RhbmNlSW5mby5pbnN0YW5jZSkpIHtcbiAgICAgICAgICAgICAgICAgIGluZm8uaW5zdGFuY2UuZGV0YWNoVG9vbHRpcEVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2F0dGFjaEluZm8gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghaW5zdGFuY2VJbmZvKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gaW5zdGFuY2VJbmZvLmluc3RhbmNlO1xuICAgICAgICAgICAgICAgIGluc3RhbmNlLmF0dGFjaFRvb2x0aXBFbGVtZW50KGNvbCwgcm93LCBpbnN0YW5jZUluZm8uY29udGVudCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLl9ncmlkLmdldENlbGxSYW5nZShjb2wsIHJvdyk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9hdHRhY2hJbmZvID0ge1xuICAgICAgICAgICAgICAgICAgcmFuZ2U6IHJhbmdlLFxuICAgICAgICAgICAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiX21vdmVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9tb3ZlKGNvbCwgcm93KSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZm8gPSB0aGlzLl9hdHRhY2hJbmZvO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFpbmZvIHx8ICEoMCwgdXRpbHNfMS5jZWxsSW5SYW5nZSkoaW5mby5yYW5nZSwgY29sLCByb3cpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gaW5mby5pbnN0YW5jZTtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5tb3ZlVG9vbHRpcEVsZW1lbnQoY29sLCByb3cpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJfZGV0YWNoXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZGV0YWNoKCkge1xuICAgICAgICAgICAgICAgIHZhciBpbmZvID0gdGhpcy5fYXR0YWNoSW5mbztcblxuICAgICAgICAgICAgICAgIGlmICghaW5mbykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGluZm8uaW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuZGV0YWNoVG9vbHRpcEVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hdHRhY2hJbmZvID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiX2lzQXR0YWNoQ2VsbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2lzQXR0YWNoQ2VsbChjb2wsIHJvdykge1xuICAgICAgICAgICAgICAgIHZhciBpbmZvID0gdGhpcy5fYXR0YWNoSW5mbztcblxuICAgICAgICAgICAgICAgIGlmICghaW5mbykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbHNfMS5jZWxsSW5SYW5nZSkoaW5mby5yYW5nZSwgY29sLCByb3cpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJfYmluZEdyaWRFdmVudFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2JpbmRHcmlkRXZlbnQoZ3JpZCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpczExMSA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICBncmlkLmxpc3RlbihMR19FVkVOVF9UWVBFXzEuTEdfRVZFTlRfVFlQRS5NT1VTRU9WRVJfQ0VMTCwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChlLnJlbGF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzMTExLl9pc0F0dGFjaENlbGwoZS5jb2wsIGUucm93KSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBfdGhpczExMS5fYXR0YWNoKGUuY29sLCBlLnJvdyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZ3JpZC5saXN0ZW4oTEdfRVZFTlRfVFlQRV8xLkxHX0VWRU5UX1RZUEUuTU9VU0VPVVRfQ0VMTCwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChlLnJlbGF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzMTExLl9pc0F0dGFjaENlbGwoZS5yZWxhdGVkLmNvbCwgZS5yZWxhdGVkLnJvdykpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgX3RoaXMxMTEuX2RldGFjaCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGdyaWQubGlzdGVuKExHX0VWRU5UX1RZUEVfMS5MR19FVkVOVF9UWVBFLlNFTEVDVEVEX0NFTEwsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoX3RoaXMxMTEuX2lzQXR0YWNoQ2VsbChlLmNvbCwgZS5yb3cpKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzMTExLl9kZXRhY2goKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBncmlkLmxpc3RlbihMR19FVkVOVF9UWVBFXzEuTEdfRVZFTlRfVFlQRS5TQ1JPTEwsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBpbmZvID0gX3RoaXMxMTEuX2F0dGFjaEluZm87XG5cbiAgICAgICAgICAgICAgICAgIGlmICghaW5mbykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIF90aGlzMTExLl9tb3ZlKGluZm8ucmFuZ2Uuc3RhcnQuY29sLCBpbmZvLnJhbmdlLnN0YXJ0LnJvdyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZ3JpZC5saXN0ZW4oTEdfRVZFTlRfVFlQRV8xLkxHX0VWRU5UX1RZUEUuQ0hBTkdFRF9WQUxVRSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChfdGhpczExMS5faXNBdHRhY2hDZWxsKGUuY29sLCBlLnJvdykpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMxMTEuX2RldGFjaCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIF90aGlzMTExLl9hdHRhY2goZS5jb2wsIGUucm93KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiX2dldFRvb2x0aXBJbnN0YW5jZUluZm9cIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRUb29sdGlwSW5zdGFuY2VJbmZvKGNvbCwgcm93KSB7XG4gICAgICAgICAgICAgICAgdmFyIGdyaWQgPSB0aGlzLl9ncmlkO1xuICAgICAgICAgICAgICAgIHZhciB0b29sdGlwSW5zdGFuY2VzID0gdGhpcy5fdG9vbHRpcEluc3RhbmNlcztcbiAgICAgICAgICAgICAgICB2YXIgaW5mbyA9IGdldFRvb2x0aXBJbnN0YW5jZUluZm8oZ3JpZCwgY29sLCByb3cpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFpbmZvKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IGluZm8udHlwZTtcbiAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSB0b29sdGlwSW5zdGFuY2VzW3R5cGVdIHx8ICh0b29sdGlwSW5zdGFuY2VzW3R5cGVdID0gVE9PTFRJUF9JTlNUQU5DRV9GQUNUT1JZW3R5cGVdKGdyaWQpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGluZm8uY29udGVudFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIFRvb2x0aXBIYW5kbGVyO1xuICAgICAgICAgIH0oKTtcblxuICAgICAgICAgIGV4cG9ydHMuVG9vbHRpcEhhbmRsZXIgPSBUb29sdGlwSGFuZGxlcjtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi90b29sdGlwL2ludGVybmFsL1Rvb2x0aXBFbGVtZW50LmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi90b29sdGlwL2ludGVybmFsL1Rvb2x0aXBFbGVtZW50LmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiB0b29sdGlwSW50ZXJuYWxUb29sdGlwRWxlbWVudEpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuVG9vbHRpcEVsZW1lbnQgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgRXZlbnRIYW5kbGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi9pbnRlcm5hbC9FdmVudEhhbmRsZXIgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvRXZlbnRIYW5kbGVyLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIGRvbV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vaW50ZXJuYWwvZG9tICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL2RvbS5qc1wiKTtcblxuICAgICAgICAgIHZhciBDTEFTU05BTUUgPSBcImNoZWV0YWgtZ3JpZF9fdG9vbHRpcC1lbGVtZW50XCI7XG4gICAgICAgICAgdmFyIENPTlRFTlRfQ0xBU1NOQU1FID0gXCJcIi5jb25jYXQoQ0xBU1NOQU1FLCBcIl9fY29udGVudFwiKTtcbiAgICAgICAgICB2YXIgSElEREVOX0NMQVNTTkFNRSA9IFwiXCIuY29uY2F0KENMQVNTTkFNRSwgXCItLWhpZGRlblwiKTtcbiAgICAgICAgICB2YXIgU0hPV05fQ0xBU1NOQU1FID0gXCJcIi5jb25jYXQoQ0xBU1NOQU1FLCBcIi0tc2hvd25cIik7XG5cbiAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVUb29sdGlwRG9tRWxlbWVudCgpIHtcbiAgICAgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgQC90b29sdGlwL2ludGVybmFsL1Rvb2x0aXBFbGVtZW50LmNzcyAqL1xuICAgICAgICAgICAgXCIuLi9zcmMvanMvdG9vbHRpcC9pbnRlcm5hbC9Ub29sdGlwRWxlbWVudC5jc3NcIik7XG5cbiAgICAgICAgICAgIHZhciByb290RWxlbWVudCA9ICgwLCBkb21fMS5jcmVhdGVFbGVtZW50KShcImRpdlwiLCB7XG4gICAgICAgICAgICAgIGNsYXNzTGlzdDogW0NMQVNTTkFNRSwgSElEREVOX0NMQVNTTkFNRV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2VFbGVtZW50ID0gKDAsIGRvbV8xLmNyZWF0ZUVsZW1lbnQpKFwicHJlXCIsIHtcbiAgICAgICAgICAgICAgY2xhc3NMaXN0OiBbQ09OVEVOVF9DTEFTU05BTUVdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJvb3RFbGVtZW50LmFwcGVuZENoaWxkKG1lc3NhZ2VFbGVtZW50KTtcbiAgICAgICAgICAgIHJldHVybiByb290RWxlbWVudDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgVG9vbHRpcEVsZW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gVG9vbHRpcEVsZW1lbnQoKSB7XG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUb29sdGlwRWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgdGhpcy5faGFuZGxlciA9IG5ldyBFdmVudEhhbmRsZXJfMS5FdmVudEhhbmRsZXIoKTtcbiAgICAgICAgICAgICAgdmFyIHJvb3RFbGVtZW50ID0gdGhpcy5fcm9vdEVsZW1lbnQgPSBjcmVhdGVUb29sdGlwRG9tRWxlbWVudCgpO1xuICAgICAgICAgICAgICB0aGlzLl9tZXNzYWdlRWxlbWVudCA9IHJvb3RFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCIuXCIuY29uY2F0KENPTlRFTlRfQ0xBU1NOQU1FKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhUb29sdGlwRWxlbWVudCwgW3tcbiAgICAgICAgICAgICAga2V5OiBcImRpc3Bvc2VcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXRhY2goKTtcbiAgICAgICAgICAgICAgICB2YXIgcm9vdEVsZW1lbnQgPSB0aGlzLl9yb290RWxlbWVudDtcblxuICAgICAgICAgICAgICAgIGlmIChyb290RWxlbWVudC5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICByb290RWxlbWVudC5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKHJvb3RFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyLmRpc3Bvc2UoKTsgLy8gQHRzLWV4cGVjdC1lcnJvciAtLSBpZ25vcmVcblxuXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3Jvb3RFbGVtZW50OyAvLyBAdHMtZXhwZWN0LWVycm9yIC0tIGlnbm9yZVxuXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX21lc3NhZ2VFbGVtZW50O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJhdHRhY2hcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGF0dGFjaChncmlkLCBjb2wsIHJvdywgY29udGVudCkge1xuICAgICAgICAgICAgICAgIHZhciByb290RWxlbWVudCA9IHRoaXMuX3Jvb3RFbGVtZW50O1xuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlRWxlbWVudCA9IHRoaXMuX21lc3NhZ2VFbGVtZW50O1xuICAgICAgICAgICAgICAgIHJvb3RFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoU0hPV05fQ0xBU1NOQU1FKTtcbiAgICAgICAgICAgICAgICByb290RWxlbWVudC5jbGFzc0xpc3QuYWRkKEhJRERFTl9DTEFTU05BTUUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2F0dGFjaENlbGwoZ3JpZCwgY29sLCByb3cpKSB7XG4gICAgICAgICAgICAgICAgICByb290RWxlbWVudC5jbGFzc0xpc3QuYWRkKFNIT1dOX0NMQVNTTkFNRSk7XG4gICAgICAgICAgICAgICAgICByb290RWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKEhJRERFTl9DTEFTU05BTUUpO1xuICAgICAgICAgICAgICAgICAgbWVzc2FnZUVsZW1lbnQudGV4dENvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9kZXRhY2goKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIm1vdmVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1vdmUoZ3JpZCwgY29sLCByb3cpIHtcbiAgICAgICAgICAgICAgICB2YXIgcm9vdEVsZW1lbnQgPSB0aGlzLl9yb290RWxlbWVudDtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hdHRhY2hDZWxsKGdyaWQsIGNvbCwgcm93KSkge1xuICAgICAgICAgICAgICAgICAgcm9vdEVsZW1lbnQuY2xhc3NMaXN0LmFkZChTSE9XTl9DTEFTU05BTUUpO1xuICAgICAgICAgICAgICAgICAgcm9vdEVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShISURERU5fQ0xBU1NOQU1FKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fZGV0YWNoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJkZXRhY2hcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRldGFjaCgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZXRhY2goKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiX2RldGFjaFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2RldGFjaCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcm9vdEVsZW1lbnQgPSB0aGlzLl9yb290RWxlbWVudDtcblxuICAgICAgICAgICAgICAgIGlmIChyb290RWxlbWVudC5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAvLyByb290RWxlbWVudC5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKHJvb3RFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgIHJvb3RFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoU0hPV05fQ0xBU1NOQU1FKTtcbiAgICAgICAgICAgICAgICAgIHJvb3RFbGVtZW50LmNsYXNzTGlzdC5hZGQoSElEREVOX0NMQVNTTkFNRSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJfYXR0YWNoQ2VsbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2F0dGFjaENlbGwoZ3JpZCwgY29sLCByb3cpIHtcbiAgICAgICAgICAgICAgICB2YXIgcm9vdEVsZW1lbnQgPSB0aGlzLl9yb290RWxlbWVudDtcblxuICAgICAgICAgICAgICAgIHZhciBfZ3JpZCRnZXRBdHRhY2hDZWxsc0E4ID0gZ3JpZC5nZXRBdHRhY2hDZWxsc0FyZWEoZ3JpZC5nZXRDZWxsUmFuZ2UoY29sLCByb3cpKSxcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IF9ncmlkJGdldEF0dGFjaENlbGxzQTguZWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgcmVjdCA9IF9ncmlkJGdldEF0dGFjaENlbGxzQTgucmVjdDtcblxuICAgICAgICAgICAgICAgIHZhciB0b3AgPSByZWN0LmJvdHRvbSxcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IHJlY3QubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSByZWN0LndpZHRoO1xuICAgICAgICAgICAgICAgIHZhciBmcm96ZW5Sb3dDb3VudCA9IGdyaWQuZnJvemVuUm93Q291bnQsXG4gICAgICAgICAgICAgICAgICAgIGZyb3plbkNvbENvdW50ID0gZ3JpZC5mcm96ZW5Db2xDb3VudDtcblxuICAgICAgICAgICAgICAgIGlmIChyb3cgPj0gZnJvemVuUm93Q291bnQgJiYgZnJvemVuUm93Q291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgX2dyaWQkZ2V0QXR0YWNoQ2VsbHNBOSA9IGdyaWQuZ2V0QXR0YWNoQ2VsbHNBcmVhKGdyaWQuZ2V0Q2VsbFJhbmdlKGNvbCwgZnJvemVuUm93Q291bnQgLSAxKSksXG4gICAgICAgICAgICAgICAgICAgICAgZnJvemVuUmVjdCA9IF9ncmlkJGdldEF0dGFjaENlbGxzQTkucmVjdDtcblxuICAgICAgICAgICAgICAgICAgaWYgKHRvcCA8IGZyb3plblJlY3QuYm90dG9tKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy/nr4Tlm7LlpJZcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYgKHRvcCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvL+evhOWbsuWkllxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjb2wgPj0gZnJvemVuQ29sQ291bnQgJiYgZnJvemVuQ29sQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgX2dyaWQkZ2V0QXR0YWNoQ2VsbHNBMTAgPSBncmlkLmdldEF0dGFjaENlbGxzQXJlYShncmlkLmdldENlbGxSYW5nZShmcm96ZW5Db2xDb3VudCAtIDEsIHJvdykpLFxuICAgICAgICAgICAgICAgICAgICAgIF9mcm96ZW5SZWN0NSA9IF9ncmlkJGdldEF0dGFjaENlbGxzQTEwLnJlY3Q7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChsZWZ0IDwgX2Zyb3plblJlY3Q1LnJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy/nr4Tlm7LlpJZcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYgKGxlZnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy/nr4Tlm7LlpJZcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgX2VsZW1lbnQkZ2V0Qm91bmRpbmdDID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0SGVpZ2h0ID0gX2VsZW1lbnQkZ2V0Qm91bmRpbmdDLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0V2lkdGggPSBfZWxlbWVudCRnZXRCb3VuZGluZ0Mud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRMZWZ0ID0gX2VsZW1lbnQkZ2V0Qm91bmRpbmdDLmxlZnQsXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRSaWdodCA9IF9lbGVtZW50JGdldEJvdW5kaW5nQy5yaWdodDtcblxuICAgICAgICAgICAgICAgIGlmIChvZmZzZXRIZWlnaHQgPCB0b3ApIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy/nr4Tlm7LlpJZcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0V2lkdGggPCBsZWZ0KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8v56+E5Zuy5aSWXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGNlbGxDZW50ZXIgPSBsZWZ0ICsgd2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIHJvb3RFbGVtZW50LnN0eWxlLnRvcCA9IFwiXCIuY29uY2F0KHRvcC50b0ZpeGVkKCksIFwicHhcIik7XG4gICAgICAgICAgICAgICAgcm9vdEVsZW1lbnQuc3R5bGUubGVmdCA9IFwiXCIuY29uY2F0KGNlbGxDZW50ZXIudG9GaXhlZCgpLCBcInB4XCIpO1xuICAgICAgICAgICAgICAgIHJvb3RFbGVtZW50LnN0eWxlLm1pbldpZHRoID0gXCJcIi5jb25jYXQod2lkdGgudG9GaXhlZCgpLCBcInB4XCIpO1xuICAgICAgICAgICAgICAgIHZhciBtYXhXaWR0aEZvckxlZnQgPSAoZWxlbWVudExlZnQgKyBjZWxsQ2VudGVyKSAqIDI7XG4gICAgICAgICAgICAgICAgdmFyIHdpbldpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICAgICAgICAgICAgdmFyIG1heFdpZHRoRm9yUmlnaHQgPSAob2Zmc2V0V2lkdGggLSBjZWxsQ2VudGVyICsgKHdpbldpZHRoIC0gZWxlbWVudFJpZ2h0KSkgKiAyO1xuICAgICAgICAgICAgICAgIHZhciBtYXhXaWR0aCA9IE1hdGgubWluKG1heFdpZHRoRm9yTGVmdCwgbWF4V2lkdGhGb3JSaWdodCk7XG4gICAgICAgICAgICAgICAgcm9vdEVsZW1lbnQuc3R5bGUubWF4V2lkdGggPSBcIlwiLmNvbmNhdChtYXhXaWR0aC50b0ZpeGVkKCksIFwicHhcIik7XG5cbiAgICAgICAgICAgICAgICBpZiAocm9vdEVsZW1lbnQucGFyZW50RWxlbWVudCAhPT0gZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChyb290RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIFRvb2x0aXBFbGVtZW50O1xuICAgICAgICAgIH0oKTtcblxuICAgICAgICAgIGV4cG9ydHMuVG9vbHRpcEVsZW1lbnQgPSBUb29sdGlwRWxlbWVudDtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9XG4gICAgICAgIC8qKioqKiovXG5cbiAgICAgIH0pXG4gICAgKTtcbiAgfSk7XG59KS5jYWxsKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB3aW5kb3csIHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB3aW5kb3cpO1xufSkoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoZWV0YWhHcmlkLmVzNS5qcy5tYXAiLCJleHBvcnQgZnVuY3Rpb24gY29tYmluZUNvbHVtbnNBbmRHcm91cHMoY29sdW1uc0xpc3QsIGNvbEdyb3Vwcykge1xuICAgIC8vIDEuIEJ1aWxkIGEgbG9va3VwIGJ5IGZpZWxkXG4gICAgY29uc3QgY29sc0J5RmllbGQgPSB7fTtcbiAgICBjb2x1bW5zTGlzdC5mb3JFYWNoKGNvbCA9PiB7XG4gICAgICBjb2xzQnlGaWVsZFtjb2wuZmllbGRdID0gY29sO1xuICAgIH0pO1xuICBcbiAgICAvLyAyLiBGaW5kIGVhY2ggZ3JvdXAncyBmaXJzdCBtZW1iZXIgYW5kIGFsbCBtZW1iZXJzXG4gICAgY29uc3QgZ3JvdXBGaXJzdCAgID0gY29sR3JvdXBzLm1hcChnID0+IGcuY29sdW1uc1swXSk7XG4gICAgY29uc3QgZ3JvdXBNZW1iZXJzID0gY29sR3JvdXBzLnJlZHVjZSgoYWNjLCBnKSA9PiBhY2MuY29uY2F0KGcuY29sdW1ucyksIFtdKTtcbiAgXG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gIFxuICAgIC8vIDMuIEl0ZXJhdGUgaW4gb3JpZ2luYWwgb3JkZXJcbiAgICBjb2x1bW5zTGlzdC5mb3JFYWNoKGNvbCA9PiB7XG4gICAgICBjb25zdCBmID0gY29sLmZpZWxkO1xuICAgICAgY29uc3QgZ2kgPSBncm91cEZpcnN0LmluZGV4T2YoZik7XG4gIFxuICAgICAgaWYgKGdpICE9PSAtMSkge1xuICAgICAgICAvLyB0aGlzIGlzIHRoZSBmaXJzdCBmaWVsZCBvZiBncm91cCBnaSDihpIgZW1pdCB0aGUgZ3JvdXBcbiAgICAgICAgY29uc3QgZ3JwID0gY29sR3JvdXBzW2dpXTtcbiAgXG4gICAgICAgIC8vIGJ1aWxkIG5lc3RlZCBjb2x1bW4gZGVmaW5pdGlvbnNcbiAgICAgICAgY29uc3QgbmVzdGVkID0gZ3JwLmNvbHVtbnMubWFwKGZpZWxkTmFtZSA9PiBjb2xzQnlGaWVsZFtmaWVsZE5hbWVdKTtcbiAgXG4gICAgICAgIC8vIGV4dHJhY3QgZXZlcnl0aGluZyBleGNlcHQgYGNvbHVtbnNgIGZyb20gZ3JwXG4gICAgICAgIGNvbnN0IHsgY29sdW1ucywgLi4uZ3JwTWV0YSB9ID0gZ3JwO1xuICBcbiAgICAgICAgcmVzdWx0LnB1c2goeyAuLi5ncnBNZXRhLCBjb2x1bW5zOiBuZXN0ZWQgfSk7XG4gIFxuICAgICAgfSBlbHNlIGlmIChncm91cE1lbWJlcnMuaW5jbHVkZXMoZikpIHtcbiAgICAgICAgLy8gYSBtZW1iZXIgb2Ygc29tZSBncm91cCBidXQgbm90IGl0cyBmaXJzdCDihpIgc2tpcFxuICBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHN0YW5kYWxvbmUgY29sdW1uXG4gICAgICAgIHJlc3VsdC5wdXNoKGNvbHNCeUZpZWxkW2ZdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBcbiAgIiwibW9kdWxlLmV4cG9ydHMgPSBIVE1MV2lkZ2V0czsiLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdGlkOiBtb2R1bGVJZCxcblx0XHRsb2FkZWQ6IGZhbHNlLFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcblx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gKG1vZHVsZSkgPT4ge1xuXHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cblx0XHQoKSA9PiAobW9kdWxlWydkZWZhdWx0J10pIDpcblx0XHQoKSA9PiAobW9kdWxlKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgeyBhOiBnZXR0ZXIgfSk7XG5cdHJldHVybiBnZXR0ZXI7XG59OyIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18uZyA9IChmdW5jdGlvbigpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JykgcmV0dXJuIGdsb2JhbFRoaXM7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHRoaXMgfHwgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHJldHVybiB3aW5kb3c7XG5cdH1cbn0pKCk7IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubm1kID0gKG1vZHVsZSkgPT4ge1xuXHRtb2R1bGUucGF0aHMgPSBbXTtcblx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRyZXR1cm4gbW9kdWxlO1xufTsiLCJpbXBvcnQgJ3dpZGdldHMnO1xuaW1wb3J0IHsgY29tYmluZUNvbHVtbnNBbmRHcm91cHMgfSBmcm9tICcuLi9tb2R1bGVzL3V0aWxzLmpzJztcbmltcG9ydCAqIGFzIGNoZWV0YWhHcmlkIGZyb20gXCJjaGVldGFoLWdyaWRcIjtcblxuSFRNTFdpZGdldHMud2lkZ2V0KHtcblxuICBuYW1lOiAnY2hlZXRhaCcsXG5cbiAgdHlwZTogJ291dHB1dCcsXG5cbiAgZmFjdG9yeTogZnVuY3Rpb24gKGVsLCB3aWR0aCwgaGVpZ2h0KSB7XG5cbiAgICBsZXQgaWQgPSBlbC5pZDtcblxuICAgIHJldHVybiB7XG5cbiAgICAgIHJlbmRlclZhbHVlOiBmdW5jdGlvbiAoeCwgaWQgPSBlbC5pZCkge1xuICAgICAgICBsZXQgY29sdW1ucztcbiAgICAgICAgY29uc3QgaGVhZGVyID0gT2JqZWN0LmtleXMoeC5kYXRhWzBdKVxuICAgICAgICBjb25zdCBkZWZhdWx0Q29sID0gaGVhZGVyLm1hcCgoa2V5KSA9PiB7XG4gICAgICAgICAgcmV0dXJuICh7IGZpZWxkOiBrZXksIGNhcHRpb246IGtleSwgd2lkdGg6ICdhdXRvJyB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHguY29sdW1ucyAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIENyZWF0ZSBhIGxvb2t1cCBtYXAgZnJvbSB1c2VyIGlucHV0XG4gICAgICAgICAgY29uc3QgdXNlck1hcCA9IE9iamVjdC5mcm9tRW50cmllcyh4LmNvbHVtbnMubWFwKGl0ZW0gPT4gW2l0ZW0uZmllbGQsIGl0ZW1dKSk7XG5cbiAgICAgICAgICAvLyBNZXJnZSB1c2VyIGlucHV0IHZhbHVlcyBpbnRvIGRlZmF1bHRDb2xcbiAgICAgICAgICBjb2x1bW5zID0gZGVmYXVsdENvbC5tYXAoaXRlbSA9PiAoe1xuICAgICAgICAgICAgLi4uaXRlbSxcbiAgICAgICAgICAgIC4uLih1c2VyTWFwW2l0ZW0uZmllbGRdIHx8IHt9KVxuICAgICAgICAgIH0pKTtcblxuICAgICAgICAgIC8vIEl0ZXJhdGUgb3ZlciB0aGUgbGlzdCBhbmQgcHJvY2VzcyB0aGUgYGFjdGlvbmAgcHJvcGVydHkgaWYgaXQgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgY29sdW1ucy5mb3JFYWNoKChvYmopID0+IHtcbiAgICAgICAgICAgIGlmIChvYmouYWN0aW9uICE9IG51bGwpIHsgIC8vIENoZWNrcyBmb3IgYm90aCBudWxsIGFuZCB1bmRlZmluZWRcbiAgICAgICAgICAgICAgaWYgKG9iai5hY3Rpb24udHlwZSA9PT0gXCJpbmxpbmVfbWVudVwiKSB7XG4gICAgICAgICAgICAgICAgb2JqLmNvbHVtblR5cGUgPSBuZXcgY2hlZXRhaEdyaWQuY29sdW1ucy50eXBlLk1lbnVDb2x1bW4oe1xuICAgICAgICAgICAgICAgICAgb3B0aW9uczogb2JqLmFjdGlvbi5vcHRpb25zLFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgb2JqLmFjdGlvbiA9IG5ldyBjaGVldGFoR3JpZC5jb2x1bW5zLmFjdGlvbi5JbmxpbmVNZW51RWRpdG9yKHtcbiAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IG9iai5hY3Rpb24ub3B0aW9ucyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29sdW1ucyA9IGRlZmF1bHRDb2w7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoeC5jb2xHcm91cCAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvbHVtbnMgPSBjb21iaW5lQ29sdW1uc0FuZEdyb3Vwcyhjb2x1bW5zLCB4LmNvbEdyb3VwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGdyaWQgPSBuZXcgY2hlZXRhaEdyaWQuTGlzdEdyaWQoe1xuICAgICAgICAgIHBhcmVudEVsZW1lbnQ6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSxcbiAgICAgICAgICBoZWFkZXI6IGNvbHVtbnMsXG4gICAgICAgICAgLy8gQ29sdW1uIGZpeGVkIHBvc2l0aW9uXG4gICAgICAgICAgLy8gZnJvemVuQ29sQ291bnQ6IDEsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFNlYXJjaCBmZWF0dXJlXG4gICAgICAgIGlmICh4LnNlYXJjaCAhPT0gJ2Rpc2FibGVkJykge1xuICAgICAgICAgIGNvbnN0IGZpbHRlckRhdGFTb3VyY2UgPSBuZXcgY2hlZXRhaEdyaWRcbiAgICAgICAgICAgIC5kYXRhXG4gICAgICAgICAgICAuRmlsdGVyRGF0YVNvdXJjZShcbiAgICAgICAgICAgICAgY2hlZXRhaEdyaWQuZGF0YS5EYXRhU291cmNlLm9mQXJyYXkoeC5kYXRhKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBncmlkLmRhdGFTb3VyY2UgPSBmaWx0ZXJEYXRhU291cmNlO1xuXG4gICAgICAgICAgY29uc3Qgd2lkZ2V0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWwuaWQpO1xuICAgICAgICAgIGNvbnN0IGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcbiAgICAgICAgICBsYWJlbC50ZXh0Q29udGVudCA9ICdGaWx0ZXI6JztcbiAgICAgICAgICAvLyBDcmVhdGUgaW5wdXRcbiAgICAgICAgICBjb25zdCBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgICAgaW5wdXQuaWQgPSBgJHtlbC5pZH0tZmlsdGVyLWlucHV0YDtcbiAgICAgICAgICBpbnB1dC5zdHlsZS5tYXJnaW4gPSAnMTBweCc7XG4gICAgICAgICAgd2lkZ2V0LnByZXBlbmQobGFiZWwsIGlucHV0KTtcblxuICAgICAgICAgIGNvbnN0IGZpbHRlcklucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYCR7ZWwuaWR9LWZpbHRlci1pbnB1dGApO1xuICAgICAgICAgIGZpbHRlcklucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgKGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZpbHRlclZhbHVlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZS5jdXJyZW50VGFyZ2V0LmlkKS52YWx1ZTtcbiAgICAgICAgICAgIGZpbHRlckRhdGFTb3VyY2UuZmlsdGVyID0gZmlsdGVyVmFsdWVcbiAgICAgICAgICAgICAgPyAocmVjb3JkKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gZmlsdGVyaW5nIG1ldGhvZFxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgayBpbiByZWNvcmQpIHtcbiAgICAgICAgICAgICAgICAgIGxldCB0ZXN0Q29uZDtcbiAgICAgICAgICAgICAgICAgIHN3aXRjaCAoeC5zZWFyY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29udGFpbnMnOlxuICAgICAgICAgICAgICAgICAgICAgIHRlc3RDb25kID0gYCR7cmVjb3JkW2tdfWAuaW5kZXhPZihmaWx0ZXJWYWx1ZSkgPj0gMDs7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2V4YWN0JzpcbiAgICAgICAgICAgICAgICAgICAgICBsZXQgciA9IG5ldyBSZWdFeHAoYF4ke2ZpbHRlclZhbHVlfSRgKTtcbiAgICAgICAgICAgICAgICAgICAgICB0ZXN0Q29uZCA9IHIudGVzdChgJHtyZWNvcmRba119YCk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYCR7eC5zZWFyY2h9IHZhbHVlIG5vdCBpbXBsZW1lbnRlZCB5ZXQuYCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAodGVzdENvbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICBncmlkLmludmFsaWRhdGUoKTtcbiAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEFycmF5IGRhdGEgdG8gYmUgZGlzcGxheWVkIG9uIHRoZSBncmlkXG4gICAgICAgICAgZ3JpZC5yZWNvcmRzID0geC5kYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT25seSBpcyBTaGlueSBleGlzdHNcbiAgICAgICAgaWYgKEhUTUxXaWRnZXRzLnNoaW55TW9kZSkge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIENMSUNLX0NFTEwsXG4gICAgICAgICAgICBDSEFOR0VEX1ZBTFVFLFxuICAgICAgICAgIH0gPSBjaGVldGFoR3JpZC5MaXN0R3JpZC5FVkVOVF9UWVBFO1xuXG4gICAgICAgICAgZ3JpZC5saXN0ZW4oXG4gICAgICAgICAgICBDTElDS19DRUxMLCAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgICBTaGlueS5zZXRJbnB1dFZhbHVlKGAke2lkfV9jbGlja19jZWxsYCwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGdyaWQubGlzdGVuKFxuICAgICAgICAgICAgQ0hBTkdFRF9WQUxVRSwgKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgU2hpbnkuc2V0SW5wdXRWYWx1ZShgJHtpZH1fY2hhbmdlZF92YWx1ZWAsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHJlc2l6ZTogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcblxuICAgICAgICAvLyBUT0RPOiBjb2RlIHRvIHJlLXJlbmRlciB0aGUgd2lkZ2V0IHdpdGggYSBuZXcgc2l6ZVxuXG4gICAgICB9XG5cbiAgICB9O1xuICB9XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==